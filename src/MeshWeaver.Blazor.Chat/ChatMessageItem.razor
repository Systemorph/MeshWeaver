@using System.Runtime.CompilerServices
@using System.Text.RegularExpressions
@using System.Text
@using System.Linq
@using MeshWeaver.Blazor.Components
@using MeshWeaver.Layout
@using MeshWeaver.Utils
@using MeshWeaver.AI
@using ChatMessage = Microsoft.Extensions.AI.ChatMessage

@if (Message.Role == ChatRole.User)
{
    <div class="user-message">
        @Message.Text
    </div>
}
else if (Message is ChatDelegationMessage delegationMessage)
{
    <ChatDelegationView DelegationMessage="delegationMessage" />
}
else if (Message.Role != ChatRole.User)
{
    foreach (var content in Message.Contents)
    {
        if (content is TextContent { Text: { Length: > 0 } text })
        {
            // Check if this is a delegation message that wasn't properly typed
            if (text.StartsWith("Delegating to @") || text.StartsWith("Requesting user feedback before delegating to @"))
            {
                // Parse delegation info from text
                var isDelegationWithFeedback = text.StartsWith("Requesting user feedback");
                var targetAgentStart = text.IndexOf('@') + 1;
                var targetAgentEnd = text.IndexOf(':', targetAgentStart);
                var targetAgent = text.Substring(targetAgentStart, targetAgentEnd - targetAgentStart);
                var delegationMessageText = text.Substring(targetAgentEnd + 2); // Skip ": "

                // Create a delegation message for display
                var parsedDelegationMessage = new ChatDelegationMessage(
                    Message.AuthorName?.ToString() ?? "Assistant",
                    targetAgent,
                    delegationMessageText,
                    isDelegationWithFeedback);

                <ChatDelegationView DelegationMessage="parsedDelegationMessage" />
            }
            else
            {
            <div class="assistant-message">
                <div>
                    <div class="assistant-message-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18" />
                        </svg>
                    </div>
                </div>
                <div class="assistant-message-header">@Message.Role.Value.Wordify()</div>
                <div class="assistant-message-text">
                    @{
                        var (beforeCode, language, codeContent, isIncomplete, afterCode) = ParseIncompleteCodeBlock(text);
                    }
                    
                    @if (isIncomplete)
                    {
                        @* Render text before the incomplete code block *@
                        @if (!string.IsNullOrEmpty(beforeCode))
                        {
                            <MarkdownView ViewModel="@(new MarkdownControl(FormatTextForMarkdown(beforeCode)))" />
                        }
                        
                        @* Render the incomplete code block with spinner only - no preview *@
                        <div class="incomplete-code-block">
                            <div class="code-block-header">
                                <span class="code-language">@(!string.IsNullOrEmpty(language) ? language : "code")</span>
                            </div>
                            <div class="code-loading-area">
                                <div class="centered-spinner">
                                    <div class="spinner-container">
                                        <div class="pulse-spinner"></div>
                                        <svg class="rotating-spinner" width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <circle class="spinner-track" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none" opacity="0.25"></circle>
                                            <circle class="spinner-fill" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none" stroke-dasharray="31.416" stroke-dashoffset="23.562" stroke-linecap="round"></circle>
                                        </svg>
                                    </div>
                                    <div class="loading-text">
                                        <span class="typing-dots">Writing code</span>
                                        <span class="dots">
                                            <span class="dot">.</span>
                                            <span class="dot">.</span>
                                            <span class="dot">.</span>
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        @* Render text after the incomplete code block *@
                        @if (!string.IsNullOrEmpty(afterCode))
                        {
                            <MarkdownView ViewModel="@(new MarkdownControl(FormatTextForMarkdown(afterCode)))" />
                        }
                    }
                    else
                    {
                        @* Normal markdown rendering for complete text *@
                        <MarkdownView ViewModel="@(new MarkdownControl(FormatTextForMarkdown(text)))" />
                    }

                    @foreach (var citation in Citations ?? [])
                    {
                        <ChatCitation File="@citation.File" PageNumber="@citation.Page" Quote="@citation.Quote" />
                    }
                </div>
            </div>
            }
        }
        else if (content is FunctionCallContent fcc)
        {
            var progress = GetProgress(fcc);
            <div class="assistant-function">
                <div class="assistant-function-icon">
                    <IconView ViewModel=@GetIcon(progress)></IconView>
                </div>
                <div class="assistant-function-content">
                    <span class="assistant-function-phrase">@progress.Message</span>
                </div>
            </div>
        }
    }
}

@code {
    private static readonly ConditionalWeakTable<ChatMessage, ChatMessageItem> SubscribersLookup = new();
    private static readonly Regex CitationRegex = new(@"<citation filename='(?<file>[^']*)'
page_number='(?<page>\d*)'>(?<quote>.*?)</citation>", RegexOptions.NonBacktracking);

    private List<(string File, int? Page, string Quote)>? Citations;

    [Parameter, EditorRequired]
    public required ChatMessage Message { get; set; }

    [Parameter]
    public bool InProgress { get; set; }

    protected override void OnInitialized()
    {
        SubscribersLookup.AddOrUpdate(Message, this);

        if (!InProgress && Message.Role == ChatRole.Assistant && Message.Text is { Length: > 0 } text)
        {
            ParseCitations(text);
        }
    }

    public static void NotifyChanged(ChatMessage source)
    {
        if (SubscribersLookup.TryGetValue(source, out var subscriber))
        {
            subscriber.StateHasChanged();
        }
    }

    private void ParseCitations(string text)
    {
        var matches = CitationRegex.Matches(text);
        Citations = matches.Any()
        ? matches.Select(m => (m.Groups["file"].Value, int.TryParse(m.Groups["page"].Value, out var page) ? page : (int?)null,
        m.Groups["quote"].Value)).ToList()
        : null;
    }
    private ProgressMessage GetProgress(FunctionCallContent fcc)
    {
        return new() { Icon = Application.Styles.FluentIcons.SettingsChat(), Message = $"Calling {fcc.Name.Wordify()}" };
    }

    private IconControl GetIcon(ProgressMessage progress)
    {
        return new(progress.Icon ?? new object());
    } /// <summary>
      /// Formats text to ensure proper markdown rendering, especially for bullet points
      /// </summary>
    private string FormatTextForMarkdown(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;

        // Replace bullet points that start with • and ensure proper line breaks
        var lines = text.Split('\n');
        var formattedLines = new List<string>();

        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i].Trim();

            // If this line starts with a bullet point
            if (line.StartsWith("•"))
            {
                // Convert • to - for proper markdown bullet points
                formattedLines.Add("- " + line.Substring(1).TrimStart());
            }
            else
            {
                formattedLines.Add(line);
            }
        }
        return string.Join("\n", formattedLines);
    }

    /// <summary>
    /// Checks if the text contains an incomplete code block and returns the components needed for rendering.
    /// </summary>
    private (string beforeCodeBlock, string language, string codeContent, bool isIncomplete, string afterCodeBlock) ParseIncompleteCodeBlock(string text)
    {
        if (string.IsNullOrEmpty(text))
            return (text, "", "", false, "");

        // Look for code block start pattern
        var codeBlockStartPattern = new Regex(@"```(\w*)?");
        var lines = text.Split('\n');
        var inCodeBlock = false;
        var codeBlockStartIndex = -1;
        var language = "";
        var codeContent = new StringBuilder();
        var beforeCodeBlock = new StringBuilder();
        
        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            
            if (!inCodeBlock)
            {
                var startMatch = codeBlockStartPattern.Match(line.Trim());
                if (startMatch.Success && line.Trim() == startMatch.Value)
                {
                    inCodeBlock = true;
                    codeBlockStartIndex = i;
                    language = startMatch.Groups[1].Value;
                    continue;
                }
                
                if (beforeCodeBlock.Length > 0)
                    beforeCodeBlock.AppendLine();
                beforeCodeBlock.Append(line);
            }
            else
            {
                // We're in a code block
                if (line.Trim() == "```")
                {
                    // Code block is complete - this is handled by normal markdown
                    return (text, "", "", false, "");
                }
                
                if (codeContent.Length > 0)
                    codeContent.AppendLine();
                codeContent.Append(line);
            }
        }
        
        // If we're still in a code block at the end, it's incomplete
        if (inCodeBlock)
        {
            return (beforeCodeBlock.ToString(), language, codeContent.ToString(), true, "");
        }
        
        return (text, "", "", false, "");
    }

}
