var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x2 = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
  function A(a) {
    if (null === a || "object" !== typeof a) return null;
    a = z && a[z] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C2 = Object.assign, D = {};
  function E(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  E.prototype.isReactComponent = {};
  E.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b, "setState");
  };
  E.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E.prototype;
  function G(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  var H = G.prototype = new F();
  H.constructor = G;
  C2(H, E.prototype);
  H.isPureReactComponent = true;
  var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M(a, b, e) {
    var d, c = {}, k = null, h2 = null;
    if (null != b) for (d in void 0 !== b.ref && (h2 = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
    var g = arguments.length - 2;
    if (1 === g) c.children = e;
    else if (1 < g) {
      for (var f = Array(g), m2 = 0; m2 < g; m2++) f[m2] = arguments[m2 + 2];
      c.children = f;
    }
    if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
    return { $$typeof: l, type: a, key: k, ref: h2, props: c, _owner: K.current };
  }
  function N(a, b) {
    return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
  }
  function O(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l;
  }
  function escape2(a) {
    var b = { "=": "=0", ":": "=2" };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b[a2];
    });
  }
  var P = /\/+/g;
  function Q(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
  }
  function R(a, b, e, d, c) {
    var k = typeof a;
    if ("undefined" === k || "boolean" === k) a = null;
    var h2 = false;
    if (null === a) h2 = true;
    else switch (k) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l:
          case n:
            h2 = true;
        }
    }
    if (h2) return h2 = a, c = c(h2), a = "" === d ? "." + Q(h2, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
      return a2;
    })) : null != c && (O(c) && (c = N(c, e + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
    h2 = 0;
    d = "" === d ? "." : d + ":";
    if (I(a)) for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = d + Q(k, g);
      h2 += R(k, b, e, f, c);
    }
    else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h2 += R(k, b, e, f, c);
    else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S(a, b, e) {
    if (null == a) return a;
    var d = [], c = 0;
    R(a, d, "", "", function(a2) {
      return b.call(e, a2, c++);
    });
    return d;
  }
  function T(a) {
    if (-1 === a._status) {
      var b = a._result;
      b = b();
      b.then(function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
      }, function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
      });
      -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
  }
  var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
  function X() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S, forEach: function(a, b, e) {
    S(a, function() {
      b.apply(this, arguments);
    }, e);
  }, count: function(a) {
    var b = 0;
    S(a, function() {
      b++;
    });
    return b;
  }, toArray: function(a) {
    return S(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  } };
  react_production_min.Component = E;
  react_production_min.Fragment = p;
  react_production_min.Profiler = r;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X;
  react_production_min.cloneElement = function(a, b, e) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d = C2({}, a.props), c = a.key, k = a.ref, h2 = a._owner;
    if (null != b) {
      void 0 !== b.ref && (k = b.ref, h2 = K.current);
      void 0 !== b.key && (c = "" + b.key);
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
      for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
    var f = arguments.length - 2;
    if (1 === f) d.children = e;
    else if (1 < f) {
      g = Array(f);
      for (var m2 = 0; m2 < f; m2++) g[m2] = arguments[m2 + 2];
      d.children = g;
    }
    return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h2 };
  };
  react_production_min.createContext = function(a) {
    a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a.Provider = { $$typeof: t, _context: a };
    return a.Consumer = a;
  };
  react_production_min.createElement = M;
  react_production_min.createFactory = function(a) {
    var b = M.bind(null, a);
    b.type = a;
    return b;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a) {
    return { $$typeof: v, render: a };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a) {
    return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
  };
  react_production_min.memo = function(a, b) {
    return { $$typeof: x2, type: a, compare: void 0 === b ? null : b };
  };
  react_production_min.startTransition = function(a) {
    var b = V.transition;
    V.transition = {};
    try {
      a();
    } finally {
      V.transition = b;
    }
  };
  react_production_min.unstable_act = X;
  react_production_min.useCallback = function(a, b) {
    return U.current.useCallback(a, b);
  };
  react_production_min.useContext = function(a) {
    return U.current.useContext(a);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a) {
    return U.current.useDeferredValue(a);
  };
  react_production_min.useEffect = function(a, b) {
    return U.current.useEffect(a, b);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a, b, e) {
    return U.current.useImperativeHandle(a, b, e);
  };
  react_production_min.useInsertionEffect = function(a, b) {
    return U.current.useInsertionEffect(a, b);
  };
  react_production_min.useLayoutEffect = function(a, b) {
    return U.current.useLayoutEffect(a, b);
  };
  react_production_min.useMemo = function(a, b) {
    return U.current.useMemo(a, b);
  };
  react_production_min.useReducer = function(a, b, e) {
    return U.current.useReducer(a, b, e);
  };
  react_production_min.useRef = function(a) {
    return U.current.useRef(a);
  };
  react_production_min.useState = function(a) {
    return U.current.useState(a);
  };
  react_production_min.useSyncExternalStore = function(a, b, e) {
    return U.current.useSyncExternalStore(a, b, e);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var react_development = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
react_development.exports;
var hasRequiredReact_development;
function requireReact_development() {
  if (hasRequiredReact_development) return react_development.exports;
  hasRequiredReact_development = 1;
  (function(module, exports) {
    if (process.env.NODE_ENV !== "production") {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.3.1";
        var REACT_ELEMENT_TYPE2 = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn2(format2) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format2, args);
            }
          }
        }
        function error(format2) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format2, args);
            }
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign2 = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn2("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign2(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray2(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x2) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config2) {
          {
            if (hasOwnProperty.call(config2, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.ref !== void 0;
        }
        function hasValidKey(config2) {
          {
            if (hasOwnProperty.call(config2, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config2) {
          {
            if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key2, ref2, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE2,
            // Built-in properties that belong on the element
            type,
            key: key2,
            ref: ref2,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config2, children2) {
          var propName;
          var props = {};
          var key2 = null;
          var ref2 = null;
          var self2 = null;
          var source = null;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref2 = config2.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config2);
              }
            }
            if (hasValidKey(config2)) {
              {
                checkKeyStringCoercion(config2.key);
              }
              key2 = "" + config2.key;
            }
            self2 = config2.__self === void 0 ? null : config2.__self;
            source = config2.__source === void 0 ? null : config2.__source;
            for (propName in config2) {
              if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config2[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children2;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i2 = 0; i2 < childrenLength; i2++) {
              childArray[i2] = arguments[i2 + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key2 || ref2) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key2) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref2) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key2, ref2, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config2, children2) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign2({}, element.props);
          var key2 = element.key;
          var ref2 = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref2 = config2.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config2)) {
              {
                checkKeyStringCoercion(config2.key);
              }
              key2 = "" + config2.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config2) {
              if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config2[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config2[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children2;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i2 = 0; i2 < childrenLength; i2++) {
              childArray[i2] = arguments[i2 + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key2, ref2, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE2;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape2(key2) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key2.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text2) {
          return text2.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape2("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children2, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children2;
          if (type === "undefined" || type === "boolean") {
            children2 = null;
          }
          var invokeCallback = false;
          if (children2 === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children2.$$typeof) {
                  case REACT_ELEMENT_TYPE2:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children2;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray2(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray2(children2)) {
            for (var i2 = 0; i2 < children2.length; i2++) {
              child = children2[i2];
              nextName = nextNamePrefix + getElementKey(child, i2);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children2);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children2;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children2);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children2).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children2, func, context) {
          if (children2 == null) {
            return children2;
          }
          var result2 = [];
          var count = 0;
          mapIntoArray(children2, result2, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result2;
        }
        function countChildren(children2) {
          var n = 0;
          mapChildren(children2, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children2, forEachFunc, forEachContext) {
          mapChildren(children2, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children2) {
          return mapChildren(children2, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children2) {
          if (!isValidElement(children2)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children2;
        }
        function createContext(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn2("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render2) {
          {
            if (render2 != null && render2.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render2 !== "function") {
              error("forwardRef requires a render function but was given %s.", render2 === null ? "null" : typeof render2);
            } else {
              if (render2.length !== 0 && render2.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render2.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render2 != null) {
              if (render2.defaultProps != null || render2.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render2
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (!render2.name && !render2.displayName) {
                  render2.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare2) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare2 === void 0 ? null : compare2
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (!type.name && !type.displayName) {
                  type.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context2) {
          var dispatcher = resolveDispatcher();
          {
            if (Context2._context !== void 0) {
              var realContext = Context2._context;
              if (realContext.Consumer === Context2) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context2) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context2);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create2, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create2, deps);
        }
        function useInsertionEffect(create2, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create2, deps);
        }
        function useLayoutEffect(create2, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create2, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create2, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create2, deps);
        }
        function useImperativeHandle(ref2, create2, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref2, create2, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign2({}, props, {
                  value: prevLog
                }),
                info: assign2({}, props, {
                  value: prevInfo
                }),
                warn: assign2({}, props, {
                  value: prevWarn
                }),
                error: assign2({}, props, {
                  value: prevError
                }),
                group: assign2({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign2({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign2({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x2) {
                var match = x2.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x2) {
                  control = x2;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x2) {
                  control = x2;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x2) {
                control = x2;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x2) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has2 = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name2 = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node2, parentType) {
          if (typeof node2 !== "object") {
            return;
          }
          if (isArray2(node2)) {
            for (var i2 = 0; i2 < node2.length; i2++) {
              var child = node2[i2];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node2)) {
            if (node2._store) {
              node2._store.validated = true;
            }
          } else if (node2) {
            var iteratorFn = getIteratorFn(node2);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node2.entries) {
                var iterator = iteratorFn.call(node2);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name2 = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name2, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i2 = 0; i2 < keys2.length; i2++) {
              var key2 = keys2[i2];
              if (key2 !== "children" && key2 !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children2) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray2(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE2) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i2 = 2; i2 < arguments.length; i2++) {
              validateChildKeys(arguments[i2], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn2("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn2("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children2) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i2 = 2; i2 < arguments.length; i2++) {
            validateChildKeys(arguments[i2], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn2("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module && module[requireString];
              enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result2;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result2 = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth);
              throw error2;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result2 !== null && typeof result2 === "object" && typeof result2.then === "function") {
              var thenableResult = result2;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve3, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve3, reject);
                    } else {
                      resolve3(returnValue2);
                    }
                  }, function(error2) {
                    popActScope(prevActScopeDepth);
                    reject(error2);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result2;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve3, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve3, reject);
                    } else {
                      resolve3(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve3, reject) {
                    resolve3(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve3, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve3(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve3, reject);
                  }
                });
              } catch (error2) {
                reject(error2);
              }
            } else {
              resolve3(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i2 = 0;
              try {
                for (; i2 < queue.length; i2++) {
                  var callback = queue[i2];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error2) {
                queue = queue.slice(i2 + 1);
                throw error2;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.act = act;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  })(react_development, react_development.exports);
  return react_development.exports;
}
if (process.env.NODE_ENV === "production") {
  react.exports = requireReact_production_min();
} else {
  react.exports = requireReact_development();
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
var lib$9 = {};
var activitymonitor = {};
var ArrayExt;
(function(ArrayExt2) {
  function firstIndexOf(array, value, start = 0, stop = -1) {
    let n = array.length;
    if (n === 0) {
      return -1;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    let span;
    if (stop < start) {
      span = stop + 1 + (n - start);
    } else {
      span = stop - start + 1;
    }
    for (let i2 = 0; i2 < span; ++i2) {
      let j = (start + i2) % n;
      if (array[j] === value) {
        return j;
      }
    }
    return -1;
  }
  ArrayExt2.firstIndexOf = firstIndexOf;
  function lastIndexOf(array, value, start = -1, stop = 0) {
    let n = array.length;
    if (n === 0) {
      return -1;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    let span;
    if (start < stop) {
      span = start + 1 + (n - stop);
    } else {
      span = start - stop + 1;
    }
    for (let i2 = 0; i2 < span; ++i2) {
      let j = (start - i2 + n) % n;
      if (array[j] === value) {
        return j;
      }
    }
    return -1;
  }
  ArrayExt2.lastIndexOf = lastIndexOf;
  function findFirstIndex(array, fn, start = 0, stop = -1) {
    let n = array.length;
    if (n === 0) {
      return -1;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    let span;
    if (stop < start) {
      span = stop + 1 + (n - start);
    } else {
      span = stop - start + 1;
    }
    for (let i2 = 0; i2 < span; ++i2) {
      let j = (start + i2) % n;
      if (fn(array[j], j)) {
        return j;
      }
    }
    return -1;
  }
  ArrayExt2.findFirstIndex = findFirstIndex;
  function findLastIndex(array, fn, start = -1, stop = 0) {
    let n = array.length;
    if (n === 0) {
      return -1;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    let d;
    if (start < stop) {
      d = start + 1 + (n - stop);
    } else {
      d = start - stop + 1;
    }
    for (let i2 = 0; i2 < d; ++i2) {
      let j = (start - i2 + n) % n;
      if (fn(array[j], j)) {
        return j;
      }
    }
    return -1;
  }
  ArrayExt2.findLastIndex = findLastIndex;
  function findFirstValue(array, fn, start = 0, stop = -1) {
    let index = findFirstIndex(array, fn, start, stop);
    return index !== -1 ? array[index] : void 0;
  }
  ArrayExt2.findFirstValue = findFirstValue;
  function findLastValue(array, fn, start = -1, stop = 0) {
    let index = findLastIndex(array, fn, start, stop);
    return index !== -1 ? array[index] : void 0;
  }
  ArrayExt2.findLastValue = findLastValue;
  function lowerBound(array, value, fn, start = 0, stop = -1) {
    let n = array.length;
    if (n === 0) {
      return 0;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    let begin = start;
    let span = stop - start + 1;
    while (span > 0) {
      let half = span >> 1;
      let middle = begin + half;
      if (fn(array[middle], value) < 0) {
        begin = middle + 1;
        span -= half + 1;
      } else {
        span = half;
      }
    }
    return begin;
  }
  ArrayExt2.lowerBound = lowerBound;
  function upperBound(array, value, fn, start = 0, stop = -1) {
    let n = array.length;
    if (n === 0) {
      return 0;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    let begin = start;
    let span = stop - start + 1;
    while (span > 0) {
      let half = span >> 1;
      let middle = begin + half;
      if (fn(array[middle], value) > 0) {
        span = half;
      } else {
        begin = middle + 1;
        span -= half + 1;
      }
    }
    return begin;
  }
  ArrayExt2.upperBound = upperBound;
  function shallowEqual(a, b, fn) {
    if (a === b) {
      return true;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i2 = 0, n = a.length; i2 < n; ++i2) {
      if (fn ? !fn(a[i2], b[i2]) : a[i2] !== b[i2]) {
        return false;
      }
    }
    return true;
  }
  ArrayExt2.shallowEqual = shallowEqual;
  function slice(array, options = {}) {
    let { start, stop, step } = options;
    if (step === void 0) {
      step = 1;
    }
    if (step === 0) {
      throw new Error("Slice `step` cannot be zero.");
    }
    let n = array.length;
    if (start === void 0) {
      start = step < 0 ? n - 1 : 0;
    } else if (start < 0) {
      start = Math.max(start + n, step < 0 ? -1 : 0);
    } else if (start >= n) {
      start = step < 0 ? n - 1 : n;
    }
    if (stop === void 0) {
      stop = step < 0 ? -1 : n;
    } else if (stop < 0) {
      stop = Math.max(stop + n, step < 0 ? -1 : 0);
    } else if (stop >= n) {
      stop = step < 0 ? n - 1 : n;
    }
    let length2;
    if (step < 0 && stop >= start || step > 0 && start >= stop) {
      length2 = 0;
    } else if (step < 0) {
      length2 = Math.floor((stop - start + 1) / step + 1);
    } else {
      length2 = Math.floor((stop - start - 1) / step + 1);
    }
    let result2 = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      result2[i2] = array[start + i2 * step];
    }
    return result2;
  }
  ArrayExt2.slice = slice;
  function move(array, fromIndex, toIndex) {
    let n = array.length;
    if (n <= 1) {
      return;
    }
    if (fromIndex < 0) {
      fromIndex = Math.max(0, fromIndex + n);
    } else {
      fromIndex = Math.min(fromIndex, n - 1);
    }
    if (toIndex < 0) {
      toIndex = Math.max(0, toIndex + n);
    } else {
      toIndex = Math.min(toIndex, n - 1);
    }
    if (fromIndex === toIndex) {
      return;
    }
    let value = array[fromIndex];
    let d = fromIndex < toIndex ? 1 : -1;
    for (let i2 = fromIndex; i2 !== toIndex; i2 += d) {
      array[i2] = array[i2 + d];
    }
    array[toIndex] = value;
  }
  ArrayExt2.move = move;
  function reverse(array, start = 0, stop = -1) {
    let n = array.length;
    if (n <= 1) {
      return;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    while (start < stop) {
      let a = array[start];
      let b = array[stop];
      array[start++] = b;
      array[stop--] = a;
    }
  }
  ArrayExt2.reverse = reverse;
  function rotate(array, delta, start = 0, stop = -1) {
    let n = array.length;
    if (n <= 1) {
      return;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    if (start >= stop) {
      return;
    }
    let length2 = stop - start + 1;
    if (delta > 0) {
      delta = delta % length2;
    } else if (delta < 0) {
      delta = (delta % length2 + length2) % length2;
    }
    if (delta === 0) {
      return;
    }
    let pivot = start + delta;
    reverse(array, start, pivot - 1);
    reverse(array, pivot, stop);
    reverse(array, start, stop);
  }
  ArrayExt2.rotate = rotate;
  function fill(array, value, start = 0, stop = -1) {
    let n = array.length;
    if (n === 0) {
      return;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    let span;
    if (stop < start) {
      span = stop + 1 + (n - start);
    } else {
      span = stop - start + 1;
    }
    for (let i2 = 0; i2 < span; ++i2) {
      array[(start + i2) % n] = value;
    }
  }
  ArrayExt2.fill = fill;
  function insert2(array, index, value) {
    let n = array.length;
    if (index < 0) {
      index = Math.max(0, index + n);
    } else {
      index = Math.min(index, n);
    }
    for (let i2 = n; i2 > index; --i2) {
      array[i2] = array[i2 - 1];
    }
    array[index] = value;
  }
  ArrayExt2.insert = insert2;
  function removeAt(array, index) {
    let n = array.length;
    if (index < 0) {
      index += n;
    }
    if (index < 0 || index >= n) {
      return void 0;
    }
    let value = array[index];
    for (let i2 = index + 1; i2 < n; ++i2) {
      array[i2 - 1] = array[i2];
    }
    array.length = n - 1;
    return value;
  }
  ArrayExt2.removeAt = removeAt;
  function removeFirstOf(array, value, start = 0, stop = -1) {
    let index = firstIndexOf(array, value, start, stop);
    if (index !== -1) {
      removeAt(array, index);
    }
    return index;
  }
  ArrayExt2.removeFirstOf = removeFirstOf;
  function removeLastOf(array, value, start = -1, stop = 0) {
    let index = lastIndexOf(array, value, start, stop);
    if (index !== -1) {
      removeAt(array, index);
    }
    return index;
  }
  ArrayExt2.removeLastOf = removeLastOf;
  function removeAllOf(array, value, start = 0, stop = -1) {
    let n = array.length;
    if (n === 0) {
      return 0;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    let count = 0;
    for (let i2 = 0; i2 < n; ++i2) {
      if (start <= stop && i2 >= start && i2 <= stop && array[i2] === value) {
        count++;
      } else if (stop < start && (i2 <= stop || i2 >= start) && array[i2] === value) {
        count++;
      } else if (count > 0) {
        array[i2 - count] = array[i2];
      }
    }
    if (count > 0) {
      array.length = n - count;
    }
    return count;
  }
  ArrayExt2.removeAllOf = removeAllOf;
  function removeFirstWhere(array, fn, start = 0, stop = -1) {
    let value;
    let index = findFirstIndex(array, fn, start, stop);
    if (index !== -1) {
      value = removeAt(array, index);
    }
    return { index, value };
  }
  ArrayExt2.removeFirstWhere = removeFirstWhere;
  function removeLastWhere(array, fn, start = -1, stop = 0) {
    let value;
    let index = findLastIndex(array, fn, start, stop);
    if (index !== -1) {
      value = removeAt(array, index);
    }
    return { index, value };
  }
  ArrayExt2.removeLastWhere = removeLastWhere;
  function removeAllWhere(array, fn, start = 0, stop = -1) {
    let n = array.length;
    if (n === 0) {
      return 0;
    }
    if (start < 0) {
      start = Math.max(0, start + n);
    } else {
      start = Math.min(start, n - 1);
    }
    if (stop < 0) {
      stop = Math.max(0, stop + n);
    } else {
      stop = Math.min(stop, n - 1);
    }
    let count = 0;
    for (let i2 = 0; i2 < n; ++i2) {
      if (start <= stop && i2 >= start && i2 <= stop && fn(array[i2], i2)) {
        count++;
      } else if (stop < start && (i2 <= stop || i2 >= start) && fn(array[i2], i2)) {
        count++;
      } else if (count > 0) {
        array[i2 - count] = array[i2];
      }
    }
    if (count > 0) {
      array.length = n - count;
    }
    return count;
  }
  ArrayExt2.removeAllWhere = removeAllWhere;
})(ArrayExt || (ArrayExt = {}));
function* empty() {
  return;
}
function find$3(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return value;
    }
  }
  return void 0;
}
function findIndex(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return index - 1;
    }
  }
  return -1;
}
function max$1(object, fn) {
  let result2 = void 0;
  for (const value of object) {
    if (result2 === void 0) {
      result2 = value;
      continue;
    }
    if (fn(value, result2) > 0) {
      result2 = value;
    }
  }
  return result2;
}
function every$1(object, fn) {
  let index = 0;
  for (const value of object) {
    if (false === fn(value, index++)) {
      return false;
    }
  }
  return true;
}
function some$1(object, fn) {
  let index = 0;
  for (const value of object) {
    if (fn(value, index++)) {
      return true;
    }
  }
  return false;
}
function* map$1(object, fn) {
  let index = 0;
  for (const value of object) {
    yield fn(value, index++);
  }
}
var Private$B;
(function(Private2) {
  function rangeLength(start, stop, step) {
    if (step === 0) {
      return Infinity;
    }
    if (start > stop && step > 0) {
      return 0;
    }
    if (start < stop && step < 0) {
      return 0;
    }
    return Math.ceil((stop - start) / step);
  }
  Private2.rangeLength = rangeLength;
})(Private$B || (Private$B = {}));
function* retro(object) {
  if (typeof object.retro === "function") {
    yield* object.retro();
  } else {
    for (let index = object.length - 1; index > -1; index--) {
      yield object[index];
    }
  }
}
function topologicSort(edges) {
  let sorted = [];
  let visited = /* @__PURE__ */ new Set();
  let graph = /* @__PURE__ */ new Map();
  for (const edge of edges) {
    addEdge(edge);
  }
  for (const [k] of graph) {
    visit(k);
  }
  return sorted;
  function addEdge(edge) {
    let [fromNode, toNode] = edge;
    let children2 = graph.get(toNode);
    if (children2) {
      children2.push(fromNode);
    } else {
      graph.set(toNode, [fromNode]);
    }
  }
  function visit(node2) {
    if (visited.has(node2)) {
      return;
    }
    visited.add(node2);
    let children2 = graph.get(node2);
    if (children2) {
      for (const child of children2) {
        visit(child);
      }
    }
    sorted.push(node2);
  }
}
var StringExt;
(function(StringExt2) {
  function findIndices(source, query, start = 0) {
    let indices = new Array(query.length);
    for (let i2 = 0, j = start, n = query.length; i2 < n; ++i2, ++j) {
      j = source.indexOf(query[i2], j);
      if (j === -1) {
        return null;
      }
      indices[i2] = j;
    }
    return indices;
  }
  StringExt2.findIndices = findIndices;
  function matchSumOfSquares(source, query, start = 0) {
    let indices = findIndices(source, query, start);
    if (!indices) {
      return null;
    }
    let score = 0;
    for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
      let j = indices[i2] - start;
      score += j * j;
    }
    return { score, indices };
  }
  StringExt2.matchSumOfSquares = matchSumOfSquares;
  function matchSumOfDeltas(source, query, start = 0) {
    let indices = findIndices(source, query, start);
    if (!indices) {
      return null;
    }
    let score = 0;
    let last2 = start - 1;
    for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
      let j = indices[i2];
      score += j - last2 - 1;
      last2 = j;
    }
    return { score, indices };
  }
  StringExt2.matchSumOfDeltas = matchSumOfDeltas;
  function highlight(source, indices, fn) {
    let result2 = [];
    let k = 0;
    let last2 = 0;
    let n = indices.length;
    while (k < n) {
      let i2 = indices[k];
      let j = indices[k];
      while (++k < n && indices[k] === j + 1) {
        j++;
      }
      if (last2 < i2) {
        result2.push(source.slice(last2, i2));
      }
      if (i2 < j + 1) {
        result2.push(fn(source.slice(i2, j + 1)));
      }
      last2 = j + 1;
    }
    if (last2 < source.length) {
      result2.push(source.slice(last2));
    }
    return result2;
  }
  StringExt2.highlight = highlight;
  function cmp(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  StringExt2.cmp = cmp;
})(StringExt || (StringExt = {}));
var JSONExt;
(function(JSONExt2) {
  JSONExt2.emptyObject = Object.freeze({});
  JSONExt2.emptyArray = Object.freeze([]);
  function isPrimitive(value) {
    return value === null || typeof value === "boolean" || typeof value === "number" || typeof value === "string";
  }
  JSONExt2.isPrimitive = isPrimitive;
  function isArray2(value) {
    return Array.isArray(value);
  }
  JSONExt2.isArray = isArray2;
  function isObject2(value) {
    return !isPrimitive(value) && !isArray2(value);
  }
  JSONExt2.isObject = isObject2;
  function deepEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (isPrimitive(first) || isPrimitive(second)) {
      return false;
    }
    let a1 = isArray2(first);
    let a2 = isArray2(second);
    if (a1 !== a2) {
      return false;
    }
    if (a1 && a2) {
      return deepArrayEqual(first, second);
    }
    return deepObjectEqual(first, second);
  }
  JSONExt2.deepEqual = deepEqual;
  function deepCopy(value) {
    if (isPrimitive(value)) {
      return value;
    }
    if (isArray2(value)) {
      return deepArrayCopy(value);
    }
    return deepObjectCopy(value);
  }
  JSONExt2.deepCopy = deepCopy;
  function deepArrayEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (first.length !== second.length) {
      return false;
    }
    for (let i2 = 0, n = first.length; i2 < n; ++i2) {
      if (!deepEqual(first[i2], second[i2])) {
        return false;
      }
    }
    return true;
  }
  function deepObjectEqual(first, second) {
    if (first === second) {
      return true;
    }
    for (let key2 in first) {
      if (first[key2] !== void 0 && !(key2 in second)) {
        return false;
      }
    }
    for (let key2 in second) {
      if (second[key2] !== void 0 && !(key2 in first)) {
        return false;
      }
    }
    for (let key2 in first) {
      let firstValue = first[key2];
      let secondValue = second[key2];
      if (firstValue === void 0 && secondValue === void 0) {
        continue;
      }
      if (firstValue === void 0 || secondValue === void 0) {
        return false;
      }
      if (!deepEqual(firstValue, secondValue)) {
        return false;
      }
    }
    return true;
  }
  function deepArrayCopy(value) {
    let result2 = new Array(value.length);
    for (let i2 = 0, n = value.length; i2 < n; ++i2) {
      result2[i2] = deepCopy(value[i2]);
    }
    return result2;
  }
  function deepObjectCopy(value) {
    let result2 = {};
    for (let key2 in value) {
      let subvalue = value[key2];
      if (subvalue === void 0) {
        continue;
      }
      result2[key2] = deepCopy(subvalue);
    }
    return result2;
  }
})(JSONExt || (JSONExt = {}));
class MimeData {
  constructor() {
    this._types = [];
    this._values = [];
  }
  /**
   * Get an array of the MIME types contained within the dataset.
   *
   * @returns A new array of the MIME types, in order of insertion.
   */
  types() {
    return this._types.slice();
  }
  /**
   * Test whether the dataset has an entry for the given type.
   *
   * @param mime - The MIME type of interest.
   *
   * @returns `true` if the dataset contains a value for the given
   *   MIME type, `false` otherwise.
   */
  hasData(mime) {
    return this._types.indexOf(mime) !== -1;
  }
  /**
   * Get the data value for the given MIME type.
   *
   * @param mime - The MIME type of interest.
   *
   * @returns The value for the given MIME type, or `undefined` if
   *   the dataset does not contain a value for the type.
   */
  getData(mime) {
    let i2 = this._types.indexOf(mime);
    return i2 !== -1 ? this._values[i2] : void 0;
  }
  /**
   * Set the data value for the given MIME type.
   *
   * @param mime - The MIME type of interest.
   *
   * @param data - The data value for the given MIME type.
   *
   * #### Notes
   * This will overwrite any previous entry for the MIME type.
   */
  setData(mime, data) {
    this.clearData(mime);
    this._types.push(mime);
    this._values.push(data);
  }
  /**
   * Remove the data entry for the given MIME type.
   *
   * @param mime - The MIME type of interest.
   *
   * #### Notes
   * This is a no-op if there is no entry for the given MIME type.
   */
  clearData(mime) {
    let i2 = this._types.indexOf(mime);
    if (i2 !== -1) {
      this._types.splice(i2, 1);
      this._values.splice(i2, 1);
    }
  }
  /**
   * Remove all data entries from the dataset.
   */
  clear() {
    this._types.length = 0;
    this._values.length = 0;
  }
}
class PluginRegistry {
  constructor(options = {}) {
    this._application = null;
    this._validatePlugin = () => true;
    this._plugins = /* @__PURE__ */ new Map();
    this._services = /* @__PURE__ */ new Map();
    if (options.validatePlugin) {
      console.info("Plugins may be rejected by the custom validation plugin method.");
      this._validatePlugin = options.validatePlugin;
    }
  }
  /**
   * The application object.
   *
   * It will be provided as first argument to the
   * plugins activation and deactivation functions.
   *
   * It can only be set once.
   *
   * By default, it is `null`.
   */
  get application() {
    return this._application;
  }
  set application(v) {
    if (this._application !== null) {
      throw Error("PluginRegistry.application is already set. It cannot be overridden.");
    }
    this._application = v;
  }
  /**
   * The list of all the deferred plugins.
   */
  get deferredPlugins() {
    return Array.from(this._plugins).filter(([id, plugin2]) => plugin2.autoStart === "defer").map(([id, plugin2]) => id);
  }
  /**
   * Get a plugin description.
   *
   * @param id - The ID of the plugin of interest.
   *
   * @returns The plugin description.
   */
  getPluginDescription(id) {
    var _a, _b;
    return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : "";
  }
  /**
   * Test whether a plugin is registered with the application.
   *
   * @param id - The ID of the plugin of interest.
   *
   * @returns `true` if the plugin is registered, `false` otherwise.
   */
  hasPlugin(id) {
    return this._plugins.has(id);
  }
  /**
   * Test whether a plugin is activated with the application.
   *
   * @param id - The ID of the plugin of interest.
   *
   * @returns `true` if the plugin is activated, `false` otherwise.
   */
  isPluginActivated(id) {
    var _a, _b;
    return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.activated) !== null && _b !== void 0 ? _b : false;
  }
  /**
   * List the IDs of the plugins registered with the application.
   *
   * @returns A new array of the registered plugin IDs.
   */
  listPlugins() {
    return Array.from(this._plugins.keys());
  }
  /**
   * Register a plugin with the application.
   *
   * @param plugin - The plugin to register.
   *
   * #### Notes
   * An error will be thrown if a plugin with the same ID is already
   * registered, or if the plugin has a circular dependency.
   *
   * If the plugin provides a service which has already been provided
   * by another plugin, the new service will override the old service.
   */
  registerPlugin(plugin2) {
    if (this._plugins.has(plugin2.id)) {
      throw new TypeError(`Plugin '${plugin2.id}' is already registered.`);
    }
    if (!this._validatePlugin(plugin2)) {
      throw new Error(`Plugin '${plugin2.id}' is not valid.`);
    }
    const data = Private$A.createPluginData(plugin2);
    Private$A.ensureNoCycle(data, this._plugins, this._services);
    if (data.provides) {
      this._services.set(data.provides, data.id);
    }
    this._plugins.set(data.id, data);
  }
  /**
   * Register multiple plugins with the application.
   *
   * @param plugins - The plugins to register.
   *
   * #### Notes
   * This calls `registerPlugin()` for each of the given plugins.
   */
  registerPlugins(plugins) {
    for (const plugin2 of plugins) {
      this.registerPlugin(plugin2);
    }
  }
  /**
   * Deregister a plugin with the application.
   *
   * @param id - The ID of the plugin of interest.
   *
   * @param force - Whether to deregister the plugin even if it is active.
   */
  deregisterPlugin(id, force) {
    const plugin2 = this._plugins.get(id);
    if (!plugin2) {
      return;
    }
    if (plugin2.activated && !force) {
      throw new Error(`Plugin '${id}' is still active.`);
    }
    this._plugins.delete(id);
  }
  /**
   * Activate the plugin with the given ID.
   *
   * @param id - The ID of the plugin of interest.
   *
   * @returns A promise which resolves when the plugin is activated
   *   or rejects with an error if it cannot be activated.
   */
  async activatePlugin(id) {
    const plugin2 = this._plugins.get(id);
    if (!plugin2) {
      throw new ReferenceError(`Plugin '${id}' is not registered.`);
    }
    if (plugin2.activated) {
      return;
    }
    if (plugin2.promise) {
      return plugin2.promise;
    }
    const required3 = plugin2.requires.map((t) => this.resolveRequiredService(t));
    const optional = plugin2.optional.map((t) => this.resolveOptionalService(t));
    plugin2.promise = Promise.all([...required3, ...optional]).then((services) => plugin2.activate.apply(void 0, [this.application, ...services])).then((service) => {
      plugin2.service = service;
      plugin2.activated = true;
      plugin2.promise = null;
    }).catch((error) => {
      plugin2.promise = null;
      throw error;
    });
    return plugin2.promise;
  }
  /**
   * Activate all the deferred plugins.
   *
   * @returns A promise which will resolve when each plugin is activated
   * or rejects with an error if one cannot be activated.
   */
  async activatePlugins(kind, options = {}) {
    switch (kind) {
      case "defer": {
        const promises = this.deferredPlugins.filter((pluginId) => this._plugins.get(pluginId).autoStart).map((pluginId) => {
          return this.activatePlugin(pluginId);
        });
        await Promise.all(promises);
        break;
      }
      case "startUp": {
        const startups = Private$A.collectStartupPlugins(this._plugins, options);
        const promises = startups.map(async (id) => {
          try {
            return await this.activatePlugin(id);
          } catch (error) {
            console.error(`Plugin '${id}' failed to activate.`, error);
          }
        });
        await Promise.all(promises);
        break;
      }
    }
  }
  /**
   * Deactivate the plugin and its downstream dependents if and only if the
   * plugin and its dependents all support `deactivate`.
   *
   * @param id - The ID of the plugin of interest.
   *
   * @returns A list of IDs of downstream plugins deactivated with this one.
   */
  async deactivatePlugin(id) {
    const plugin2 = this._plugins.get(id);
    if (!plugin2) {
      throw new ReferenceError(`Plugin '${id}' is not registered.`);
    }
    if (!plugin2.activated) {
      return [];
    }
    if (!plugin2.deactivate) {
      throw new TypeError(`Plugin '${id}'#deactivate() method missing`);
    }
    const manifest = Private$A.findDependents(id, this._plugins, this._services);
    const downstream = manifest.map((id2) => this._plugins.get(id2));
    for (const plugin3 of downstream) {
      if (!plugin3.deactivate) {
        throw new TypeError(`Plugin ${plugin3.id}#deactivate() method missing (depends on ${id})`);
      }
    }
    for (const plugin3 of downstream) {
      const services = [...plugin3.requires, ...plugin3.optional].map((service) => {
        const id2 = this._services.get(service);
        return id2 ? this._plugins.get(id2).service : null;
      });
      await plugin3.deactivate(this.application, ...services);
      plugin3.service = null;
      plugin3.activated = false;
    }
    manifest.pop();
    return manifest;
  }
  /**
   * Resolve a required service of a given type.
   *
   * @param token - The token for the service type of interest.
   *
   * @returns A promise which resolves to an instance of the requested
   *   service, or rejects with an error if it cannot be resolved.
   *
   * #### Notes
   * Services are singletons. The same instance will be returned each
   * time a given service token is resolved.
   *
   * If the plugin which provides the service has not been activated,
   * resolving the service will automatically activate the plugin.
   *
   * User code will not typically call this method directly. Instead,
   * the required services for the user's plugins will be resolved
   * automatically when the plugin is activated.
   */
  async resolveRequiredService(token) {
    const id = this._services.get(token);
    if (!id) {
      throw new TypeError(`No provider for: ${token.name}.`);
    }
    const plugin2 = this._plugins.get(id);
    if (!plugin2.activated) {
      await this.activatePlugin(id);
    }
    return plugin2.service;
  }
  /**
   * Resolve an optional service of a given type.
   *
   * @param token - The token for the service type of interest.
   *
   * @returns A promise which resolves to an instance of the requested
   *   service, or `null` if it cannot be resolved.
   *
   * #### Notes
   * Services are singletons. The same instance will be returned each
   * time a given service token is resolved.
   *
   * If the plugin which provides the service has not been activated,
   * resolving the service will automatically activate the plugin.
   *
   * User code will not typically call this method directly. Instead,
   * the optional services for the user's plugins will be resolved
   * automatically when the plugin is activated.
   */
  async resolveOptionalService(token) {
    const id = this._services.get(token);
    if (!id) {
      return null;
    }
    const plugin2 = this._plugins.get(id);
    if (!plugin2.activated) {
      try {
        await this.activatePlugin(id);
      } catch (reason) {
        console.error(reason);
        return null;
      }
    }
    return plugin2.service;
  }
}
var Private$A;
(function(Private2) {
  class PluginData {
    constructor(plugin2) {
      var _a, _b, _c, _d;
      this._activated = false;
      this._promise = null;
      this._service = null;
      this.id = plugin2.id;
      this.description = (_a = plugin2.description) !== null && _a !== void 0 ? _a : "";
      this.activate = plugin2.activate;
      this.deactivate = (_b = plugin2.deactivate) !== null && _b !== void 0 ? _b : null;
      this.provides = (_c = plugin2.provides) !== null && _c !== void 0 ? _c : null;
      this.autoStart = (_d = plugin2.autoStart) !== null && _d !== void 0 ? _d : false;
      this.requires = plugin2.requires ? plugin2.requires.slice() : [];
      this.optional = plugin2.optional ? plugin2.optional.slice() : [];
    }
    /**
     * Whether the plugin has been activated.
     */
    get activated() {
      return this._activated;
    }
    set activated(a) {
      this._activated = a;
    }
    /**
     * The resolved service for the plugin, or `null`.
     */
    get service() {
      return this._service;
    }
    set service(s) {
      this._service = s;
    }
    /**
     * The pending resolver promise, or `null`.
     */
    get promise() {
      return this._promise;
    }
    set promise(p) {
      this._promise = p;
    }
  }
  function createPluginData(plugin2) {
    return new PluginData(plugin2);
  }
  Private2.createPluginData = createPluginData;
  function ensureNoCycle(plugin2, plugins, services) {
    const dependencies = [...plugin2.requires, ...plugin2.optional];
    const visit = (token) => {
      if (token === plugin2.provides) {
        return true;
      }
      const id = services.get(token);
      if (!id) {
        return false;
      }
      const visited = plugins.get(id);
      const dependencies2 = [...visited.requires, ...visited.optional];
      if (dependencies2.length === 0) {
        return false;
      }
      trace.push(id);
      if (dependencies2.some(visit)) {
        return true;
      }
      trace.pop();
      return false;
    };
    if (!plugin2.provides || dependencies.length === 0) {
      return;
    }
    const trace = [plugin2.id];
    if (dependencies.some(visit)) {
      throw new ReferenceError(`Cycle detected: ${trace.join(" -> ")}.`);
    }
  }
  Private2.ensureNoCycle = ensureNoCycle;
  function findDependents(id, plugins, services) {
    const edges = new Array();
    const add = (id2) => {
      const plugin2 = plugins.get(id2);
      const dependencies = [...plugin2.requires, ...plugin2.optional];
      edges.push(...dependencies.reduce((acc, dep) => {
        const service = services.get(dep);
        if (service) {
          acc.push([id2, service]);
        }
        return acc;
      }, []));
    };
    for (const id2 of plugins.keys()) {
      add(id2);
    }
    const newEdges = edges.filter((edge) => edge[1] === id);
    let oldSize = 0;
    while (newEdges.length > oldSize) {
      const previousSize = newEdges.length;
      const packagesOfInterest = new Set(newEdges.map((edge) => edge[0]));
      for (const poi of packagesOfInterest) {
        edges.filter((edge) => edge[1] === poi).forEach((edge) => {
          if (!newEdges.includes(edge)) {
            newEdges.push(edge);
          }
        });
      }
      oldSize = previousSize;
    }
    const sorted = topologicSort(newEdges);
    const index = sorted.findIndex((candidate) => candidate === id);
    if (index === -1) {
      return [id];
    }
    return sorted.slice(0, index + 1);
  }
  Private2.findDependents = findDependents;
  function collectStartupPlugins(plugins, options) {
    const collection = /* @__PURE__ */ new Set();
    for (const id of plugins.keys()) {
      if (plugins.get(id).autoStart === true) {
        collection.add(id);
      }
    }
    if (options.startPlugins) {
      for (const id of options.startPlugins) {
        collection.add(id);
      }
    }
    if (options.ignorePlugins) {
      for (const id of options.ignorePlugins) {
        collection.delete(id);
      }
    }
    return Array.from(collection);
  }
  Private2.collectStartupPlugins = collectStartupPlugins;
})(Private$A || (Private$A = {}));
class PromiseDelegate {
  /**
   * Construct a new promise delegate.
   */
  constructor() {
    this.promise = new Promise((resolve3, reject) => {
      this._resolve = resolve3;
      this._reject = reject;
    });
  }
  /**
   * Resolve the wrapped promise with the given value.
   *
   * @param value - The value to use for resolving the promise.
   */
  resolve(value) {
    let resolve3 = this._resolve;
    resolve3(value);
  }
  /**
   * Reject the wrapped promise with the given value.
   *
   * @reason - The reason for rejecting the promise.
   */
  reject(reason) {
    let reject = this._reject;
    reject(reason);
  }
}
class Token {
  /**
   * Construct a new token.
   *
   * @param name - A human readable name for the token.
   * @param description - Token purpose description for documentation.
   */
  constructor(name2, description) {
    this.name = name2;
    this.description = description !== null && description !== void 0 ? description : "";
    this._tokenStructuralPropertyT = null;
  }
}
function fallbackRandomValues(buffer) {
  let value = 0;
  for (let i2 = 0, n = buffer.length; i2 < n; ++i2) {
    if (i2 % 4 === 0) {
      value = Math.random() * 4294967295 >>> 0;
    }
    buffer[i2] = value & 255;
    value >>>= 8;
  }
}
var Random;
(function(Random2) {
  Random2.getRandomValues = (() => {
    const crypto2 = typeof window !== "undefined" && (window.crypto || window.msCrypto) || null;
    if (crypto2 && typeof crypto2.getRandomValues === "function") {
      return function getRandomValues2(buffer) {
        return crypto2.getRandomValues(buffer);
      };
    }
    return fallbackRandomValues;
  })();
})(Random || (Random = {}));
function uuid4Factory(getRandomValues2) {
  const bytes = new Uint8Array(16);
  const lut = new Array(256);
  for (let i2 = 0; i2 < 16; ++i2) {
    lut[i2] = "0" + i2.toString(16);
  }
  for (let i2 = 16; i2 < 256; ++i2) {
    lut[i2] = i2.toString(16);
  }
  return function uuid4() {
    getRandomValues2(bytes);
    bytes[6] = 64 | bytes[6] & 15;
    bytes[8] = 128 | bytes[8] & 63;
    return lut[bytes[0]] + lut[bytes[1]] + lut[bytes[2]] + lut[bytes[3]] + "-" + lut[bytes[4]] + lut[bytes[5]] + "-" + lut[bytes[6]] + lut[bytes[7]] + "-" + lut[bytes[8]] + lut[bytes[9]] + "-" + lut[bytes[10]] + lut[bytes[11]] + lut[bytes[12]] + lut[bytes[13]] + lut[bytes[14]] + lut[bytes[15]];
  };
}
var UUID;
(function(UUID2) {
  UUID2.uuid4 = uuid4Factory(Random.getRandomValues);
})(UUID || (UUID = {}));
const index_es6$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get JSONExt() {
    return JSONExt;
  },
  MimeData,
  PluginRegistry,
  PromiseDelegate,
  get Random() {
    return Random;
  },
  Token,
  get UUID() {
    return UUID;
  }
}, Symbol.toStringTag, { value: "Module" }));
class Signal {
  /**
   * Construct a new signal.
   *
   * @param sender - The sender which owns the signal.
   */
  constructor(sender) {
    this.sender = sender;
  }
  /**
   * Connect a slot to the signal.
   *
   * @param slot - The slot to invoke when the signal is emitted.
   *
   * @param thisArg - The `this` context for the slot. If provided,
   *   this must be a non-primitive object.
   *
   * @returns `true` if the connection succeeds, `false` otherwise.
   */
  connect(slot, thisArg) {
    return Private$z.connect(this, slot, thisArg);
  }
  /**
   * Disconnect a slot from the signal.
   *
   * @param slot - The slot to disconnect from the signal.
   *
   * @param thisArg - The `this` context for the slot. If provided,
   *   this must be a non-primitive object.
   *
   * @returns `true` if the connection is removed, `false` otherwise.
   */
  disconnect(slot, thisArg) {
    return Private$z.disconnect(this, slot, thisArg);
  }
  /**
   * Emit the signal and invoke the connected slots.
   *
   * @param args - The args to pass to the connected slots.
   *
   * #### Notes
   * Slots are invoked synchronously in connection order.
   *
   * Exceptions thrown by connected slots will be caught and logged.
   */
  emit(args) {
    Private$z.emit(this, args);
  }
}
(function(Signal2) {
  function disconnectBetween(sender, receiver) {
    Private$z.disconnectBetween(sender, receiver);
  }
  Signal2.disconnectBetween = disconnectBetween;
  function disconnectSender(sender) {
    Private$z.disconnectSender(sender);
  }
  Signal2.disconnectSender = disconnectSender;
  function disconnectReceiver(receiver) {
    Private$z.disconnectReceiver(receiver);
  }
  Signal2.disconnectReceiver = disconnectReceiver;
  function disconnectAll(object) {
    Private$z.disconnectAll(object);
  }
  Signal2.disconnectAll = disconnectAll;
  function clearData(object) {
    Private$z.disconnectAll(object);
  }
  Signal2.clearData = clearData;
  function getExceptionHandler() {
    return Private$z.exceptionHandler;
  }
  Signal2.getExceptionHandler = getExceptionHandler;
  function setExceptionHandler(handler) {
    let old = Private$z.exceptionHandler;
    Private$z.exceptionHandler = handler;
    return old;
  }
  Signal2.setExceptionHandler = setExceptionHandler;
})(Signal || (Signal = {}));
class Stream extends Signal {
  constructor() {
    super(...arguments);
    this._pending = new PromiseDelegate();
  }
  /**
   * Return an async iterator that yields every emission.
   */
  async *[Symbol.asyncIterator]() {
    let pending = this._pending;
    while (true) {
      try {
        const { args, next } = await pending.promise;
        pending = next;
        yield args;
      } catch (_) {
        return;
      }
    }
  }
  /**
   * Emit the signal, invoke the connected slots, and yield the emission.
   *
   * @param args - The args to pass to the connected slots.
   */
  emit(args) {
    const pending = this._pending;
    const next = this._pending = new PromiseDelegate();
    pending.resolve({ args, next });
    super.emit(args);
  }
  /**
   * Stop the stream's async iteration.
   */
  stop() {
    this._pending.promise.catch(() => void 0);
    this._pending.reject("stop");
    this._pending = new PromiseDelegate();
  }
}
var Private$z;
(function(Private2) {
  Private2.exceptionHandler = (err) => {
    console.error(err);
  };
  function connect(signal2, slot, thisArg) {
    thisArg = thisArg || void 0;
    let receivers = receiversForSender.get(signal2.sender);
    if (!receivers) {
      receivers = [];
      receiversForSender.set(signal2.sender, receivers);
    }
    if (findConnection(receivers, signal2, slot, thisArg)) {
      return false;
    }
    let receiver = thisArg || slot;
    let senders = sendersForReceiver.get(receiver);
    if (!senders) {
      senders = [];
      sendersForReceiver.set(receiver, senders);
    }
    let connection = { signal: signal2, slot, thisArg };
    receivers.push(connection);
    senders.push(connection);
    return true;
  }
  Private2.connect = connect;
  function disconnect(signal2, slot, thisArg) {
    thisArg = thisArg || void 0;
    let receivers = receiversForSender.get(signal2.sender);
    if (!receivers || receivers.length === 0) {
      return false;
    }
    let connection = findConnection(receivers, signal2, slot, thisArg);
    if (!connection) {
      return false;
    }
    let receiver = thisArg || slot;
    let senders = sendersForReceiver.get(receiver);
    connection.signal = null;
    scheduleCleanup(receivers);
    scheduleCleanup(senders);
    return true;
  }
  Private2.disconnect = disconnect;
  function disconnectBetween(sender, receiver) {
    let receivers = receiversForSender.get(sender);
    if (!receivers || receivers.length === 0) {
      return;
    }
    let senders = sendersForReceiver.get(receiver);
    if (!senders || senders.length === 0) {
      return;
    }
    for (const connection of senders) {
      if (!connection.signal) {
        continue;
      }
      if (connection.signal.sender === sender) {
        connection.signal = null;
      }
    }
    scheduleCleanup(receivers);
    scheduleCleanup(senders);
  }
  Private2.disconnectBetween = disconnectBetween;
  function disconnectSender(sender) {
    let receivers = receiversForSender.get(sender);
    if (!receivers || receivers.length === 0) {
      return;
    }
    for (const connection of receivers) {
      if (!connection.signal) {
        continue;
      }
      let receiver = connection.thisArg || connection.slot;
      connection.signal = null;
      scheduleCleanup(sendersForReceiver.get(receiver));
    }
    scheduleCleanup(receivers);
  }
  Private2.disconnectSender = disconnectSender;
  function disconnectReceiver(receiver) {
    let senders = sendersForReceiver.get(receiver);
    if (!senders || senders.length === 0) {
      return;
    }
    for (const connection of senders) {
      if (!connection.signal) {
        continue;
      }
      let sender = connection.signal.sender;
      connection.signal = null;
      scheduleCleanup(receiversForSender.get(sender));
    }
    scheduleCleanup(senders);
  }
  Private2.disconnectReceiver = disconnectReceiver;
  function disconnectAll(object) {
    disconnectSender(object);
    disconnectReceiver(object);
  }
  Private2.disconnectAll = disconnectAll;
  function emit(signal2, args) {
    let receivers = receiversForSender.get(signal2.sender);
    if (!receivers || receivers.length === 0) {
      return;
    }
    for (let i2 = 0, n = receivers.length; i2 < n; ++i2) {
      let connection = receivers[i2];
      if (connection.signal === signal2) {
        invokeSlot(connection, args);
      }
    }
  }
  Private2.emit = emit;
  const receiversForSender = /* @__PURE__ */ new WeakMap();
  const sendersForReceiver = /* @__PURE__ */ new WeakMap();
  const dirtySet = /* @__PURE__ */ new Set();
  const schedule = (() => {
    let ok = typeof requestAnimationFrame === "function";
    return ok ? requestAnimationFrame : setImmediate;
  })();
  function findConnection(connections, signal2, slot, thisArg) {
    return find$3(connections, (connection) => connection.signal === signal2 && connection.slot === slot && connection.thisArg === thisArg);
  }
  function invokeSlot(connection, args) {
    let { signal: signal2, slot, thisArg } = connection;
    try {
      slot.call(thisArg, signal2.sender, args);
    } catch (err) {
      Private2.exceptionHandler(err);
    }
  }
  function scheduleCleanup(array) {
    if (dirtySet.size === 0) {
      schedule(cleanupDirtySet);
    }
    dirtySet.add(array);
  }
  function cleanupDirtySet() {
    dirtySet.forEach(cleanupConnections);
    dirtySet.clear();
  }
  function cleanupConnections(connections) {
    ArrayExt.removeAllWhere(connections, isDeadConnection);
  }
  function isDeadConnection(connection) {
    return connection.signal === null;
  }
})(Private$z || (Private$z = {}));
const index_es6$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get Signal() {
    return Signal;
  },
  Stream
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(index_es6$3);
Object.defineProperty(activitymonitor, "__esModule", { value: true });
activitymonitor.ActivityMonitor = void 0;
const signaling_1$6 = require$$0$1;
class ActivityMonitor {
  /**
   * Construct a new activity monitor.
   */
  constructor(options) {
    this._timer = -1;
    this._timeout = -1;
    this._isDisposed = false;
    this._activityStopped = new signaling_1$6.Signal(this);
    options.signal.connect(this._onSignalFired, this);
    this._timeout = options.timeout || 1e3;
  }
  /**
   * A signal emitted when activity has ceased.
   */
  get activityStopped() {
    return this._activityStopped;
  }
  /**
   * The timeout associated with the monitor, in milliseconds.
   */
  get timeout() {
    return this._timeout;
  }
  set timeout(value) {
    this._timeout = value;
  }
  /**
   * Test whether the monitor has been disposed.
   *
   * #### Notes
   * This is a read-only property.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of the resources used by the activity monitor.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    signaling_1$6.Signal.clearData(this);
  }
  /**
   * A signal handler for the monitored signal.
   */
  _onSignalFired(sender, args) {
    clearTimeout(this._timer);
    this._sender = sender;
    this._args = args;
    this._timer = setTimeout(() => {
      this._activityStopped.emit({
        sender: this._sender,
        args: this._args
      });
    }, this._timeout);
  }
}
activitymonitor.ActivityMonitor = ActivityMonitor;
var interfaces$1 = {};
Object.defineProperty(interfaces$1, "__esModule", { value: true });
var lru = {};
Object.defineProperty(lru, "__esModule", { value: true });
lru.LruCache = void 0;
const DEFAULT_MAX_SIZE = 128;
class LruCache {
  constructor(options = {}) {
    this._map = /* @__PURE__ */ new Map();
    this._maxSize = (options === null || options === void 0 ? void 0 : options.maxSize) || DEFAULT_MAX_SIZE;
  }
  /**
   * Return the current size of the cache.
   */
  get size() {
    return this._map.size;
  }
  /**
   * Clear the values in the cache.
   */
  clear() {
    this._map.clear();
  }
  /**
   * Get a value (or null) from the cache, pushing the item to the front of the cache.
   */
  get(key2) {
    const item = this._map.get(key2) || null;
    if (item != null) {
      this._map.delete(key2);
      this._map.set(key2, item);
    }
    return item;
  }
  /**
   * Set a value in the cache, potentially evicting an old item.
   */
  set(key2, value) {
    if (this._map.size >= this._maxSize) {
      this._map.delete(this._map.keys().next().value);
    }
    this._map.set(key2, value);
  }
}
lru.LruCache = LruCache;
var markdowncodeblocks = {};
Object.defineProperty(markdowncodeblocks, "__esModule", { value: true });
markdowncodeblocks.MarkdownCodeBlocks = void 0;
var MarkdownCodeBlocks;
(function(MarkdownCodeBlocks2) {
  MarkdownCodeBlocks2.CODE_BLOCK_MARKER = "```";
  const markdownExtensions = [
    ".markdown",
    ".mdown",
    ".mkdn",
    ".md",
    ".mkd",
    ".mdwn",
    ".mdtxt",
    ".mdtext",
    ".text",
    ".txt",
    ".Rmd"
  ];
  class MarkdownCodeBlock {
    constructor(startLine) {
      this.startLine = startLine;
      this.code = "";
      this.endLine = -1;
    }
  }
  MarkdownCodeBlocks2.MarkdownCodeBlock = MarkdownCodeBlock;
  function isMarkdown2(extension) {
    return markdownExtensions.indexOf(extension) > -1;
  }
  MarkdownCodeBlocks2.isMarkdown = isMarkdown2;
  function findMarkdownCodeBlocks(text2) {
    if (!text2 || text2 === "") {
      return [];
    }
    const lines = text2.split("\n");
    const codeBlocks = [];
    let currentBlock = null;
    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      const line = lines[lineIndex];
      const lineContainsMarker = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER) === 0;
      const constructingBlock = currentBlock != null;
      if (!lineContainsMarker && !constructingBlock) {
        continue;
      }
      if (!constructingBlock) {
        currentBlock = new MarkdownCodeBlock(lineIndex);
        const firstIndex = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
        const lastIndex = line.lastIndexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
        const isSingleLine = firstIndex !== lastIndex;
        if (isSingleLine) {
          currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks2.CODE_BLOCK_MARKER.length, lastIndex);
          currentBlock.endLine = lineIndex;
          codeBlocks.push(currentBlock);
          currentBlock = null;
        }
      } else if (currentBlock) {
        if (lineContainsMarker) {
          currentBlock.endLine = lineIndex - 1;
          codeBlocks.push(currentBlock);
          currentBlock = null;
        } else {
          currentBlock.code += line + "\n";
        }
      }
    }
    return codeBlocks;
  }
  MarkdownCodeBlocks2.findMarkdownCodeBlocks = findMarkdownCodeBlocks;
})(MarkdownCodeBlocks || (markdowncodeblocks.MarkdownCodeBlocks = MarkdownCodeBlocks = {}));
var pageconfig = {};
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(index_es6$4);
function hasKey(obj, keys2) {
  var o = obj;
  keys2.slice(0, -1).forEach(function(key3) {
    o = o[key3] || {};
  });
  var key2 = keys2[keys2.length - 1];
  return key2 in o;
}
function isNumber(x2) {
  if (typeof x2 === "number") {
    return true;
  }
  if (/^0x[0-9a-f]+$/i.test(x2)) {
    return true;
  }
  return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x2);
}
function isConstructorOrProto(obj, key2) {
  return key2 === "constructor" && typeof obj[key2] === "function" || key2 === "__proto__";
}
var minimist = function(args, opts) {
  if (!opts) {
    opts = {};
  }
  var flags = {
    bools: {},
    strings: {},
    unknownFn: null
  };
  if (typeof opts.unknown === "function") {
    flags.unknownFn = opts.unknown;
  }
  if (typeof opts.boolean === "boolean" && opts.boolean) {
    flags.allBools = true;
  } else {
    [].concat(opts.boolean).filter(Boolean).forEach(function(key3) {
      flags.bools[key3] = true;
    });
  }
  var aliases = {};
  function aliasIsBoolean(key3) {
    return aliases[key3].some(function(x2) {
      return flags.bools[x2];
    });
  }
  Object.keys(opts.alias || {}).forEach(function(key3) {
    aliases[key3] = [].concat(opts.alias[key3]);
    aliases[key3].forEach(function(x2) {
      aliases[x2] = [key3].concat(aliases[key3].filter(function(y) {
        return x2 !== y;
      }));
    });
  });
  [].concat(opts.string).filter(Boolean).forEach(function(key3) {
    flags.strings[key3] = true;
    if (aliases[key3]) {
      [].concat(aliases[key3]).forEach(function(k) {
        flags.strings[k] = true;
      });
    }
  });
  var defaults = opts.default || {};
  var argv = { _: [] };
  function argDefined(key3, arg2) {
    return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key3] || flags.bools[key3] || aliases[key3];
  }
  function setKey(obj, keys2, value2) {
    var o = obj;
    for (var i3 = 0; i3 < keys2.length - 1; i3++) {
      var key3 = keys2[i3];
      if (isConstructorOrProto(o, key3)) {
        return;
      }
      if (o[key3] === void 0) {
        o[key3] = {};
      }
      if (o[key3] === Object.prototype || o[key3] === Number.prototype || o[key3] === String.prototype) {
        o[key3] = {};
      }
      if (o[key3] === Array.prototype) {
        o[key3] = [];
      }
      o = o[key3];
    }
    var lastKey = keys2[keys2.length - 1];
    if (isConstructorOrProto(o, lastKey)) {
      return;
    }
    if (o === Object.prototype || o === Number.prototype || o === String.prototype) {
      o = {};
    }
    if (o === Array.prototype) {
      o = [];
    }
    if (o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] === "boolean") {
      o[lastKey] = value2;
    } else if (Array.isArray(o[lastKey])) {
      o[lastKey].push(value2);
    } else {
      o[lastKey] = [o[lastKey], value2];
    }
  }
  function setArg(key3, val, arg2) {
    if (arg2 && flags.unknownFn && !argDefined(key3, arg2)) {
      if (flags.unknownFn(arg2) === false) {
        return;
      }
    }
    var value2 = !flags.strings[key3] && isNumber(val) ? Number(val) : val;
    setKey(argv, key3.split("."), value2);
    (aliases[key3] || []).forEach(function(x2) {
      setKey(argv, x2.split("."), value2);
    });
  }
  Object.keys(flags.bools).forEach(function(key3) {
    setArg(key3, defaults[key3] === void 0 ? false : defaults[key3]);
  });
  var notFlags = [];
  if (args.indexOf("--") !== -1) {
    notFlags = args.slice(args.indexOf("--") + 1);
    args = args.slice(0, args.indexOf("--"));
  }
  for (var i2 = 0; i2 < args.length; i2++) {
    var arg = args[i2];
    var key2;
    var next;
    if (/^--.+=/.test(arg)) {
      var m2 = arg.match(/^--([^=]+)=([\s\S]*)$/);
      key2 = m2[1];
      var value = m2[2];
      if (flags.bools[key2]) {
        value = value !== "false";
      }
      setArg(key2, value, arg);
    } else if (/^--no-.+/.test(arg)) {
      key2 = arg.match(/^--no-(.+)/)[1];
      setArg(key2, false, arg);
    } else if (/^--.+/.test(arg)) {
      key2 = arg.match(/^--(.+)/)[1];
      next = args[i2 + 1];
      if (next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key2] && !flags.allBools && (aliases[key2] ? !aliasIsBoolean(key2) : true)) {
        setArg(key2, next, arg);
        i2 += 1;
      } else if (/^(true|false)$/.test(next)) {
        setArg(key2, next === "true", arg);
        i2 += 1;
      } else {
        setArg(key2, flags.strings[key2] ? "" : true, arg);
      }
    } else if (/^-[^-]+/.test(arg)) {
      var letters = arg.slice(1, -1).split("");
      var broken = false;
      for (var j = 0; j < letters.length; j++) {
        next = arg.slice(j + 2);
        if (next === "-") {
          setArg(letters[j], next, arg);
          continue;
        }
        if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
          setArg(letters[j], next.slice(1), arg);
          broken = true;
          break;
        }
        if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letters[j], next, arg);
          broken = true;
          break;
        }
        if (letters[j + 1] && letters[j + 1].match(/\W/)) {
          setArg(letters[j], arg.slice(j + 2), arg);
          broken = true;
          break;
        } else {
          setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
        }
      }
      key2 = arg.slice(-1)[0];
      if (!broken && key2 !== "-") {
        if (args[i2 + 1] && !/^(-|--)[^-]/.test(args[i2 + 1]) && !flags.bools[key2] && (aliases[key2] ? !aliasIsBoolean(key2) : true)) {
          setArg(key2, args[i2 + 1], arg);
          i2 += 1;
        } else if (args[i2 + 1] && /^(true|false)$/.test(args[i2 + 1])) {
          setArg(key2, args[i2 + 1] === "true", arg);
          i2 += 1;
        } else {
          setArg(key2, flags.strings[key2] ? "" : true, arg);
        }
      }
    } else {
      if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
        argv._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg));
      }
      if (opts.stopEarly) {
        argv._.push.apply(argv._, args.slice(i2 + 1));
        break;
      }
    }
  }
  Object.keys(defaults).forEach(function(k) {
    if (!hasKey(argv, k.split("."))) {
      setKey(argv, k.split("."), defaults[k]);
      (aliases[k] || []).forEach(function(x2) {
        setKey(argv, x2.split("."), defaults[k]);
      });
    }
  });
  if (opts["--"]) {
    argv["--"] = notFlags.slice();
  } else {
    notFlags.forEach(function(k) {
      argv._.push(k);
    });
  }
  return argv;
};
var url = {};
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
  }
}
function normalizeStringPosix(path2, allowAboveRoot) {
  var res = "";
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code2;
  for (var i2 = 0; i2 <= path2.length; ++i2) {
    if (i2 < path2.length)
      code2 = path2.charCodeAt(i2);
    else if (code2 === 47)
      break;
    else
      code2 = 47;
    if (code2 === 47) {
      if (lastSlash === i2 - 1 || dots === 1) ;
      else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i2;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += "/..";
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += "/" + path2.slice(lastSlash + 1, i2);
        else
          res = path2.slice(lastSlash + 1, i2);
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code2 === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep2, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base2 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir) {
    return base2;
  }
  if (dir === pathObject.root) {
    return dir + base2;
  }
  return dir + sep2 + base2;
}
var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve2() {
    var resolvedPath = "";
    var resolvedAbsolute = false;
    var cwd;
    for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
      var path2;
      if (i2 >= 0)
        path2 = arguments[i2];
      else {
        if (cwd === void 0)
          cwd = process.cwd();
        path2 = cwd;
      }
      assertPath(path2);
      if (path2.length === 0) {
        continue;
      }
      resolvedPath = path2 + "/" + resolvedPath;
      resolvedAbsolute = path2.charCodeAt(0) === 47;
    }
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return "/" + resolvedPath;
      else
        return "/";
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return ".";
    }
  },
  normalize: function normalize2(path2) {
    assertPath(path2);
    if (path2.length === 0) return ".";
    var isAbsolute3 = path2.charCodeAt(0) === 47;
    var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
    path2 = normalizeStringPosix(path2, !isAbsolute3);
    if (path2.length === 0 && !isAbsolute3) path2 = ".";
    if (path2.length > 0 && trailingSeparator) path2 += "/";
    if (isAbsolute3) return "/" + path2;
    return path2;
  },
  isAbsolute: function isAbsolute2(path2) {
    assertPath(path2);
    return path2.length > 0 && path2.charCodeAt(0) === 47;
  },
  join: function join2() {
    if (arguments.length === 0)
      return ".";
    var joined;
    for (var i2 = 0; i2 < arguments.length; ++i2) {
      var arg = arguments[i2];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else
          joined += "/" + arg;
      }
    }
    if (joined === void 0)
      return ".";
    return posix.normalize(joined);
  },
  relative: function relative2(from2, to) {
    assertPath(from2);
    assertPath(to);
    if (from2 === to) return "";
    from2 = posix.resolve(from2);
    to = posix.resolve(to);
    if (from2 === to) return "";
    var fromStart = 1;
    for (; fromStart < from2.length; ++fromStart) {
      if (from2.charCodeAt(fromStart) !== 47)
        break;
    }
    var fromEnd = from2.length;
    var fromLen = fromEnd - fromStart;
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;
    var length2 = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i2 = 0;
    for (; i2 <= length2; ++i2) {
      if (i2 === length2) {
        if (toLen > length2) {
          if (to.charCodeAt(toStart + i2) === 47) {
            return to.slice(toStart + i2 + 1);
          } else if (i2 === 0) {
            return to.slice(toStart + i2);
          }
        } else if (fromLen > length2) {
          if (from2.charCodeAt(fromStart + i2) === 47) {
            lastCommonSep = i2;
          } else if (i2 === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from2.charCodeAt(fromStart + i2);
      var toCode = to.charCodeAt(toStart + i2);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47)
        lastCommonSep = i2;
    }
    var out = "";
    for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
      if (i2 === fromEnd || from2.charCodeAt(i2) === 47) {
        if (out.length === 0)
          out += "..";
        else
          out += "/..";
      }
    }
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47)
        ++toStart;
      return to.slice(toStart);
    }
  },
  _makeLong: function _makeLong(path2) {
    return path2;
  },
  dirname: function dirname2(path2) {
    assertPath(path2);
    if (path2.length === 0) return ".";
    var code2 = path2.charCodeAt(0);
    var hasRoot = code2 === 47;
    var end = -1;
    var matchedSlash = true;
    for (var i2 = path2.length - 1; i2 >= 1; --i2) {
      code2 = path2.charCodeAt(i2);
      if (code2 === 47) {
        if (!matchedSlash) {
          end = i2;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path2.slice(0, end);
  },
  basename: function basename(path2, ext) {
    if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
    assertPath(path2);
    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i2;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2) return "";
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i2 = path2.length - 1; i2 >= 0; --i2) {
        var code2 = path2.charCodeAt(i2);
        if (code2 === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i2 + 1;
          }
          if (extIdx >= 0) {
            if (code2 === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i2;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) end = firstNonSlashEnd;
      else if (end === -1) end = path2.length;
      return path2.slice(start, end);
    } else {
      for (i2 = path2.length - 1; i2 >= 0; --i2) {
        if (path2.charCodeAt(i2) === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
      }
      if (end === -1) return "";
      return path2.slice(start, end);
    }
  },
  extname: function extname(path2) {
    assertPath(path2);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var preDotState = 0;
    for (var i2 = path2.length - 1; i2 >= 0; --i2) {
      var code2 = path2.charCodeAt(i2);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code2 === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format("/", pathObject);
  },
  parse: function parse2(path2) {
    assertPath(path2);
    var ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0) return ret;
    var code2 = path2.charCodeAt(0);
    var isAbsolute3 = code2 === 47;
    var start;
    if (isAbsolute3) {
      ret.root = "/";
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i2 = path2.length - 1;
    var preDotState = 0;
    for (; i2 >= start; --i2) {
      code2 = path2.charCodeAt(i2);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code2 === 46) {
        if (startDot === -1) startDot = i2;
        else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute3) ret.base = ret.name = path2.slice(1, end);
        else ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute3) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
    else if (isAbsolute3) ret.dir = "/";
    return ret;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
posix.posix = posix;
var pathBrowserify = posix;
var requiresPort = function required2(port2, protocol) {
  protocol = protocol.split(":")[0];
  port2 = +port2;
  if (!port2) return false;
  switch (protocol) {
    case "http":
    case "ws":
      return port2 !== 80;
    case "https":
    case "wss":
      return port2 !== 443;
    case "ftp":
      return port2 !== 21;
    case "gopher":
      return port2 !== 70;
    case "file":
      return false;
  }
  return port2 !== 0;
};
var querystringify$1 = {};
var has$1 = Object.prototype.hasOwnProperty, undef;
function decode$1(input2) {
  try {
    return decodeURIComponent(input2.replace(/\+/g, " "));
  } catch (e) {
    return null;
  }
}
function encode$1(input2) {
  try {
    return encodeURIComponent(input2);
  } catch (e) {
    return null;
  }
}
function querystring(query) {
  var parser2 = /([^=?#&]+)=?([^&]*)/g, result2 = {}, part;
  while (part = parser2.exec(query)) {
    var key2 = decode$1(part[1]), value = decode$1(part[2]);
    if (key2 === null || value === null || key2 in result2) continue;
    result2[key2] = value;
  }
  return result2;
}
function querystringify(obj, prefix) {
  prefix = prefix || "";
  var pairs = [], value, key2;
  if ("string" !== typeof prefix) prefix = "?";
  for (key2 in obj) {
    if (has$1.call(obj, key2)) {
      value = obj[key2];
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = "";
      }
      key2 = encode$1(key2);
      value = encode$1(value);
      if (key2 === null || value === null) continue;
      pairs.push(key2 + "=" + value);
    }
  }
  return pairs.length ? prefix + pairs.join("&") : "";
}
querystringify$1.stringify = querystringify;
querystringify$1.parse = querystring;
var required = requiresPort, qs = querystringify$1, controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, CRHTLF = /[\n\r\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, port = /:\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;
function trimLeft$1(str) {
  return (str ? str : "").toString().replace(controlOrWhitespace, "");
}
var rules = [
  ["#", "hash"],
  // Extract from the back.
  ["?", "query"],
  // Extract from the back.
  function sanitize2(address, url2) {
    return isSpecial$1(url2.protocol) ? address.replace(/\\/g, "/") : address;
  },
  ["/", "pathname"],
  // Extract from the back.
  ["@", "auth", 1],
  // Extract from the front.
  [NaN, "host", void 0, 1, 1],
  // Set left over value.
  [/:(\d*)$/, "port", void 0, 1],
  // RegExp the back.
  [NaN, "hostname", void 0, 1, 1]
  // Set left over.
];
var ignore = { hash: 1, query: 1 };
function lolcation(loc) {
  var globalVar;
  if (typeof window !== "undefined") globalVar = window;
  else if (typeof commonjsGlobal !== "undefined") globalVar = commonjsGlobal;
  else if (typeof self !== "undefined") globalVar = self;
  else globalVar = {};
  var location2 = globalVar.location || {};
  loc = loc || location2;
  var finaldestination = {}, type = typeof loc, key2;
  if ("blob:" === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ("string" === type) {
    finaldestination = new Url(loc, {});
    for (key2 in ignore) delete finaldestination[key2];
  } else if ("object" === type) {
    for (key2 in loc) {
      if (key2 in ignore) continue;
      finaldestination[key2] = loc[key2];
    }
    if (finaldestination.slashes === void 0) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }
  return finaldestination;
}
function isSpecial$1(scheme) {
  return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
}
function extractProtocol(address, location2) {
  address = trimLeft$1(address);
  address = address.replace(CRHTLF, "");
  location2 = location2 || {};
  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : "";
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;
  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4];
    }
  }
  if (protocol === "file:") {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial$1(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial$1(location2.protocol)) {
    rest = match[4];
  }
  return {
    protocol,
    slashes: forwardSlashes || isSpecial$1(protocol),
    slashesCount,
    rest
  };
}
function resolve$2(relative3, base2) {
  if (relative3 === "") return base2;
  var path2 = (base2 || "/").split("/").slice(0, -1).concat(relative3.split("/")), i2 = path2.length, last2 = path2[i2 - 1], unshift = false, up = 0;
  while (i2--) {
    if (path2[i2] === ".") {
      path2.splice(i2, 1);
    } else if (path2[i2] === "..") {
      path2.splice(i2, 1);
      up++;
    } else if (up) {
      if (i2 === 0) unshift = true;
      path2.splice(i2, 1);
      up--;
    }
  }
  if (unshift) path2.unshift("");
  if (last2 === "." || last2 === "..") path2.push("");
  return path2.join("/");
}
function Url(address, location2, parser2) {
  address = trimLeft$1(address);
  address = address.replace(CRHTLF, "");
  if (!(this instanceof Url)) {
    return new Url(address, location2, parser2);
  }
  var relative3, extracted, parse3, instruction, index, key2, instructions = rules.slice(), type = typeof location2, url2 = this, i2 = 0;
  if ("object" !== type && "string" !== type) {
    parser2 = location2;
    location2 = null;
  }
  if (parser2 && "function" !== typeof parser2) parser2 = qs.parse;
  location2 = lolcation(location2);
  extracted = extractProtocol(address || "", location2);
  relative3 = !extracted.protocol && !extracted.slashes;
  url2.slashes = extracted.slashes || relative3 && location2.slashes;
  url2.protocol = extracted.protocol || location2.protocol || "";
  address = extracted.rest;
  if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial$1(url2.protocol))) {
    instructions[3] = [/(.*)/, "pathname"];
  }
  for (; i2 < instructions.length; i2++) {
    instruction = instructions[i2];
    if (typeof instruction === "function") {
      address = instruction(address, url2);
      continue;
    }
    parse3 = instruction[0];
    key2 = instruction[1];
    if (parse3 !== parse3) {
      url2[key2] = address;
    } else if ("string" === typeof parse3) {
      index = parse3 === "@" ? address.lastIndexOf(parse3) : address.indexOf(parse3);
      if (~index) {
        if ("number" === typeof instruction[2]) {
          url2[key2] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url2[key2] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if (index = parse3.exec(address)) {
      url2[key2] = index[1];
      address = address.slice(0, index.index);
    }
    url2[key2] = url2[key2] || (relative3 && instruction[3] ? location2[key2] || "" : "");
    if (instruction[4]) url2[key2] = url2[key2].toLowerCase();
  }
  if (parser2) url2.query = parser2(url2.query);
  if (relative3 && location2.slashes && url2.pathname.charAt(0) !== "/" && (url2.pathname !== "" || location2.pathname !== "")) {
    url2.pathname = resolve$2(url2.pathname, location2.pathname);
  }
  if (url2.pathname.charAt(0) !== "/" && isSpecial$1(url2.protocol)) {
    url2.pathname = "/" + url2.pathname;
  }
  if (!required(url2.port, url2.protocol)) {
    url2.host = url2.hostname;
    url2.port = "";
  }
  url2.username = url2.password = "";
  if (url2.auth) {
    index = url2.auth.indexOf(":");
    if (~index) {
      url2.username = url2.auth.slice(0, index);
      url2.username = encodeURIComponent(decodeURIComponent(url2.username));
      url2.password = url2.auth.slice(index + 1);
      url2.password = encodeURIComponent(decodeURIComponent(url2.password));
    } else {
      url2.username = encodeURIComponent(decodeURIComponent(url2.auth));
    }
    url2.auth = url2.password ? url2.username + ":" + url2.password : url2.username;
  }
  url2.origin = url2.protocol !== "file:" && isSpecial$1(url2.protocol) && url2.host ? url2.protocol + "//" + url2.host : "null";
  url2.href = url2.toString();
}
function set(part, value, fn) {
  var url2 = this;
  switch (part) {
    case "query":
      if ("string" === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }
      url2[part] = value;
      break;
    case "port":
      url2[part] = value;
      if (!required(value, url2.protocol)) {
        url2.host = url2.hostname;
        url2[part] = "";
      } else if (value) {
        url2.host = url2.hostname + ":" + value;
      }
      break;
    case "hostname":
      url2[part] = value;
      if (url2.port) value += ":" + url2.port;
      url2.host = value;
      break;
    case "host":
      url2[part] = value;
      if (port.test(value)) {
        value = value.split(":");
        url2.port = value.pop();
        url2.hostname = value.join(":");
      } else {
        url2.hostname = value;
        url2.port = "";
      }
      break;
    case "protocol":
      url2.protocol = value.toLowerCase();
      url2.slashes = !fn;
      break;
    case "pathname":
    case "hash":
      if (value) {
        var char = part === "pathname" ? "/" : "#";
        url2[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url2[part] = value;
      }
      break;
    case "username":
    case "password":
      url2[part] = encodeURIComponent(value);
      break;
    case "auth":
      var index = value.indexOf(":");
      if (~index) {
        url2.username = value.slice(0, index);
        url2.username = encodeURIComponent(decodeURIComponent(url2.username));
        url2.password = value.slice(index + 1);
        url2.password = encodeURIComponent(decodeURIComponent(url2.password));
      } else {
        url2.username = encodeURIComponent(decodeURIComponent(value));
      }
  }
  for (var i2 = 0; i2 < rules.length; i2++) {
    var ins = rules[i2];
    if (ins[4]) url2[ins[1]] = url2[ins[1]].toLowerCase();
  }
  url2.auth = url2.password ? url2.username + ":" + url2.password : url2.username;
  url2.origin = url2.protocol !== "file:" && isSpecial$1(url2.protocol) && url2.host ? url2.protocol + "//" + url2.host : "null";
  url2.href = url2.toString();
  return url2;
}
function toString$1(stringify2) {
  if (!stringify2 || "function" !== typeof stringify2) stringify2 = qs.stringify;
  var query, url2 = this, host = url2.host, protocol = url2.protocol;
  if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
  var result2 = protocol + (url2.protocol && url2.slashes || isSpecial$1(url2.protocol) ? "//" : "");
  if (url2.username) {
    result2 += url2.username;
    if (url2.password) result2 += ":" + url2.password;
    result2 += "@";
  } else if (url2.password) {
    result2 += ":" + url2.password;
    result2 += "@";
  } else if (url2.protocol !== "file:" && isSpecial$1(url2.protocol) && !host && url2.pathname !== "/") {
    result2 += "@";
  }
  if (host[host.length - 1] === ":" || port.test(url2.hostname) && !url2.port) {
    host += ":";
  }
  result2 += host + url2.pathname;
  query = "object" === typeof url2.query ? stringify2(url2.query) : url2.query;
  if (query) result2 += "?" !== query.charAt(0) ? "?" + query : query;
  if (url2.hash) result2 += url2.hash;
  return result2;
}
Url.prototype = { set, toString: toString$1 };
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft$1;
Url.qs = qs;
var urlParse = Url;
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(url, "__esModule", { value: true });
url.URLExt = void 0;
const path_1$1 = pathBrowserify;
const url_parse_1 = __importDefault$3(urlParse);
var URLExt;
(function(URLExt2) {
  function parse3(url2) {
    if (typeof document !== "undefined" && document) {
      const a = document.createElement("a");
      a.href = url2;
      return a;
    }
    return (0, url_parse_1.default)(url2);
  }
  URLExt2.parse = parse3;
  function getHostName(url2) {
    return (0, url_parse_1.default)(url2).hostname;
  }
  URLExt2.getHostName = getHostName;
  function normalize3(url2) {
    return url2 && parse3(url2).toString();
  }
  URLExt2.normalize = normalize3;
  function join3(...parts) {
    let u = (0, url_parse_1.default)(parts[0], {});
    const isSchemaLess = u.protocol === "" && u.slashes;
    if (isSchemaLess) {
      u = (0, url_parse_1.default)(parts[0], "https:" + parts[0]);
    }
    const prefix = `${isSchemaLess ? "" : u.protocol}${u.slashes ? "//" : ""}${u.auth}${u.auth ? "@" : ""}${u.host}`;
    const path2 = path_1$1.posix.join(`${!!prefix && u.pathname[0] !== "/" ? "/" : ""}${u.pathname}`, ...parts.slice(1));
    return `${prefix}${path2 === "." ? "" : path2}`;
  }
  URLExt2.join = join3;
  function encodeParts(url2) {
    return join3(...url2.split("/").map(encodeURIComponent));
  }
  URLExt2.encodeParts = encodeParts;
  function objectToQueryString(value) {
    const keys2 = Object.keys(value).filter((key2) => key2.length > 0);
    if (!keys2.length) {
      return "";
    }
    return "?" + keys2.map((key2) => {
      const content = encodeURIComponent(String(value[key2]));
      return key2 + (content ? "=" + content : "");
    }).join("&");
  }
  URLExt2.objectToQueryString = objectToQueryString;
  function queryStringToObject(value) {
    return value.replace(/^\?/, "").split("&").reduce((acc, val) => {
      const [key2, value2] = val.split("=");
      if (key2.length > 0) {
        acc[key2] = decodeURIComponent(value2 || "");
      }
      return acc;
    }, {});
  }
  URLExt2.queryStringToObject = queryStringToObject;
  function isLocal(url2, allowRoot = false) {
    const { protocol } = parse3(url2);
    return (!protocol || url2.toLowerCase().indexOf(protocol) !== 0) && (allowRoot ? url2.indexOf("//") !== 0 : url2.indexOf("/") !== 0);
  }
  URLExt2.isLocal = isLocal;
})(URLExt || (url.URLExt = URLExt = {}));
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(pageconfig, "__esModule", { value: true });
pageconfig.PageConfig = void 0;
const coreutils_1$e = require$$1$2;
const minimist_1 = __importDefault$2(minimist);
const url_1 = url;
var PageConfig;
(function(PageConfig) {
  function getOption(name) {
    if (configData) {
      return configData[name] || getBodyData(name);
    }
    configData = /* @__PURE__ */ Object.create(null);
    let found = false;
    if (typeof document !== "undefined" && document) {
      const el = document.getElementById("jupyter-config-data");
      if (el) {
        configData = JSON.parse(el.textContent || "");
        found = true;
      }
    }
    if (!found && typeof process !== "undefined" && process.argv) {
      try {
        const cli = (0, minimist_1.default)(process.argv.slice(2));
        const path = pathBrowserify;
        let fullPath = "";
        if ("jupyter-config-data" in cli) {
          fullPath = path.resolve(cli["jupyter-config-data"]);
        } else if ("JUPYTER_CONFIG_DATA" in process.env) {
          fullPath = path.resolve(process.env["JUPYTER_CONFIG_DATA"]);
        }
        if (fullPath) {
          configData = eval("require")(fullPath);
        }
      } catch (e) {
        console.error(e);
      }
    }
    if (!coreutils_1$e.JSONExt.isObject(configData)) {
      configData = /* @__PURE__ */ Object.create(null);
    } else {
      for (const key2 in configData) {
        if (typeof configData[key2] !== "string") {
          configData[key2] = JSON.stringify(configData[key2]);
        }
      }
    }
    return configData[name] || getBodyData(name);
  }
  PageConfig.getOption = getOption;
  function setOption(name2, value) {
    const last2 = getOption(name2);
    configData[name2] = value;
    return last2;
  }
  PageConfig.setOption = setOption;
  function getBaseUrl() {
    return url_1.URLExt.normalize(getOption("baseUrl") || "/");
  }
  PageConfig.getBaseUrl = getBaseUrl;
  function getTreeUrl() {
    return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
  }
  PageConfig.getTreeUrl = getTreeUrl;
  function getShareUrl() {
    return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
  }
  PageConfig.getShareUrl = getShareUrl;
  function getTreeShareUrl() {
    return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
  }
  PageConfig.getTreeShareUrl = getTreeShareUrl;
  function getUrl(options) {
    var _a, _b, _c, _d;
    let path2 = options.toShare ? getShareUrl() : getBaseUrl();
    const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : getOption("mode");
    const workspace2 = (_b = options.workspace) !== null && _b !== void 0 ? _b : getOption("workspace");
    const labOrDoc = mode === "single-document" ? "doc" : "lab";
    path2 = url_1.URLExt.join(path2, labOrDoc);
    if (workspace2 !== PageConfig.defaultWorkspace) {
      path2 = url_1.URLExt.join(path2, "workspaces", encodeURIComponent((_c = getOption("workspace")) !== null && _c !== void 0 ? _c : PageConfig.defaultWorkspace));
    }
    const treePath = (_d = options.treePath) !== null && _d !== void 0 ? _d : getOption("treePath");
    if (treePath) {
      path2 = url_1.URLExt.join(path2, "tree", url_1.URLExt.encodeParts(treePath));
    }
    return path2;
  }
  PageConfig.getUrl = getUrl;
  PageConfig.defaultWorkspace = "default";
  function getWsUrl(baseUrl) {
    let wsUrl = getOption("wsUrl");
    if (!wsUrl) {
      baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl();
      if (baseUrl.indexOf("http") !== 0) {
        return "";
      }
      wsUrl = "ws" + baseUrl.slice(4);
    }
    return url_1.URLExt.normalize(wsUrl);
  }
  PageConfig.getWsUrl = getWsUrl;
  function getNBConvertURL({ path: path2, format: format2, download }) {
    const notebookPath = url_1.URLExt.encodeParts(path2);
    const url2 = url_1.URLExt.join(getBaseUrl(), "nbconvert", format2, notebookPath);
    if (download) {
      return url2 + "?download=true";
    }
    return url2;
  }
  PageConfig.getNBConvertURL = getNBConvertURL;
  function getToken() {
    return getOption("token") || getBodyData("jupyterApiToken");
  }
  PageConfig.getToken = getToken;
  function getNotebookVersion() {
    const notebookVersion = getOption("notebookVersion");
    if (notebookVersion === "") {
      return [0, 0, 0];
    }
    return JSON.parse(notebookVersion);
  }
  PageConfig.getNotebookVersion = getNotebookVersion;
  let configData = null;
  function getBodyData(key2) {
    if (typeof document === "undefined" || !document.body) {
      return "";
    }
    const val = document.body.dataset[key2];
    if (typeof val === "undefined") {
      return "";
    }
    return decodeURIComponent(val);
  }
  (function(Extension) {
    function populate(key2) {
      try {
        const raw = getOption(key2);
        if (raw) {
          return JSON.parse(raw);
        }
      } catch (error) {
        console.warn(`Unable to parse ${key2}.`, error);
      }
      return [];
    }
    Extension.deferred = populate("deferredExtensions");
    Extension.disabled = populate("disabledExtensions");
    function isDeferred(id) {
      const separatorIndex = id.indexOf(":");
      let extName = "";
      if (separatorIndex !== -1) {
        extName = id.slice(0, separatorIndex);
      }
      return Extension.deferred.some((val) => val === id || extName && val === extName);
    }
    Extension.isDeferred = isDeferred;
    function isDisabled(id) {
      const separatorIndex = id.indexOf(":");
      let extName = "";
      if (separatorIndex !== -1) {
        extName = id.slice(0, separatorIndex);
      }
      return Extension.disabled.some((val) => val === id || extName && val === extName);
    }
    Extension.isDisabled = isDisabled;
  })(PageConfig.Extension || (PageConfig.Extension = {}));
})(PageConfig || (pageconfig.PageConfig = PageConfig = {}));
var path = {};
Object.defineProperty(path, "__esModule", { value: true });
path.PathExt = void 0;
const path_1 = pathBrowserify;
var PathExt;
(function(PathExt2) {
  function join3(...paths) {
    const path2 = path_1.posix.join(...paths);
    return path2 === "." ? "" : removeSlash(path2);
  }
  PathExt2.join = join3;
  function joinWithLeadingSlash(...paths) {
    const path2 = path_1.posix.join(...paths);
    return path2 === "." ? "" : path2;
  }
  PathExt2.joinWithLeadingSlash = joinWithLeadingSlash;
  function basename2(path2, ext) {
    return path_1.posix.basename(path2, ext);
  }
  PathExt2.basename = basename2;
  function dirname3(path2) {
    const dir = removeSlash(path_1.posix.dirname(path2));
    return dir === "." ? "" : dir;
  }
  PathExt2.dirname = dirname3;
  function extname2(path2) {
    return path_1.posix.extname(path2);
  }
  PathExt2.extname = extname2;
  function normalize3(path2) {
    if (path2 === "") {
      return "";
    }
    return removeSlash(path_1.posix.normalize(path2));
  }
  PathExt2.normalize = normalize3;
  function resolve3(...parts) {
    return removeSlash(path_1.posix.resolve(...parts));
  }
  PathExt2.resolve = resolve3;
  function relative3(from2, to) {
    return removeSlash(path_1.posix.relative(from2, to));
  }
  PathExt2.relative = relative3;
  function normalizeExtension(extension) {
    if (extension.length > 0 && extension.indexOf(".") !== 0) {
      extension = `.${extension}`;
    }
    return extension;
  }
  PathExt2.normalizeExtension = normalizeExtension;
  function removeSlash(path2) {
    if (path2.indexOf("/") === 0) {
      path2 = path2.slice(1);
    }
    return path2;
  }
  PathExt2.removeSlash = removeSlash;
})(PathExt || (path.PathExt = PathExt = {}));
var signal = {};
Object.defineProperty(signal, "__esModule", { value: true });
signal.signalToPromise = void 0;
const coreutils_1$d = require$$1$2;
function signalToPromise(signal2, timeout) {
  const waitForSignal = new coreutils_1$d.PromiseDelegate();
  function cleanup() {
    signal2.disconnect(slot);
  }
  function slot(sender, args) {
    cleanup();
    waitForSignal.resolve([sender, args]);
  }
  signal2.connect(slot);
  if ((timeout !== null && timeout !== void 0 ? timeout : 0) > 0) {
    setTimeout(() => {
      cleanup();
      waitForSignal.reject(`Signal not emitted within ${timeout} ms.`);
    }, timeout);
  }
  return waitForSignal.promise;
}
signal.signalToPromise = signalToPromise;
var text = {};
Object.defineProperty(text, "__esModule", { value: true });
text.Text = void 0;
var Text$2;
(function(Text2) {
  const HAS_SURROGATES = "".length > 1;
  function jsIndexToCharIndex(jsIdx, text2) {
    if (HAS_SURROGATES) {
      return jsIdx;
    }
    let charIdx = jsIdx;
    for (let i2 = 0; i2 + 1 < text2.length && i2 < jsIdx; i2++) {
      const charCode = text2.charCodeAt(i2);
      if (charCode >= 55296 && charCode <= 56319) {
        const nextCharCode = text2.charCodeAt(i2 + 1);
        if (nextCharCode >= 56320 && nextCharCode <= 57343) {
          charIdx--;
          i2++;
        }
      }
    }
    return charIdx;
  }
  Text2.jsIndexToCharIndex = jsIndexToCharIndex;
  function charIndexToJsIndex(charIdx, text2) {
    if (HAS_SURROGATES) {
      return charIdx;
    }
    let jsIdx = charIdx;
    for (let i2 = 0; i2 + 1 < text2.length && i2 < jsIdx; i2++) {
      const charCode = text2.charCodeAt(i2);
      if (charCode >= 55296 && charCode <= 56319) {
        const nextCharCode = text2.charCodeAt(i2 + 1);
        if (nextCharCode >= 56320 && nextCharCode <= 57343) {
          jsIdx++;
          i2++;
        }
      }
    }
    return jsIdx;
  }
  Text2.charIndexToJsIndex = charIndexToJsIndex;
  function camelCase(str, upper = false) {
    return str.replace(/^(\w)|[\s-_:]+(\w)/g, function(match, p1, p2) {
      if (p2) {
        return p2.toUpperCase();
      } else {
        return upper ? p1.toUpperCase() : p1.toLowerCase();
      }
    });
  }
  Text2.camelCase = camelCase;
  function titleCase(str) {
    return (str || "").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
  }
  Text2.titleCase = titleCase;
})(Text$2 || (text.Text = Text$2 = {}));
var time = {};
Object.defineProperty(time, "__esModule", { value: true });
time.Time = void 0;
const UNITS = [
  { name: "years", milliseconds: 365 * 24 * 60 * 60 * 1e3 },
  { name: "months", milliseconds: 30 * 24 * 60 * 60 * 1e3 },
  { name: "days", milliseconds: 24 * 60 * 60 * 1e3 },
  { name: "hours", milliseconds: 60 * 60 * 1e3 },
  { name: "minutes", milliseconds: 60 * 1e3 },
  { name: "seconds", milliseconds: 1e3 }
];
var Time;
(function(Time2) {
  function formatHuman(value, format3 = "long") {
    const lang = document.documentElement.lang || "en";
    const formatter = new Intl.RelativeTimeFormat(lang, {
      numeric: "auto",
      style: format3
    });
    const delta = new Date(value).getTime() - Date.now();
    for (let unit of UNITS) {
      const amount = Math.ceil(delta / unit.milliseconds);
      if (amount === 0) {
        continue;
      }
      return formatter.format(amount, unit.name);
    }
    return formatter.format(0, "seconds");
  }
  Time2.formatHuman = formatHuman;
  function format2(value) {
    const lang = document.documentElement.lang || "en";
    const formatter = new Intl.DateTimeFormat(lang, {
      dateStyle: "short",
      timeStyle: "short"
    });
    return formatter.format(new Date(value));
  }
  Time2.format = format2;
})(Time || (time.Time = Time = {}));
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(activitymonitor, exports);
  __exportStar(interfaces$1, exports);
  __exportStar(lru, exports);
  __exportStar(markdowncodeblocks, exports);
  __exportStar(pageconfig, exports);
  __exportStar(path, exports);
  __exportStar(signal, exports);
  __exportStar(text, exports);
  __exportStar(time, exports);
  __exportStar(url, exports);
})(lib$9);
function _classes(classes2) {
  return classes2.map((c) => c && typeof c === "object" ? Object.keys(c).map((key2) => !!c[key2] && key2) : typeof c === "string" ? c.split(/\s+/) : []).reduce((flattened, c) => flattened.concat(c), []).filter((c) => !!c);
}
function classes$1(...classes2) {
  return _classes(classes2).join(" ");
}
function getReactAttrs(elem, { ignore: ignore2 = [] } = {}) {
  return elem.getAttributeNames().reduce((d, name2) => {
    if (name2 === "style" || ignore2.includes(name2)) ;
    else if (name2.startsWith("data")) {
      d[name2] = elem.getAttribute(name2);
    } else {
      d[lib$9.Text.camelCase(name2)] = elem.getAttribute(name2);
    }
    return d;
  }, {});
}
function Button$2(props) {
  const { minimal, small, children: children2, ...others } = props;
  return React.createElement("button", { ...others, className: classes$1(props.className, minimal ? "jp-mod-minimal" : "", small ? "jp-mod-small" : "", "jp-Button") }, children2);
}
var ClipboardExt;
(function(ClipboardExt2) {
  function copyText(text2) {
    const body = document.body;
    const handler = (event2) => {
      event2.preventDefault();
      event2.stopPropagation();
      event2.clipboardData.setData("text", text2);
      body.removeEventListener("copy", handler, true);
    };
    body.addEventListener("copy", handler, true);
    document.execCommand("copy");
  }
  ClipboardExt2.copyText = copyText;
})(ClipboardExt || (ClipboardExt = {}));
var ElementExt;
(function(ElementExt2) {
  function boxSizing(element) {
    let style2 = window.getComputedStyle(element);
    let bt = parseFloat(style2.borderTopWidth) || 0;
    let bl = parseFloat(style2.borderLeftWidth) || 0;
    let br = parseFloat(style2.borderRightWidth) || 0;
    let bb = parseFloat(style2.borderBottomWidth) || 0;
    let pt = parseFloat(style2.paddingTop) || 0;
    let pl = parseFloat(style2.paddingLeft) || 0;
    let pr = parseFloat(style2.paddingRight) || 0;
    let pb = parseFloat(style2.paddingBottom) || 0;
    let hs = bl + pl + pr + br;
    let vs = bt + pt + pb + bb;
    return {
      borderTop: bt,
      borderLeft: bl,
      borderRight: br,
      borderBottom: bb,
      paddingTop: pt,
      paddingLeft: pl,
      paddingRight: pr,
      paddingBottom: pb,
      horizontalSum: hs,
      verticalSum: vs
    };
  }
  ElementExt2.boxSizing = boxSizing;
  function sizeLimits(element) {
    let style2 = window.getComputedStyle(element);
    let minWidth = parseFloat(style2.minWidth) || 0;
    let minHeight = parseFloat(style2.minHeight) || 0;
    let maxWidth = parseFloat(style2.maxWidth) || Infinity;
    let maxHeight = parseFloat(style2.maxHeight) || Infinity;
    maxWidth = Math.max(minWidth, maxWidth);
    maxHeight = Math.max(minHeight, maxHeight);
    return { minWidth, minHeight, maxWidth, maxHeight };
  }
  ElementExt2.sizeLimits = sizeLimits;
  function hitTest(element, clientX, clientY) {
    let rect = element.getBoundingClientRect();
    return clientX >= rect.left && clientX < rect.right && clientY >= rect.top && clientY < rect.bottom;
  }
  ElementExt2.hitTest = hitTest;
  function scrollIntoViewIfNeeded(area, element) {
    let ar = area.getBoundingClientRect();
    let er = element.getBoundingClientRect();
    if (er.top <= ar.top && er.bottom >= ar.bottom) {
      return;
    }
    if (er.top < ar.top && er.height <= ar.height) {
      area.scrollTop -= ar.top - er.top;
      return;
    }
    if (er.bottom > ar.bottom && er.height >= ar.height) {
      area.scrollTop -= ar.top - er.top;
      return;
    }
    if (er.top < ar.top && er.height > ar.height) {
      area.scrollTop -= ar.bottom - er.bottom;
      return;
    }
    if (er.bottom > ar.bottom && er.height < ar.height) {
      area.scrollTop -= ar.bottom - er.bottom;
      return;
    }
  }
  ElementExt2.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;
})(ElementExt || (ElementExt = {}));
var Platform;
(function(Platform2) {
  Platform2.IS_MAC = !!navigator.platform.match(/Mac/i);
  Platform2.IS_WIN = !!navigator.platform.match(/Win/i);
  Platform2.IS_IE = /Trident/.test(navigator.userAgent);
  Platform2.IS_EDGE = /Edge/.test(navigator.userAgent);
  function accelKey(event2) {
    return Platform2.IS_MAC ? event2.metaKey : event2.ctrlKey;
  }
  Platform2.accelKey = accelKey;
})(Platform || (Platform = {}));
var Selector$1;
(function(Selector2) {
  function calculateSpecificity(selector) {
    if (selector in Private$y.specificityCache) {
      return Private$y.specificityCache[selector];
    }
    let result2 = Private$y.calculateSingle(selector);
    return Private$y.specificityCache[selector] = result2;
  }
  Selector2.calculateSpecificity = calculateSpecificity;
  function isValid(selector) {
    if (selector in Private$y.validityCache) {
      return Private$y.validityCache[selector];
    }
    let result2 = true;
    try {
      Private$y.testElem.querySelector(selector);
    } catch (err) {
      result2 = false;
    }
    return Private$y.validityCache[selector] = result2;
  }
  Selector2.isValid = isValid;
  function matches2(element, selector) {
    return Private$y.protoMatchFunc.call(element, selector);
  }
  Selector2.matches = matches2;
})(Selector$1 || (Selector$1 = {}));
var Private$y;
(function(Private2) {
  Private2.specificityCache = /* @__PURE__ */ Object.create(null);
  Private2.validityCache = /* @__PURE__ */ Object.create(null);
  Private2.testElem = document.createElement("div");
  Private2.protoMatchFunc = (() => {
    let proto = Element.prototype;
    return proto.matches || proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector || function(selector) {
      let elem = this;
      let matches2 = elem.ownerDocument ? elem.ownerDocument.querySelectorAll(selector) : [];
      return Array.prototype.indexOf.call(matches2, elem) !== -1;
    };
  })();
  function calculateSingle(selector) {
    selector = selector.split(",", 1)[0];
    let a = 0;
    let b = 0;
    let c = 0;
    function match(re) {
      let match2 = selector.match(re);
      if (match2 === null) {
        return false;
      }
      selector = selector.slice(match2[0].length);
      return true;
    }
    selector = selector.replace(NEGATION_RE, " $1 ");
    while (selector.length > 0) {
      if (match(ID_RE)) {
        a++;
        continue;
      }
      if (match(CLASS_RE)) {
        b++;
        continue;
      }
      if (match(ATTR_RE)) {
        b++;
        continue;
      }
      if (match(PSEUDO_ELEM_RE)) {
        c++;
        continue;
      }
      if (match(PSEDUO_CLASS_RE)) {
        b++;
        continue;
      }
      if (match(TYPE_RE)) {
        c++;
        continue;
      }
      if (match(IGNORE_RE)) {
        continue;
      }
      return 0;
    }
    a = Math.min(a, 255);
    b = Math.min(b, 255);
    c = Math.min(c, 255);
    return a << 16 | b << 8 | c;
  }
  Private2.calculateSingle = calculateSingle;
  const ID_RE = /^#[^\s\+>~#\.\[:]+/;
  const CLASS_RE = /^\.[^\s\+>~#\.\[:]+/;
  const ATTR_RE = /^\[[^\]]+\]/;
  const TYPE_RE = /^[^\s\+>~#\.\[:]+/;
  const PSEUDO_ELEM_RE = /^(::[^\s\+>~#\.\[:]+|:first-line|:first-letter|:before|:after)/;
  const PSEDUO_CLASS_RE = /^:[^\s\+>~#\.\[:]+/;
  const IGNORE_RE = /^[\s\+>~\*]+/;
  const NEGATION_RE = /:not\(([^\)]+)\)/g;
})(Private$y || (Private$y = {}));
class LinkedList {
  constructor() {
    this._first = null;
    this._last = null;
    this._size = 0;
  }
  /**
   * Whether the list is empty.
   *
   * #### Complexity
   * Constant.
   */
  get isEmpty() {
    return this._size === 0;
  }
  /**
   * The size of the list.
   *
   * #### Complexity
   * `O(1)`
   *
   * #### Notes
   * This is equivalent to `length`.
   */
  get size() {
    return this._size;
  }
  /**
   * The length of the list.
   *
   * #### Complexity
   * Constant.
   *
   * #### Notes
   * This is equivalent to `size`.
   *
   * This property is deprecated.
   */
  get length() {
    return this._size;
  }
  /**
   * The first value in the list.
   *
   * This is `undefined` if the list is empty.
   *
   * #### Complexity
   * Constant.
   */
  get first() {
    return this._first ? this._first.value : void 0;
  }
  /**
   * The last value in the list.
   *
   * This is `undefined` if the list is empty.
   *
   * #### Complexity
   * Constant.
   */
  get last() {
    return this._last ? this._last.value : void 0;
  }
  /**
   * The first node in the list.
   *
   * This is `null` if the list is empty.
   *
   * #### Complexity
   * Constant.
   */
  get firstNode() {
    return this._first;
  }
  /**
   * The last node in the list.
   *
   * This is `null` if the list is empty.
   *
   * #### Complexity
   * Constant.
   */
  get lastNode() {
    return this._last;
  }
  /**
   * Create an iterator over the values in the list.
   *
   * @returns A new iterator starting with the first value.
   *
   * #### Complexity
   * Constant.
   */
  *[Symbol.iterator]() {
    let node2 = this._first;
    while (node2) {
      yield node2.value;
      node2 = node2.next;
    }
  }
  /**
   * Create a reverse iterator over the values in the list.
   *
   * @returns A new iterator starting with the last value.
   *
   * #### Complexity
   * Constant.
   */
  *retro() {
    let node2 = this._last;
    while (node2) {
      yield node2.value;
      node2 = node2.prev;
    }
  }
  /**
   * Create an iterator over the nodes in the list.
   *
   * @returns A new iterator starting with the first node.
   *
   * #### Complexity
   * Constant.
   */
  *nodes() {
    let node2 = this._first;
    while (node2) {
      yield node2;
      node2 = node2.next;
    }
  }
  /**
   * Create a reverse iterator over the nodes in the list.
   *
   * @returns A new iterator starting with the last node.
   *
   * #### Complexity
   * Constant.
   */
  *retroNodes() {
    let node2 = this._last;
    while (node2) {
      yield node2;
      node2 = node2.prev;
    }
  }
  /**
   * Assign new values to the list, replacing all current values.
   *
   * @param values - The values to assign to the list.
   *
   * #### Complexity
   * Linear.
   */
  assign(values) {
    this.clear();
    for (const value of values) {
      this.addLast(value);
    }
  }
  /**
   * Add a value to the end of the list.
   *
   * @param value - The value to add to the end of the list.
   *
   * #### Complexity
   * Constant.
   *
   * #### Notes
   * This is equivalent to `addLast`.
   */
  push(value) {
    this.addLast(value);
  }
  /**
   * Remove and return the value at the end of the list.
   *
   * @returns The removed value, or `undefined` if the list is empty.
   *
   * #### Complexity
   * Constant.
   *
   * #### Notes
   * This is equivalent to `removeLast`.
   */
  pop() {
    return this.removeLast();
  }
  /**
   * Add a value to the beginning of the list.
   *
   * @param value - The value to add to the beginning of the list.
   *
   * #### Complexity
   * Constant.
   *
   * #### Notes
   * This is equivalent to `addFirst`.
   */
  shift(value) {
    this.addFirst(value);
  }
  /**
   * Remove and return the value at the beginning of the list.
   *
   * @returns The removed value, or `undefined` if the list is empty.
   *
   * #### Complexity
   * Constant.
   *
   * #### Notes
   * This is equivalent to `removeFirst`.
   */
  unshift() {
    return this.removeFirst();
  }
  /**
   * Add a value to the beginning of the list.
   *
   * @param value - The value to add to the beginning of the list.
   *
   * @returns The list node which holds the value.
   *
   * #### Complexity
   * Constant.
   */
  addFirst(value) {
    let node2 = new Private$x.LinkedListNode(this, value);
    if (!this._first) {
      this._first = node2;
      this._last = node2;
    } else {
      node2.next = this._first;
      this._first.prev = node2;
      this._first = node2;
    }
    this._size++;
    return node2;
  }
  /**
   * Add a value to the end of the list.
   *
   * @param value - The value to add to the end of the list.
   *
   * @returns The list node which holds the value.
   *
   * #### Complexity
   * Constant.
   */
  addLast(value) {
    let node2 = new Private$x.LinkedListNode(this, value);
    if (!this._last) {
      this._first = node2;
      this._last = node2;
    } else {
      node2.prev = this._last;
      this._last.next = node2;
      this._last = node2;
    }
    this._size++;
    return node2;
  }
  /**
   * Insert a value before a specific node in the list.
   *
   * @param value - The value to insert before the reference node.
   *
   * @param ref - The reference node of interest. If this is `null`,
   *   the value will be added to the beginning of the list.
   *
   * @returns The list node which holds the value.
   *
   * #### Notes
   * The reference node must be owned by the list.
   *
   * #### Complexity
   * Constant.
   */
  insertBefore(value, ref2) {
    if (!ref2 || ref2 === this._first) {
      return this.addFirst(value);
    }
    if (!(ref2 instanceof Private$x.LinkedListNode) || ref2.list !== this) {
      throw new Error("Reference node is not owned by the list.");
    }
    let node2 = new Private$x.LinkedListNode(this, value);
    let _ref = ref2;
    let prev = _ref.prev;
    node2.next = _ref;
    node2.prev = prev;
    _ref.prev = node2;
    prev.next = node2;
    this._size++;
    return node2;
  }
  /**
   * Insert a value after a specific node in the list.
   *
   * @param value - The value to insert after the reference node.
   *
   * @param ref - The reference node of interest. If this is `null`,
   *   the value will be added to the end of the list.
   *
   * @returns The list node which holds the value.
   *
   * #### Notes
   * The reference node must be owned by the list.
   *
   * #### Complexity
   * Constant.
   */
  insertAfter(value, ref2) {
    if (!ref2 || ref2 === this._last) {
      return this.addLast(value);
    }
    if (!(ref2 instanceof Private$x.LinkedListNode) || ref2.list !== this) {
      throw new Error("Reference node is not owned by the list.");
    }
    let node2 = new Private$x.LinkedListNode(this, value);
    let _ref = ref2;
    let next = _ref.next;
    node2.next = next;
    node2.prev = _ref;
    _ref.next = node2;
    next.prev = node2;
    this._size++;
    return node2;
  }
  /**
   * Remove and return the value at the beginning of the list.
   *
   * @returns The removed value, or `undefined` if the list is empty.
   *
   * #### Complexity
   * Constant.
   */
  removeFirst() {
    let node2 = this._first;
    if (!node2) {
      return void 0;
    }
    if (node2 === this._last) {
      this._first = null;
      this._last = null;
    } else {
      this._first = node2.next;
      this._first.prev = null;
    }
    node2.list = null;
    node2.next = null;
    node2.prev = null;
    this._size--;
    return node2.value;
  }
  /**
   * Remove and return the value at the end of the list.
   *
   * @returns The removed value, or `undefined` if the list is empty.
   *
   * #### Complexity
   * Constant.
   */
  removeLast() {
    let node2 = this._last;
    if (!node2) {
      return void 0;
    }
    if (node2 === this._first) {
      this._first = null;
      this._last = null;
    } else {
      this._last = node2.prev;
      this._last.next = null;
    }
    node2.list = null;
    node2.next = null;
    node2.prev = null;
    this._size--;
    return node2.value;
  }
  /**
   * Remove a specific node from the list.
   *
   * @param node - The node to remove from the list.
   *
   * #### Complexity
   * Constant.
   *
   * #### Notes
   * The node must be owned by the list.
   */
  removeNode(node2) {
    if (!(node2 instanceof Private$x.LinkedListNode) || node2.list !== this) {
      throw new Error("Node is not owned by the list.");
    }
    let _node = node2;
    if (_node === this._first && _node === this._last) {
      this._first = null;
      this._last = null;
    } else if (_node === this._first) {
      this._first = _node.next;
      this._first.prev = null;
    } else if (_node === this._last) {
      this._last = _node.prev;
      this._last.next = null;
    } else {
      _node.next.prev = _node.prev;
      _node.prev.next = _node.next;
    }
    _node.list = null;
    _node.next = null;
    _node.prev = null;
    this._size--;
  }
  /**
   * Remove all values from the list.
   *
   * #### Complexity
   * Linear.
   */
  clear() {
    let node2 = this._first;
    while (node2) {
      let next = node2.next;
      node2.list = null;
      node2.prev = null;
      node2.next = null;
      node2 = next;
    }
    this._first = null;
    this._last = null;
    this._size = 0;
  }
}
(function(LinkedList2) {
  function from2(values) {
    let list2 = new LinkedList2();
    list2.assign(values);
    return list2;
  }
  LinkedList2.from = from2;
})(LinkedList || (LinkedList = {}));
var Private$x;
(function(Private2) {
  class LinkedListNode {
    /**
     * Construct a new linked list node.
     *
     * @param list - The list which owns the node.
     *
     * @param value - The value for the link.
     */
    constructor(list2, value) {
      this.list = null;
      this.next = null;
      this.prev = null;
      this.list = list2;
      this.value = value;
    }
  }
  Private2.LinkedListNode = LinkedListNode;
})(Private$x || (Private$x = {}));
class Message {
  /**
   * Construct a new message.
   *
   * @param type - The type of the message.
   */
  constructor(type) {
    this.type = type;
  }
  /**
   * Test whether the message is conflatable.
   *
   * #### Notes
   * Message conflation is an advanced topic. Most message types will
   * not make use of this feature.
   *
   * If a conflatable message is posted to a handler while another
   * conflatable message of the same `type` has already been posted
   * to the handler, the `conflate()` method of the existing message
   * will be invoked. If that method returns `true`, the new message
   * will not be enqueued. This allows messages to be compressed, so
   * that only a single instance of the message type is processed per
   * cycle, no matter how many times messages of that type are posted.
   *
   * Custom message types may reimplement this property.
   *
   * The default implementation is always `false`.
   */
  get isConflatable() {
    return false;
  }
  /**
   * Conflate this message with another message of the same `type`.
   *
   * @param other - A conflatable message of the same `type`.
   *
   * @returns `true` if the message was successfully conflated, or
   *   `false` otherwise.
   *
   * #### Notes
   * Message conflation is an advanced topic. Most message types will
   * not make use of this feature.
   *
   * This method is called automatically by the message loop when the
   * given message is posted to the handler paired with this message.
   * This message will already be enqueued and conflatable, and the
   * given message will have the same `type` and also be conflatable.
   *
   * This method should merge the state of the other message into this
   * message as needed so that when this message is finally delivered
   * to the handler, it receives the most up-to-date information.
   *
   * If this method returns `true`, it signals that the other message
   * was successfully conflated and that message will not be enqueued.
   *
   * If this method returns `false`, the other message will be enqueued
   * for normal delivery.
   *
   * Custom message types may reimplement this method.
   *
   * The default implementation always returns `false`.
   */
  conflate(other) {
    return false;
  }
}
class ConflatableMessage extends Message {
  /**
   * Test whether the message is conflatable.
   *
   * #### Notes
   * This property is always `true`.
   */
  get isConflatable() {
    return true;
  }
  /**
   * Conflate this message with another message of the same `type`.
   *
   * #### Notes
   * This method always returns `true`.
   */
  conflate(other) {
    return true;
  }
}
var MessageLoop;
(function(MessageLoop2) {
  let pending = null;
  const schedule = /* @__PURE__ */ ((resolved) => (fn) => {
    let rejected = false;
    resolved.then(() => !rejected && fn());
    return () => {
      rejected = true;
    };
  })(Promise.resolve());
  function sendMessage(handler, msg) {
    let hooks = messageHooks.get(handler);
    if (!hooks || hooks.length === 0) {
      invokeHandler(handler, msg);
      return;
    }
    let passed = every$1(retro(hooks), (hook) => {
      return hook ? invokeHook(hook, handler, msg) : true;
    });
    if (passed) {
      invokeHandler(handler, msg);
    }
  }
  MessageLoop2.sendMessage = sendMessage;
  function postMessage(handler, msg) {
    if (!msg.isConflatable) {
      enqueueMessage(handler, msg);
      return;
    }
    let conflated = some$1(messageQueue, (posted) => {
      if (posted.handler !== handler) {
        return false;
      }
      if (!posted.msg) {
        return false;
      }
      if (posted.msg.type !== msg.type) {
        return false;
      }
      if (!posted.msg.isConflatable) {
        return false;
      }
      return posted.msg.conflate(msg);
    });
    if (!conflated) {
      enqueueMessage(handler, msg);
    }
  }
  MessageLoop2.postMessage = postMessage;
  function installMessageHook(handler, hook) {
    let hooks = messageHooks.get(handler);
    if (hooks && hooks.indexOf(hook) !== -1) {
      return;
    }
    if (!hooks) {
      messageHooks.set(handler, [hook]);
    } else {
      hooks.push(hook);
    }
  }
  MessageLoop2.installMessageHook = installMessageHook;
  function removeMessageHook(handler, hook) {
    let hooks = messageHooks.get(handler);
    if (!hooks) {
      return;
    }
    let i2 = hooks.indexOf(hook);
    if (i2 === -1) {
      return;
    }
    hooks[i2] = null;
    scheduleCleanup(hooks);
  }
  MessageLoop2.removeMessageHook = removeMessageHook;
  function clearData(handler) {
    let hooks = messageHooks.get(handler);
    if (hooks && hooks.length > 0) {
      ArrayExt.fill(hooks, null);
      scheduleCleanup(hooks);
    }
    for (const posted of messageQueue) {
      if (posted.handler === handler) {
        posted.handler = null;
        posted.msg = null;
      }
    }
  }
  MessageLoop2.clearData = clearData;
  function flush() {
    if (flushGuard || pending === null) {
      return;
    }
    pending();
    pending = null;
    flushGuard = true;
    runMessageLoop();
    flushGuard = false;
  }
  MessageLoop2.flush = flush;
  function getExceptionHandler() {
    return exceptionHandler;
  }
  MessageLoop2.getExceptionHandler = getExceptionHandler;
  function setExceptionHandler(handler) {
    let old = exceptionHandler;
    exceptionHandler = handler;
    return old;
  }
  MessageLoop2.setExceptionHandler = setExceptionHandler;
  const messageQueue = new LinkedList();
  const messageHooks = /* @__PURE__ */ new WeakMap();
  const dirtySet = /* @__PURE__ */ new Set();
  let exceptionHandler = (err) => {
    console.error(err);
  };
  let flushGuard = false;
  function invokeHook(hook, handler, msg) {
    let result2 = true;
    try {
      if (typeof hook === "function") {
        result2 = hook(handler, msg);
      } else {
        result2 = hook.messageHook(handler, msg);
      }
    } catch (err) {
      exceptionHandler(err);
    }
    return result2;
  }
  function invokeHandler(handler, msg) {
    try {
      handler.processMessage(msg);
    } catch (err) {
      exceptionHandler(err);
    }
  }
  function enqueueMessage(handler, msg) {
    messageQueue.addLast({ handler, msg });
    if (pending !== null) {
      return;
    }
    pending = schedule(runMessageLoop);
  }
  function runMessageLoop() {
    pending = null;
    if (messageQueue.isEmpty) {
      return;
    }
    let sentinel = { handler: null, msg: null };
    messageQueue.addLast(sentinel);
    while (true) {
      let posted = messageQueue.removeFirst();
      if (posted === sentinel) {
        return;
      }
      if (posted.handler && posted.msg) {
        sendMessage(posted.handler, posted.msg);
      }
    }
  }
  function scheduleCleanup(hooks) {
    if (dirtySet.size === 0) {
      schedule(cleanupDirtySet);
    }
    dirtySet.add(hooks);
  }
  function cleanupDirtySet() {
    dirtySet.forEach(cleanupHooks);
    dirtySet.clear();
  }
  function cleanupHooks(hooks) {
    ArrayExt.removeAllWhere(hooks, isNull);
  }
  function isNull(value) {
    return value === null;
  }
})(MessageLoop || (MessageLoop = {}));
class AttachedProperty {
  /**
   * Construct a new attached property.
   *
   * @param options - The options for initializing the property.
   */
  constructor(options) {
    this._pid = Private$w.nextPID();
    this.name = options.name;
    this._create = options.create;
    this._coerce = options.coerce || null;
    this._compare = options.compare || null;
    this._changed = options.changed || null;
  }
  /**
   * Get the current value of the property for a given owner.
   *
   * @param owner - The property owner of interest.
   *
   * @returns The current value of the property.
   *
   * #### Notes
   * If the value has not yet been set, the default value will be
   * computed and assigned as the current value of the property.
   */
  get(owner) {
    let value;
    let map2 = Private$w.ensureMap(owner);
    if (this._pid in map2) {
      value = map2[this._pid];
    } else {
      value = map2[this._pid] = this._createValue(owner);
    }
    return value;
  }
  /**
   * Set the current value of the property for a given owner.
   *
   * @param owner - The property owner of interest.
   *
   * @param value - The value for the property.
   *
   * #### Notes
   * If the value has not yet been set, the default value will be
   * computed and used as the previous value for the comparison.
   */
  set(owner, value) {
    let oldValue;
    let map2 = Private$w.ensureMap(owner);
    if (this._pid in map2) {
      oldValue = map2[this._pid];
    } else {
      oldValue = map2[this._pid] = this._createValue(owner);
    }
    let newValue = this._coerceValue(owner, value);
    this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
  }
  /**
   * Explicitly coerce the current property value for a given owner.
   *
   * @param owner - The property owner of interest.
   *
   * #### Notes
   * If the value has not yet been set, the default value will be
   * computed and used as the previous value for the comparison.
   */
  coerce(owner) {
    let oldValue;
    let map2 = Private$w.ensureMap(owner);
    if (this._pid in map2) {
      oldValue = map2[this._pid];
    } else {
      oldValue = map2[this._pid] = this._createValue(owner);
    }
    let newValue = this._coerceValue(owner, oldValue);
    this._maybeNotify(owner, oldValue, map2[this._pid] = newValue);
  }
  /**
   * Get or create the default value for the given owner.
   */
  _createValue(owner) {
    let create2 = this._create;
    return create2(owner);
  }
  /**
   * Coerce the value for the given owner.
   */
  _coerceValue(owner, value) {
    let coerce = this._coerce;
    return coerce ? coerce(owner, value) : value;
  }
  /**
   * Compare the old value and new value for equality.
   */
  _compareValue(oldValue, newValue) {
    let compare2 = this._compare;
    return compare2 ? compare2(oldValue, newValue) : oldValue === newValue;
  }
  /**
   * Run the change notification if the given values are different.
   */
  _maybeNotify(owner, oldValue, newValue) {
    let changed = this._changed;
    if (changed && !this._compareValue(oldValue, newValue)) {
      changed(owner, oldValue, newValue);
    }
  }
}
(function(AttachedProperty2) {
  function clearData(owner) {
    Private$w.ownerData.delete(owner);
  }
  AttachedProperty2.clearData = clearData;
})(AttachedProperty || (AttachedProperty = {}));
var Private$w;
(function(Private2) {
  Private2.ownerData = /* @__PURE__ */ new WeakMap();
  Private2.nextPID = /* @__PURE__ */ (() => {
    let id = 0;
    return () => {
      let rand = Math.random();
      let stem = `${rand}`.slice(2);
      return `pid-${stem}-${id++}`;
    };
  })();
  function ensureMap(owner) {
    let map2 = Private2.ownerData.get(owner);
    if (map2) {
      return map2;
    }
    map2 = /* @__PURE__ */ Object.create(null);
    Private2.ownerData.set(owner, map2);
    return map2;
  }
  Private2.ensureMap = ensureMap;
})(Private$w || (Private$w = {}));
const index_es6$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get AttachedProperty() {
    return AttachedProperty;
  }
}, Symbol.toStringTag, { value: "Module" }));
class DisposableDelegate {
  /**
   * Construct a new disposable delegate.
   *
   * @param fn - The callback function to invoke on dispose.
   */
  constructor(fn) {
    this._fn = fn;
  }
  /**
   * Test whether the delegate has been disposed.
   */
  get isDisposed() {
    return !this._fn;
  }
  /**
   * Dispose of the delegate and invoke the callback function.
   */
  dispose() {
    if (!this._fn) {
      return;
    }
    let fn = this._fn;
    this._fn = null;
    fn();
  }
}
class ObservableDisposableDelegate extends DisposableDelegate {
  constructor() {
    super(...arguments);
    this._disposed = new Signal(this);
  }
  /**
   * A signal emitted when the delegate is disposed.
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * Dispose of the delegate and invoke the callback function.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    super.dispose();
    this._disposed.emit(void 0);
    Signal.clearData(this);
  }
}
class DisposableSet {
  constructor() {
    this._isDisposed = false;
    this._items = /* @__PURE__ */ new Set();
  }
  /**
   * Test whether the set has been disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of the set and the items it contains.
   *
   * #### Notes
   * Items are disposed in the order they are added to the set.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    this._items.forEach((item) => {
      item.dispose();
    });
    this._items.clear();
  }
  /**
   * Test whether the set contains a specific item.
   *
   * @param item - The item of interest.
   *
   * @returns `true` if the set contains the item, `false` otherwise.
   */
  contains(item) {
    return this._items.has(item);
  }
  /**
   * Add a disposable item to the set.
   *
   * @param item - The item to add to the set.
   *
   * #### Notes
   * If the item is already contained in the set, this is a no-op.
   */
  add(item) {
    this._items.add(item);
  }
  /**
   * Remove a disposable item from the set.
   *
   * @param item - The item to remove from the set.
   *
   * #### Notes
   * If the item is not contained in the set, this is a no-op.
   */
  remove(item) {
    this._items.delete(item);
  }
  /**
   * Remove all items from the set.
   */
  clear() {
    this._items.clear();
  }
}
(function(DisposableSet2) {
  function from2(items) {
    let set2 = new DisposableSet2();
    for (const item of items) {
      set2.add(item);
    }
    return set2;
  }
  DisposableSet2.from = from2;
})(DisposableSet || (DisposableSet = {}));
class ObservableDisposableSet extends DisposableSet {
  constructor() {
    super(...arguments);
    this._disposed = new Signal(this);
  }
  /**
   * A signal emitted when the set is disposed.
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * Dispose of the set and the items it contains.
   *
   * #### Notes
   * Items are disposed in the order they are added to the set.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    super.dispose();
    this._disposed.emit(void 0);
    Signal.clearData(this);
  }
}
(function(ObservableDisposableSet2) {
  function from2(items) {
    let set2 = new ObservableDisposableSet2();
    for (const item of items) {
      set2.add(item);
    }
    return set2;
  }
  ObservableDisposableSet2.from = from2;
})(ObservableDisposableSet || (ObservableDisposableSet = {}));
const index_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DisposableDelegate,
  get DisposableSet() {
    return DisposableSet;
  },
  ObservableDisposableDelegate,
  get ObservableDisposableSet() {
    return ObservableDisposableSet;
  }
}, Symbol.toStringTag, { value: "Module" }));
class Drag {
  /**
   * Construct a new drag object.
   *
   * @param options - The options for initializing the drag.
   */
  constructor(options) {
    this._onScrollFrame = () => {
      if (!this._scrollTarget) {
        return;
      }
      let { element, edge, distance } = this._scrollTarget;
      let d = Private$v.SCROLL_EDGE_SIZE - distance;
      let f = Math.pow(d / Private$v.SCROLL_EDGE_SIZE, 2);
      let s = Math.max(1, Math.round(f * Private$v.SCROLL_EDGE_SIZE));
      switch (edge) {
        case "top":
          element.scrollTop -= s;
          break;
        case "left":
          element.scrollLeft -= s;
          break;
        case "right":
          element.scrollLeft += s;
          break;
        case "bottom":
          element.scrollTop += s;
          break;
      }
      requestAnimationFrame(this._onScrollFrame);
    };
    this._disposed = false;
    this._dropAction = "none";
    this._override = null;
    this._currentTarget = null;
    this._currentElement = null;
    this._promise = null;
    this._scrollTarget = null;
    this._resolve = null;
    this.document = options.document || document;
    this.mimeData = options.mimeData;
    this.dragImage = options.dragImage || null;
    this.proposedAction = options.proposedAction || "copy";
    this.supportedActions = options.supportedActions || "all";
    this.source = options.source || null;
  }
  /**
   * Dispose of the resources held by the drag object.
   *
   * #### Notes
   * This will cancel the drag operation if it is active.
   */
  dispose() {
    if (this._disposed) {
      return;
    }
    this._disposed = true;
    if (this._currentTarget) {
      let event2 = new PointerEvent("pointerup", {
        bubbles: true,
        cancelable: true,
        clientX: -1,
        clientY: -1
      });
      Private$v.dispatchDragLeave(this, this._currentTarget, null, event2);
    }
    this._finalize("none");
  }
  /**
   * Test whether the drag object is disposed.
   */
  get isDisposed() {
    return this._disposed;
  }
  /**
   * Start the drag operation at the specified client position.
   *
   * @param clientX - The client X position for the drag start.
   *
   * @param clientY - The client Y position for the drag start.
   *
   * @returns A promise which resolves to the result of the drag.
   *
   * #### Notes
   * If the drag has already been started, the promise created by the
   * first call to `start` is returned.
   *
   * If the drag operation has ended, or if the drag object has been
   * disposed, the returned promise will resolve to `'none'`.
   *
   * The drag object will be automatically disposed when drag operation
   * completes. This means `Drag` objects are for single-use only.
   *
   * This method assumes the left mouse button is already held down.
   */
  start(clientX, clientY) {
    if (this._disposed) {
      return Promise.resolve("none");
    }
    if (this._promise) {
      return this._promise;
    }
    this._addListeners();
    this._attachDragImage(clientX, clientY);
    this._promise = new Promise((resolve3) => {
      this._resolve = resolve3;
    });
    let event2 = new PointerEvent("pointermove", {
      bubbles: true,
      cancelable: true,
      clientX,
      clientY
    });
    document.dispatchEvent(event2);
    return this._promise;
  }
  /**
   * Handle the DOM events for the drag operation.
   *
   * @param event - The DOM event sent to the drag object.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the document. It should not be
   * called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "pointermove":
        this._evtPointerMove(event2);
        break;
      case "pointerup":
        this._evtPointerUp(event2);
        break;
      case "keydown":
        this._evtKeyDown(event2);
        break;
      default:
        event2.preventDefault();
        event2.stopPropagation();
        break;
    }
  }
  /**
   * Move the drag image element to the specified location.
   *
   * This is a no-op if there is no drag image element.
   */
  moveDragImage(clientX, clientY) {
    if (!this.dragImage) {
      return;
    }
    let style2 = this.dragImage.style;
    style2.transform = `translate(${clientX}px, ${clientY}px)`;
  }
  /**
   * Handle the `'pointermove'` event for the drag object.
   */
  _evtPointerMove(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    this._updateCurrentTarget(event2);
    this._updateDragScroll(event2);
    this.moveDragImage(event2.clientX, event2.clientY);
  }
  /**
   * Handle the `'pointerup'` event for the drag object.
   */
  _evtPointerUp(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    if (event2.button !== 0) {
      return;
    }
    this._updateCurrentTarget(event2);
    if (!this._currentTarget) {
      this._finalize("none");
      return;
    }
    if (this._dropAction === "none") {
      Private$v.dispatchDragLeave(this, this._currentTarget, null, event2);
      this._finalize("none");
      return;
    }
    let action = Private$v.dispatchDrop(this, this._currentTarget, event2);
    this._finalize(action);
  }
  /**
   * Handle the `'keydown'` event for the drag object.
   */
  _evtKeyDown(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    if (event2.keyCode === 27) {
      this.dispose();
    }
  }
  /**
   * Add the document event listeners for the drag object.
   */
  _addListeners() {
    document.addEventListener("pointerdown", this, true);
    document.addEventListener("pointermove", this, true);
    document.addEventListener("pointerup", this, true);
    document.addEventListener("pointerenter", this, true);
    document.addEventListener("pointerleave", this, true);
    document.addEventListener("pointerover", this, true);
    document.addEventListener("pointerout", this, true);
    document.addEventListener("keydown", this, true);
    document.addEventListener("keyup", this, true);
    document.addEventListener("keypress", this, true);
    document.addEventListener("contextmenu", this, true);
  }
  /**
   * Remove the document event listeners for the drag object.
   */
  _removeListeners() {
    document.removeEventListener("pointerdown", this, true);
    document.removeEventListener("pointermove", this, true);
    document.removeEventListener("pointerup", this, true);
    document.removeEventListener("pointerenter", this, true);
    document.removeEventListener("pointerleave", this, true);
    document.removeEventListener("pointerover", this, true);
    document.removeEventListener("pointerout", this, true);
    document.removeEventListener("keydown", this, true);
    document.removeEventListener("keyup", this, true);
    document.removeEventListener("keypress", this, true);
    document.removeEventListener("contextmenu", this, true);
  }
  /**
   * Update the drag scroll element under the mouse.
   */
  _updateDragScroll(event2) {
    let target2 = Private$v.findScrollTarget(event2);
    if (!this._scrollTarget && !target2) {
      return;
    }
    if (!this._scrollTarget) {
      setTimeout(this._onScrollFrame, 500);
    }
    this._scrollTarget = target2;
  }
  /**
   * Update the current target node using the given mouse event.
   */
  _updateCurrentTarget(event2) {
    let prevTarget = this._currentTarget;
    let currTarget = this._currentTarget;
    let prevElem = this._currentElement;
    let currElem = Private$v.findElementBehindBackdrop(event2, this.document);
    this._currentElement = currElem;
    if (currElem !== prevElem && currElem !== currTarget) {
      Private$v.dispatchDragExit(this, currTarget, currElem, event2);
    }
    if (currElem !== prevElem && currElem !== currTarget) {
      currTarget = Private$v.dispatchDragEnter(this, currElem, currTarget, event2);
    }
    if (currTarget !== prevTarget) {
      this._currentTarget = currTarget;
      Private$v.dispatchDragLeave(this, prevTarget, currTarget, event2);
    }
    let action = Private$v.dispatchDragOver(this, currTarget, event2);
    this._setDropAction(action);
  }
  /**
   * Attach the drag image element at the specified location.
   *
   * This is a no-op if there is no drag image element.
   */
  _attachDragImage(clientX, clientY) {
    if (!this.dragImage) {
      return;
    }
    this.dragImage.classList.add("lm-mod-drag-image");
    let style2 = this.dragImage.style;
    style2.pointerEvents = "none";
    style2.position = "fixed";
    style2.transform = `translate(${clientX}px, ${clientY}px)`;
    const body = this.document instanceof Document ? this.document.body : this.document.firstElementChild;
    body.appendChild(this.dragImage);
  }
  /**
   * Detach the drag image element from the DOM.
   *
   * This is a no-op if there is no drag image element.
   */
  _detachDragImage() {
    if (!this.dragImage) {
      return;
    }
    let parent = this.dragImage.parentNode;
    if (!parent) {
      return;
    }
    parent.removeChild(this.dragImage);
  }
  /**
   * Set the internal drop action state and update the drag cursor.
   */
  _setDropAction(action) {
    action = Private$v.validateAction(action, this.supportedActions);
    if (this._override && this._dropAction === action) {
      return;
    }
    switch (action) {
      case "none":
        this._dropAction = action;
        this._override = Drag.overrideCursor("no-drop", this.document);
        break;
      case "copy":
        this._dropAction = action;
        this._override = Drag.overrideCursor("copy", this.document);
        break;
      case "link":
        this._dropAction = action;
        this._override = Drag.overrideCursor("alias", this.document);
        break;
      case "move":
        this._dropAction = action;
        this._override = Drag.overrideCursor("move", this.document);
        break;
    }
  }
  /**
   * Finalize the drag operation and resolve the drag promise.
   */
  _finalize(action) {
    let resolve3 = this._resolve;
    this._removeListeners();
    this._detachDragImage();
    if (this._override) {
      this._override.dispose();
      this._override = null;
    }
    this.mimeData.clear();
    this._disposed = true;
    this._dropAction = "none";
    this._currentTarget = null;
    this._currentElement = null;
    this._scrollTarget = null;
    this._promise = null;
    this._resolve = null;
    if (resolve3) {
      resolve3(action);
    }
  }
}
(function(Drag2) {
  class Event2 extends DragEvent {
    constructor(event2, options) {
      super(options.type, {
        bubbles: true,
        cancelable: true,
        altKey: event2.altKey,
        button: event2.button,
        clientX: event2.clientX,
        clientY: event2.clientY,
        ctrlKey: event2.ctrlKey,
        detail: 0,
        metaKey: event2.metaKey,
        relatedTarget: options.related,
        screenX: event2.screenX,
        screenY: event2.screenY,
        shiftKey: event2.shiftKey,
        view: window
      });
      const { drag } = options;
      this.dropAction = "none";
      this.mimeData = drag.mimeData;
      this.proposedAction = drag.proposedAction;
      this.supportedActions = drag.supportedActions;
      this.source = drag.source;
    }
  }
  Drag2.Event = Event2;
  function overrideCursor(cursor, doc2 = document) {
    return Private$v.overrideCursor(cursor, doc2);
  }
  Drag2.overrideCursor = overrideCursor;
})(Drag || (Drag = {}));
var Private$v;
(function(Private2) {
  Private2.SCROLL_EDGE_SIZE = 20;
  function validateAction(action, supported) {
    return actionTable[action] & supportedTable[supported] ? action : "none";
  }
  Private2.validateAction = validateAction;
  function findElementBehindBackdrop(event2, root2 = document) {
    if (event2) {
      if (lastElementEventSearch && event2 == lastElementEventSearch.event) {
        return lastElementEventSearch.element;
      }
      Private2.cursorBackdrop.style.zIndex = "-1000";
      const element = root2.elementFromPoint(event2.clientX, event2.clientY);
      Private2.cursorBackdrop.style.zIndex = "";
      lastElementEventSearch = { event: event2, element };
      return element;
    } else {
      const transform = Private2.cursorBackdrop.style.transform;
      if (lastElementSearch && transform === lastElementSearch.transform) {
        return lastElementSearch.element;
      }
      const bbox = Private2.cursorBackdrop.getBoundingClientRect();
      Private2.cursorBackdrop.style.zIndex = "-1000";
      const element = root2.elementFromPoint(bbox.left + bbox.width / 2, bbox.top + bbox.height / 2);
      Private2.cursorBackdrop.style.zIndex = "";
      lastElementSearch = { transform, element };
      return element;
    }
  }
  Private2.findElementBehindBackdrop = findElementBehindBackdrop;
  let lastElementEventSearch = null;
  let lastElementSearch = null;
  function findScrollTarget(event2) {
    let x2 = event2.clientX;
    let y = event2.clientY;
    let element = findElementBehindBackdrop(event2);
    for (; element; element = element.parentElement) {
      if (!element.hasAttribute("data-lm-dragscroll")) {
        continue;
      }
      let offsetX = 0;
      let offsetY = 0;
      if (element === document.body) {
        offsetX = window.pageXOffset;
        offsetY = window.pageYOffset;
      }
      let r = element.getBoundingClientRect();
      let top2 = r.top + offsetY;
      let left = r.left + offsetX;
      let right = left + r.width;
      let bottom = top2 + r.height;
      if (x2 < left || x2 >= right || y < top2 || y >= bottom) {
        continue;
      }
      let dl = x2 - left + 1;
      let dt = y - top2 + 1;
      let dr = right - x2;
      let db = bottom - y;
      let distance = Math.min(dl, dt, dr, db);
      if (distance > Private2.SCROLL_EDGE_SIZE) {
        continue;
      }
      let edge;
      switch (distance) {
        case db:
          edge = "bottom";
          break;
        case dt:
          edge = "top";
          break;
        case dr:
          edge = "right";
          break;
        case dl:
          edge = "left";
          break;
        default:
          throw "unreachable";
      }
      let dsw = element.scrollWidth - element.clientWidth;
      let dsh = element.scrollHeight - element.clientHeight;
      let shouldScroll;
      switch (edge) {
        case "top":
          shouldScroll = dsh > 0 && element.scrollTop > 0;
          break;
        case "left":
          shouldScroll = dsw > 0 && element.scrollLeft > 0;
          break;
        case "right":
          shouldScroll = dsw > 0 && element.scrollLeft < dsw;
          break;
        case "bottom":
          shouldScroll = dsh > 0 && element.scrollTop < dsh;
          break;
        default:
          throw "unreachable";
      }
      if (!shouldScroll) {
        continue;
      }
      return { element, edge, distance };
    }
    return null;
  }
  Private2.findScrollTarget = findScrollTarget;
  function dispatchDragEnter(drag, currElem, currTarget, event2) {
    if (!currElem) {
      return null;
    }
    let dragEvent = new Drag.Event(event2, {
      drag,
      related: currTarget,
      type: "lm-dragenter"
    });
    let canceled = !currElem.dispatchEvent(dragEvent);
    if (canceled) {
      return currElem;
    }
    const body = drag.document instanceof Document ? drag.document.body : drag.document.firstElementChild;
    if (currElem === body) {
      return currTarget;
    }
    dragEvent = new Drag.Event(event2, {
      drag,
      related: currTarget,
      type: "lm-dragenter"
    });
    body.dispatchEvent(dragEvent);
    return body;
  }
  Private2.dispatchDragEnter = dispatchDragEnter;
  function dispatchDragExit(drag, prevTarget, currTarget, event2) {
    if (!prevTarget) {
      return;
    }
    let dragEvent = new Drag.Event(event2, {
      drag,
      related: currTarget,
      type: "lm-dragexit"
    });
    prevTarget.dispatchEvent(dragEvent);
  }
  Private2.dispatchDragExit = dispatchDragExit;
  function dispatchDragLeave(drag, prevTarget, currTarget, event2) {
    if (!prevTarget) {
      return;
    }
    let dragEvent = new Drag.Event(event2, {
      drag,
      related: currTarget,
      type: "lm-dragleave"
    });
    prevTarget.dispatchEvent(dragEvent);
  }
  Private2.dispatchDragLeave = dispatchDragLeave;
  function dispatchDragOver(drag, currTarget, event2) {
    if (!currTarget) {
      return "none";
    }
    let dragEvent = new Drag.Event(event2, {
      drag,
      related: null,
      type: "lm-dragover"
    });
    let canceled = !currTarget.dispatchEvent(dragEvent);
    if (canceled) {
      return dragEvent.dropAction;
    }
    return "none";
  }
  Private2.dispatchDragOver = dispatchDragOver;
  function dispatchDrop(drag, currTarget, event2) {
    if (!currTarget) {
      return "none";
    }
    let dragEvent = new Drag.Event(event2, {
      drag,
      related: null,
      type: "lm-drop"
    });
    let canceled = !currTarget.dispatchEvent(dragEvent);
    if (canceled) {
      return dragEvent.dropAction;
    }
    return "none";
  }
  Private2.dispatchDrop = dispatchDrop;
  const actionTable = {
    none: 0,
    copy: 1,
    link: 2,
    move: 4
  };
  const supportedTable = {
    none: actionTable["none"],
    copy: actionTable["copy"],
    link: actionTable["link"],
    move: actionTable["move"],
    "copy-link": actionTable["copy"] | actionTable["link"],
    "copy-move": actionTable["copy"] | actionTable["move"],
    "link-move": actionTable["link"] | actionTable["move"],
    all: actionTable["copy"] | actionTable["link"] | actionTable["move"]
  };
  function overrideCursor(cursor, doc2 = document) {
    let id = ++overrideCursorID;
    const body = doc2 instanceof Document ? doc2.body : doc2.firstElementChild;
    if (!Private2.cursorBackdrop.isConnected) {
      Private2.cursorBackdrop.style.transform = "scale(0)";
      body.appendChild(Private2.cursorBackdrop);
      resetBackdropScroll();
      document.addEventListener("pointermove", alignBackdrop, {
        capture: true,
        passive: true
      });
      Private2.cursorBackdrop.addEventListener("scroll", propagateBackdropScroll, {
        capture: true,
        passive: true
      });
    }
    Private2.cursorBackdrop.style.cursor = cursor;
    return new DisposableDelegate(() => {
      if (id === overrideCursorID && Private2.cursorBackdrop.isConnected) {
        document.removeEventListener("pointermove", alignBackdrop, true);
        Private2.cursorBackdrop.removeEventListener("scroll", propagateBackdropScroll, true);
        body.removeChild(Private2.cursorBackdrop);
      }
    });
  }
  Private2.overrideCursor = overrideCursor;
  function alignBackdrop(event2) {
    if (!Private2.cursorBackdrop) {
      return;
    }
    Private2.cursorBackdrop.style.transform = `translate(${event2.clientX}px, ${event2.clientY}px)`;
  }
  function propagateBackdropScroll(_event) {
    if (!Private2.cursorBackdrop) {
      return;
    }
    let element = findElementBehindBackdrop();
    if (!element) {
      return;
    }
    const scrollTarget = element.closest("[data-lm-dragscroll]");
    if (!scrollTarget) {
      return;
    }
    scrollTarget.scrollTop += Private2.cursorBackdrop.scrollTop - backdropScrollOrigin;
    scrollTarget.scrollLeft += Private2.cursorBackdrop.scrollLeft - backdropScrollOrigin;
    resetBackdropScroll();
  }
  function resetBackdropScroll() {
    Private2.cursorBackdrop.scrollTop = backdropScrollOrigin;
    Private2.cursorBackdrop.scrollLeft = backdropScrollOrigin;
  }
  const backdropScrollOrigin = 500;
  function createCursorBackdrop() {
    const backdrop = document.createElement("div");
    backdrop.classList.add("lm-cursor-backdrop");
    return backdrop;
  }
  let overrideCursorID = 0;
  Private2.cursorBackdrop = createCursorBackdrop();
})(Private$v || (Private$v = {}));
function getKeyboardLayout() {
  return Private$u.keyboardLayout;
}
class KeycodeLayout {
  /**
   * Construct a new keycode layout.
   *
   * @param name - The human readable name for the layout.
   *
   * @param codes - A mapping of keycode to key value.
   *
   * @param modifierKeys - Array of modifier key names
   */
  constructor(name2, codes, modifierKeys = []) {
    this.name = name2;
    this._codes = codes;
    this._keys = KeycodeLayout.extractKeys(codes);
    this._modifierKeys = KeycodeLayout.convertToKeySet(modifierKeys);
  }
  /**
   * Get an array of the key values supported by the layout.
   *
   * @returns A new array of the supported key values.
   */
  keys() {
    return Object.keys(this._keys);
  }
  /**
   * Test whether the given key is a valid value for the layout.
   *
   * @param key - The user provided key to test for validity.
   *
   * @returns `true` if the key is valid, `false` otherwise.
   */
  isValidKey(key2) {
    return key2 in this._keys;
  }
  /**
   * Test whether the given key is a modifier key.
   *
   * @param key - The user provided key.
   *
   * @returns `true` if the key is a modifier key, `false` otherwise.
   */
  isModifierKey(key2) {
    return key2 in this._modifierKeys;
  }
  /**
   * Get the key for a `'keydown'` event.
   *
   * @param event - The event object for a `'keydown'` event.
   *
   * @returns The associated key value, or an empty string if
   *   the event does not represent a valid primary key.
   */
  keyForKeydownEvent(event2) {
    return this._codes[event2.keyCode] || "";
  }
}
(function(KeycodeLayout2) {
  function extractKeys(codes) {
    let keys2 = /* @__PURE__ */ Object.create(null);
    for (let c in codes) {
      keys2[codes[c]] = true;
    }
    return keys2;
  }
  KeycodeLayout2.extractKeys = extractKeys;
  function convertToKeySet(keys2) {
    let keySet = Object(null);
    for (let i2 = 0, n = keys2.length; i2 < n; ++i2) {
      keySet[keys2[i2]] = true;
    }
    return keySet;
  }
  KeycodeLayout2.convertToKeySet = convertToKeySet;
})(KeycodeLayout || (KeycodeLayout = {}));
const EN_US = new KeycodeLayout(
  "en-us",
  {
    8: "Backspace",
    9: "Tab",
    13: "Enter",
    16: "Shift",
    17: "Ctrl",
    18: "Alt",
    19: "Pause",
    27: "Escape",
    32: "Space",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    48: "0",
    49: "1",
    50: "2",
    51: "3",
    52: "4",
    53: "5",
    54: "6",
    55: "7",
    56: "8",
    57: "9",
    59: ";",
    61: "=",
    65: "A",
    66: "B",
    67: "C",
    68: "D",
    69: "E",
    70: "F",
    71: "G",
    72: "H",
    73: "I",
    74: "J",
    75: "K",
    76: "L",
    77: "M",
    78: "N",
    79: "O",
    80: "P",
    81: "Q",
    82: "R",
    83: "S",
    84: "T",
    85: "U",
    86: "V",
    87: "W",
    88: "X",
    89: "Y",
    90: "Z",
    91: "Meta",
    93: "ContextMenu",
    96: "0",
    97: "1",
    98: "2",
    99: "3",
    100: "4",
    101: "5",
    102: "6",
    103: "7",
    104: "8",
    105: "9",
    106: "*",
    107: "+",
    109: "-",
    110: ".",
    111: "/",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
    224: "Meta"
    // firefox
  },
  ["Shift", "Ctrl", "Alt", "Meta"]
  // modifier keys
);
var Private$u;
(function(Private2) {
  Private2.keyboardLayout = EN_US;
})(Private$u || (Private$u = {}));
class CommandRegistry {
  constructor() {
    this._timerID = 0;
    this._timerModifierID = 0;
    this._replaying = false;
    this._keystrokes = [];
    this._keydownEvents = [];
    this._keyBindings = [];
    this._exactKeyMatch = null;
    this._commands = /* @__PURE__ */ new Map();
    this._commandChanged = new Signal(this);
    this._commandExecuted = new Signal(this);
    this._keyBindingChanged = new Signal(this);
    this._holdKeyBindingPromises = /* @__PURE__ */ new Map();
  }
  /**
   * A signal emitted when a command has changed.
   *
   * #### Notes
   * This signal is useful for visual representations of commands which
   * need to refresh when the state of a relevant command has changed.
   */
  get commandChanged() {
    return this._commandChanged;
  }
  /**
   * A signal emitted when a command has executed.
   *
   * #### Notes
   * Care should be taken when consuming this signal. The command system is used
   * by many components for many user actions. Handlers registered with this
   * signal must return quickly to ensure the overall application remains responsive.
   */
  get commandExecuted() {
    return this._commandExecuted;
  }
  /**
   * A signal emitted when a key binding is changed.
   */
  get keyBindingChanged() {
    return this._keyBindingChanged;
  }
  /**
   * A read-only array of the key bindings in the registry.
   */
  get keyBindings() {
    return this._keyBindings;
  }
  /**
   * List the ids of the registered commands.
   *
   * @returns A new array of the registered command ids.
   */
  listCommands() {
    return Array.from(this._commands.keys());
  }
  /**
   * Test whether a specific command is registered.
   *
   * @param id - The id of the command of interest.
   *
   * @returns `true` if the command is registered, `false` otherwise.
   */
  hasCommand(id) {
    return this._commands.has(id);
  }
  /**
   * Add a command to the registry.
   *
   * @param id - The unique id of the command.
   *
   * @param options - The options for the command.
   *
   * @returns A disposable which will remove the command.
   *
   * @throws An error if the given `id` is already registered.
   */
  addCommand(id, options) {
    if (this._commands.has(id)) {
      throw new Error(`Command '${id}' already registered.`);
    }
    this._commands.set(id, Private$t.createCommand(options));
    this._commandChanged.emit({ id, type: "added" });
    return new DisposableDelegate(() => {
      this._commands.delete(id);
      this._commandChanged.emit({ id, type: "removed" });
    });
  }
  /**
   * Notify listeners that the state of a command has changed.
   *
   * @param id - The id of the command which has changed. If more than
   *   one command has changed, this argument should be omitted.
   *
   * @throws An error if the given `id` is not registered.
   *
   * #### Notes
   * This method should be called by the command author whenever the
   * application state changes such that the results of the command
   * metadata functions may have changed.
   *
   * This will cause the `commandChanged` signal to be emitted.
   */
  notifyCommandChanged(id) {
    if (id !== void 0 && !this._commands.has(id)) {
      throw new Error(`Command '${id}' is not registered.`);
    }
    this._commandChanged.emit({ id, type: id ? "changed" : "many-changed" });
  }
  /**
   * Get the description for a specific command.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns The description for the command.
   */
  describedBy(id, args = JSONExt.emptyObject) {
    var _a;
    let cmd = this._commands.get(id);
    return Promise.resolve((_a = cmd === null || cmd === void 0 ? void 0 : cmd.describedBy.call(void 0, args)) !== null && _a !== void 0 ? _a : { args: null });
  }
  /**
   * Get the display label for a specific command.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns The display label for the command, or an empty string
   *   if the command is not registered.
   */
  label(id, args = JSONExt.emptyObject) {
    var _a;
    let cmd = this._commands.get(id);
    return (_a = cmd === null || cmd === void 0 ? void 0 : cmd.label.call(void 0, args)) !== null && _a !== void 0 ? _a : "";
  }
  /**
   * Get the mnemonic index for a specific command.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns The mnemonic index for the command, or `-1` if the
   *   command is not registered.
   */
  mnemonic(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.mnemonic.call(void 0, args) : -1;
  }
  /**
   * Get the icon renderer for a specific command.
   *
   * DEPRECATED: if set to a string value, the .icon field will
   * function as an alias for the .iconClass field, for backwards
   * compatibility. In the future when this is removed, the default
   * return type will become undefined.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns The icon renderer for the command or `undefined`.
   */
  icon(id, args = JSONExt.emptyObject) {
    var _a;
    return (_a = this._commands.get(id)) === null || _a === void 0 ? void 0 : _a.icon.call(void 0, args);
  }
  /**
   * Get the icon class for a specific command.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns The icon class for the command, or an empty string if
   *   the command is not registered.
   */
  iconClass(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.iconClass.call(void 0, args) : "";
  }
  /**
   * Get the icon label for a specific command.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns The icon label for the command, or an empty string if
   *   the command is not registered.
   */
  iconLabel(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.iconLabel.call(void 0, args) : "";
  }
  /**
   * Get the short form caption for a specific command.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns The caption for the command, or an empty string if the
   *   command is not registered.
   */
  caption(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.caption.call(void 0, args) : "";
  }
  /**
   * Get the usage help text for a specific command.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns The usage text for the command, or an empty string if
   *   the command is not registered.
   */
  usage(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.usage.call(void 0, args) : "";
  }
  /**
   * Get the extra class name for a specific command.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns The class name for the command, or an empty string if
   *   the command is not registered.
   */
  className(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.className.call(void 0, args) : "";
  }
  /**
   * Get the dataset for a specific command.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns The dataset for the command, or an empty dataset if
   *   the command is not registered.
   */
  dataset(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.dataset.call(void 0, args) : {};
  }
  /**
   * Test whether a specific command is enabled.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns A boolean indicating whether the command is enabled,
   *   or `false` if the command is not registered.
   */
  isEnabled(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.isEnabled.call(void 0, args) : false;
  }
  /**
   * Test whether a specific command is toggled.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns A boolean indicating whether the command is toggled,
   *   or `false` if the command is not registered.
   */
  isToggled(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.isToggled.call(void 0, args) : false;
  }
  /**
   * Test whether a specific command is toggleable.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns A boolean indicating whether the command is toggleable,
   *   or `false` if the command is not registered.
   */
  isToggleable(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.isToggleable : false;
  }
  /**
   * Test whether a specific command is visible.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns A boolean indicating whether the command is visible,
   *   or `false` if the command is not registered.
   */
  isVisible(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    return cmd ? cmd.isVisible.call(void 0, args) : false;
  }
  /**
   * Execute a specific command.
   *
   * @param id - The id of the command of interest.
   *
   * @param args - The arguments for the command.
   *
   * @returns A promise which resolves with the result of the command.
   *
   * #### Notes
   * The promise will reject if the command throws an exception,
   * or if the command is not registered.
   */
  execute(id, args = JSONExt.emptyObject) {
    let cmd = this._commands.get(id);
    if (!cmd) {
      return Promise.reject(new Error(`Command '${id}' not registered.`));
    }
    let value;
    try {
      value = cmd.execute.call(void 0, args);
    } catch (err) {
      value = Promise.reject(err);
    }
    let result2 = Promise.resolve(value);
    this._commandExecuted.emit({ id, args, result: result2 });
    return result2;
  }
  /**
   * Add a key binding to the registry.
   *
   * @param options - The options for creating the key binding.
   *
   * @returns A disposable which removes the added key binding.
   *
   * #### Notes
   * If multiple key bindings are registered for the same sequence, the
   * binding with the highest selector specificity is executed first. A
   * tie is broken by using the most recently added key binding.
   *
   * Ambiguous key bindings are resolved with a timeout. As an example,
   * suppose two key bindings are registered: one with the key sequence
   * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user
   * presses `Ctrl D`, the first binding cannot be immediately executed
   * since the user may intend to complete the chord with `Ctrl W`. For
   * such cases, a timer is used to allow the chord to be completed. If
   * the chord is not completed before the timeout, the first binding
   * is executed.
   */
  addKeyBinding(options) {
    let binding = Private$t.createKeyBinding(options);
    this._keyBindings.push(binding);
    this._keyBindingChanged.emit({ binding, type: "added" });
    return new DisposableDelegate(() => {
      ArrayExt.removeFirstOf(this._keyBindings, binding);
      this._keyBindingChanged.emit({ binding, type: "removed" });
    });
  }
  /**
   * Process a `'keydown'` event and invoke a matching key binding.
   *
   * @param event - The event object for a `'keydown'` event.
   *
   * #### Notes
   * This should be called in response to a `'keydown'` event in order
   * to invoke the command for the best matching key binding.
   *
   * The registry **does not** install its own listener for `'keydown'`
   * events. This allows the application full control over the nodes
   * and phase for which the registry processes `'keydown'` events.
   *
   * When the keydown event is processed, if the event target or any of its
   * ancestor nodes has a `data-lm-suppress-shortcuts` attribute, its keydown
   * events will not invoke commands.
   */
  processKeydownEvent(event2) {
    if (event2.defaultPrevented || this._replaying) {
      return;
    }
    const keystroke = CommandRegistry.keystrokeForKeydownEvent(event2);
    if (!keystroke) {
      this._replayKeydownEvents();
      this._clearPendingState();
      return;
    }
    if (CommandRegistry.isModifierKeyPressed(event2)) {
      let { exact: exact2 } = Private$t.matchKeyBinding(this._keyBindings, [keystroke], event2);
      if (exact2) {
        event2.preventDefault();
        event2.stopPropagation();
        this._startModifierTimer(exact2);
      } else {
        this._clearModifierTimer();
      }
      return;
    }
    this._keystrokes.push(keystroke);
    const { exact, partial } = Private$t.matchKeyBinding(this._keyBindings, this._keystrokes, event2);
    const hasPartial = partial.length !== 0;
    if (!exact && !hasPartial) {
      this._replayKeydownEvents();
      this._clearPendingState();
      return;
    }
    if ((exact === null || exact === void 0 ? void 0 : exact.preventDefault) || partial.some((match) => match.preventDefault)) {
      event2.preventDefault();
      event2.stopPropagation();
    }
    this._keydownEvents.push(event2);
    if (exact && !hasPartial) {
      this._executeKeyBinding(exact);
      this._clearPendingState();
      return;
    }
    if (exact) {
      this._exactKeyMatch = exact;
    }
    this._startTimer();
  }
  /**
   * Delay the execution of any command matched against the given 'keydown' event
   * until the `permission` to execute is granted.
   *
   * @param event - The event object for a `'keydown'` event.
   * @param permission - The promise with value indicating whether to proceed with the execution.
   *
   * ### Note
   * This enables the caller of `processKeydownEvent` to asynchronously prevent the
   * execution of the command based on external events.
   */
  holdKeyBindingExecution(event2, permission) {
    this._holdKeyBindingPromises.set(event2, permission);
  }
  /**
   * Process a ``keyup`` event to clear the timer on the modifier, if it exists.
   *
   * @param event - The event object for a `'keydown'` event.
   */
  processKeyupEvent(event2) {
    this._clearModifierTimer();
  }
  /**
   * Start or restart the timeout on the modifier keys.
   *
   * This timeout will end only if the keys are hold.
   */
  _startModifierTimer(exact) {
    this._clearModifierTimer();
    this._timerModifierID = window.setTimeout(() => {
      this._executeKeyBinding(exact);
    }, Private$t.modifierkeyTimeOut);
  }
  /**
   * Clear the timeout on modifier keys.
   */
  _clearModifierTimer() {
    if (this._timerModifierID !== 0) {
      clearTimeout(this._timerModifierID);
      this._timerModifierID = 0;
    }
  }
  /**
   * Start or restart the pending timeout.
   */
  _startTimer() {
    this._clearTimer();
    this._timerID = window.setTimeout(() => {
      this._onPendingTimeout();
    }, Private$t.CHORD_TIMEOUT);
  }
  /**
   * Clear the pending timeout.
   */
  _clearTimer() {
    if (this._timerID !== 0) {
      clearTimeout(this._timerID);
      this._timerID = 0;
    }
  }
  /**
   * Replay the keydown events which were suppressed.
   */
  _replayKeydownEvents() {
    if (this._keydownEvents.length === 0) {
      return;
    }
    this._replaying = true;
    this._keydownEvents.forEach(Private$t.replayKeyEvent);
    this._replaying = false;
  }
  /**
   * Execute the command for the given key binding.
   *
   * If the command is missing or disabled, a warning will be logged.
   *
   * The execution will not proceed if any of the events leading to
   * the keybinding matching were held with the permission resolving to false.
   */
  async _executeKeyBinding(binding) {
    if (this._holdKeyBindingPromises.size !== 0) {
      const keydownEvents = [...this._keydownEvents];
      const executionAllowed = (await Promise.race([
        Promise.all(keydownEvents.map(async (event2) => {
          var _a;
          return (_a = this._holdKeyBindingPromises.get(event2)) !== null && _a !== void 0 ? _a : Promise.resolve(true);
        })),
        new Promise((resolve3) => {
          setTimeout(() => resolve3([false]), Private$t.KEYBINDING_HOLD_TIMEOUT);
        })
      ])).every(Boolean);
      this._holdKeyBindingPromises.clear();
      if (!executionAllowed) {
        return;
      }
    }
    let { command, args } = binding;
    let newArgs = {
      _luminoEvent: { type: "keybinding", keys: binding.keys },
      ...args
    };
    if (!this.hasCommand(command) || !this.isEnabled(command, newArgs)) {
      let word = this.hasCommand(command) ? "enabled" : "registered";
      let keys2 = binding.keys.join(", ");
      let msg1 = `Cannot execute key binding '${keys2}':`;
      let msg2 = `command '${command}' is not ${word}.`;
      console.warn(`${msg1} ${msg2}`);
      return;
    }
    await this.execute(command, newArgs);
  }
  /**
   * Clear the internal pending state.
   */
  _clearPendingState() {
    this._clearTimer();
    this._clearModifierTimer();
    this._exactKeyMatch = null;
    this._keystrokes.length = 0;
    this._keydownEvents.length = 0;
  }
  /**
   * Handle the partial match timeout.
   */
  _onPendingTimeout() {
    this._timerID = 0;
    if (this._exactKeyMatch) {
      this._executeKeyBinding(this._exactKeyMatch);
    } else {
      this._replayKeydownEvents();
    }
    this._clearPendingState();
  }
}
(function(CommandRegistry2) {
  function parseKeystroke(keystroke) {
    let key2 = "";
    let alt = false;
    let cmd = false;
    let ctrl = false;
    let shift2 = false;
    for (let token of keystroke.split(/\s+/)) {
      if (token === "Accel") {
        if (Platform.IS_MAC) {
          cmd = true;
        } else {
          ctrl = true;
        }
      } else if (token === "Alt") {
        alt = true;
      } else if (token === "Cmd") {
        cmd = true;
      } else if (token === "Ctrl") {
        ctrl = true;
      } else if (token === "Shift") {
        shift2 = true;
      } else if (token.length > 0) {
        key2 = token;
      }
    }
    return { cmd, ctrl, alt, shift: shift2, key: key2 };
  }
  CommandRegistry2.parseKeystroke = parseKeystroke;
  function normalizeKeystroke(keystroke) {
    let mods = "";
    let parts = parseKeystroke(keystroke);
    if (parts.ctrl) {
      mods += "Ctrl ";
    }
    if (parts.alt) {
      mods += "Alt ";
    }
    if (parts.shift) {
      mods += "Shift ";
    }
    if (parts.cmd && Platform.IS_MAC) {
      mods += "Cmd ";
    }
    if (!parts.key) {
      return mods.trim();
    }
    return mods + parts.key;
  }
  CommandRegistry2.normalizeKeystroke = normalizeKeystroke;
  function normalizeKeys(options) {
    let keys2;
    if (Platform.IS_WIN) {
      keys2 = options.winKeys || options.keys;
    } else if (Platform.IS_MAC) {
      keys2 = options.macKeys || options.keys;
    } else {
      keys2 = options.linuxKeys || options.keys;
    }
    return keys2.map(normalizeKeystroke);
  }
  CommandRegistry2.normalizeKeys = normalizeKeys;
  function formatKeystroke(keystroke) {
    return typeof keystroke === "string" ? formatSingleKey(keystroke) : keystroke.map(formatSingleKey).join(", ");
    function formatSingleKey(key2) {
      let mods = [];
      let separator = Platform.IS_MAC ? " " : "+";
      let parts = parseKeystroke(key2);
      if (parts.ctrl) {
        mods.push("Ctrl");
      }
      if (parts.alt) {
        mods.push("Alt");
      }
      if (parts.shift) {
        mods.push("Shift");
      }
      if (Platform.IS_MAC && parts.cmd) {
        mods.push("Cmd");
      }
      mods.push(parts.key);
      return mods.map(Private$t.formatKey).join(separator);
    }
  }
  CommandRegistry2.formatKeystroke = formatKeystroke;
  function isModifierKeyPressed(event2) {
    let layout = getKeyboardLayout();
    let key2 = layout.keyForKeydownEvent(event2);
    return layout.isModifierKey(key2);
  }
  CommandRegistry2.isModifierKeyPressed = isModifierKeyPressed;
  function keystrokeForKeydownEvent(event2) {
    let layout = getKeyboardLayout();
    let key2 = layout.keyForKeydownEvent(event2);
    let mods = [];
    if (event2.ctrlKey) {
      mods.push("Ctrl");
    }
    if (event2.altKey) {
      mods.push("Alt");
    }
    if (event2.shiftKey) {
      mods.push("Shift");
    }
    if (event2.metaKey && Platform.IS_MAC) {
      mods.push("Cmd");
    }
    if (!layout.isModifierKey(key2)) {
      mods.push(key2);
    }
    return mods.join(" ");
  }
  CommandRegistry2.keystrokeForKeydownEvent = keystrokeForKeydownEvent;
})(CommandRegistry || (CommandRegistry = {}));
var Private$t;
(function(Private2) {
  Private2.CHORD_TIMEOUT = 1e3;
  Private2.KEYBINDING_HOLD_TIMEOUT = 1e3;
  Private2.modifierkeyTimeOut = 500;
  function createCommand(options) {
    return {
      execute: options.execute,
      describedBy: asFunc(typeof options.describedBy === "function" ? options.describedBy : { args: null, ...options.describedBy }, () => {
        return { args: null };
      }),
      label: asFunc(options.label, emptyStringFunc),
      mnemonic: asFunc(options.mnemonic, negativeOneFunc),
      icon: asFunc(options.icon, undefinedFunc),
      iconClass: asFunc(options.iconClass, emptyStringFunc),
      iconLabel: asFunc(options.iconLabel, emptyStringFunc),
      caption: asFunc(options.caption, emptyStringFunc),
      usage: asFunc(options.usage, emptyStringFunc),
      className: asFunc(options.className, emptyStringFunc),
      dataset: asFunc(options.dataset, emptyDatasetFunc),
      isEnabled: options.isEnabled || trueFunc,
      isToggled: options.isToggled || falseFunc,
      isToggleable: options.isToggleable || !!options.isToggled,
      isVisible: options.isVisible || trueFunc
    };
  }
  Private2.createCommand = createCommand;
  function createKeyBinding(options) {
    var _a;
    return {
      keys: CommandRegistry.normalizeKeys(options),
      selector: validateSelector(options),
      command: options.command,
      args: options.args || JSONExt.emptyObject,
      preventDefault: (_a = options.preventDefault) !== null && _a !== void 0 ? _a : true
    };
  }
  Private2.createKeyBinding = createKeyBinding;
  function matchKeyBinding(bindings, keys2, event2) {
    let exact = null;
    let partial = [];
    let distance = Infinity;
    let specificity = 0;
    for (let i2 = 0, n = bindings.length; i2 < n; ++i2) {
      let binding = bindings[i2];
      let sqm = matchSequence(binding.keys, keys2);
      if (sqm === 0) {
        continue;
      }
      if (sqm === 2) {
        if (targetDistance(binding.selector, event2) !== -1) {
          partial.push(binding);
        }
        continue;
      }
      let td = targetDistance(binding.selector, event2);
      if (td === -1 || td > distance) {
        continue;
      }
      let sp = Selector$1.calculateSpecificity(binding.selector);
      if (!exact || td < distance || sp >= specificity) {
        exact = binding;
        distance = td;
        specificity = sp;
      }
    }
    return { exact, partial };
  }
  Private2.matchKeyBinding = matchKeyBinding;
  function replayKeyEvent(event2) {
    event2.target.dispatchEvent(cloneKeyboardEvent(event2));
  }
  Private2.replayKeyEvent = replayKeyEvent;
  function formatKey(key2) {
    if (Platform.IS_MAC) {
      return MAC_DISPLAY.hasOwnProperty(key2) ? MAC_DISPLAY[key2] : key2;
    } else {
      return WIN_DISPLAY.hasOwnProperty(key2) ? WIN_DISPLAY[key2] : key2;
    }
  }
  Private2.formatKey = formatKey;
  const MAC_DISPLAY = {
    Backspace: "",
    Tab: "",
    Enter: "",
    Shift: "",
    Ctrl: "",
    Alt: "",
    Escape: "",
    PageUp: "",
    PageDown: "",
    End: "",
    Home: "",
    ArrowLeft: "",
    ArrowUp: "",
    ArrowRight: "",
    ArrowDown: "",
    Delete: "",
    Cmd: ""
  };
  const WIN_DISPLAY = {
    Escape: "Esc",
    PageUp: "Page Up",
    PageDown: "Page Down",
    ArrowLeft: "Left",
    ArrowUp: "Up",
    ArrowRight: "Right",
    ArrowDown: "Down",
    Delete: "Del"
  };
  const emptyStringFunc = () => "";
  const negativeOneFunc = () => -1;
  const trueFunc = () => true;
  const falseFunc = () => false;
  const emptyDatasetFunc = () => ({});
  const undefinedFunc = () => void 0;
  function asFunc(value, dfault) {
    if (value === void 0) {
      return dfault;
    }
    if (typeof value === "function") {
      return value;
    }
    return () => value;
  }
  function validateSelector(options) {
    if (options.selector.indexOf(",") !== -1) {
      throw new Error(`Selector cannot contain commas: ${options.selector}`);
    }
    if (!Selector$1.isValid(options.selector)) {
      throw new Error(`Invalid selector: ${options.selector}`);
    }
    return options.selector;
  }
  function matchSequence(bindKeys, userKeys) {
    if (bindKeys.length < userKeys.length) {
      return 0;
    }
    for (let i2 = 0, n = userKeys.length; i2 < n; ++i2) {
      if (bindKeys[i2] !== userKeys[i2]) {
        return 0;
      }
    }
    if (bindKeys.length > userKeys.length) {
      return 2;
    }
    return 1;
  }
  function targetDistance(selector, event2) {
    let targ = event2.target;
    let curr = event2.currentTarget;
    for (let dist2 = 0; targ !== null; targ = targ.parentElement, ++dist2) {
      if (targ.hasAttribute("data-lm-suppress-shortcuts")) {
        return -1;
      }
      if (Selector$1.matches(targ, selector)) {
        return dist2;
      }
      if (targ === curr) {
        return -1;
      }
    }
    return -1;
  }
  function cloneKeyboardEvent(event2) {
    let clone = document.createEvent("Event");
    let bubbles = event2.bubbles || true;
    let cancelable = event2.cancelable || true;
    clone.initEvent(event2.type || "keydown", bubbles, cancelable);
    clone.key = event2.key || "";
    clone.keyCode = event2.keyCode || 0;
    clone.which = event2.keyCode || 0;
    clone.ctrlKey = event2.ctrlKey || false;
    clone.altKey = event2.altKey || false;
    clone.shiftKey = event2.shiftKey || false;
    clone.metaKey = event2.metaKey || false;
    clone.view = event2.view || window;
    return clone;
  }
})(Private$t || (Private$t = {}));
class VirtualText {
  /**
   * Construct a new virtual text node.
   *
   * @param content - The text content for the node.
   */
  constructor(content) {
    this.type = "text";
    this.content = content;
  }
}
class VirtualElement {
  /**
   * Construct a new virtual element node.
   *
   * @param tag - The element tag name.
   *
   * @param attrs - The element attributes.
   *
   * @param children - The element children.
   *
   * @param renderer - An optional custom renderer for the element.
   */
  constructor(tag, attrs, children2, renderer) {
    this.type = "element";
    this.tag = tag;
    this.attrs = attrs;
    this.children = children2;
    this.renderer = renderer;
  }
}
function h(tag) {
  let attrs = {};
  let renderer;
  let children2 = [];
  for (let i2 = 1, n = arguments.length; i2 < n; ++i2) {
    let arg = arguments[i2];
    if (typeof arg === "string") {
      children2.push(new VirtualText(arg));
    } else if (arg instanceof VirtualText) {
      children2.push(arg);
    } else if (arg instanceof VirtualElement) {
      children2.push(arg);
    } else if (arg instanceof Array) {
      extend2(children2, arg);
    } else if ((i2 === 1 || i2 === 2) && arg && typeof arg === "object") {
      if ("render" in arg) {
        renderer = arg;
      } else {
        attrs = arg;
      }
    }
  }
  return new VirtualElement(tag, attrs, children2, renderer);
  function extend2(array, values) {
    for (let child of values) {
      if (typeof child === "string") {
        array.push(new VirtualText(child));
      } else if (child instanceof VirtualText) {
        array.push(child);
      } else if (child instanceof VirtualElement) {
        array.push(child);
      }
    }
  }
}
(function(h2) {
  h2.a = h2.bind(void 0, "a");
  h2.abbr = h2.bind(void 0, "abbr");
  h2.address = h2.bind(void 0, "address");
  h2.area = h2.bind(void 0, "area");
  h2.article = h2.bind(void 0, "article");
  h2.aside = h2.bind(void 0, "aside");
  h2.audio = h2.bind(void 0, "audio");
  h2.b = h2.bind(void 0, "b");
  h2.bdi = h2.bind(void 0, "bdi");
  h2.bdo = h2.bind(void 0, "bdo");
  h2.blockquote = h2.bind(void 0, "blockquote");
  h2.br = h2.bind(void 0, "br");
  h2.button = h2.bind(void 0, "button");
  h2.canvas = h2.bind(void 0, "canvas");
  h2.caption = h2.bind(void 0, "caption");
  h2.cite = h2.bind(void 0, "cite");
  h2.code = h2.bind(void 0, "code");
  h2.col = h2.bind(void 0, "col");
  h2.colgroup = h2.bind(void 0, "colgroup");
  h2.data = h2.bind(void 0, "data");
  h2.datalist = h2.bind(void 0, "datalist");
  h2.dd = h2.bind(void 0, "dd");
  h2.del = h2.bind(void 0, "del");
  h2.dfn = h2.bind(void 0, "dfn");
  h2.div = h2.bind(void 0, "div");
  h2.dl = h2.bind(void 0, "dl");
  h2.dt = h2.bind(void 0, "dt");
  h2.em = h2.bind(void 0, "em");
  h2.embed = h2.bind(void 0, "embed");
  h2.fieldset = h2.bind(void 0, "fieldset");
  h2.figcaption = h2.bind(void 0, "figcaption");
  h2.figure = h2.bind(void 0, "figure");
  h2.footer = h2.bind(void 0, "footer");
  h2.form = h2.bind(void 0, "form");
  h2.h1 = h2.bind(void 0, "h1");
  h2.h2 = h2.bind(void 0, "h2");
  h2.h3 = h2.bind(void 0, "h3");
  h2.h4 = h2.bind(void 0, "h4");
  h2.h5 = h2.bind(void 0, "h5");
  h2.h6 = h2.bind(void 0, "h6");
  h2.header = h2.bind(void 0, "header");
  h2.hr = h2.bind(void 0, "hr");
  h2.i = h2.bind(void 0, "i");
  h2.iframe = h2.bind(void 0, "iframe");
  h2.img = h2.bind(void 0, "img");
  h2.input = h2.bind(void 0, "input");
  h2.ins = h2.bind(void 0, "ins");
  h2.kbd = h2.bind(void 0, "kbd");
  h2.label = h2.bind(void 0, "label");
  h2.legend = h2.bind(void 0, "legend");
  h2.li = h2.bind(void 0, "li");
  h2.main = h2.bind(void 0, "main");
  h2.map = h2.bind(void 0, "map");
  h2.mark = h2.bind(void 0, "mark");
  h2.meter = h2.bind(void 0, "meter");
  h2.nav = h2.bind(void 0, "nav");
  h2.noscript = h2.bind(void 0, "noscript");
  h2.object = h2.bind(void 0, "object");
  h2.ol = h2.bind(void 0, "ol");
  h2.optgroup = h2.bind(void 0, "optgroup");
  h2.option = h2.bind(void 0, "option");
  h2.output = h2.bind(void 0, "output");
  h2.p = h2.bind(void 0, "p");
  h2.param = h2.bind(void 0, "param");
  h2.pre = h2.bind(void 0, "pre");
  h2.progress = h2.bind(void 0, "progress");
  h2.q = h2.bind(void 0, "q");
  h2.rp = h2.bind(void 0, "rp");
  h2.rt = h2.bind(void 0, "rt");
  h2.ruby = h2.bind(void 0, "ruby");
  h2.s = h2.bind(void 0, "s");
  h2.samp = h2.bind(void 0, "samp");
  h2.section = h2.bind(void 0, "section");
  h2.select = h2.bind(void 0, "select");
  h2.small = h2.bind(void 0, "small");
  h2.source = h2.bind(void 0, "source");
  h2.span = h2.bind(void 0, "span");
  h2.strong = h2.bind(void 0, "strong");
  h2.sub = h2.bind(void 0, "sub");
  h2.summary = h2.bind(void 0, "summary");
  h2.sup = h2.bind(void 0, "sup");
  h2.table = h2.bind(void 0, "table");
  h2.tbody = h2.bind(void 0, "tbody");
  h2.td = h2.bind(void 0, "td");
  h2.textarea = h2.bind(void 0, "textarea");
  h2.tfoot = h2.bind(void 0, "tfoot");
  h2.th = h2.bind(void 0, "th");
  h2.thead = h2.bind(void 0, "thead");
  h2.time = h2.bind(void 0, "time");
  h2.title = h2.bind(void 0, "title");
  h2.tr = h2.bind(void 0, "tr");
  h2.track = h2.bind(void 0, "track");
  h2.u = h2.bind(void 0, "u");
  h2.ul = h2.bind(void 0, "ul");
  h2.var_ = h2.bind(void 0, "var");
  h2.video = h2.bind(void 0, "video");
  h2.wbr = h2.bind(void 0, "wbr");
})(h || (h = {}));
var VirtualDOM;
(function(VirtualDOM2) {
  function realize(node2) {
    return Private$s.createDOMNode(node2);
  }
  VirtualDOM2.realize = realize;
  function render2(content, host) {
    let oldContent = Private$s.hostMap.get(host) || [];
    let newContent = Private$s.asContentArray(content);
    Private$s.hostMap.set(host, newContent);
    Private$s.updateContent(host, oldContent, newContent);
  }
  VirtualDOM2.render = render2;
})(VirtualDOM || (VirtualDOM = {}));
var Private$s;
(function(Private2) {
  Private2.hostMap = /* @__PURE__ */ new WeakMap();
  function asContentArray(value) {
    if (!value) {
      return [];
    }
    if (value instanceof Array) {
      return value;
    }
    return [value];
  }
  Private2.asContentArray = asContentArray;
  function createDOMNode(node2) {
    let host = arguments[1] || null;
    const before = arguments[2] || null;
    if (host) {
      host.insertBefore(createDOMNode(node2), before);
    } else {
      if (node2.type === "text") {
        return document.createTextNode(node2.content);
      }
      host = document.createElement(node2.tag);
      addAttrs(host, node2.attrs);
      if (node2.renderer) {
        node2.renderer.render(host, {
          attrs: node2.attrs,
          children: node2.children
        });
        return host;
      }
      for (let i2 = 0, n = node2.children.length; i2 < n; ++i2) {
        createDOMNode(node2.children[i2], host);
      }
    }
    return host;
  }
  Private2.createDOMNode = createDOMNode;
  function updateContent(host, oldContent, newContent) {
    if (oldContent === newContent) {
      return;
    }
    let oldKeyed = collectKeys(host, oldContent);
    let oldCopy = oldContent.slice();
    let currElem = host.firstChild;
    let newCount = newContent.length;
    for (let i2 = 0; i2 < newCount; ++i2) {
      if (i2 >= oldCopy.length) {
        createDOMNode(newContent[i2], host);
        continue;
      }
      let oldVNode = oldCopy[i2];
      let newVNode = newContent[i2];
      if (oldVNode === newVNode) {
        currElem = currElem.nextSibling;
        continue;
      }
      if (oldVNode.type === "text" && newVNode.type === "text") {
        if (currElem.textContent !== newVNode.content) {
          currElem.textContent = newVNode.content;
        }
        currElem = currElem.nextSibling;
        continue;
      }
      if (oldVNode.type === "text" || newVNode.type === "text") {
        ArrayExt.insert(oldCopy, i2, newVNode);
        createDOMNode(newVNode, host, currElem);
        continue;
      }
      if (!oldVNode.renderer != !newVNode.renderer) {
        ArrayExt.insert(oldCopy, i2, newVNode);
        createDOMNode(newVNode, host, currElem);
        continue;
      }
      let newKey = newVNode.attrs.key;
      if (newKey && newKey in oldKeyed) {
        let pair = oldKeyed[newKey];
        if (pair.vNode !== oldVNode) {
          ArrayExt.move(oldCopy, oldCopy.indexOf(pair.vNode, i2 + 1), i2);
          host.insertBefore(pair.element, currElem);
          oldVNode = pair.vNode;
          currElem = pair.element;
        }
      }
      if (oldVNode === newVNode) {
        currElem = currElem.nextSibling;
        continue;
      }
      let oldKey = oldVNode.attrs.key;
      if (oldKey && oldKey !== newKey) {
        ArrayExt.insert(oldCopy, i2, newVNode);
        createDOMNode(newVNode, host, currElem);
        continue;
      }
      if (oldVNode.tag !== newVNode.tag) {
        ArrayExt.insert(oldCopy, i2, newVNode);
        createDOMNode(newVNode, host, currElem);
        continue;
      }
      updateAttrs2(currElem, oldVNode.attrs, newVNode.attrs);
      if (newVNode.renderer) {
        newVNode.renderer.render(currElem, {
          attrs: newVNode.attrs,
          children: newVNode.children
        });
      } else {
        updateContent(currElem, oldVNode.children, newVNode.children);
      }
      currElem = currElem.nextSibling;
    }
    removeContent(host, oldCopy, newCount, true);
  }
  Private2.updateContent = updateContent;
  function removeContent(host, oldContent, newCount, _sentinel) {
    for (let i2 = oldContent.length - 1; i2 >= newCount; --i2) {
      const oldNode = oldContent[i2];
      const child = _sentinel ? host.lastChild : host.childNodes[i2];
      if (oldNode.type === "text") ;
      else if (oldNode.renderer && oldNode.renderer.unrender) {
        oldNode.renderer.unrender(child, {
          attrs: oldNode.attrs,
          children: oldNode.children
        });
      } else {
        removeContent(child, oldNode.children, 0, false);
      }
      if (_sentinel) {
        host.removeChild(child);
      }
    }
  }
  const specialAttrs = {
    key: true,
    className: true,
    htmlFor: true,
    dataset: true,
    style: true
  };
  function addAttrs(element, attrs) {
    for (let name2 in attrs) {
      if (name2 in specialAttrs) {
        continue;
      }
      if (name2.substr(0, 2) === "on") {
        element[name2] = attrs[name2];
      } else {
        element.setAttribute(name2, attrs[name2]);
      }
    }
    if (attrs.className !== void 0) {
      element.setAttribute("class", attrs.className);
    }
    if (attrs.htmlFor !== void 0) {
      element.setAttribute("for", attrs.htmlFor);
    }
    if (attrs.dataset) {
      addDataset(element, attrs.dataset);
    }
    if (attrs.style) {
      addStyle(element, attrs.style);
    }
  }
  function updateAttrs2(element, oldAttrs, newAttrs) {
    if (oldAttrs === newAttrs) {
      return;
    }
    let name2;
    for (name2 in oldAttrs) {
      if (name2 in specialAttrs || name2 in newAttrs) {
        continue;
      }
      if (name2.substr(0, 2) === "on") {
        element[name2] = null;
      } else {
        element.removeAttribute(name2);
      }
    }
    for (name2 in newAttrs) {
      if (name2 in specialAttrs || oldAttrs[name2] === newAttrs[name2]) {
        continue;
      }
      if (name2.substr(0, 2) === "on") {
        element[name2] = newAttrs[name2];
      } else {
        element.setAttribute(name2, newAttrs[name2]);
      }
    }
    if (oldAttrs.className !== newAttrs.className) {
      if (newAttrs.className !== void 0) {
        element.setAttribute("class", newAttrs.className);
      } else {
        element.removeAttribute("class");
      }
    }
    if (oldAttrs.htmlFor !== newAttrs.htmlFor) {
      if (newAttrs.htmlFor !== void 0) {
        element.setAttribute("for", newAttrs.htmlFor);
      } else {
        element.removeAttribute("for");
      }
    }
    if (oldAttrs.dataset !== newAttrs.dataset) {
      updateDataset(element, oldAttrs.dataset || {}, newAttrs.dataset || {});
    }
    if (oldAttrs.style !== newAttrs.style) {
      updateStyle(element, oldAttrs.style || {}, newAttrs.style || {});
    }
  }
  function addDataset(element, dataset) {
    for (let name2 in dataset) {
      element.setAttribute(`data-${name2}`, dataset[name2]);
    }
  }
  function updateDataset(element, oldDataset, newDataset) {
    for (let name2 in oldDataset) {
      if (!(name2 in newDataset)) {
        element.removeAttribute(`data-${name2}`);
      }
    }
    for (let name2 in newDataset) {
      if (oldDataset[name2] !== newDataset[name2]) {
        element.setAttribute(`data-${name2}`, newDataset[name2]);
      }
    }
  }
  function addStyle(element, style2) {
    let elemStyle = element.style;
    let name2;
    for (name2 in style2) {
      elemStyle[name2] = style2[name2];
    }
  }
  function updateStyle(element, oldStyle, newStyle) {
    let elemStyle = element.style;
    let name2;
    for (name2 in oldStyle) {
      if (!(name2 in newStyle)) {
        elemStyle[name2] = "";
      }
    }
    for (name2 in newStyle) {
      if (oldStyle[name2] !== newStyle[name2]) {
        elemStyle[name2] = newStyle[name2];
      }
    }
  }
  function collectKeys(host, content) {
    let node2 = host.firstChild;
    let keyMap = /* @__PURE__ */ Object.create(null);
    for (let vNode of content) {
      if (vNode.type === "element" && vNode.attrs.key) {
        keyMap[vNode.attrs.key] = { vNode, element: node2 };
      }
      node2 = node2.nextSibling;
    }
    return keyMap;
  }
})(Private$s || (Private$s = {}));
class BoxSizer {
  constructor() {
    this.sizeHint = 0;
    this.minSize = 0;
    this.maxSize = Infinity;
    this.stretch = 1;
    this.size = 0;
    this.done = false;
  }
}
var BoxEngine;
(function(BoxEngine2) {
  function calc(sizers, space) {
    let count = sizers.length;
    if (count === 0) {
      return space;
    }
    let totalMin = 0;
    let totalMax = 0;
    let totalSize = 0;
    let totalStretch = 0;
    let stretchCount = 0;
    for (let i2 = 0; i2 < count; ++i2) {
      let sizer = sizers[i2];
      let min2 = sizer.minSize;
      let max2 = sizer.maxSize;
      let hint = sizer.sizeHint;
      sizer.done = false;
      sizer.size = Math.max(min2, Math.min(hint, max2));
      totalSize += sizer.size;
      totalMin += min2;
      totalMax += max2;
      if (sizer.stretch > 0) {
        totalStretch += sizer.stretch;
        stretchCount++;
      }
    }
    if (space === totalSize) {
      return 0;
    }
    if (space <= totalMin) {
      for (let i2 = 0; i2 < count; ++i2) {
        let sizer = sizers[i2];
        sizer.size = sizer.minSize;
      }
      return space - totalMin;
    }
    if (space >= totalMax) {
      for (let i2 = 0; i2 < count; ++i2) {
        let sizer = sizers[i2];
        sizer.size = sizer.maxSize;
      }
      return space - totalMax;
    }
    let nearZero = 0.01;
    let notDoneCount = count;
    if (space < totalSize) {
      let freeSpace = totalSize - space;
      while (stretchCount > 0 && freeSpace > nearZero) {
        let distSpace = freeSpace;
        let distStretch = totalStretch;
        for (let i2 = 0; i2 < count; ++i2) {
          let sizer = sizers[i2];
          if (sizer.done || sizer.stretch === 0) {
            continue;
          }
          let amt = sizer.stretch * distSpace / distStretch;
          if (sizer.size - amt <= sizer.minSize) {
            freeSpace -= sizer.size - sizer.minSize;
            totalStretch -= sizer.stretch;
            sizer.size = sizer.minSize;
            sizer.done = true;
            notDoneCount--;
            stretchCount--;
          } else {
            freeSpace -= amt;
            sizer.size -= amt;
          }
        }
      }
      while (notDoneCount > 0 && freeSpace > nearZero) {
        let amt = freeSpace / notDoneCount;
        for (let i2 = 0; i2 < count; ++i2) {
          let sizer = sizers[i2];
          if (sizer.done) {
            continue;
          }
          if (sizer.size - amt <= sizer.minSize) {
            freeSpace -= sizer.size - sizer.minSize;
            sizer.size = sizer.minSize;
            sizer.done = true;
            notDoneCount--;
          } else {
            freeSpace -= amt;
            sizer.size -= amt;
          }
        }
      }
    } else {
      let freeSpace = space - totalSize;
      while (stretchCount > 0 && freeSpace > nearZero) {
        let distSpace = freeSpace;
        let distStretch = totalStretch;
        for (let i2 = 0; i2 < count; ++i2) {
          let sizer = sizers[i2];
          if (sizer.done || sizer.stretch === 0) {
            continue;
          }
          let amt = sizer.stretch * distSpace / distStretch;
          if (sizer.size + amt >= sizer.maxSize) {
            freeSpace -= sizer.maxSize - sizer.size;
            totalStretch -= sizer.stretch;
            sizer.size = sizer.maxSize;
            sizer.done = true;
            notDoneCount--;
            stretchCount--;
          } else {
            freeSpace -= amt;
            sizer.size += amt;
          }
        }
      }
      while (notDoneCount > 0 && freeSpace > nearZero) {
        let amt = freeSpace / notDoneCount;
        for (let i2 = 0; i2 < count; ++i2) {
          let sizer = sizers[i2];
          if (sizer.done) {
            continue;
          }
          if (sizer.size + amt >= sizer.maxSize) {
            freeSpace -= sizer.maxSize - sizer.size;
            sizer.size = sizer.maxSize;
            sizer.done = true;
            notDoneCount--;
          } else {
            freeSpace -= amt;
            sizer.size += amt;
          }
        }
      }
    }
    return 0;
  }
  BoxEngine2.calc = calc;
  function adjust(sizers, index, delta) {
    if (sizers.length === 0 || delta === 0) {
      return;
    }
    if (delta > 0) {
      growSizer(sizers, index, delta);
    } else {
      shrinkSizer(sizers, index, -delta);
    }
  }
  BoxEngine2.adjust = adjust;
  function growSizer(sizers, index, delta) {
    let growLimit = 0;
    for (let i2 = 0; i2 <= index; ++i2) {
      let sizer = sizers[i2];
      growLimit += sizer.maxSize - sizer.size;
    }
    let shrinkLimit = 0;
    for (let i2 = index + 1, n = sizers.length; i2 < n; ++i2) {
      let sizer = sizers[i2];
      shrinkLimit += sizer.size - sizer.minSize;
    }
    delta = Math.min(delta, growLimit, shrinkLimit);
    let grow = delta;
    for (let i2 = index; i2 >= 0 && grow > 0; --i2) {
      let sizer = sizers[i2];
      let limit2 = sizer.maxSize - sizer.size;
      if (limit2 >= grow) {
        sizer.sizeHint = sizer.size + grow;
        grow = 0;
      } else {
        sizer.sizeHint = sizer.size + limit2;
        grow -= limit2;
      }
    }
    let shrink = delta;
    for (let i2 = index + 1, n = sizers.length; i2 < n && shrink > 0; ++i2) {
      let sizer = sizers[i2];
      let limit2 = sizer.size - sizer.minSize;
      if (limit2 >= shrink) {
        sizer.sizeHint = sizer.size - shrink;
        shrink = 0;
      } else {
        sizer.sizeHint = sizer.size - limit2;
        shrink -= limit2;
      }
    }
  }
  function shrinkSizer(sizers, index, delta) {
    let growLimit = 0;
    for (let i2 = index + 1, n = sizers.length; i2 < n; ++i2) {
      let sizer = sizers[i2];
      growLimit += sizer.maxSize - sizer.size;
    }
    let shrinkLimit = 0;
    for (let i2 = 0; i2 <= index; ++i2) {
      let sizer = sizers[i2];
      shrinkLimit += sizer.size - sizer.minSize;
    }
    delta = Math.min(delta, growLimit, shrinkLimit);
    let grow = delta;
    for (let i2 = index + 1, n = sizers.length; i2 < n && grow > 0; ++i2) {
      let sizer = sizers[i2];
      let limit2 = sizer.maxSize - sizer.size;
      if (limit2 >= grow) {
        sizer.sizeHint = sizer.size + grow;
        grow = 0;
      } else {
        sizer.sizeHint = sizer.size + limit2;
        grow -= limit2;
      }
    }
    let shrink = delta;
    for (let i2 = index; i2 >= 0 && shrink > 0; --i2) {
      let sizer = sizers[i2];
      let limit2 = sizer.size - sizer.minSize;
      if (limit2 >= shrink) {
        sizer.sizeHint = sizer.size - shrink;
        shrink = 0;
      } else {
        sizer.sizeHint = sizer.size - limit2;
        shrink -= limit2;
      }
    }
  }
})(BoxEngine || (BoxEngine = {}));
class Title {
  /**
   * Construct a new title.
   *
   * @param options - The options for initializing the title.
   */
  constructor(options) {
    this._label = "";
    this._caption = "";
    this._mnemonic = -1;
    this._icon = void 0;
    this._iconClass = "";
    this._iconLabel = "";
    this._className = "";
    this._closable = false;
    this._changed = new Signal(this);
    this._isDisposed = false;
    this.owner = options.owner;
    if (options.label !== void 0) {
      this._label = options.label;
    }
    if (options.mnemonic !== void 0) {
      this._mnemonic = options.mnemonic;
    }
    if (options.icon !== void 0) {
      this._icon = options.icon;
    }
    if (options.iconClass !== void 0) {
      this._iconClass = options.iconClass;
    }
    if (options.iconLabel !== void 0) {
      this._iconLabel = options.iconLabel;
    }
    if (options.caption !== void 0) {
      this._caption = options.caption;
    }
    if (options.className !== void 0) {
      this._className = options.className;
    }
    if (options.closable !== void 0) {
      this._closable = options.closable;
    }
    this._dataset = options.dataset || {};
  }
  /**
   * A signal emitted when the state of the title changes.
   */
  get changed() {
    return this._changed;
  }
  /**
   * Get the label for the title.
   *
   * #### Notes
   * The default value is an empty string.
   */
  get label() {
    return this._label;
  }
  /**
   * Set the label for the title.
   */
  set label(value) {
    if (this._label === value) {
      return;
    }
    this._label = value;
    this._changed.emit(void 0);
  }
  /**
   * Get the mnemonic index for the title.
   *
   * #### Notes
   * The default value is `-1`.
   */
  get mnemonic() {
    return this._mnemonic;
  }
  /**
   * Set the mnemonic index for the title.
   */
  set mnemonic(value) {
    if (this._mnemonic === value) {
      return;
    }
    this._mnemonic = value;
    this._changed.emit(void 0);
  }
  /**
   * Get the icon renderer for the title.
   *
   * #### Notes
   * The default value is undefined.
   */
  get icon() {
    return this._icon;
  }
  /**
   * Set the icon renderer for the title.
   *
   * #### Notes
   * A renderer is an object that supplies a render and unrender function.
   */
  set icon(value) {
    if (this._icon === value) {
      return;
    }
    this._icon = value;
    this._changed.emit(void 0);
  }
  /**
   * Get the icon class name for the title.
   *
   * #### Notes
   * The default value is an empty string.
   */
  get iconClass() {
    return this._iconClass;
  }
  /**
   * Set the icon class name for the title.
   *
   * #### Notes
   * Multiple class names can be separated with whitespace.
   */
  set iconClass(value) {
    if (this._iconClass === value) {
      return;
    }
    this._iconClass = value;
    this._changed.emit(void 0);
  }
  /**
   * Get the icon label for the title.
   *
   * #### Notes
   * The default value is an empty string.
   */
  get iconLabel() {
    return this._iconLabel;
  }
  /**
   * Set the icon label for the title.
   *
   * #### Notes
   * Multiple class names can be separated with whitespace.
   */
  set iconLabel(value) {
    if (this._iconLabel === value) {
      return;
    }
    this._iconLabel = value;
    this._changed.emit(void 0);
  }
  /**
   * Get the caption for the title.
   *
   * #### Notes
   * The default value is an empty string.
   */
  get caption() {
    return this._caption;
  }
  /**
   * Set the caption for the title.
   */
  set caption(value) {
    if (this._caption === value) {
      return;
    }
    this._caption = value;
    this._changed.emit(void 0);
  }
  /**
   * Get the extra class name for the title.
   *
   * #### Notes
   * The default value is an empty string.
   */
  get className() {
    return this._className;
  }
  /**
   * Set the extra class name for the title.
   *
   * #### Notes
   * Multiple class names can be separated with whitespace.
   */
  set className(value) {
    if (this._className === value) {
      return;
    }
    this._className = value;
    this._changed.emit(void 0);
  }
  /**
   * Get the closable state for the title.
   *
   * #### Notes
   * The default value is `false`.
   */
  get closable() {
    return this._closable;
  }
  /**
   * Set the closable state for the title.
   *
   * #### Notes
   * This controls the presence of a close icon when applicable.
   */
  set closable(value) {
    if (this._closable === value) {
      return;
    }
    this._closable = value;
    this._changed.emit(void 0);
  }
  /**
   * Get the dataset for the title.
   *
   * #### Notes
   * The default value is an empty dataset.
   */
  get dataset() {
    return this._dataset;
  }
  /**
   * Set the dataset for the title.
   *
   * #### Notes
   * This controls the data attributes when applicable.
   */
  set dataset(value) {
    if (this._dataset === value) {
      return;
    }
    this._dataset = value;
    this._changed.emit(void 0);
  }
  /**
   * Test whether the title has been disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of the resources held by the title.
   *
   * #### Notes
   * It is the responsibility of the owner to call the title disposal.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._isDisposed = true;
    Signal.clearData(this);
  }
}
class Widget {
  /**
   * Construct a new widget.
   *
   * @param options - The options for initializing the widget.
   */
  constructor(options = {}) {
    this._flags = 0;
    this._layout = null;
    this._parent = null;
    this._disposed = new Signal(this);
    this._hiddenMode = Widget.HiddenMode.Display;
    this.node = Private$j$1.createNode(options);
    this.addClass("lm-Widget");
  }
  /**
   * Dispose of the widget and its descendant widgets.
   *
   * #### Notes
   * It is unsafe to use the widget after it has been disposed.
   *
   * All calls made to this method after the first are a no-op.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.setFlag(Widget.Flag.IsDisposed);
    this._disposed.emit(void 0);
    if (this.parent) {
      this.parent = null;
    } else if (this.isAttached) {
      Widget.detach(this);
    }
    if (this._layout) {
      this._layout.dispose();
      this._layout = null;
    }
    this.title.dispose();
    Signal.clearData(this);
    MessageLoop.clearData(this);
    AttachedProperty.clearData(this);
  }
  /**
   * A signal emitted when the widget is disposed.
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * Test whether the widget has been disposed.
   */
  get isDisposed() {
    return this.testFlag(Widget.Flag.IsDisposed);
  }
  /**
   * Test whether the widget's node is attached to the DOM.
   */
  get isAttached() {
    return this.testFlag(Widget.Flag.IsAttached);
  }
  /**
   * Test whether the widget is explicitly hidden.
   */
  get isHidden() {
    return this.testFlag(Widget.Flag.IsHidden);
  }
  /**
   * Test whether the widget is visible.
   *
   * #### Notes
   * A widget is visible when it is attached to the DOM, is not
   * explicitly hidden, and has no explicitly hidden ancestors.
   */
  get isVisible() {
    return this.testFlag(Widget.Flag.IsVisible);
  }
  /**
   * The title object for the widget.
   *
   * #### Notes
   * The title object is used by some container widgets when displaying
   * the widget alongside some title, such as a tab panel or side bar.
   *
   * Since not all widgets will use the title, it is created on demand.
   *
   * The `owner` property of the title is set to this widget.
   */
  get title() {
    return Private$j$1.titleProperty.get(this);
  }
  /**
   * Get the id of the widget's DOM node.
   */
  get id() {
    return this.node.id;
  }
  /**
   * Set the id of the widget's DOM node.
   */
  set id(value) {
    this.node.id = value;
  }
  /**
   * The dataset for the widget's DOM node.
   */
  get dataset() {
    return this.node.dataset;
  }
  /**
   * Get the method for hiding the widget.
   */
  get hiddenMode() {
    return this._hiddenMode;
  }
  /**
   * Set the method for hiding the widget.
   */
  set hiddenMode(value) {
    if (this._hiddenMode === value) {
      return;
    }
    if (this.isHidden) {
      this._toggleHidden(false);
    }
    if (value == Widget.HiddenMode.Scale) {
      this.node.style.willChange = "transform";
    } else {
      this.node.style.willChange = "auto";
    }
    this._hiddenMode = value;
    if (this.isHidden) {
      this._toggleHidden(true);
    }
  }
  /**
   * Get the parent of the widget.
   */
  get parent() {
    return this._parent;
  }
  /**
   * Set the parent of the widget.
   *
   * #### Notes
   * Children are typically added to a widget by using a layout, which
   * means user code will not normally set the parent widget directly.
   *
   * The widget will be automatically removed from its old parent.
   *
   * This is a no-op if there is no effective parent change.
   */
  set parent(value) {
    if (this._parent === value) {
      return;
    }
    if (value && this.contains(value)) {
      throw new Error("Invalid parent widget.");
    }
    if (this._parent && !this._parent.isDisposed) {
      let msg = new Widget.ChildMessage("child-removed", this);
      MessageLoop.sendMessage(this._parent, msg);
    }
    this._parent = value;
    if (this._parent && !this._parent.isDisposed) {
      let msg = new Widget.ChildMessage("child-added", this);
      MessageLoop.sendMessage(this._parent, msg);
    }
    if (!this.isDisposed) {
      MessageLoop.sendMessage(this, Widget.Msg.ParentChanged);
    }
  }
  /**
   * Get the layout for the widget.
   */
  get layout() {
    return this._layout;
  }
  /**
   * Set the layout for the widget.
   *
   * #### Notes
   * The layout is single-use only. It cannot be changed after the
   * first assignment.
   *
   * The layout is disposed automatically when the widget is disposed.
   */
  set layout(value) {
    if (this._layout === value) {
      return;
    }
    if (this.testFlag(Widget.Flag.DisallowLayout)) {
      throw new Error("Cannot set widget layout.");
    }
    if (this._layout) {
      throw new Error("Cannot change widget layout.");
    }
    if (value.parent) {
      throw new Error("Cannot change layout parent.");
    }
    this._layout = value;
    value.parent = this;
  }
  /**
   * Create an iterator over the widget's children.
   *
   * @returns A new iterator over the children of the widget.
   *
   * #### Notes
   * The widget must have a populated layout in order to have children.
   *
   * If a layout is not installed, the returned iterator will be empty.
   */
  *children() {
    if (this._layout) {
      yield* this._layout;
    }
  }
  /**
   * Test whether a widget is a descendant of this widget.
   *
   * @param widget - The descendant widget of interest.
   *
   * @returns `true` if the widget is a descendant, `false` otherwise.
   */
  contains(widget) {
    for (let value = widget; value; value = value._parent) {
      if (value === this) {
        return true;
      }
    }
    return false;
  }
  /**
   * Test whether the widget's DOM node has the given class name.
   *
   * @param name - The class name of interest.
   *
   * @returns `true` if the node has the class, `false` otherwise.
   */
  hasClass(name2) {
    return this.node.classList.contains(name2);
  }
  /**
   * Add a class name to the widget's DOM node.
   *
   * @param name - The class name to add to the node.
   *
   * #### Notes
   * If the class name is already added to the node, this is a no-op.
   *
   * The class name must not contain whitespace.
   */
  addClass(name2) {
    this.node.classList.add(name2);
  }
  /**
   * Remove a class name from the widget's DOM node.
   *
   * @param name - The class name to remove from the node.
   *
   * #### Notes
   * If the class name is not yet added to the node, this is a no-op.
   *
   * The class name must not contain whitespace.
   */
  removeClass(name2) {
    this.node.classList.remove(name2);
  }
  /**
   * Toggle a class name on the widget's DOM node.
   *
   * @param name - The class name to toggle on the node.
   *
   * @param force - Whether to force add the class (`true`) or force
   *   remove the class (`false`). If not provided, the presence of
   *   the class will be toggled from its current state.
   *
   * @returns `true` if the class is now present, `false` otherwise.
   *
   * #### Notes
   * The class name must not contain whitespace.
   */
  toggleClass(name2, force) {
    if (force === true) {
      this.node.classList.add(name2);
      return true;
    }
    if (force === false) {
      this.node.classList.remove(name2);
      return false;
    }
    return this.node.classList.toggle(name2);
  }
  /**
   * Post an `'update-request'` message to the widget.
   *
   * #### Notes
   * This is a simple convenience method for posting the message.
   */
  update() {
    MessageLoop.postMessage(this, Widget.Msg.UpdateRequest);
  }
  /**
   * Post a `'fit-request'` message to the widget.
   *
   * #### Notes
   * This is a simple convenience method for posting the message.
   */
  fit() {
    MessageLoop.postMessage(this, Widget.Msg.FitRequest);
  }
  /**
   * Post an `'activate-request'` message to the widget.
   *
   * #### Notes
   * This is a simple convenience method for posting the message.
   */
  activate() {
    MessageLoop.postMessage(this, Widget.Msg.ActivateRequest);
  }
  /**
   * Send a `'close-request'` message to the widget.
   *
   * #### Notes
   * This is a simple convenience method for sending the message.
   */
  close() {
    MessageLoop.sendMessage(this, Widget.Msg.CloseRequest);
  }
  /**
   * Show the widget and make it visible to its parent widget.
   *
   * #### Notes
   * This causes the {@link isHidden} property to be `false`.
   *
   * If the widget is not explicitly hidden, this is a no-op.
   */
  show() {
    if (!this.testFlag(Widget.Flag.IsHidden)) {
      return;
    }
    if (this.isAttached && (!this.parent || this.parent.isVisible)) {
      MessageLoop.sendMessage(this, Widget.Msg.BeforeShow);
    }
    this.clearFlag(Widget.Flag.IsHidden);
    this._toggleHidden(false);
    if (this.isAttached && (!this.parent || this.parent.isVisible)) {
      MessageLoop.sendMessage(this, Widget.Msg.AfterShow);
    }
    if (this.parent) {
      let msg = new Widget.ChildMessage("child-shown", this);
      MessageLoop.sendMessage(this.parent, msg);
    }
  }
  /**
   * Hide the widget and make it hidden to its parent widget.
   *
   * #### Notes
   * This causes the {@link isHidden} property to be `true`.
   *
   * If the widget is explicitly hidden, this is a no-op.
   */
  hide() {
    if (this.testFlag(Widget.Flag.IsHidden)) {
      return;
    }
    if (this.isAttached && (!this.parent || this.parent.isVisible)) {
      MessageLoop.sendMessage(this, Widget.Msg.BeforeHide);
    }
    this.setFlag(Widget.Flag.IsHidden);
    this._toggleHidden(true);
    if (this.isAttached && (!this.parent || this.parent.isVisible)) {
      MessageLoop.sendMessage(this, Widget.Msg.AfterHide);
    }
    if (this.parent) {
      let msg = new Widget.ChildMessage("child-hidden", this);
      MessageLoop.sendMessage(this.parent, msg);
    }
  }
  /**
   * Show or hide the widget according to a boolean value.
   *
   * @param hidden - `true` to hide the widget, or `false` to show it.
   *
   * #### Notes
   * This is a convenience method for `hide()` and `show()`.
   */
  setHidden(hidden2) {
    if (hidden2) {
      this.hide();
    } else {
      this.show();
    }
  }
  /**
   * Test whether the given widget flag is set.
   *
   * #### Notes
   * This will not typically be called directly by user code.
   */
  testFlag(flag) {
    return (this._flags & flag) !== 0;
  }
  /**
   * Set the given widget flag.
   *
   * #### Notes
   * This will not typically be called directly by user code.
   */
  setFlag(flag) {
    this._flags |= flag;
  }
  /**
   * Clear the given widget flag.
   *
   * #### Notes
   * This will not typically be called directly by user code.
   */
  clearFlag(flag) {
    this._flags &= ~flag;
  }
  /**
   * Process a message sent to the widget.
   *
   * @param msg - The message sent to the widget.
   *
   * #### Notes
   * Subclasses may reimplement this method as needed.
   */
  processMessage(msg) {
    switch (msg.type) {
      case "resize":
        this.notifyLayout(msg);
        this.onResize(msg);
        break;
      case "update-request":
        this.notifyLayout(msg);
        this.onUpdateRequest(msg);
        break;
      case "fit-request":
        this.notifyLayout(msg);
        this.onFitRequest(msg);
        break;
      case "before-show":
        this.notifyLayout(msg);
        this.onBeforeShow(msg);
        break;
      case "after-show":
        this.setFlag(Widget.Flag.IsVisible);
        this.notifyLayout(msg);
        this.onAfterShow(msg);
        break;
      case "before-hide":
        this.notifyLayout(msg);
        this.onBeforeHide(msg);
        break;
      case "after-hide":
        this.clearFlag(Widget.Flag.IsVisible);
        this.notifyLayout(msg);
        this.onAfterHide(msg);
        break;
      case "before-attach":
        this.notifyLayout(msg);
        this.onBeforeAttach(msg);
        break;
      case "after-attach":
        if (!this.isHidden && (!this.parent || this.parent.isVisible)) {
          this.setFlag(Widget.Flag.IsVisible);
        }
        this.setFlag(Widget.Flag.IsAttached);
        this.notifyLayout(msg);
        this.onAfterAttach(msg);
        break;
      case "before-detach":
        this.notifyLayout(msg);
        this.onBeforeDetach(msg);
        break;
      case "after-detach":
        this.clearFlag(Widget.Flag.IsVisible);
        this.clearFlag(Widget.Flag.IsAttached);
        this.notifyLayout(msg);
        this.onAfterDetach(msg);
        break;
      case "activate-request":
        this.notifyLayout(msg);
        this.onActivateRequest(msg);
        break;
      case "close-request":
        this.notifyLayout(msg);
        this.onCloseRequest(msg);
        break;
      case "child-added":
        this.notifyLayout(msg);
        this.onChildAdded(msg);
        break;
      case "child-removed":
        this.notifyLayout(msg);
        this.onChildRemoved(msg);
        break;
      default:
        this.notifyLayout(msg);
        break;
    }
  }
  /**
   * Invoke the message processing routine of the widget's layout.
   *
   * @param msg - The message to dispatch to the layout.
   *
   * #### Notes
   * This is a no-op if the widget does not have a layout.
   *
   * This will not typically be called directly by user code.
   */
  notifyLayout(msg) {
    if (this._layout) {
      this._layout.processParentMessage(msg);
    }
  }
  /**
   * A message handler invoked on a `'close-request'` message.
   *
   * #### Notes
   * The default implementation unparents or detaches the widget.
   */
  onCloseRequest(msg) {
    if (this.parent) {
      this.parent = null;
    } else if (this.isAttached) {
      Widget.detach(this);
    }
  }
  /**
   * A message handler invoked on a `'resize'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onResize(msg) {
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onUpdateRequest(msg) {
  }
  /**
   * A message handler invoked on a `'fit-request'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onFitRequest(msg) {
  }
  /**
   * A message handler invoked on an `'activate-request'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onActivateRequest(msg) {
  }
  /**
   * A message handler invoked on a `'before-show'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onBeforeShow(msg) {
  }
  /**
   * A message handler invoked on an `'after-show'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onAfterShow(msg) {
  }
  /**
   * A message handler invoked on a `'before-hide'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onBeforeHide(msg) {
  }
  /**
   * A message handler invoked on an `'after-hide'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onAfterHide(msg) {
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onBeforeAttach(msg) {
  }
  /**
   * A message handler invoked on an `'after-attach'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onAfterAttach(msg) {
  }
  /**
   * A message handler invoked on a `'before-detach'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onBeforeDetach(msg) {
  }
  /**
   * A message handler invoked on an `'after-detach'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onAfterDetach(msg) {
  }
  /**
   * A message handler invoked on a `'child-added'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onChildAdded(msg) {
  }
  /**
   * A message handler invoked on a `'child-removed'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onChildRemoved(msg) {
  }
  _toggleHidden(hidden2) {
    if (hidden2) {
      switch (this._hiddenMode) {
        case Widget.HiddenMode.Display:
          this.addClass("lm-mod-hidden");
          break;
        case Widget.HiddenMode.Scale:
          this.node.style.transform = "scale(0)";
          this.node.setAttribute("aria-hidden", "true");
          break;
        case Widget.HiddenMode.ContentVisibility:
          this.node.style.contentVisibility = "hidden";
          this.node.style.zIndex = "-1";
          break;
      }
    } else {
      switch (this._hiddenMode) {
        case Widget.HiddenMode.Display:
          this.removeClass("lm-mod-hidden");
          break;
        case Widget.HiddenMode.Scale:
          this.node.style.transform = "";
          this.node.removeAttribute("aria-hidden");
          break;
        case Widget.HiddenMode.ContentVisibility:
          this.node.style.contentVisibility = "";
          this.node.style.zIndex = "";
          break;
      }
    }
  }
}
(function(Widget2) {
  (function(HiddenMode) {
    HiddenMode[HiddenMode["Display"] = 0] = "Display";
    HiddenMode[HiddenMode["Scale"] = 1] = "Scale";
    HiddenMode[HiddenMode["ContentVisibility"] = 2] = "ContentVisibility";
  })(Widget2.HiddenMode || (Widget2.HiddenMode = {}));
  (function(Flag) {
    Flag[Flag["IsDisposed"] = 1] = "IsDisposed";
    Flag[Flag["IsAttached"] = 2] = "IsAttached";
    Flag[Flag["IsHidden"] = 4] = "IsHidden";
    Flag[Flag["IsVisible"] = 8] = "IsVisible";
    Flag[Flag["DisallowLayout"] = 16] = "DisallowLayout";
  })(Widget2.Flag || (Widget2.Flag = {}));
  (function(Msg) {
    Msg.BeforeShow = new Message("before-show");
    Msg.AfterShow = new Message("after-show");
    Msg.BeforeHide = new Message("before-hide");
    Msg.AfterHide = new Message("after-hide");
    Msg.BeforeAttach = new Message("before-attach");
    Msg.AfterAttach = new Message("after-attach");
    Msg.BeforeDetach = new Message("before-detach");
    Msg.AfterDetach = new Message("after-detach");
    Msg.ParentChanged = new Message("parent-changed");
    Msg.UpdateRequest = new ConflatableMessage("update-request");
    Msg.FitRequest = new ConflatableMessage("fit-request");
    Msg.ActivateRequest = new ConflatableMessage("activate-request");
    Msg.CloseRequest = new ConflatableMessage("close-request");
  })(Widget2.Msg || (Widget2.Msg = {}));
  class ChildMessage extends Message {
    /**
     * Construct a new child message.
     *
     * @param type - The message type.
     *
     * @param child - The child widget for the message.
     */
    constructor(type, child) {
      super(type);
      this.child = child;
    }
  }
  Widget2.ChildMessage = ChildMessage;
  class ResizeMessage extends Message {
    /**
     * Construct a new resize message.
     *
     * @param width - The **offset width** of the widget, or `-1` if
     *   the width is not known.
     *
     * @param height - The **offset height** of the widget, or `-1` if
     *   the height is not known.
     */
    constructor(width, height) {
      super("resize");
      this.width = width;
      this.height = height;
    }
  }
  Widget2.ResizeMessage = ResizeMessage;
  (function(ResizeMessage2) {
    ResizeMessage2.UnknownSize = new ResizeMessage2(-1, -1);
  })(ResizeMessage = Widget2.ResizeMessage || (Widget2.ResizeMessage = {}));
  function attach(widget, host, ref2 = null) {
    if (widget.parent) {
      throw new Error("Cannot attach a child widget.");
    }
    if (widget.isAttached || widget.node.isConnected) {
      throw new Error("Widget is already attached.");
    }
    if (!host.isConnected) {
      throw new Error("Host is not attached.");
    }
    MessageLoop.sendMessage(widget, Widget2.Msg.BeforeAttach);
    host.insertBefore(widget.node, ref2);
    MessageLoop.sendMessage(widget, Widget2.Msg.AfterAttach);
  }
  Widget2.attach = attach;
  function detach(widget) {
    if (widget.parent) {
      throw new Error("Cannot detach a child widget.");
    }
    if (!widget.isAttached || !widget.node.isConnected) {
      throw new Error("Widget is not attached.");
    }
    MessageLoop.sendMessage(widget, Widget2.Msg.BeforeDetach);
    widget.node.parentNode.removeChild(widget.node);
    MessageLoop.sendMessage(widget, Widget2.Msg.AfterDetach);
  }
  Widget2.detach = detach;
})(Widget || (Widget = {}));
var Private$j$1;
(function(Private2) {
  Private2.titleProperty = new AttachedProperty({
    name: "title",
    create: (owner) => new Title({ owner })
  });
  function createNode(options) {
    return options.node || document.createElement(options.tag || "div");
  }
  Private2.createNode = createNode;
})(Private$j$1 || (Private$j$1 = {}));
class Layout {
  /**
   * Construct a new layout.
   *
   * @param options - The options for initializing the layout.
   */
  constructor(options = {}) {
    this._disposed = false;
    this._parent = null;
    this._fitPolicy = options.fitPolicy || "set-min-size";
  }
  /**
   * Dispose of the resources held by the layout.
   *
   * #### Notes
   * This should be reimplemented to clear and dispose of the widgets.
   *
   * All reimplementations should call the superclass method.
   *
   * This method is called automatically when the parent is disposed.
   */
  dispose() {
    this._parent = null;
    this._disposed = true;
    Signal.clearData(this);
    AttachedProperty.clearData(this);
  }
  /**
   * Test whether the layout is disposed.
   */
  get isDisposed() {
    return this._disposed;
  }
  /**
   * Get the parent widget of the layout.
   */
  get parent() {
    return this._parent;
  }
  /**
   * Set the parent widget of the layout.
   *
   * #### Notes
   * This is set automatically when installing the layout on the parent
   * widget. The parent widget should not be set directly by user code.
   */
  set parent(value) {
    if (this._parent === value) {
      return;
    }
    if (this._parent) {
      throw new Error("Cannot change parent widget.");
    }
    if (value.layout !== this) {
      throw new Error("Invalid parent widget.");
    }
    this._parent = value;
    this.init();
  }
  /**
   * Get the fit policy for the layout.
   *
   * #### Notes
   * The fit policy controls the computed size constraints which are
   * applied to the parent widget by the layout.
   *
   * Some layout implementations may ignore the fit policy.
   */
  get fitPolicy() {
    return this._fitPolicy;
  }
  /**
   * Set the fit policy for the layout.
   *
   * #### Notes
   * The fit policy controls the computed size constraints which are
   * applied to the parent widget by the layout.
   *
   * Some layout implementations may ignore the fit policy.
   *
   * Changing the fit policy will clear the current size constraint
   * for the parent widget and then re-fit the parent.
   */
  set fitPolicy(value) {
    if (this._fitPolicy === value) {
      return;
    }
    this._fitPolicy = value;
    if (this._parent) {
      let style2 = this._parent.node.style;
      style2.minWidth = "";
      style2.minHeight = "";
      style2.maxWidth = "";
      style2.maxHeight = "";
      this._parent.fit();
    }
  }
  /**
   * Process a message sent to the parent widget.
   *
   * @param msg - The message sent to the parent widget.
   *
   * #### Notes
   * This method is called by the parent widget to process a message.
   *
   * Subclasses may reimplement this method as needed.
   */
  processParentMessage(msg) {
    switch (msg.type) {
      case "resize":
        this.onResize(msg);
        break;
      case "update-request":
        this.onUpdateRequest(msg);
        break;
      case "fit-request":
        this.onFitRequest(msg);
        break;
      case "before-show":
        this.onBeforeShow(msg);
        break;
      case "after-show":
        this.onAfterShow(msg);
        break;
      case "before-hide":
        this.onBeforeHide(msg);
        break;
      case "after-hide":
        this.onAfterHide(msg);
        break;
      case "before-attach":
        this.onBeforeAttach(msg);
        break;
      case "after-attach":
        this.onAfterAttach(msg);
        break;
      case "before-detach":
        this.onBeforeDetach(msg);
        break;
      case "after-detach":
        this.onAfterDetach(msg);
        break;
      case "child-removed":
        this.onChildRemoved(msg);
        break;
      case "child-shown":
        this.onChildShown(msg);
        break;
      case "child-hidden":
        this.onChildHidden(msg);
        break;
    }
  }
  /**
   * Perform layout initialization which requires the parent widget.
   *
   * #### Notes
   * This method is invoked immediately after the layout is installed
   * on the parent widget.
   *
   * The default implementation reparents all of the widgets to the
   * layout parent widget.
   *
   * Subclasses should reimplement this method and attach the child
   * widget nodes to the parent widget's node.
   */
  init() {
    for (const widget of this) {
      widget.parent = this.parent;
    }
  }
  /**
   * A message handler invoked on a `'resize'` message.
   *
   * #### Notes
   * The layout should ensure that its widgets are resized according
   * to the specified layout space, and that they are sent a `'resize'`
   * message if appropriate.
   *
   * The default implementation of this method sends an `UnknownSize`
   * resize message to all widgets.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onResize(msg) {
    for (const widget of this) {
      MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);
    }
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   *
   * #### Notes
   * The layout should ensure that its widgets are resized according
   * to the available layout space, and that they are sent a `'resize'`
   * message if appropriate.
   *
   * The default implementation of this method sends an `UnknownSize`
   * resize message to all widgets.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onUpdateRequest(msg) {
    for (const widget of this) {
      MessageLoop.sendMessage(widget, Widget.ResizeMessage.UnknownSize);
    }
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   *
   * #### Notes
   * The default implementation of this method forwards the message
   * to all widgets. It assumes all widget nodes are attached to the
   * parent widget node.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onBeforeAttach(msg) {
    for (const widget of this) {
      MessageLoop.sendMessage(widget, msg);
    }
  }
  /**
   * A message handler invoked on an `'after-attach'` message.
   *
   * #### Notes
   * The default implementation of this method forwards the message
   * to all widgets. It assumes all widget nodes are attached to the
   * parent widget node.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onAfterAttach(msg) {
    for (const widget of this) {
      MessageLoop.sendMessage(widget, msg);
    }
  }
  /**
   * A message handler invoked on a `'before-detach'` message.
   *
   * #### Notes
   * The default implementation of this method forwards the message
   * to all widgets. It assumes all widget nodes are attached to the
   * parent widget node.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onBeforeDetach(msg) {
    for (const widget of this) {
      MessageLoop.sendMessage(widget, msg);
    }
  }
  /**
   * A message handler invoked on an `'after-detach'` message.
   *
   * #### Notes
   * The default implementation of this method forwards the message
   * to all widgets. It assumes all widget nodes are attached to the
   * parent widget node.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onAfterDetach(msg) {
    for (const widget of this) {
      MessageLoop.sendMessage(widget, msg);
    }
  }
  /**
   * A message handler invoked on a `'before-show'` message.
   *
   * #### Notes
   * The default implementation of this method forwards the message to
   * all non-hidden widgets. It assumes all widget nodes are attached
   * to the parent widget node.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onBeforeShow(msg) {
    for (const widget of this) {
      if (!widget.isHidden) {
        MessageLoop.sendMessage(widget, msg);
      }
    }
  }
  /**
   * A message handler invoked on an `'after-show'` message.
   *
   * #### Notes
   * The default implementation of this method forwards the message to
   * all non-hidden widgets. It assumes all widget nodes are attached
   * to the parent widget node.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onAfterShow(msg) {
    for (const widget of this) {
      if (!widget.isHidden) {
        MessageLoop.sendMessage(widget, msg);
      }
    }
  }
  /**
   * A message handler invoked on a `'before-hide'` message.
   *
   * #### Notes
   * The default implementation of this method forwards the message to
   * all non-hidden widgets. It assumes all widget nodes are attached
   * to the parent widget node.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onBeforeHide(msg) {
    for (const widget of this) {
      if (!widget.isHidden) {
        MessageLoop.sendMessage(widget, msg);
      }
    }
  }
  /**
   * A message handler invoked on an `'after-hide'` message.
   *
   * #### Notes
   * The default implementation of this method forwards the message to
   * all non-hidden widgets. It assumes all widget nodes are attached
   * to the parent widget node.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onAfterHide(msg) {
    for (const widget of this) {
      if (!widget.isHidden) {
        MessageLoop.sendMessage(widget, msg);
      }
    }
  }
  /**
   * A message handler invoked on a `'child-removed'` message.
   *
   * #### Notes
   * This will remove the child widget from the layout.
   *
   * Subclasses should **not** typically reimplement this method.
   */
  onChildRemoved(msg) {
    this.removeWidget(msg.child);
  }
  /**
   * A message handler invoked on a `'fit-request'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onFitRequest(msg) {
  }
  /**
   * A message handler invoked on a `'child-shown'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onChildShown(msg) {
  }
  /**
   * A message handler invoked on a `'child-hidden'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onChildHidden(msg) {
  }
}
(function(Layout2) {
  function getHorizontalAlignment(widget) {
    return Private$i$1.horizontalAlignmentProperty.get(widget);
  }
  Layout2.getHorizontalAlignment = getHorizontalAlignment;
  function setHorizontalAlignment(widget, value) {
    Private$i$1.horizontalAlignmentProperty.set(widget, value);
  }
  Layout2.setHorizontalAlignment = setHorizontalAlignment;
  function getVerticalAlignment(widget) {
    return Private$i$1.verticalAlignmentProperty.get(widget);
  }
  Layout2.getVerticalAlignment = getVerticalAlignment;
  function setVerticalAlignment(widget, value) {
    Private$i$1.verticalAlignmentProperty.set(widget, value);
  }
  Layout2.setVerticalAlignment = setVerticalAlignment;
})(Layout || (Layout = {}));
class LayoutItem {
  /**
   * Construct a new layout item.
   *
   * @param widget - The widget to be managed by the item.
   *
   * #### Notes
   * The widget will be set to absolute positioning.
   * The widget will use strict CSS containment.
   */
  constructor(widget) {
    this._top = NaN;
    this._left = NaN;
    this._width = NaN;
    this._height = NaN;
    this._minWidth = 0;
    this._minHeight = 0;
    this._maxWidth = Infinity;
    this._maxHeight = Infinity;
    this._disposed = false;
    this.widget = widget;
    this.widget.node.style.position = "absolute";
    this.widget.node.style.contain = "strict";
  }
  /**
   * Dispose of the the layout item.
   *
   * #### Notes
   * This will reset the positioning of the widget.
   */
  dispose() {
    if (this._disposed) {
      return;
    }
    this._disposed = true;
    let style2 = this.widget.node.style;
    style2.position = "";
    style2.top = "";
    style2.left = "";
    style2.width = "";
    style2.height = "";
    style2.contain = "";
  }
  /**
   * The computed minimum width of the widget.
   *
   * #### Notes
   * This value can be updated by calling the `fit` method.
   */
  get minWidth() {
    return this._minWidth;
  }
  /**
   * The computed minimum height of the widget.
   *
   * #### Notes
   * This value can be updated by calling the `fit` method.
   */
  get minHeight() {
    return this._minHeight;
  }
  /**
   * The computed maximum width of the widget.
   *
   * #### Notes
   * This value can be updated by calling the `fit` method.
   */
  get maxWidth() {
    return this._maxWidth;
  }
  /**
   * The computed maximum height of the widget.
   *
   * #### Notes
   * This value can be updated by calling the `fit` method.
   */
  get maxHeight() {
    return this._maxHeight;
  }
  /**
   * Whether the layout item is disposed.
   */
  get isDisposed() {
    return this._disposed;
  }
  /**
   * Whether the managed widget is hidden.
   */
  get isHidden() {
    return this.widget.isHidden;
  }
  /**
   * Whether the managed widget is visible.
   */
  get isVisible() {
    return this.widget.isVisible;
  }
  /**
   * Whether the managed widget is attached.
   */
  get isAttached() {
    return this.widget.isAttached;
  }
  /**
   * Update the computed size limits of the managed widget.
   */
  fit() {
    let limits = ElementExt.sizeLimits(this.widget.node);
    this._minWidth = limits.minWidth;
    this._minHeight = limits.minHeight;
    this._maxWidth = limits.maxWidth;
    this._maxHeight = limits.maxHeight;
  }
  /**
   * Update the position and size of the managed widget.
   *
   * @param left - The left edge position of the layout box.
   *
   * @param top - The top edge position of the layout box.
   *
   * @param width - The width of the layout box.
   *
   * @param height - The height of the layout box.
   */
  update(left, top2, width, height) {
    let clampW = Math.max(this._minWidth, Math.min(width, this._maxWidth));
    let clampH = Math.max(this._minHeight, Math.min(height, this._maxHeight));
    if (clampW < width) {
      switch (Layout.getHorizontalAlignment(this.widget)) {
        case "left":
          break;
        case "center":
          left += (width - clampW) / 2;
          break;
        case "right":
          left += width - clampW;
          break;
        default:
          throw "unreachable";
      }
    }
    if (clampH < height) {
      switch (Layout.getVerticalAlignment(this.widget)) {
        case "top":
          break;
        case "center":
          top2 += (height - clampH) / 2;
          break;
        case "bottom":
          top2 += height - clampH;
          break;
        default:
          throw "unreachable";
      }
    }
    let resized = false;
    let style2 = this.widget.node.style;
    if (this._top !== top2) {
      this._top = top2;
      style2.top = `${top2}px`;
    }
    if (this._left !== left) {
      this._left = left;
      style2.left = `${left}px`;
    }
    if (this._width !== clampW) {
      resized = true;
      this._width = clampW;
      style2.width = `${clampW}px`;
    }
    if (this._height !== clampH) {
      resized = true;
      this._height = clampH;
      style2.height = `${clampH}px`;
    }
    if (resized) {
      let msg = new Widget.ResizeMessage(clampW, clampH);
      MessageLoop.sendMessage(this.widget, msg);
    }
  }
}
var Private$i$1;
(function(Private2) {
  Private2.horizontalAlignmentProperty = new AttachedProperty({
    name: "horizontalAlignment",
    create: () => "center",
    changed: onAlignmentChanged
  });
  Private2.verticalAlignmentProperty = new AttachedProperty({
    name: "verticalAlignment",
    create: () => "top",
    changed: onAlignmentChanged
  });
  function onAlignmentChanged(child) {
    if (child.parent && child.parent.layout) {
      child.parent.update();
    }
  }
})(Private$i$1 || (Private$i$1 = {}));
class PanelLayout extends Layout {
  constructor() {
    super(...arguments);
    this._widgets = [];
  }
  /**
   * Dispose of the resources held by the layout.
   *
   * #### Notes
   * This will clear and dispose all widgets in the layout.
   *
   * All reimplementations should call the superclass method.
   *
   * This method is called automatically when the parent is disposed.
   */
  dispose() {
    while (this._widgets.length > 0) {
      this._widgets.pop().dispose();
    }
    super.dispose();
  }
  /**
   * A read-only array of the widgets in the layout.
   */
  get widgets() {
    return this._widgets;
  }
  /**
   * Create an iterator over the widgets in the layout.
   *
   * @returns A new iterator over the widgets in the layout.
   */
  *[Symbol.iterator]() {
    yield* this._widgets;
  }
  /**
   * Add a widget to the end of the layout.
   *
   * @param widget - The widget to add to the layout.
   *
   * #### Notes
   * If the widget is already contained in the layout, it will be moved.
   */
  addWidget(widget) {
    this.insertWidget(this._widgets.length, widget);
  }
  /**
   * Insert a widget into the layout at the specified index.
   *
   * @param index - The index at which to insert the widget.
   *
   * @param widget - The widget to insert into the layout.
   *
   * #### Notes
   * The index will be clamped to the bounds of the widgets.
   *
   * If the widget is already added to the layout, it will be moved.
   *
   * #### Undefined Behavior
   * An `index` which is non-integral.
   */
  insertWidget(index, widget) {
    widget.parent = this.parent;
    let i2 = this._widgets.indexOf(widget);
    let j = Math.max(0, Math.min(index, this._widgets.length));
    if (i2 === -1) {
      ArrayExt.insert(this._widgets, j, widget);
      if (this.parent) {
        this.attachWidget(j, widget);
      }
      return;
    }
    if (j === this._widgets.length) {
      j--;
    }
    if (i2 === j) {
      return;
    }
    ArrayExt.move(this._widgets, i2, j);
    if (this.parent) {
      this.moveWidget(i2, j, widget);
    }
  }
  /**
   * Remove a widget from the layout.
   *
   * @param widget - The widget to remove from the layout.
   *
   * #### Notes
   * A widget is automatically removed from the layout when its `parent`
   * is set to `null`. This method should only be invoked directly when
   * removing a widget from a layout which has yet to be installed on a
   * parent widget.
   *
   * This method does *not* modify the widget's `parent`.
   */
  removeWidget(widget) {
    this.removeWidgetAt(this._widgets.indexOf(widget));
  }
  /**
   * Remove the widget at a given index from the layout.
   *
   * @param index - The index of the widget to remove.
   *
   * #### Notes
   * A widget is automatically removed from the layout when its `parent`
   * is set to `null`. This method should only be invoked directly when
   * removing a widget from a layout which has yet to be installed on a
   * parent widget.
   *
   * This method does *not* modify the widget's `parent`.
   *
   * #### Undefined Behavior
   * An `index` which is non-integral.
   */
  removeWidgetAt(index) {
    let widget = ArrayExt.removeAt(this._widgets, index);
    if (widget && this.parent) {
      this.detachWidget(index, widget);
    }
  }
  /**
   * Perform layout initialization which requires the parent widget.
   */
  init() {
    super.init();
    let index = 0;
    for (const widget of this) {
      this.attachWidget(index++, widget);
    }
  }
  /**
   * Attach a widget to the parent's DOM node.
   *
   * @param index - The current index of the widget in the layout.
   *
   * @param widget - The widget to attach to the parent.
   *
   * #### Notes
   * This method is called automatically by the panel layout at the
   * appropriate time. It should not be called directly by user code.
   *
   * The default implementation adds the widgets's node to the parent's
   * node at the proper location, and sends the appropriate attach
   * messages to the widget if the parent is attached to the DOM.
   *
   * Subclasses may reimplement this method to control how the widget's
   * node is added to the parent's node.
   */
  attachWidget(index, widget) {
    let ref2 = this.parent.node.children[index];
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
    }
    this.parent.node.insertBefore(widget.node, ref2);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
    }
  }
  /**
   * Move a widget in the parent's DOM node.
   *
   * @param fromIndex - The previous index of the widget in the layout.
   *
   * @param toIndex - The current index of the widget in the layout.
   *
   * @param widget - The widget to move in the parent.
   *
   * #### Notes
   * This method is called automatically by the panel layout at the
   * appropriate time. It should not be called directly by user code.
   *
   * The default implementation moves the widget's node to the proper
   * location in the parent's node and sends the appropriate attach and
   * detach messages to the widget if the parent is attached to the DOM.
   *
   * Subclasses may reimplement this method to control how the widget's
   * node is moved in the parent's node.
   */
  moveWidget(fromIndex, toIndex, widget) {
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
    }
    this.parent.node.removeChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
    }
    let ref2 = this.parent.node.children[toIndex];
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
    }
    this.parent.node.insertBefore(widget.node, ref2);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
    }
  }
  /**
   * Detach a widget from the parent's DOM node.
   *
   * @param index - The previous index of the widget in the layout.
   *
   * @param widget - The widget to detach from the parent.
   *
   * #### Notes
   * This method is called automatically by the panel layout at the
   * appropriate time. It should not be called directly by user code.
   *
   * The default implementation removes the widget's node from the
   * parent's node, and sends the appropriate detach messages to the
   * widget if the parent is attached to the DOM.
   *
   * Subclasses may reimplement this method to control how the widget's
   * node is removed from the parent's node.
   */
  detachWidget(index, widget) {
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
    }
    this.parent.node.removeChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
    }
  }
}
var Utils;
(function(Utils2) {
  function clampDimension(value) {
    return Math.max(0, Math.floor(value));
  }
  Utils2.clampDimension = clampDimension;
})(Utils || (Utils = {}));
var Utils$1 = Utils;
class SplitLayout extends PanelLayout {
  /**
   * Construct a new split layout.
   *
   * @param options - The options for initializing the layout.
   */
  constructor(options) {
    super();
    this.widgetOffset = 0;
    this._fixed = 0;
    this._spacing = 4;
    this._dirty = false;
    this._hasNormedSizes = false;
    this._sizers = [];
    this._items = [];
    this._handles = [];
    this._box = null;
    this._alignment = "start";
    this._orientation = "horizontal";
    this.renderer = options.renderer;
    if (options.orientation !== void 0) {
      this._orientation = options.orientation;
    }
    if (options.alignment !== void 0) {
      this._alignment = options.alignment;
    }
    if (options.spacing !== void 0) {
      this._spacing = Utils.clampDimension(options.spacing);
    }
  }
  /**
   * Dispose of the resources held by the layout.
   */
  dispose() {
    for (const item of this._items) {
      item.dispose();
    }
    this._box = null;
    this._items.length = 0;
    this._sizers.length = 0;
    this._handles.length = 0;
    super.dispose();
  }
  /**
   * Get the layout orientation for the split layout.
   */
  get orientation() {
    return this._orientation;
  }
  /**
   * Set the layout orientation for the split layout.
   */
  set orientation(value) {
    if (this._orientation === value) {
      return;
    }
    this._orientation = value;
    if (!this.parent) {
      return;
    }
    this.parent.dataset["orientation"] = value;
    this.parent.fit();
  }
  /**
   * Get the content alignment for the split layout.
   *
   * #### Notes
   * This is the alignment of the widgets in the layout direction.
   *
   * The alignment has no effect if the widgets can expand  to fill the
   * entire split layout.
   */
  get alignment() {
    return this._alignment;
  }
  /**
   * Set the content alignment for the split layout.
   *
   * #### Notes
   * This is the alignment of the widgets in the layout direction.
   *
   * The alignment has no effect if the widgets can expand  to fill the
   * entire split layout.
   */
  set alignment(value) {
    if (this._alignment === value) {
      return;
    }
    this._alignment = value;
    if (!this.parent) {
      return;
    }
    this.parent.dataset["alignment"] = value;
    this.parent.update();
  }
  /**
   * Get the inter-element spacing for the split layout.
   */
  get spacing() {
    return this._spacing;
  }
  /**
   * Set the inter-element spacing for the split layout.
   */
  set spacing(value) {
    value = Utils.clampDimension(value);
    if (this._spacing === value) {
      return;
    }
    this._spacing = value;
    if (!this.parent) {
      return;
    }
    this.parent.fit();
  }
  /**
   * A read-only array of the split handles in the layout.
   */
  get handles() {
    return this._handles;
  }
  /**
   * Get the absolute sizes of the widgets in the layout.
   *
   * @returns A new array of the absolute sizes of the widgets.
   *
   * This method **does not** measure the DOM nodes.
   */
  absoluteSizes() {
    return this._sizers.map((sizer) => sizer.size);
  }
  /**
   * Get the relative sizes of the widgets in the layout.
   *
   * @returns A new array of the relative sizes of the widgets.
   *
   * #### Notes
   * The returned sizes reflect the sizes of the widgets normalized
   * relative to their siblings.
   *
   * This method **does not** measure the DOM nodes.
   */
  relativeSizes() {
    return Private$h$1.normalize(this._sizers.map((sizer) => sizer.size));
  }
  /**
   * Set the relative sizes for the widgets in the layout.
   *
   * @param sizes - The relative sizes for the widgets in the panel.
   * @param update - Update the layout after setting relative sizes.
   * Default is True.
   *
   * #### Notes
   * Extra values are ignored, too few will yield an undefined layout.
   *
   * The actual geometry of the DOM nodes is updated asynchronously.
   */
  setRelativeSizes(sizes, update = true) {
    let n = this._sizers.length;
    let temp = sizes.slice(0, n);
    while (temp.length < n) {
      temp.push(0);
    }
    let normed = Private$h$1.normalize(temp);
    for (let i2 = 0; i2 < n; ++i2) {
      let sizer = this._sizers[i2];
      sizer.sizeHint = normed[i2];
      sizer.size = normed[i2];
    }
    this._hasNormedSizes = true;
    if (update && this.parent) {
      this.parent.update();
    }
  }
  /**
   * Move the offset position of a split handle.
   *
   * @param index - The index of the handle of the interest.
   *
   * @param position - The desired offset position of the handle.
   *
   * #### Notes
   * The position is relative to the offset parent.
   *
   * This will move the handle as close as possible to the desired
   * position. The sibling widgets will be adjusted as necessary.
   */
  moveHandle(index, position) {
    let handle = this._handles[index];
    if (!handle || handle.classList.contains("lm-mod-hidden")) {
      return;
    }
    let delta;
    if (this._orientation === "horizontal") {
      delta = position - handle.offsetLeft;
    } else {
      delta = position - handle.offsetTop;
    }
    if (delta === 0) {
      return;
    }
    for (let sizer of this._sizers) {
      if (sizer.size > 0) {
        sizer.sizeHint = sizer.size;
      }
    }
    BoxEngine.adjust(this._sizers, index, delta);
    if (this.parent) {
      this.parent.update();
    }
  }
  /**
   * Perform layout initialization which requires the parent widget.
   */
  init() {
    this.parent.dataset["orientation"] = this.orientation;
    this.parent.dataset["alignment"] = this.alignment;
    super.init();
  }
  /**
   * Attach a widget to the parent's DOM node.
   *
   * @param index - The current index of the widget in the layout.
   *
   * @param widget - The widget to attach to the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  attachWidget(index, widget) {
    let item = new LayoutItem(widget);
    let handle = Private$h$1.createHandle(this.renderer);
    let average = Private$h$1.averageSize(this._sizers);
    let sizer = Private$h$1.createSizer(average);
    ArrayExt.insert(this._items, index, item);
    ArrayExt.insert(this._sizers, index, sizer);
    ArrayExt.insert(this._handles, index, handle);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
    }
    this.parent.node.appendChild(widget.node);
    this.parent.node.appendChild(handle);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
    }
    this.parent.fit();
  }
  /**
   * Move a widget in the parent's DOM node.
   *
   * @param fromIndex - The previous index of the widget in the layout.
   *
   * @param toIndex - The current index of the widget in the layout.
   *
   * @param widget - The widget to move in the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  moveWidget(fromIndex, toIndex, widget) {
    ArrayExt.move(this._items, fromIndex, toIndex);
    ArrayExt.move(this._sizers, fromIndex, toIndex);
    ArrayExt.move(this._handles, fromIndex, toIndex);
    this.parent.fit();
  }
  /**
   * Detach a widget from the parent's DOM node.
   *
   * @param index - The previous index of the widget in the layout.
   *
   * @param widget - The widget to detach from the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  detachWidget(index, widget) {
    let item = ArrayExt.removeAt(this._items, index);
    let handle = ArrayExt.removeAt(this._handles, index);
    ArrayExt.removeAt(this._sizers, index);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
    }
    this.parent.node.removeChild(widget.node);
    this.parent.node.removeChild(handle);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
    }
    item.dispose();
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'before-show'` message.
   */
  onBeforeShow(msg) {
    super.onBeforeShow(msg);
    this.parent.update();
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    super.onBeforeAttach(msg);
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-shown'` message.
   */
  onChildShown(msg) {
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-hidden'` message.
   */
  onChildHidden(msg) {
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'resize'` message.
   */
  onResize(msg) {
    if (this.parent.isVisible) {
      this._update(msg.width, msg.height);
    }
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   */
  onUpdateRequest(msg) {
    if (this.parent.isVisible) {
      this._update(-1, -1);
    }
  }
  /**
   * A message handler invoked on a `'fit-request'` message.
   */
  onFitRequest(msg) {
    if (this.parent.isAttached) {
      this._fit();
    }
  }
  /**
   * Update the item position.
   *
   * @param i Item index
   * @param isHorizontal Whether the layout is horizontal or not
   * @param left Left position in pixels
   * @param top Top position in pixels
   * @param height Item height
   * @param width Item width
   * @param size Item size
   */
  updateItemPosition(i2, isHorizontal, left, top2, height, width, size2) {
    const item = this._items[i2];
    if (item.isHidden) {
      return;
    }
    let handleStyle = this._handles[i2].style;
    if (isHorizontal) {
      left += this.widgetOffset;
      item.update(left, top2, size2, height);
      left += size2;
      handleStyle.top = `${top2}px`;
      handleStyle.left = `${left}px`;
      handleStyle.width = `${this._spacing}px`;
      handleStyle.height = `${height}px`;
    } else {
      top2 += this.widgetOffset;
      item.update(left, top2, width, size2);
      top2 += size2;
      handleStyle.top = `${top2}px`;
      handleStyle.left = `${left}px`;
      handleStyle.width = `${width}px`;
      handleStyle.height = `${this._spacing}px`;
    }
  }
  /**
   * Fit the layout to the total size required by the widgets.
   */
  _fit() {
    let nVisible = 0;
    let lastHandleIndex = -1;
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      if (this._items[i2].isHidden) {
        this._handles[i2].classList.add("lm-mod-hidden");
      } else {
        this._handles[i2].classList.remove("lm-mod-hidden");
        lastHandleIndex = i2;
        nVisible++;
      }
    }
    if (lastHandleIndex !== -1) {
      this._handles[lastHandleIndex].classList.add("lm-mod-hidden");
    }
    this._fixed = this._spacing * Math.max(0, nVisible - 1) + this.widgetOffset * this._items.length;
    let horz = this._orientation === "horizontal";
    let minW = horz ? this._fixed : 0;
    let minH = horz ? 0 : this._fixed;
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      let item = this._items[i2];
      let sizer = this._sizers[i2];
      if (sizer.size > 0) {
        sizer.sizeHint = sizer.size;
      }
      if (item.isHidden) {
        sizer.minSize = 0;
        sizer.maxSize = 0;
        continue;
      }
      item.fit();
      sizer.stretch = SplitLayout.getStretch(item.widget);
      if (horz) {
        sizer.minSize = item.minWidth;
        sizer.maxSize = item.maxWidth;
        minW += item.minWidth;
        minH = Math.max(minH, item.minHeight);
      } else {
        sizer.minSize = item.minHeight;
        sizer.maxSize = item.maxHeight;
        minH += item.minHeight;
        minW = Math.max(minW, item.minWidth);
      }
    }
    let box = this._box = ElementExt.boxSizing(this.parent.node);
    minW += box.horizontalSum;
    minH += box.verticalSum;
    let style2 = this.parent.node.style;
    style2.minWidth = `${minW}px`;
    style2.minHeight = `${minH}px`;
    this._dirty = true;
    if (this.parent.parent) {
      MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
    }
    if (this._dirty) {
      MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
    }
  }
  /**
   * Update the layout position and size of the widgets.
   *
   * The parent offset dimensions should be `-1` if unknown.
   */
  _update(offsetWidth, offsetHeight) {
    this._dirty = false;
    let nVisible = 0;
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      nVisible += +!this._items[i2].isHidden;
    }
    if (nVisible === 0 && this.widgetOffset === 0) {
      return;
    }
    if (offsetWidth < 0) {
      offsetWidth = this.parent.node.offsetWidth;
    }
    if (offsetHeight < 0) {
      offsetHeight = this.parent.node.offsetHeight;
    }
    if (!this._box) {
      this._box = ElementExt.boxSizing(this.parent.node);
    }
    let top2 = this._box.paddingTop;
    let left = this._box.paddingLeft;
    let width = offsetWidth - this._box.horizontalSum;
    let height = offsetHeight - this._box.verticalSum;
    let extra = 0;
    let offset = 0;
    let horz = this._orientation === "horizontal";
    if (nVisible > 0) {
      let space;
      if (horz) {
        space = Math.max(0, width - this._fixed);
      } else {
        space = Math.max(0, height - this._fixed);
      }
      if (this._hasNormedSizes) {
        for (let sizer of this._sizers) {
          sizer.sizeHint *= space;
        }
        this._hasNormedSizes = false;
      }
      let delta = BoxEngine.calc(this._sizers, space);
      if (delta > 0) {
        switch (this._alignment) {
          case "start":
            break;
          case "center":
            extra = 0;
            offset = delta / 2;
            break;
          case "end":
            extra = 0;
            offset = delta;
            break;
          case "justify":
            extra = delta / nVisible;
            offset = 0;
            break;
          default:
            throw "unreachable";
        }
      }
    }
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      const item = this._items[i2];
      const size2 = item.isHidden ? 0 : this._sizers[i2].size + extra;
      this.updateItemPosition(i2, horz, horz ? left + offset : left, horz ? top2 : top2 + offset, height, width, size2);
      const fullOffset = this.widgetOffset + (this._handles[i2].classList.contains("lm-mod-hidden") ? 0 : this._spacing);
      if (horz) {
        left += size2 + fullOffset;
      } else {
        top2 += size2 + fullOffset;
      }
    }
  }
}
(function(SplitLayout2) {
  function getStretch(widget) {
    return Private$h$1.stretchProperty.get(widget);
  }
  SplitLayout2.getStretch = getStretch;
  function setStretch(widget, value) {
    Private$h$1.stretchProperty.set(widget, value);
  }
  SplitLayout2.setStretch = setStretch;
})(SplitLayout || (SplitLayout = {}));
var Private$h$1;
(function(Private2) {
  Private2.stretchProperty = new AttachedProperty({
    name: "stretch",
    create: () => 0,
    coerce: (owner, value) => Math.max(0, Math.floor(value)),
    changed: onChildSizingChanged
  });
  function createSizer(size2) {
    let sizer = new BoxSizer();
    sizer.sizeHint = Math.floor(size2);
    return sizer;
  }
  Private2.createSizer = createSizer;
  function createHandle(renderer) {
    let handle = renderer.createHandle();
    handle.style.position = "absolute";
    handle.style.contain = "style";
    return handle;
  }
  Private2.createHandle = createHandle;
  function averageSize(sizers) {
    return sizers.reduce((v, s) => v + s.size, 0) / sizers.length || 0;
  }
  Private2.averageSize = averageSize;
  function normalize3(values) {
    let n = values.length;
    if (n === 0) {
      return [];
    }
    let sum = values.reduce((a, b) => a + Math.abs(b), 0);
    return sum === 0 ? values.map((v) => 1 / n) : values.map((v) => v / sum);
  }
  Private2.normalize = normalize3;
  function onChildSizingChanged(child) {
    if (child.parent && child.parent.layout instanceof SplitLayout) {
      child.parent.fit();
    }
  }
})(Private$h$1 || (Private$h$1 = {}));
class AccordionLayout extends SplitLayout {
  /**
   * Construct a new accordion layout.
   *
   * @param options - The options for initializing the layout.
   *
   * #### Notes
   * The default orientation will be vertical.
   *
   * Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css
   */
  constructor(options) {
    super({ ...options, orientation: options.orientation || "vertical" });
    this._titles = [];
    this.titleSpace = options.titleSpace || 22;
  }
  /**
   * The section title height or width depending on the orientation.
   */
  get titleSpace() {
    return this.widgetOffset;
  }
  set titleSpace(value) {
    value = Utils$1.clampDimension(value);
    if (this.widgetOffset === value) {
      return;
    }
    this.widgetOffset = value;
    if (!this.parent) {
      return;
    }
    this.parent.fit();
  }
  /**
   * A read-only array of the section titles in the panel.
   */
  get titles() {
    return this._titles;
  }
  /**
   * Dispose of the resources held by the layout.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._titles.length = 0;
    super.dispose();
  }
  updateTitle(index, widget) {
    const oldTitle = this._titles[index];
    const expanded = oldTitle.classList.contains("lm-mod-expanded");
    const newTitle = Private$g$1.createTitle(this.renderer, widget.title, expanded);
    this._titles[index] = newTitle;
    this.parent.node.replaceChild(newTitle, oldTitle);
  }
  /**
   * Insert a widget into the layout at the specified index.
   *
   * @param index - The index at which to insert the widget.
   *
   * @param widget - The widget to insert into the layout.
   *
   * #### Notes
   * The index will be clamped to the bounds of the widgets.
   *
   * If the widget is already added to the layout, it will be moved.
   *
   * #### Undefined Behavior
   * An `index` which is non-integral.
   */
  insertWidget(index, widget) {
    if (!widget.id) {
      widget.id = `id-${UUID.uuid4()}`;
    }
    super.insertWidget(index, widget);
  }
  /**
   * Attach a widget to the parent's DOM node.
   *
   * @param index - The current index of the widget in the layout.
   *
   * @param widget - The widget to attach to the parent.
   */
  attachWidget(index, widget) {
    const title = Private$g$1.createTitle(this.renderer, widget.title);
    ArrayExt.insert(this._titles, index, title);
    this.parent.node.appendChild(title);
    widget.node.setAttribute("role", "region");
    widget.node.setAttribute("aria-labelledby", title.id);
    super.attachWidget(index, widget);
  }
  /**
   * Move a widget in the parent's DOM node.
   *
   * @param fromIndex - The previous index of the widget in the layout.
   *
   * @param toIndex - The current index of the widget in the layout.
   *
   * @param widget - The widget to move in the parent.
   */
  moveWidget(fromIndex, toIndex, widget) {
    ArrayExt.move(this._titles, fromIndex, toIndex);
    super.moveWidget(fromIndex, toIndex, widget);
  }
  /**
   * Detach a widget from the parent's DOM node.
   *
   * @param index - The previous index of the widget in the layout.
   *
   * @param widget - The widget to detach from the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  detachWidget(index, widget) {
    const title = ArrayExt.removeAt(this._titles, index);
    this.parent.node.removeChild(title);
    super.detachWidget(index, widget);
  }
  /**
   * Update the item position.
   *
   * @param i Item index
   * @param isHorizontal Whether the layout is horizontal or not
   * @param left Left position in pixels
   * @param top Top position in pixels
   * @param height Item height
   * @param width Item width
   * @param size Item size
   */
  updateItemPosition(i2, isHorizontal, left, top2, height, width, size2) {
    const titleStyle = this._titles[i2].style;
    titleStyle.top = `${top2}px`;
    titleStyle.left = `${left}px`;
    titleStyle.height = `${this.widgetOffset}px`;
    if (isHorizontal) {
      titleStyle.width = `${height}px`;
    } else {
      titleStyle.width = `${width}px`;
    }
    super.updateItemPosition(i2, isHorizontal, left, top2, height, width, size2);
  }
}
var Private$g$1;
(function(Private2) {
  function createTitle(renderer, data, expanded = true) {
    const title = renderer.createSectionTitle(data);
    title.style.position = "absolute";
    title.style.contain = "strict";
    title.setAttribute("aria-label", `${data.label} Section`);
    title.setAttribute("aria-expanded", expanded ? "true" : "false");
    title.setAttribute("aria-controls", data.owner.id);
    if (expanded) {
      title.classList.add("lm-mod-expanded");
    }
    return title;
  }
  Private2.createTitle = createTitle;
})(Private$g$1 || (Private$g$1 = {}));
class Panel extends Widget {
  /**
   * Construct a new panel.
   *
   * @param options - The options for initializing the panel.
   */
  constructor(options = {}) {
    super();
    this.addClass("lm-Panel");
    this.layout = Private$f$1.createLayout(options);
  }
  /**
   * A read-only array of the widgets in the panel.
   */
  get widgets() {
    return this.layout.widgets;
  }
  /**
   * Add a widget to the end of the panel.
   *
   * @param widget - The widget to add to the panel.
   *
   * #### Notes
   * If the widget is already contained in the panel, it will be moved.
   */
  addWidget(widget) {
    this.layout.addWidget(widget);
  }
  /**
   * Insert a widget at the specified index.
   *
   * @param index - The index at which to insert the widget.
   *
   * @param widget - The widget to insert into to the panel.
   *
   * #### Notes
   * If the widget is already contained in the panel, it will be moved.
   */
  insertWidget(index, widget) {
    this.layout.insertWidget(index, widget);
  }
}
var Private$f$1;
(function(Private2) {
  function createLayout(options) {
    return options.layout || new PanelLayout();
  }
  Private2.createLayout = createLayout;
})(Private$f$1 || (Private$f$1 = {}));
class SplitPanel extends Panel {
  /**
   * Construct a new split panel.
   *
   * @param options - The options for initializing the split panel.
   */
  constructor(options = {}) {
    super({ layout: Private$e$1.createLayout(options) });
    this._handleMoved = new Signal(this);
    this._pressData = null;
    this.addClass("lm-SplitPanel");
  }
  /**
   * Dispose of the resources held by the panel.
   */
  dispose() {
    this._releaseMouse();
    super.dispose();
  }
  /**
   * Get the layout orientation for the split panel.
   */
  get orientation() {
    return this.layout.orientation;
  }
  /**
   * Set the layout orientation for the split panel.
   */
  set orientation(value) {
    this.layout.orientation = value;
  }
  /**
   * Get the content alignment for the split panel.
   *
   * #### Notes
   * This is the alignment of the widgets in the layout direction.
   *
   * The alignment has no effect if the widgets can expand to fill the
   * entire split panel.
   */
  get alignment() {
    return this.layout.alignment;
  }
  /**
   * Set the content alignment for the split panel.
   *
   * #### Notes
   * This is the alignment of the widgets in the layout direction.
   *
   * The alignment has no effect if the widgets can expand to fill the
   * entire split panel.
   */
  set alignment(value) {
    this.layout.alignment = value;
  }
  /**
   * Get the inter-element spacing for the split panel.
   */
  get spacing() {
    return this.layout.spacing;
  }
  /**
   * Set the inter-element spacing for the split panel.
   */
  set spacing(value) {
    this.layout.spacing = value;
  }
  /**
   * The renderer used by the split panel.
   */
  get renderer() {
    return this.layout.renderer;
  }
  /**
   * A signal emitted when a split handle has moved.
   */
  get handleMoved() {
    return this._handleMoved;
  }
  /**
   * A read-only array of the split handles in the panel.
   */
  get handles() {
    return this.layout.handles;
  }
  /**
   * Get the relative sizes of the widgets in the panel.
   *
   * @returns A new array of the relative sizes of the widgets.
   *
   * #### Notes
   * The returned sizes reflect the sizes of the widgets normalized
   * relative to their siblings.
   *
   * This method **does not** measure the DOM nodes.
   */
  relativeSizes() {
    return this.layout.relativeSizes();
  }
  /**
   * Set the relative sizes for the widgets in the panel.
   *
   * @param sizes - The relative sizes for the widgets in the panel.
   * @param update - Update the layout after setting relative sizes.
   * Default is True.
   *
   * #### Notes
   * Extra values are ignored, too few will yield an undefined layout.
   *
   * The actual geometry of the DOM nodes is updated asynchronously.
   */
  setRelativeSizes(sizes, update = true) {
    this.layout.setRelativeSizes(sizes, update);
  }
  /**
   * Handle the DOM events for the split panel.
   *
   * @param event - The DOM event sent to the panel.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the panel's DOM node. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "pointerdown":
        this._evtPointerDown(event2);
        break;
      case "pointermove":
        this._evtPointerMove(event2);
        break;
      case "pointerup":
        this._evtPointerUp(event2);
        break;
      case "keydown":
        this._evtKeyDown(event2);
        break;
      case "contextmenu":
        event2.preventDefault();
        event2.stopPropagation();
        break;
    }
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    this.node.addEventListener("pointerdown", this);
  }
  /**
   * A message handler invoked on an `'after-detach'` message.
   */
  onAfterDetach(msg) {
    this.node.removeEventListener("pointerdown", this);
    this._releaseMouse();
  }
  /**
   * A message handler invoked on a `'child-added'` message.
   */
  onChildAdded(msg) {
    msg.child.addClass("lm-SplitPanel-child");
    this._releaseMouse();
  }
  /**
   * A message handler invoked on a `'child-removed'` message.
   */
  onChildRemoved(msg) {
    msg.child.removeClass("lm-SplitPanel-child");
    this._releaseMouse();
  }
  /**
   * Handle the `'keydown'` event for the split panel.
   */
  _evtKeyDown(event2) {
    if (this._pressData) {
      event2.preventDefault();
      event2.stopPropagation();
    }
    if (event2.keyCode === 27) {
      this._releaseMouse();
    }
  }
  /**
   * Handle the `'pointerdown'` event for the split panel.
   */
  _evtPointerDown(event2) {
    if (event2.button !== 0) {
      return;
    }
    let layout = this.layout;
    let index = ArrayExt.findFirstIndex(layout.handles, (handle2) => {
      return handle2.contains(event2.target);
    });
    if (index === -1) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    document.addEventListener("pointerup", this, true);
    document.addEventListener("pointermove", this, true);
    document.addEventListener("keydown", this, true);
    document.addEventListener("contextmenu", this, true);
    let delta;
    let handle = layout.handles[index];
    let rect = handle.getBoundingClientRect();
    if (layout.orientation === "horizontal") {
      delta = event2.clientX - rect.left;
    } else {
      delta = event2.clientY - rect.top;
    }
    let style2 = window.getComputedStyle(handle);
    let override = Drag.overrideCursor(style2.cursor);
    this._pressData = { index, delta, override };
  }
  /**
   * Handle the `'pointermove'` event for the split panel.
   */
  _evtPointerMove(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    let pos;
    let layout = this.layout;
    let rect = this.node.getBoundingClientRect();
    if (layout.orientation === "horizontal") {
      pos = event2.clientX - rect.left - this._pressData.delta;
    } else {
      pos = event2.clientY - rect.top - this._pressData.delta;
    }
    layout.moveHandle(this._pressData.index, pos);
  }
  /**
   * Handle the `'pointerup'` event for the split panel.
   */
  _evtPointerUp(event2) {
    if (event2.button !== 0) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    this._releaseMouse();
  }
  /**
   * Release the mouse grab for the split panel.
   */
  _releaseMouse() {
    if (!this._pressData) {
      return;
    }
    this._pressData.override.dispose();
    this._pressData = null;
    this._handleMoved.emit();
    document.removeEventListener("keydown", this, true);
    document.removeEventListener("pointerup", this, true);
    document.removeEventListener("pointermove", this, true);
    document.removeEventListener("contextmenu", this, true);
  }
}
(function(SplitPanel2) {
  class Renderer {
    /**
     * Create a new handle for use with a split panel.
     *
     * @returns A new handle element for a split panel.
     */
    createHandle() {
      let handle = document.createElement("div");
      handle.className = "lm-SplitPanel-handle";
      return handle;
    }
  }
  SplitPanel2.Renderer = Renderer;
  SplitPanel2.defaultRenderer = new Renderer();
  function getStretch(widget) {
    return SplitLayout.getStretch(widget);
  }
  SplitPanel2.getStretch = getStretch;
  function setStretch(widget, value) {
    SplitLayout.setStretch(widget, value);
  }
  SplitPanel2.setStretch = setStretch;
})(SplitPanel || (SplitPanel = {}));
var Private$e$1;
(function(Private2) {
  function createLayout(options) {
    return options.layout || new SplitLayout({
      renderer: options.renderer || SplitPanel.defaultRenderer,
      orientation: options.orientation,
      alignment: options.alignment,
      spacing: options.spacing
    });
  }
  Private2.createLayout = createLayout;
})(Private$e$1 || (Private$e$1 = {}));
class AccordionPanel extends SplitPanel {
  /**
   * Construct a new accordion panel.
   *
   * @param options - The options for initializing the accordion panel.
   */
  constructor(options = {}) {
    super({ ...options, layout: Private$d$1.createLayout(options) });
    this._widgetSizesCache = /* @__PURE__ */ new WeakMap();
    this._expansionToggled = new Signal(this);
    this.addClass("lm-AccordionPanel");
  }
  /**
   * The renderer used by the accordion panel.
   */
  get renderer() {
    return this.layout.renderer;
  }
  /**
   * The section title space.
   *
   * This is the height if the panel is vertical and the width if it is
   * horizontal.
   */
  get titleSpace() {
    return this.layout.titleSpace;
  }
  set titleSpace(value) {
    this.layout.titleSpace = value;
  }
  /**
   * A read-only array of the section titles in the panel.
   */
  get titles() {
    return this.layout.titles;
  }
  /**
   * A signal emitted when a widget of the AccordionPanel is collapsed or expanded.
   */
  get expansionToggled() {
    return this._expansionToggled;
  }
  /**
   * Add a widget to the end of the panel.
   *
   * @param widget - The widget to add to the panel.
   *
   * #### Notes
   * If the widget is already contained in the panel, it will be moved.
   */
  addWidget(widget) {
    super.addWidget(widget);
    widget.title.changed.connect(this._onTitleChanged, this);
  }
  /**
   * Collapse the widget at position `index`.
   *
   * #### Notes
   * If no widget is found for `index`, this will bail.
   *
   * @param index Widget index
   */
  collapse(index) {
    const widget = this.layout.widgets[index];
    if (widget && !widget.isHidden) {
      this._toggleExpansion(index);
    }
  }
  /**
   * Expand the widget at position `index`.
   *
   * #### Notes
   * If no widget is found for `index`, this will bail.
   *
   * @param index Widget index
   */
  expand(index) {
    const widget = this.layout.widgets[index];
    if (widget && widget.isHidden) {
      this._toggleExpansion(index);
    }
  }
  /**
   * Insert a widget at the specified index.
   *
   * @param index - The index at which to insert the widget.
   *
   * @param widget - The widget to insert into to the panel.
   *
   * #### Notes
   * If the widget is already contained in the panel, it will be moved.
   */
  insertWidget(index, widget) {
    super.insertWidget(index, widget);
    widget.title.changed.connect(this._onTitleChanged, this);
  }
  /**
   * Handle the DOM events for the accordion panel.
   *
   * @param event - The DOM event sent to the panel.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the panel's DOM node. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    super.handleEvent(event2);
    switch (event2.type) {
      case "click":
        this._evtClick(event2);
        break;
      case "keydown":
        this._eventKeyDown(event2);
        break;
    }
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    this.node.addEventListener("click", this);
    this.node.addEventListener("keydown", this);
    super.onBeforeAttach(msg);
  }
  /**
   * A message handler invoked on an `'after-detach'` message.
   */
  onAfterDetach(msg) {
    super.onAfterDetach(msg);
    this.node.removeEventListener("click", this);
    this.node.removeEventListener("keydown", this);
  }
  /**
   * Handle the `changed` signal of a title object.
   */
  _onTitleChanged(sender) {
    const index = ArrayExt.findFirstIndex(this.widgets, (widget) => {
      return widget.contains(sender.owner);
    });
    if (index >= 0) {
      this.layout.updateTitle(index, sender.owner);
      this.update();
    }
  }
  /**
   * Compute the size of widgets in this panel on the title click event.
   * On closing, the size of the widget is cached and we will try to expand
   * the last opened widget.
   * On opening, we will use the cached size if it is available to restore the
   * widget.
   * In both cases, if we can not compute the size of widgets, we will let
   * `SplitLayout` decide.
   *
   * @param index - The index of widget to be opened of closed
   *
   * @returns Relative size of widgets in this panel, if this size can
   * not be computed, return `undefined`
   */
  _computeWidgetSize(index) {
    const layout = this.layout;
    const widget = layout.widgets[index];
    if (!widget) {
      return void 0;
    }
    const isHidden3 = widget.isHidden;
    const widgetSizes = layout.absoluteSizes();
    const delta = (isHidden3 ? -1 : 1) * this.spacing;
    const totalSize = widgetSizes.reduce((prev, curr) => prev + curr);
    let newSize = [...widgetSizes];
    if (!isHidden3) {
      const currentSize = widgetSizes[index];
      this._widgetSizesCache.set(widget, currentSize);
      newSize[index] = 0;
      const widgetToCollapse = newSize.map((sz) => sz > 0).lastIndexOf(true);
      if (widgetToCollapse === -1) {
        return void 0;
      }
      newSize[widgetToCollapse] = widgetSizes[widgetToCollapse] + currentSize + delta;
    } else {
      const previousSize = this._widgetSizesCache.get(widget);
      if (!previousSize) {
        return void 0;
      }
      newSize[index] += previousSize;
      const widgetToCollapse = newSize.map((sz) => sz - previousSize > 0).lastIndexOf(true);
      if (widgetToCollapse === -1) {
        newSize.forEach((_, idx) => {
          if (idx !== index) {
            newSize[idx] -= widgetSizes[idx] / totalSize * (previousSize - delta);
          }
        });
      } else {
        newSize[widgetToCollapse] -= previousSize - delta;
      }
    }
    return newSize.map((sz) => sz / (totalSize + delta));
  }
  /**
   * Handle the `'click'` event for the accordion panel
   */
  _evtClick(event2) {
    const target2 = event2.target;
    if (target2) {
      const index = ArrayExt.findFirstIndex(this.titles, (title) => {
        return title.contains(target2);
      });
      if (index >= 0) {
        event2.preventDefault();
        event2.stopPropagation();
        this._toggleExpansion(index);
      }
    }
  }
  /**
   * Handle the `'keydown'` event for the accordion panel.
   */
  _eventKeyDown(event2) {
    if (event2.defaultPrevented) {
      return;
    }
    const target2 = event2.target;
    let handled = false;
    if (target2) {
      const index = ArrayExt.findFirstIndex(this.titles, (title) => {
        return title.contains(target2);
      });
      if (index >= 0) {
        const keyCode = event2.keyCode.toString();
        if (event2.key.match(/Space|Enter/) || keyCode.match(/13|32/)) {
          target2.click();
          handled = true;
        } else if (this.orientation === "horizontal" ? event2.key.match(/ArrowLeft|ArrowRight/) || keyCode.match(/37|39/) : event2.key.match(/ArrowUp|ArrowDown/) || keyCode.match(/38|40/)) {
          const direction = event2.key.match(/ArrowLeft|ArrowUp/) || keyCode.match(/37|38/) ? -1 : 1;
          const length2 = this.titles.length;
          const newIndex = (index + length2 + direction) % length2;
          this.titles[newIndex].focus();
          handled = true;
        } else if (event2.key === "End" || keyCode === "35") {
          this.titles[this.titles.length - 1].focus();
          handled = true;
        } else if (event2.key === "Home" || keyCode === "36") {
          this.titles[0].focus();
          handled = true;
        }
      }
      if (handled) {
        event2.preventDefault();
      }
    }
  }
  _toggleExpansion(index) {
    const title = this.titles[index];
    const widget = this.layout.widgets[index];
    const newSize = this._computeWidgetSize(index);
    if (newSize) {
      this.setRelativeSizes(newSize, false);
    }
    if (widget.isHidden) {
      title.classList.add("lm-mod-expanded");
      title.setAttribute("aria-expanded", "true");
      widget.show();
    } else {
      title.classList.remove("lm-mod-expanded");
      title.setAttribute("aria-expanded", "false");
      widget.hide();
    }
    this._expansionToggled.emit(index);
  }
}
(function(AccordionPanel2) {
  class Renderer extends SplitPanel.Renderer {
    constructor() {
      super();
      this.titleClassName = "lm-AccordionPanel-title";
      this._titleID = 0;
      this._titleKeys = /* @__PURE__ */ new WeakMap();
      this._uuid = ++Renderer._nInstance;
    }
    /**
     * Render the collapse indicator for a section title.
     *
     * @param data - The data to use for rendering the section title.
     *
     * @returns A element representing the collapse indicator.
     */
    createCollapseIcon(data) {
      return document.createElement("span");
    }
    /**
     * Render the element for a section title.
     *
     * @param data - The data to use for rendering the section title.
     *
     * @returns A element representing the section title.
     */
    createSectionTitle(data) {
      const handle = document.createElement("h3");
      handle.setAttribute("tabindex", "0");
      handle.id = this.createTitleKey(data);
      handle.className = this.titleClassName;
      for (const aData in data.dataset) {
        handle.dataset[aData] = data.dataset[aData];
      }
      const collapser = handle.appendChild(this.createCollapseIcon(data));
      collapser.className = "lm-AccordionPanel-titleCollapser";
      const label = handle.appendChild(document.createElement("span"));
      label.className = "lm-AccordionPanel-titleLabel";
      label.textContent = data.label;
      label.title = data.caption || data.label;
      return handle;
    }
    /**
     * Create a unique render key for the title.
     *
     * @param data - The data to use for the title.
     *
     * @returns The unique render key for the title.
     *
     * #### Notes
     * This method caches the key against the section title the first time
     * the key is generated.
     */
    createTitleKey(data) {
      let key2 = this._titleKeys.get(data);
      if (key2 === void 0) {
        key2 = `title-key-${this._uuid}-${this._titleID++}`;
        this._titleKeys.set(data, key2);
      }
      return key2;
    }
  }
  Renderer._nInstance = 0;
  AccordionPanel2.Renderer = Renderer;
  AccordionPanel2.defaultRenderer = new Renderer();
})(AccordionPanel || (AccordionPanel = {}));
var Private$d$1;
(function(Private2) {
  function createLayout(options) {
    return options.layout || new AccordionLayout({
      renderer: options.renderer || AccordionPanel.defaultRenderer,
      orientation: options.orientation,
      alignment: options.alignment,
      spacing: options.spacing,
      titleSpace: options.titleSpace
    });
  }
  Private2.createLayout = createLayout;
})(Private$d$1 || (Private$d$1 = {}));
class BoxLayout extends PanelLayout {
  /**
   * Construct a new box layout.
   *
   * @param options - The options for initializing the layout.
   */
  constructor(options = {}) {
    super();
    this._fixed = 0;
    this._spacing = 4;
    this._dirty = false;
    this._sizers = [];
    this._items = [];
    this._box = null;
    this._alignment = "start";
    this._direction = "top-to-bottom";
    if (options.direction !== void 0) {
      this._direction = options.direction;
    }
    if (options.alignment !== void 0) {
      this._alignment = options.alignment;
    }
    if (options.spacing !== void 0) {
      this._spacing = Utils$1.clampDimension(options.spacing);
    }
  }
  /**
   * Dispose of the resources held by the layout.
   */
  dispose() {
    for (const item of this._items) {
      item.dispose();
    }
    this._box = null;
    this._items.length = 0;
    this._sizers.length = 0;
    super.dispose();
  }
  /**
   * Get the layout direction for the box layout.
   */
  get direction() {
    return this._direction;
  }
  /**
   * Set the layout direction for the box layout.
   */
  set direction(value) {
    if (this._direction === value) {
      return;
    }
    this._direction = value;
    if (!this.parent) {
      return;
    }
    this.parent.dataset["direction"] = value;
    this.parent.fit();
  }
  /**
   * Get the content alignment for the box layout.
   *
   * #### Notes
   * This is the alignment of the widgets in the layout direction.
   *
   * The alignment has no effect if the widgets can expand to fill the
   * entire box layout.
   */
  get alignment() {
    return this._alignment;
  }
  /**
   * Set the content alignment for the box layout.
   *
   * #### Notes
   * This is the alignment of the widgets in the layout direction.
   *
   * The alignment has no effect if the widgets can expand to fill the
   * entire box layout.
   */
  set alignment(value) {
    if (this._alignment === value) {
      return;
    }
    this._alignment = value;
    if (!this.parent) {
      return;
    }
    this.parent.dataset["alignment"] = value;
    this.parent.update();
  }
  /**
   * Get the inter-element spacing for the box layout.
   */
  get spacing() {
    return this._spacing;
  }
  /**
   * Set the inter-element spacing for the box layout.
   */
  set spacing(value) {
    value = Utils$1.clampDimension(value);
    if (this._spacing === value) {
      return;
    }
    this._spacing = value;
    if (!this.parent) {
      return;
    }
    this.parent.fit();
  }
  /**
   * Perform layout initialization which requires the parent widget.
   */
  init() {
    this.parent.dataset["direction"] = this.direction;
    this.parent.dataset["alignment"] = this.alignment;
    super.init();
  }
  /**
   * Attach a widget to the parent's DOM node.
   *
   * @param index - The current index of the widget in the layout.
   *
   * @param widget - The widget to attach to the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  attachWidget(index, widget) {
    ArrayExt.insert(this._items, index, new LayoutItem(widget));
    ArrayExt.insert(this._sizers, index, new BoxSizer());
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
    }
    this.parent.node.appendChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
    }
    this.parent.fit();
  }
  /**
   * Move a widget in the parent's DOM node.
   *
   * @param fromIndex - The previous index of the widget in the layout.
   *
   * @param toIndex - The current index of the widget in the layout.
   *
   * @param widget - The widget to move in the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  moveWidget(fromIndex, toIndex, widget) {
    ArrayExt.move(this._items, fromIndex, toIndex);
    ArrayExt.move(this._sizers, fromIndex, toIndex);
    this.parent.update();
  }
  /**
   * Detach a widget from the parent's DOM node.
   *
   * @param index - The previous index of the widget in the layout.
   *
   * @param widget - The widget to detach from the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  detachWidget(index, widget) {
    let item = ArrayExt.removeAt(this._items, index);
    ArrayExt.removeAt(this._sizers, index);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
    }
    this.parent.node.removeChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
    }
    item.dispose();
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'before-show'` message.
   */
  onBeforeShow(msg) {
    super.onBeforeShow(msg);
    this.parent.update();
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    super.onBeforeAttach(msg);
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-shown'` message.
   */
  onChildShown(msg) {
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-hidden'` message.
   */
  onChildHidden(msg) {
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'resize'` message.
   */
  onResize(msg) {
    if (this.parent.isVisible) {
      this._update(msg.width, msg.height);
    }
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   */
  onUpdateRequest(msg) {
    if (this.parent.isVisible) {
      this._update(-1, -1);
    }
  }
  /**
   * A message handler invoked on a `'fit-request'` message.
   */
  onFitRequest(msg) {
    if (this.parent.isAttached) {
      this._fit();
    }
  }
  /**
   * Fit the layout to the total size required by the widgets.
   */
  _fit() {
    let nVisible = 0;
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      nVisible += +!this._items[i2].isHidden;
    }
    this._fixed = this._spacing * Math.max(0, nVisible - 1);
    let horz = Private$c$1.isHorizontal(this._direction);
    let minW = horz ? this._fixed : 0;
    let minH = horz ? 0 : this._fixed;
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      let item = this._items[i2];
      let sizer = this._sizers[i2];
      if (item.isHidden) {
        sizer.minSize = 0;
        sizer.maxSize = 0;
        continue;
      }
      item.fit();
      sizer.sizeHint = BoxLayout.getSizeBasis(item.widget);
      sizer.stretch = BoxLayout.getStretch(item.widget);
      if (horz) {
        sizer.minSize = item.minWidth;
        sizer.maxSize = item.maxWidth;
        minW += item.minWidth;
        minH = Math.max(minH, item.minHeight);
      } else {
        sizer.minSize = item.minHeight;
        sizer.maxSize = item.maxHeight;
        minH += item.minHeight;
        minW = Math.max(minW, item.minWidth);
      }
    }
    let box = this._box = ElementExt.boxSizing(this.parent.node);
    minW += box.horizontalSum;
    minH += box.verticalSum;
    let style2 = this.parent.node.style;
    style2.minWidth = `${minW}px`;
    style2.minHeight = `${minH}px`;
    this._dirty = true;
    if (this.parent.parent) {
      MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
    }
    if (this._dirty) {
      MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
    }
  }
  /**
   * Update the layout position and size of the widgets.
   *
   * The parent offset dimensions should be `-1` if unknown.
   */
  _update(offsetWidth, offsetHeight) {
    this._dirty = false;
    let nVisible = 0;
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      nVisible += +!this._items[i2].isHidden;
    }
    if (nVisible === 0) {
      return;
    }
    if (offsetWidth < 0) {
      offsetWidth = this.parent.node.offsetWidth;
    }
    if (offsetHeight < 0) {
      offsetHeight = this.parent.node.offsetHeight;
    }
    if (!this._box) {
      this._box = ElementExt.boxSizing(this.parent.node);
    }
    let top2 = this._box.paddingTop;
    let left = this._box.paddingLeft;
    let width = offsetWidth - this._box.horizontalSum;
    let height = offsetHeight - this._box.verticalSum;
    let delta;
    switch (this._direction) {
      case "left-to-right":
        delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));
        break;
      case "top-to-bottom":
        delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));
        break;
      case "right-to-left":
        delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));
        left += width;
        break;
      case "bottom-to-top":
        delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));
        top2 += height;
        break;
      default:
        throw "unreachable";
    }
    let extra = 0;
    let offset = 0;
    if (delta > 0) {
      switch (this._alignment) {
        case "start":
          break;
        case "center":
          extra = 0;
          offset = delta / 2;
          break;
        case "end":
          extra = 0;
          offset = delta;
          break;
        case "justify":
          extra = delta / nVisible;
          offset = 0;
          break;
        default:
          throw "unreachable";
      }
    }
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      let item = this._items[i2];
      if (item.isHidden) {
        continue;
      }
      let size2 = this._sizers[i2].size;
      switch (this._direction) {
        case "left-to-right":
          item.update(left + offset, top2, size2 + extra, height);
          left += size2 + extra + this._spacing;
          break;
        case "top-to-bottom":
          item.update(left, top2 + offset, width, size2 + extra);
          top2 += size2 + extra + this._spacing;
          break;
        case "right-to-left":
          item.update(left - offset - size2 - extra, top2, size2 + extra, height);
          left -= size2 + extra + this._spacing;
          break;
        case "bottom-to-top":
          item.update(left, top2 - offset - size2 - extra, width, size2 + extra);
          top2 -= size2 + extra + this._spacing;
          break;
        default:
          throw "unreachable";
      }
    }
  }
}
(function(BoxLayout2) {
  function getStretch(widget) {
    return Private$c$1.stretchProperty.get(widget);
  }
  BoxLayout2.getStretch = getStretch;
  function setStretch(widget, value) {
    Private$c$1.stretchProperty.set(widget, value);
  }
  BoxLayout2.setStretch = setStretch;
  function getSizeBasis(widget) {
    return Private$c$1.sizeBasisProperty.get(widget);
  }
  BoxLayout2.getSizeBasis = getSizeBasis;
  function setSizeBasis(widget, value) {
    Private$c$1.sizeBasisProperty.set(widget, value);
  }
  BoxLayout2.setSizeBasis = setSizeBasis;
})(BoxLayout || (BoxLayout = {}));
var Private$c$1;
(function(Private2) {
  Private2.stretchProperty = new AttachedProperty({
    name: "stretch",
    create: () => 0,
    coerce: (owner, value) => Math.max(0, Math.floor(value)),
    changed: onChildSizingChanged
  });
  Private2.sizeBasisProperty = new AttachedProperty({
    name: "sizeBasis",
    create: () => 0,
    coerce: (owner, value) => Math.max(0, Math.floor(value)),
    changed: onChildSizingChanged
  });
  function isHorizontal(dir) {
    return dir === "left-to-right" || dir === "right-to-left";
  }
  Private2.isHorizontal = isHorizontal;
  function clampSpacing(value) {
    return Math.max(0, Math.floor(value));
  }
  Private2.clampSpacing = clampSpacing;
  function onChildSizingChanged(child) {
    if (child.parent && child.parent.layout instanceof BoxLayout) {
      child.parent.fit();
    }
  }
})(Private$c$1 || (Private$c$1 = {}));
class BoxPanel extends Panel {
  /**
   * Construct a new box panel.
   *
   * @param options - The options for initializing the box panel.
   */
  constructor(options = {}) {
    super({ layout: Private$b$1.createLayout(options) });
    this.addClass("lm-BoxPanel");
  }
  /**
   * Get the layout direction for the box panel.
   */
  get direction() {
    return this.layout.direction;
  }
  /**
   * Set the layout direction for the box panel.
   */
  set direction(value) {
    this.layout.direction = value;
  }
  /**
   * Get the content alignment for the box panel.
   *
   * #### Notes
   * This is the alignment of the widgets in the layout direction.
   *
   * The alignment has no effect if the widgets can expand to fill the
   * entire box layout.
   */
  get alignment() {
    return this.layout.alignment;
  }
  /**
   * Set the content alignment for the box panel.
   *
   * #### Notes
   * This is the alignment of the widgets in the layout direction.
   *
   * The alignment has no effect if the widgets can expand to fill the
   * entire box layout.
   */
  set alignment(value) {
    this.layout.alignment = value;
  }
  /**
   * Get the inter-element spacing for the box panel.
   */
  get spacing() {
    return this.layout.spacing;
  }
  /**
   * Set the inter-element spacing for the box panel.
   */
  set spacing(value) {
    this.layout.spacing = value;
  }
  /**
   * A message handler invoked on a `'child-added'` message.
   */
  onChildAdded(msg) {
    msg.child.addClass("lm-BoxPanel-child");
  }
  /**
   * A message handler invoked on a `'child-removed'` message.
   */
  onChildRemoved(msg) {
    msg.child.removeClass("lm-BoxPanel-child");
  }
}
(function(BoxPanel2) {
  function getStretch(widget) {
    return BoxLayout.getStretch(widget);
  }
  BoxPanel2.getStretch = getStretch;
  function setStretch(widget, value) {
    BoxLayout.setStretch(widget, value);
  }
  BoxPanel2.setStretch = setStretch;
  function getSizeBasis(widget) {
    return BoxLayout.getSizeBasis(widget);
  }
  BoxPanel2.getSizeBasis = getSizeBasis;
  function setSizeBasis(widget, value) {
    BoxLayout.setSizeBasis(widget, value);
  }
  BoxPanel2.setSizeBasis = setSizeBasis;
})(BoxPanel || (BoxPanel = {}));
var Private$b$1;
(function(Private2) {
  function createLayout(options) {
    return options.layout || new BoxLayout(options);
  }
  Private2.createLayout = createLayout;
})(Private$b$1 || (Private$b$1 = {}));
class CommandPalette extends Widget {
  /**
   * Construct a new command palette.
   *
   * @param options - The options for initializing the palette.
   */
  constructor(options) {
    super({ node: Private$a$1.createNode() });
    this._activeIndex = -1;
    this._items = [];
    this._results = null;
    this.addClass("lm-CommandPalette");
    this.setFlag(Widget.Flag.DisallowLayout);
    this.commands = options.commands;
    this.renderer = options.renderer || CommandPalette.defaultRenderer;
    this.commands.commandChanged.connect(this._onGenericChange, this);
    this.commands.keyBindingChanged.connect(this._onGenericChange, this);
  }
  /**
   * Dispose of the resources held by the widget.
   */
  dispose() {
    this._items.length = 0;
    this._results = null;
    super.dispose();
  }
  /**
   * The command palette search node.
   *
   * #### Notes
   * This is the node which contains the search-related elements.
   */
  get searchNode() {
    return this.node.getElementsByClassName("lm-CommandPalette-search")[0];
  }
  /**
   * The command palette input node.
   *
   * #### Notes
   * This is the actual input node for the search area.
   */
  get inputNode() {
    return this.node.getElementsByClassName("lm-CommandPalette-input")[0];
  }
  /**
   * The command palette content node.
   *
   * #### Notes
   * This is the node which holds the command item nodes.
   *
   * Modifying this node directly can lead to undefined behavior.
   */
  get contentNode() {
    return this.node.getElementsByClassName("lm-CommandPalette-content")[0];
  }
  /**
   * A read-only array of the command items in the palette.
   */
  get items() {
    return this._items;
  }
  /**
   * Add a command item to the command palette.
   *
   * @param options - The options for creating the command item.
   *
   * @returns The command item added to the palette.
   */
  addItem(options) {
    let item = Private$a$1.createItem(this.commands, options);
    this._items.push(item);
    this.refresh();
    return item;
  }
  /**
   * Adds command items to the command palette.
   *
   * @param items - An array of options for creating each command item.
   *
   * @returns The command items added to the palette.
   */
  addItems(items) {
    const newItems = items.map((item) => Private$a$1.createItem(this.commands, item));
    newItems.forEach((item) => this._items.push(item));
    this.refresh();
    return newItems;
  }
  /**
   * Remove an item from the command palette.
   *
   * @param item - The item to remove from the palette.
   *
   * #### Notes
   * This is a no-op if the item is not in the palette.
   */
  removeItem(item) {
    this.removeItemAt(this._items.indexOf(item));
  }
  /**
   * Remove the item at a given index from the command palette.
   *
   * @param index - The index of the item to remove.
   *
   * #### Notes
   * This is a no-op if the index is out of range.
   */
  removeItemAt(index) {
    let item = ArrayExt.removeAt(this._items, index);
    if (!item) {
      return;
    }
    this.refresh();
  }
  /**
   * Remove all items from the command palette.
   */
  clearItems() {
    if (this._items.length === 0) {
      return;
    }
    this._items.length = 0;
    this.refresh();
  }
  /**
   * Clear the search results and schedule an update.
   *
   * #### Notes
   * This should be called whenever the search results of the palette
   * should be updated.
   *
   * This is typically called automatically by the palette as needed,
   * but can be called manually if the input text is programatically
   * changed.
   *
   * The rendered results are updated asynchronously.
   */
  refresh() {
    this._results = null;
    if (this.inputNode.value !== "") {
      let clear = this.node.getElementsByClassName("lm-close-icon")[0];
      clear.style.display = "inherit";
    } else {
      let clear = this.node.getElementsByClassName("lm-close-icon")[0];
      clear.style.display = "none";
    }
    this.update();
  }
  /**
   * Handle the DOM events for the command palette.
   *
   * @param event - The DOM event sent to the command palette.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the command palette's DOM node.
   * It should not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "click":
        this._evtClick(event2);
        break;
      case "keydown":
        this._evtKeyDown(event2);
        break;
      case "input":
        this.refresh();
        break;
      case "focus":
      case "blur":
        this._toggleFocused();
        break;
    }
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    this.node.addEventListener("click", this);
    this.node.addEventListener("keydown", this);
    this.node.addEventListener("input", this);
    this.node.addEventListener("focus", this, true);
    this.node.addEventListener("blur", this, true);
  }
  /**
   * A message handler invoked on an `'after-detach'` message.
   */
  onAfterDetach(msg) {
    this.node.removeEventListener("click", this);
    this.node.removeEventListener("keydown", this);
    this.node.removeEventListener("input", this);
    this.node.removeEventListener("focus", this, true);
    this.node.removeEventListener("blur", this, true);
  }
  /**
   * A message handler invoked on an `'after-show'` message.
   */
  onAfterShow(msg) {
    this.update();
    super.onAfterShow(msg);
  }
  /**
   * A message handler invoked on an `'activate-request'` message.
   */
  onActivateRequest(msg) {
    if (this.isAttached) {
      let input2 = this.inputNode;
      input2.focus();
      input2.select();
    }
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   */
  onUpdateRequest(msg) {
    if (this.isHidden) {
      return;
    }
    let query = this.inputNode.value;
    let contentNode = this.contentNode;
    let results = this._results;
    if (!results) {
      results = this._results = Private$a$1.search(this._items, query);
      this._activeIndex = query ? ArrayExt.findFirstIndex(results, Private$a$1.canActivate) : -1;
    }
    if (!query && results.length === 0) {
      VirtualDOM.render(null, contentNode);
      return;
    }
    if (query && results.length === 0) {
      let content2 = this.renderer.renderEmptyMessage({ query });
      VirtualDOM.render(content2, contentNode);
      return;
    }
    let renderer = this.renderer;
    let activeIndex = this._activeIndex;
    let content = new Array(results.length);
    for (let i2 = 0, n = results.length; i2 < n; ++i2) {
      let result2 = results[i2];
      if (result2.type === "header") {
        let indices = result2.indices;
        let category = result2.category;
        content[i2] = renderer.renderHeader({ category, indices });
      } else {
        let item = result2.item;
        let indices = result2.indices;
        let active = i2 === activeIndex;
        content[i2] = renderer.renderItem({ item, indices, active });
      }
    }
    VirtualDOM.render(content, contentNode);
    if (activeIndex < 0 || activeIndex >= results.length) {
      contentNode.scrollTop = 0;
    } else {
      let element = contentNode.children[activeIndex];
      ElementExt.scrollIntoViewIfNeeded(contentNode, element);
    }
  }
  /**
   * Handle the `'click'` event for the command palette.
   */
  _evtClick(event2) {
    if (event2.button !== 0) {
      return;
    }
    if (event2.target.classList.contains("lm-close-icon")) {
      this.inputNode.value = "";
      this.refresh();
      return;
    }
    let index = ArrayExt.findFirstIndex(this.contentNode.children, (node2) => {
      return node2.contains(event2.target);
    });
    if (index === -1) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    this._execute(index);
  }
  /**
   * Handle the `'keydown'` event for the command palette.
   */
  _evtKeyDown(event2) {
    if (event2.altKey || event2.ctrlKey || event2.metaKey || event2.shiftKey) {
      return;
    }
    switch (event2.keyCode) {
      case 13:
        event2.preventDefault();
        event2.stopPropagation();
        this._execute(this._activeIndex);
        break;
      case 38:
        event2.preventDefault();
        event2.stopPropagation();
        this._activatePreviousItem();
        break;
      case 40:
        event2.preventDefault();
        event2.stopPropagation();
        this._activateNextItem();
        break;
    }
  }
  /**
   * Activate the next enabled command item.
   */
  _activateNextItem() {
    if (!this._results || this._results.length === 0) {
      return;
    }
    let ai = this._activeIndex;
    let n = this._results.length;
    let start = ai < n - 1 ? ai + 1 : 0;
    let stop = start === 0 ? n - 1 : start - 1;
    this._activeIndex = ArrayExt.findFirstIndex(this._results, Private$a$1.canActivate, start, stop);
    this.update();
  }
  /**
   * Activate the previous enabled command item.
   */
  _activatePreviousItem() {
    if (!this._results || this._results.length === 0) {
      return;
    }
    let ai = this._activeIndex;
    let n = this._results.length;
    let start = ai <= 0 ? n - 1 : ai - 1;
    let stop = start === n - 1 ? 0 : start + 1;
    this._activeIndex = ArrayExt.findLastIndex(this._results, Private$a$1.canActivate, start, stop);
    this.update();
  }
  /**
   * Execute the command item at the given index, if possible.
   */
  _execute(index) {
    if (!this._results) {
      return;
    }
    let part = this._results[index];
    if (!part) {
      return;
    }
    if (part.type === "header") {
      let input2 = this.inputNode;
      input2.value = `${part.category.toLowerCase()} `;
      input2.focus();
      this.refresh();
      return;
    }
    if (!part.item.isEnabled) {
      return;
    }
    this.commands.execute(part.item.command, part.item.args);
    this.inputNode.value = "";
    this.refresh();
  }
  /**
   * Toggle the focused modifier based on the input node focus state.
   */
  _toggleFocused() {
    let focused = document.activeElement === this.inputNode;
    this.toggleClass("lm-mod-focused", focused);
  }
  /**
   * A signal handler for generic command changes.
   */
  _onGenericChange() {
    this.refresh();
  }
}
(function(CommandPalette2) {
  class Renderer {
    /**
     * Render the virtual element for a command palette header.
     *
     * @param data - The data to use for rendering the header.
     *
     * @returns A virtual element representing the header.
     */
    renderHeader(data) {
      let content = this.formatHeader(data);
      return h.li({ className: "lm-CommandPalette-header" }, content);
    }
    /**
     * Render the virtual element for a command palette item.
     *
     * @param data - The data to use for rendering the item.
     *
     * @returns A virtual element representing the item.
     */
    renderItem(data) {
      let className = this.createItemClass(data);
      let dataset = this.createItemDataset(data);
      if (data.item.isToggleable) {
        return h.li({
          className,
          dataset,
          role: "menuitemcheckbox",
          "aria-checked": `${data.item.isToggled}`
        }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
      }
      return h.li({
        className,
        dataset,
        role: "menuitem"
      }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
    }
    /**
     * Render the empty results message for a command palette.
     *
     * @param data - The data to use for rendering the message.
     *
     * @returns A virtual element representing the message.
     */
    renderEmptyMessage(data) {
      let content = this.formatEmptyMessage(data);
      return h.li({ className: "lm-CommandPalette-emptyMessage" }, content);
    }
    /**
     * Render the icon for a command palette item.
     *
     * @param data - The data to use for rendering the icon.
     *
     * @returns A virtual element representing the icon.
     */
    renderItemIcon(data) {
      let className = this.createIconClass(data);
      return h.div({ className }, data.item.icon, data.item.iconLabel);
    }
    /**
     * Render the content for a command palette item.
     *
     * @param data - The data to use for rendering the content.
     *
     * @returns A virtual element representing the content.
     */
    renderItemContent(data) {
      return h.div({ className: "lm-CommandPalette-itemContent" }, this.renderItemLabel(data), this.renderItemCaption(data));
    }
    /**
     * Render the label for a command palette item.
     *
     * @param data - The data to use for rendering the label.
     *
     * @returns A virtual element representing the label.
     */
    renderItemLabel(data) {
      let content = this.formatItemLabel(data);
      return h.div({ className: "lm-CommandPalette-itemLabel" }, content);
    }
    /**
     * Render the caption for a command palette item.
     *
     * @param data - The data to use for rendering the caption.
     *
     * @returns A virtual element representing the caption.
     */
    renderItemCaption(data) {
      let content = this.formatItemCaption(data);
      return h.div({ className: "lm-CommandPalette-itemCaption" }, content);
    }
    /**
     * Render the shortcut for a command palette item.
     *
     * @param data - The data to use for rendering the shortcut.
     *
     * @returns A virtual element representing the shortcut.
     */
    renderItemShortcut(data) {
      let content = this.formatItemShortcut(data);
      return h.div({ className: "lm-CommandPalette-itemShortcut" }, content);
    }
    /**
     * Create the class name for the command palette item.
     *
     * @param data - The data to use for the class name.
     *
     * @returns The full class name for the command palette item.
     */
    createItemClass(data) {
      let name2 = "lm-CommandPalette-item";
      if (!data.item.isEnabled) {
        name2 += " lm-mod-disabled";
      }
      if (data.item.isToggled) {
        name2 += " lm-mod-toggled";
      }
      if (data.active) {
        name2 += " lm-mod-active";
      }
      let extra = data.item.className;
      if (extra) {
        name2 += ` ${extra}`;
      }
      return name2;
    }
    /**
     * Create the dataset for the command palette item.
     *
     * @param data - The data to use for creating the dataset.
     *
     * @returns The dataset for the command palette item.
     */
    createItemDataset(data) {
      return { ...data.item.dataset, command: data.item.command };
    }
    /**
     * Create the class name for the command item icon.
     *
     * @param data - The data to use for the class name.
     *
     * @returns The full class name for the item icon.
     */
    createIconClass(data) {
      let name2 = "lm-CommandPalette-itemIcon";
      let extra = data.item.iconClass;
      return extra ? `${name2} ${extra}` : name2;
    }
    /**
     * Create the render content for the header node.
     *
     * @param data - The data to use for the header content.
     *
     * @returns The content to add to the header node.
     */
    formatHeader(data) {
      if (!data.indices || data.indices.length === 0) {
        return data.category;
      }
      return StringExt.highlight(data.category, data.indices, h.mark);
    }
    /**
     * Create the render content for the empty message node.
     *
     * @param data - The data to use for the empty message content.
     *
     * @returns The content to add to the empty message node.
     */
    formatEmptyMessage(data) {
      return `No commands found that match '${data.query}'`;
    }
    /**
     * Create the render content for the item shortcut node.
     *
     * @param data - The data to use for the shortcut content.
     *
     * @returns The content to add to the shortcut node.
     */
    formatItemShortcut(data) {
      let kb = data.item.keyBinding;
      return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
    }
    /**
     * Create the render content for the item label node.
     *
     * @param data - The data to use for the label content.
     *
     * @returns The content to add to the label node.
     */
    formatItemLabel(data) {
      if (!data.indices || data.indices.length === 0) {
        return data.item.label;
      }
      return StringExt.highlight(data.item.label, data.indices, h.mark);
    }
    /**
     * Create the render content for the item caption node.
     *
     * @param data - The data to use for the caption content.
     *
     * @returns The content to add to the caption node.
     */
    formatItemCaption(data) {
      return data.item.caption;
    }
  }
  CommandPalette2.Renderer = Renderer;
  CommandPalette2.defaultRenderer = new Renderer();
})(CommandPalette || (CommandPalette = {}));
var Private$a$1;
(function(Private2) {
  function createNode() {
    let node2 = document.createElement("div");
    let search2 = document.createElement("div");
    let wrapper = document.createElement("div");
    let input2 = document.createElement("input");
    let content = document.createElement("ul");
    let clear = document.createElement("button");
    search2.className = "lm-CommandPalette-search";
    wrapper.className = "lm-CommandPalette-wrapper";
    input2.className = "lm-CommandPalette-input";
    clear.className = "lm-close-icon";
    content.className = "lm-CommandPalette-content";
    content.setAttribute("role", "menu");
    input2.spellcheck = false;
    wrapper.appendChild(input2);
    wrapper.appendChild(clear);
    search2.appendChild(wrapper);
    node2.appendChild(search2);
    node2.appendChild(content);
    return node2;
  }
  Private2.createNode = createNode;
  function createItem(commands, options) {
    return new CommandItem(commands, options);
  }
  Private2.createItem = createItem;
  function search(items, query) {
    let scores = matchItems(items, query);
    scores.sort(scoreCmp);
    return createResults(scores);
  }
  Private2.search = search;
  function canActivate(result2) {
    return result2.type === "item" && result2.item.isEnabled;
  }
  Private2.canActivate = canActivate;
  function normalizeCategory(category) {
    return category.trim().replace(/\s+/g, " ");
  }
  function normalizeQuery(text2) {
    return text2.replace(/\s+/g, "").toLowerCase();
  }
  function matchItems(items, query) {
    query = normalizeQuery(query);
    let scores = [];
    for (let i2 = 0, n = items.length; i2 < n; ++i2) {
      let item = items[i2];
      if (!item.isVisible) {
        continue;
      }
      if (!query) {
        scores.push({
          matchType: 3,
          categoryIndices: null,
          labelIndices: null,
          score: 0,
          item
        });
        continue;
      }
      let score = fuzzySearch(item, query);
      if (!score) {
        continue;
      }
      if (!item.isEnabled) {
        score.score += 1e3;
      }
      scores.push(score);
    }
    return scores;
  }
  function fuzzySearch(item, query) {
    let category = item.category.toLowerCase();
    let label = item.label.toLowerCase();
    let source = `${category} ${label}`;
    let score = Infinity;
    let indices = null;
    let rgx = /\b\w/g;
    while (true) {
      let rgxMatch = rgx.exec(source);
      if (!rgxMatch) {
        break;
      }
      let match = StringExt.matchSumOfDeltas(source, query, rgxMatch.index);
      if (!match) {
        break;
      }
      if (match.score <= score) {
        score = match.score;
        indices = match.indices;
      }
    }
    if (!indices || score === Infinity) {
      return null;
    }
    let pivot = category.length + 1;
    let j = ArrayExt.lowerBound(indices, pivot, (a, b) => a - b);
    let categoryIndices = indices.slice(0, j);
    let labelIndices = indices.slice(j);
    for (let i2 = 0, n = labelIndices.length; i2 < n; ++i2) {
      labelIndices[i2] -= pivot;
    }
    if (categoryIndices.length === 0) {
      return {
        matchType: 0,
        categoryIndices: null,
        labelIndices,
        score,
        item
      };
    }
    if (labelIndices.length === 0) {
      return {
        matchType: 1,
        categoryIndices,
        labelIndices: null,
        score,
        item
      };
    }
    return {
      matchType: 2,
      categoryIndices,
      labelIndices,
      score,
      item
    };
  }
  function scoreCmp(a, b) {
    let m1 = a.matchType - b.matchType;
    if (m1 !== 0) {
      return m1;
    }
    let d1 = a.score - b.score;
    if (d1 !== 0) {
      return d1;
    }
    let i1 = 0;
    let i2 = 0;
    switch (a.matchType) {
      case 0:
        i1 = a.labelIndices[0];
        i2 = b.labelIndices[0];
        break;
      case 1:
      case 2:
        i1 = a.categoryIndices[0];
        i2 = b.categoryIndices[0];
        break;
    }
    if (i1 !== i2) {
      return i1 - i2;
    }
    let d2 = a.item.category.localeCompare(b.item.category);
    if (d2 !== 0) {
      return d2;
    }
    let r1 = a.item.rank;
    let r2 = b.item.rank;
    if (r1 !== r2) {
      return r1 < r2 ? -1 : 1;
    }
    return a.item.label.localeCompare(b.item.label);
  }
  function createResults(scores) {
    let results = [];
    for (let i2 = 0, n = scores.length; i2 < n; ++i2) {
      let { item, categoryIndices, labelIndices } = scores[i2];
      let category = item.category;
      if (i2 === 0 || category !== scores[i2 - 1].item.category) {
        results.push({ type: "header", category, indices: categoryIndices });
      }
      results.push({ type: "item", item, indices: labelIndices });
    }
    return results;
  }
  class CommandItem {
    /**
     * Construct a new command item.
     */
    constructor(commands, options) {
      this._commands = commands;
      this.category = normalizeCategory(options.category);
      this.command = options.command;
      this.args = options.args || JSONExt.emptyObject;
      this.rank = options.rank !== void 0 ? options.rank : Infinity;
    }
    /**
     * The display label for the command item.
     */
    get label() {
      return this._commands.label(this.command, this.args);
    }
    /**
     * The icon renderer for the command item.
     */
    get icon() {
      return this._commands.icon(this.command, this.args);
    }
    /**
     * The icon class for the command item.
     */
    get iconClass() {
      return this._commands.iconClass(this.command, this.args);
    }
    /**
     * The icon label for the command item.
     */
    get iconLabel() {
      return this._commands.iconLabel(this.command, this.args);
    }
    /**
     * The display caption for the command item.
     */
    get caption() {
      return this._commands.caption(this.command, this.args);
    }
    /**
     * The extra class name for the command item.
     */
    get className() {
      return this._commands.className(this.command, this.args);
    }
    /**
     * The dataset for the command item.
     */
    get dataset() {
      return this._commands.dataset(this.command, this.args);
    }
    /**
     * Whether the command item is enabled.
     */
    get isEnabled() {
      return this._commands.isEnabled(this.command, this.args);
    }
    /**
     * Whether the command item is toggled.
     */
    get isToggled() {
      return this._commands.isToggled(this.command, this.args);
    }
    /**
     * Whether the command item is toggleable.
     */
    get isToggleable() {
      return this._commands.isToggleable(this.command, this.args);
    }
    /**
     * Whether the command item is visible.
     */
    get isVisible() {
      return this._commands.isVisible(this.command, this.args);
    }
    /**
     * The key binding for the command item.
     */
    get keyBinding() {
      let { command, args } = this;
      return ArrayExt.findLastValue(this._commands.keyBindings, (kb) => {
        return kb.command === command && JSONExt.deepEqual(kb.args, args);
      }) || null;
    }
  }
})(Private$a$1 || (Private$a$1 = {}));
class Menu extends Widget {
  /**
   * Construct a new menu.
   *
   * @param options - The options for initializing the menu.
   */
  constructor(options) {
    super({ node: Private$9$1.createNode() });
    this._childIndex = -1;
    this._activeIndex = -1;
    this._openTimerID = 0;
    this._closeTimerID = 0;
    this._items = [];
    this._childMenu = null;
    this._parentMenu = null;
    this._aboutToClose = new Signal(this);
    this._menuRequested = new Signal(this);
    this.addClass("lm-Menu");
    this.setFlag(Widget.Flag.DisallowLayout);
    this.commands = options.commands;
    this.renderer = options.renderer || Menu.defaultRenderer;
  }
  /**
   * Dispose of the resources held by the menu.
   */
  dispose() {
    this.close();
    this._items.length = 0;
    super.dispose();
  }
  /**
   * A signal emitted just before the menu is closed.
   *
   * #### Notes
   * This signal is emitted when the menu receives a `'close-request'`
   * message, just before it removes itself from the DOM.
   *
   * This signal is not emitted if the menu is already detached from
   * the DOM when it receives the `'close-request'` message.
   */
  get aboutToClose() {
    return this._aboutToClose;
  }
  /**
   * A signal emitted when a new menu is requested by the user.
   *
   * #### Notes
   * This signal is emitted whenever the user presses the right or left
   * arrow keys, and a submenu cannot be opened or closed in response.
   *
   * This signal is useful when implementing menu bars in order to open
   * the next or previous menu in response to a user key press.
   *
   * This signal is only emitted for the root menu in a hierarchy.
   */
  get menuRequested() {
    return this._menuRequested;
  }
  /**
   * The parent menu of the menu.
   *
   * #### Notes
   * This is `null` unless the menu is an open submenu.
   */
  get parentMenu() {
    return this._parentMenu;
  }
  /**
   * The child menu of the menu.
   *
   * #### Notes
   * This is `null` unless the menu has an open submenu.
   */
  get childMenu() {
    return this._childMenu;
  }
  /**
   * The root menu of the menu hierarchy.
   */
  get rootMenu() {
    let menu = this;
    while (menu._parentMenu) {
      menu = menu._parentMenu;
    }
    return menu;
  }
  /**
   * The leaf menu of the menu hierarchy.
   */
  get leafMenu() {
    let menu = this;
    while (menu._childMenu) {
      menu = menu._childMenu;
    }
    return menu;
  }
  /**
   * The menu content node.
   *
   * #### Notes
   * This is the node which holds the menu item nodes.
   *
   * Modifying this node directly can lead to undefined behavior.
   */
  get contentNode() {
    return this.node.getElementsByClassName("lm-Menu-content")[0];
  }
  /**
   * Get the currently active menu item.
   */
  get activeItem() {
    return this._items[this._activeIndex] || null;
  }
  /**
   * Set the currently active menu item.
   *
   * #### Notes
   * If the item cannot be activated, the item will be set to `null`.
   */
  set activeItem(value) {
    this.activeIndex = value ? this._items.indexOf(value) : -1;
  }
  /**
   * Get the index of the currently active menu item.
   *
   * #### Notes
   * This will be `-1` if no menu item is active.
   */
  get activeIndex() {
    return this._activeIndex;
  }
  /**
   * Set the index of the currently active menu item.
   *
   * #### Notes
   * If the item cannot be activated, the index will be set to `-1`.
   */
  set activeIndex(value) {
    if (value < 0 || value >= this._items.length) {
      value = -1;
    }
    if (value !== -1 && !Private$9$1.canActivate(this._items[value])) {
      value = -1;
    }
    if (this._activeIndex === value) {
      return;
    }
    this._activeIndex = value;
    if (this._activeIndex >= 0 && this.contentNode.childNodes[this._activeIndex]) {
      this.contentNode.childNodes[this._activeIndex].focus();
    }
    this.update();
  }
  /**
   * A read-only array of the menu items in the menu.
   */
  get items() {
    return this._items;
  }
  /**
   * Activate the next selectable item in the menu.
   *
   * #### Notes
   * If no item is selectable, the index will be set to `-1`.
   */
  activateNextItem() {
    let n = this._items.length;
    let ai = this._activeIndex;
    let start = ai < n - 1 ? ai + 1 : 0;
    let stop = start === 0 ? n - 1 : start - 1;
    this.activeIndex = ArrayExt.findFirstIndex(this._items, Private$9$1.canActivate, start, stop);
  }
  /**
   * Activate the previous selectable item in the menu.
   *
   * #### Notes
   * If no item is selectable, the index will be set to `-1`.
   */
  activatePreviousItem() {
    let n = this._items.length;
    let ai = this._activeIndex;
    let start = ai <= 0 ? n - 1 : ai - 1;
    let stop = start === n - 1 ? 0 : start + 1;
    this.activeIndex = ArrayExt.findLastIndex(this._items, Private$9$1.canActivate, start, stop);
  }
  /**
   * Trigger the active menu item.
   *
   * #### Notes
   * If the active item is a submenu, it will be opened and the first
   * item will be activated.
   *
   * If the active item is a command, the command will be executed.
   *
   * If the menu is not attached, this is a no-op.
   *
   * If there is no active item, this is a no-op.
   */
  triggerActiveItem() {
    if (!this.isAttached) {
      return;
    }
    let item = this.activeItem;
    if (!item) {
      return;
    }
    this._cancelOpenTimer();
    this._cancelCloseTimer();
    if (item.type === "submenu") {
      this._openChildMenu(true);
      return;
    }
    this.rootMenu.close();
    let { command, args } = item;
    if (this.commands.isEnabled(command, args)) {
      this.commands.execute(command, args);
    } else {
      console.log(`Command '${command}' is disabled.`);
    }
  }
  /**
   * Add a menu item to the end of the menu.
   *
   * @param options - The options for creating the menu item.
   *
   * @returns The menu item added to the menu.
   */
  addItem(options) {
    return this.insertItem(this._items.length, options);
  }
  /**
   * Insert a menu item into the menu at the specified index.
   *
   * @param index - The index at which to insert the item.
   *
   * @param options - The options for creating the menu item.
   *
   * @returns The menu item added to the menu.
   *
   * #### Notes
   * The index will be clamped to the bounds of the items.
   */
  insertItem(index, options) {
    if (this.isAttached) {
      this.close();
    }
    this.activeIndex = -1;
    let i2 = Math.max(0, Math.min(index, this._items.length));
    let item = Private$9$1.createItem(this, options);
    ArrayExt.insert(this._items, i2, item);
    this.update();
    return item;
  }
  /**
   * Remove an item from the menu.
   *
   * @param item - The item to remove from the menu.
   *
   * #### Notes
   * This is a no-op if the item is not in the menu.
   */
  removeItem(item) {
    this.removeItemAt(this._items.indexOf(item));
  }
  /**
   * Remove the item at a given index from the menu.
   *
   * @param index - The index of the item to remove.
   *
   * #### Notes
   * This is a no-op if the index is out of range.
   */
  removeItemAt(index) {
    if (this.isAttached) {
      this.close();
    }
    this.activeIndex = -1;
    let item = ArrayExt.removeAt(this._items, index);
    if (!item) {
      return;
    }
    this.update();
  }
  /**
   * Remove all menu items from the menu.
   */
  clearItems() {
    if (this.isAttached) {
      this.close();
    }
    this.activeIndex = -1;
    if (this._items.length === 0) {
      return;
    }
    this._items.length = 0;
    this.update();
  }
  /**
   * Open the menu at the specified location.
   *
   * @param x - The client X coordinate of the menu location.
   *
   * @param y - The client Y coordinate of the menu location.
   *
   * @param options - The additional options for opening the menu.
   *
   * #### Notes
   * The menu will be opened at the given location unless it will not
   * fully fit on the screen. If it will not fit, it will be adjusted
   * to fit naturally on the screen.
   *
   * The menu will be attached under the `host` element in the DOM
   * (or `document.body` if `host` is `null`) and before the `ref`
   * element (or as the last child of `host` if `ref` is `null`).
   * The menu may be displayed outside of the `host` element
   * following the rules of CSS absolute positioning.
   *
   * This is a no-op if the menu is already attached to the DOM.
   */
  open(x2, y, options = {}) {
    var _a, _b;
    if (this.isAttached) {
      return;
    }
    let forceX = options.forceX || false;
    let forceY = options.forceY || false;
    const host = (_a = options.host) !== null && _a !== void 0 ? _a : null;
    const ref2 = (_b = options.ref) !== null && _b !== void 0 ? _b : null;
    Private$9$1.openRootMenu(this, x2, y, forceX, forceY, host, ref2);
    this.activate();
  }
  /**
   * Handle the DOM events for the menu.
   *
   * @param event - The DOM event sent to the menu.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the menu's DOM nodes. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "keydown":
        this._evtKeyDown(event2);
        break;
      case "mouseup":
        this._evtMouseUp(event2);
        break;
      case "mousemove":
        this._evtMouseMove(event2);
        break;
      case "mouseenter":
        this._evtMouseEnter(event2);
        break;
      case "mouseleave":
        this._evtMouseLeave(event2);
        break;
      case "mousedown":
        this._evtMouseDown(event2);
        break;
      case "contextmenu":
        event2.preventDefault();
        event2.stopPropagation();
        break;
    }
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    this.node.addEventListener("keydown", this);
    this.node.addEventListener("mouseup", this);
    this.node.addEventListener("mousemove", this);
    this.node.addEventListener("mouseenter", this);
    this.node.addEventListener("mouseleave", this);
    this.node.addEventListener("contextmenu", this);
    document.addEventListener("mousedown", this, true);
  }
  /**
   * A message handler invoked on an `'after-detach'` message.
   */
  onAfterDetach(msg) {
    this.node.removeEventListener("keydown", this);
    this.node.removeEventListener("mouseup", this);
    this.node.removeEventListener("mousemove", this);
    this.node.removeEventListener("mouseenter", this);
    this.node.removeEventListener("mouseleave", this);
    this.node.removeEventListener("contextmenu", this);
    document.removeEventListener("mousedown", this, true);
  }
  /**
   * A message handler invoked on an `'activate-request'` message.
   */
  onActivateRequest(msg) {
    if (this.isAttached) {
      this.node.focus();
    }
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   */
  onUpdateRequest(msg) {
    let items = this._items;
    let renderer = this.renderer;
    let activeIndex = this._activeIndex;
    let collapsedFlags = Private$9$1.computeCollapsed(items);
    let content = new Array(items.length);
    for (let i2 = 0, n = items.length; i2 < n; ++i2) {
      let item = items[i2];
      let active = i2 === activeIndex;
      let collapsed = collapsedFlags[i2];
      content[i2] = renderer.renderItem({
        item,
        active,
        collapsed,
        onfocus: () => {
          this.activeIndex = i2;
        }
      });
    }
    VirtualDOM.render(content, this.contentNode);
  }
  /**
   * A message handler invoked on a `'close-request'` message.
   */
  onCloseRequest(msg) {
    this._cancelOpenTimer();
    this._cancelCloseTimer();
    this.activeIndex = -1;
    let childMenu = this._childMenu;
    if (childMenu) {
      this._childIndex = -1;
      this._childMenu = null;
      childMenu._parentMenu = null;
      childMenu.close();
    }
    let parentMenu = this._parentMenu;
    if (parentMenu) {
      this._parentMenu = null;
      parentMenu._childIndex = -1;
      parentMenu._childMenu = null;
      parentMenu.activate();
    }
    if (this.isAttached) {
      this._aboutToClose.emit(void 0);
    }
    super.onCloseRequest(msg);
  }
  /**
   * Handle the `'keydown'` event for the menu.
   *
   * #### Notes
   * This listener is attached to the menu node.
   */
  _evtKeyDown(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    let kc = event2.keyCode;
    if (kc === 13) {
      this.triggerActiveItem();
      return;
    }
    if (kc === 27) {
      this.close();
      return;
    }
    if (kc === 37) {
      if (this._parentMenu) {
        this.close();
      } else {
        this._menuRequested.emit("previous");
      }
      return;
    }
    if (kc === 38) {
      this.activatePreviousItem();
      return;
    }
    if (kc === 39) {
      let item = this.activeItem;
      if (item && item.type === "submenu") {
        this.triggerActiveItem();
      } else {
        this.rootMenu._menuRequested.emit("next");
      }
      return;
    }
    if (kc === 40) {
      this.activateNextItem();
      return;
    }
    let key2 = getKeyboardLayout().keyForKeydownEvent(event2);
    if (!key2) {
      return;
    }
    let start = this._activeIndex + 1;
    let result2 = Private$9$1.findMnemonic(this._items, key2, start);
    if (result2.index !== -1 && !result2.multiple) {
      this.activeIndex = result2.index;
      this.triggerActiveItem();
    } else if (result2.index !== -1) {
      this.activeIndex = result2.index;
    } else if (result2.auto !== -1) {
      this.activeIndex = result2.auto;
    }
  }
  /**
   * Handle the `'mouseup'` event for the menu.
   *
   * #### Notes
   * This listener is attached to the menu node.
   */
  _evtMouseUp(event2) {
    if (event2.button !== 0) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    this.triggerActiveItem();
  }
  /**
   * Handle the `'mousemove'` event for the menu.
   *
   * #### Notes
   * This listener is attached to the menu node.
   */
  _evtMouseMove(event2) {
    let index = ArrayExt.findFirstIndex(this.contentNode.children, (node2) => {
      return ElementExt.hitTest(node2, event2.clientX, event2.clientY);
    });
    if (index === this._activeIndex) {
      return;
    }
    this.activeIndex = index;
    index = this.activeIndex;
    if (index === this._childIndex) {
      this._cancelOpenTimer();
      this._cancelCloseTimer();
      return;
    }
    if (this._childIndex !== -1) {
      this._startCloseTimer();
    }
    this._cancelOpenTimer();
    let item = this.activeItem;
    if (!item || item.type !== "submenu" || !item.submenu) {
      return;
    }
    this._startOpenTimer();
  }
  /**
   * Handle the `'mouseenter'` event for the menu.
   *
   * #### Notes
   * This listener is attached to the menu node.
   */
  _evtMouseEnter(event2) {
    for (let menu = this._parentMenu; menu; menu = menu._parentMenu) {
      menu._cancelOpenTimer();
      menu._cancelCloseTimer();
      menu.activeIndex = menu._childIndex;
    }
  }
  /**
   * Handle the `'mouseleave'` event for the menu.
   *
   * #### Notes
   * This listener is attached to the menu node.
   */
  _evtMouseLeave(event2) {
    this._cancelOpenTimer();
    if (!this._childMenu) {
      this.activeIndex = -1;
      return;
    }
    let { clientX, clientY } = event2;
    if (ElementExt.hitTest(this._childMenu.node, clientX, clientY)) {
      this._cancelCloseTimer();
      return;
    }
    this.activeIndex = -1;
    this._startCloseTimer();
  }
  /**
   * Handle the `'mousedown'` event for the menu.
   *
   * #### Notes
   * This listener is attached to the document node.
   */
  _evtMouseDown(event2) {
    if (this._parentMenu) {
      return;
    }
    if (Private$9$1.hitTestMenus(this, event2.clientX, event2.clientY)) {
      event2.preventDefault();
      event2.stopPropagation();
    } else {
      this.close();
    }
  }
  /**
   * Open the child menu at the active index immediately.
   *
   * If a different child menu is already open, it will be closed,
   * even if the active item is not a valid submenu.
   */
  _openChildMenu(activateFirst = false) {
    let item = this.activeItem;
    if (!item || item.type !== "submenu" || !item.submenu) {
      this._closeChildMenu();
      return;
    }
    let submenu = item.submenu;
    if (submenu === this._childMenu) {
      return;
    }
    Menu.saveWindowData();
    this._closeChildMenu();
    this._childMenu = submenu;
    this._childIndex = this._activeIndex;
    submenu._parentMenu = this;
    MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);
    let itemNode = this.contentNode.children[this._activeIndex];
    Private$9$1.openSubmenu(submenu, itemNode);
    if (activateFirst) {
      submenu.activeIndex = -1;
      submenu.activateNextItem();
    }
    submenu.activate();
  }
  /**
   * Close the child menu immediately.
   *
   * This is a no-op if a child menu is not open.
   */
  _closeChildMenu() {
    if (this._childMenu) {
      this._childMenu.close();
    }
  }
  /**
   * Start the open timer, unless it is already pending.
   */
  _startOpenTimer() {
    if (this._openTimerID === 0) {
      this._openTimerID = window.setTimeout(() => {
        this._openTimerID = 0;
        this._openChildMenu();
      }, Private$9$1.TIMER_DELAY);
    }
  }
  /**
   * Start the close timer, unless it is already pending.
   */
  _startCloseTimer() {
    if (this._closeTimerID === 0) {
      this._closeTimerID = window.setTimeout(() => {
        this._closeTimerID = 0;
        this._closeChildMenu();
      }, Private$9$1.TIMER_DELAY);
    }
  }
  /**
   * Cancel the open timer, if the timer is pending.
   */
  _cancelOpenTimer() {
    if (this._openTimerID !== 0) {
      clearTimeout(this._openTimerID);
      this._openTimerID = 0;
    }
  }
  /**
   * Cancel the close timer, if the timer is pending.
   */
  _cancelCloseTimer() {
    if (this._closeTimerID !== 0) {
      clearTimeout(this._closeTimerID);
      this._closeTimerID = 0;
    }
  }
  /**
   * Save window data used for menu positioning in transient cache.
   *
   * In order to avoid layout trashing it is recommended to invoke this
   * method immediately prior to opening the menu and any DOM modifications
   * (like closing previously visible menu, or adding a class to menu widget).
   *
   * The transient cache will be released upon `open()` call.
   */
  static saveWindowData() {
    Private$9$1.saveWindowData();
  }
}
(function(Menu2) {
  class Renderer {
    /**
     * Render the virtual element for a menu item.
     *
     * @param data - The data to use for rendering the item.
     *
     * @returns A virtual element representing the item.
     */
    renderItem(data) {
      let className = this.createItemClass(data);
      let dataset = this.createItemDataset(data);
      let aria = this.createItemARIA(data);
      return h.li({
        className,
        dataset,
        tabindex: "0",
        onfocus: data.onfocus,
        ...aria
      }, this.renderIcon(data), this.renderLabel(data), this.renderShortcut(data), this.renderSubmenu(data));
    }
    /**
     * Render the icon element for a menu item.
     *
     * @param data - The data to use for rendering the icon.
     *
     * @returns A virtual element representing the item icon.
     */
    renderIcon(data) {
      let className = this.createIconClass(data);
      return h.div({ className }, data.item.icon, data.item.iconLabel);
    }
    /**
     * Render the label element for a menu item.
     *
     * @param data - The data to use for rendering the label.
     *
     * @returns A virtual element representing the item label.
     */
    renderLabel(data) {
      let content = this.formatLabel(data);
      return h.div({ className: "lm-Menu-itemLabel" }, content);
    }
    /**
     * Render the shortcut element for a menu item.
     *
     * @param data - The data to use for rendering the shortcut.
     *
     * @returns A virtual element representing the item shortcut.
     */
    renderShortcut(data) {
      let content = this.formatShortcut(data);
      return h.div({ className: "lm-Menu-itemShortcut" }, content);
    }
    /**
     * Render the submenu icon element for a menu item.
     *
     * @param data - The data to use for rendering the submenu icon.
     *
     * @returns A virtual element representing the submenu icon.
     */
    renderSubmenu(data) {
      return h.div({ className: "lm-Menu-itemSubmenuIcon" });
    }
    /**
     * Create the class name for the menu item.
     *
     * @param data - The data to use for the class name.
     *
     * @returns The full class name for the menu item.
     */
    createItemClass(data) {
      let name2 = "lm-Menu-item";
      if (!data.item.isEnabled) {
        name2 += " lm-mod-disabled";
      }
      if (data.item.isToggled) {
        name2 += " lm-mod-toggled";
      }
      if (!data.item.isVisible) {
        name2 += " lm-mod-hidden";
      }
      if (data.active) {
        name2 += " lm-mod-active";
      }
      if (data.collapsed) {
        name2 += " lm-mod-collapsed";
      }
      let extra = data.item.className;
      if (extra) {
        name2 += ` ${extra}`;
      }
      return name2;
    }
    /**
     * Create the dataset for the menu item.
     *
     * @param data - The data to use for creating the dataset.
     *
     * @returns The dataset for the menu item.
     */
    createItemDataset(data) {
      let result2;
      let { type, command, dataset } = data.item;
      if (type === "command") {
        result2 = { ...dataset, type, command };
      } else {
        result2 = { ...dataset, type };
      }
      return result2;
    }
    /**
     * Create the class name for the menu item icon.
     *
     * @param data - The data to use for the class name.
     *
     * @returns The full class name for the item icon.
     */
    createIconClass(data) {
      let name2 = "lm-Menu-itemIcon";
      let extra = data.item.iconClass;
      return extra ? `${name2} ${extra}` : name2;
    }
    /**
     * Create the aria attributes for menu item.
     *
     * @param data - The data to use for the aria attributes.
     *
     * @returns The aria attributes object for the item.
     */
    createItemARIA(data) {
      let aria = {};
      switch (data.item.type) {
        case "separator":
          aria.role = "presentation";
          break;
        case "submenu":
          aria["aria-haspopup"] = "true";
          if (!data.item.isEnabled) {
            aria["aria-disabled"] = "true";
          }
          break;
        default:
          if (!data.item.isEnabled) {
            aria["aria-disabled"] = "true";
          }
          aria.role = "menuitem";
      }
      return aria;
    }
    /**
     * Create the render content for the label node.
     *
     * @param data - The data to use for the label content.
     *
     * @returns The content to add to the label node.
     */
    formatLabel(data) {
      let { label, mnemonic } = data.item;
      if (mnemonic < 0 || mnemonic >= label.length) {
        return label;
      }
      let prefix = label.slice(0, mnemonic);
      let suffix = label.slice(mnemonic + 1);
      let char = label[mnemonic];
      let span = h.span({ className: "lm-Menu-itemMnemonic" }, char);
      return [prefix, span, suffix];
    }
    /**
     * Create the render content for the shortcut node.
     *
     * @param data - The data to use for the shortcut content.
     *
     * @returns The content to add to the shortcut node.
     */
    formatShortcut(data) {
      let kb = data.item.keyBinding;
      return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
    }
  }
  Menu2.Renderer = Renderer;
  Menu2.defaultRenderer = new Renderer();
})(Menu || (Menu = {}));
var Private$9$1;
(function(Private2) {
  Private2.TIMER_DELAY = 300;
  Private2.SUBMENU_OVERLAP = 3;
  let transientWindowDataCache = null;
  let transientCacheCounter = 0;
  function getWindowData() {
    if (transientCacheCounter > 0) {
      transientCacheCounter--;
      return transientWindowDataCache;
    }
    return _getWindowData();
  }
  function saveWindowData() {
    transientWindowDataCache = _getWindowData();
    transientCacheCounter++;
  }
  Private2.saveWindowData = saveWindowData;
  function createNode() {
    let node2 = document.createElement("div");
    let content = document.createElement("ul");
    content.className = "lm-Menu-content";
    node2.appendChild(content);
    content.setAttribute("role", "menu");
    node2.tabIndex = 0;
    return node2;
  }
  Private2.createNode = createNode;
  function canActivate(item) {
    return item.type !== "separator" && item.isEnabled && item.isVisible;
  }
  Private2.canActivate = canActivate;
  function createItem(owner, options) {
    return new MenuItem(owner.commands, options);
  }
  Private2.createItem = createItem;
  function hitTestMenus(menu, x2, y) {
    for (let temp = menu; temp; temp = temp.childMenu) {
      if (ElementExt.hitTest(temp.node, x2, y)) {
        return true;
      }
    }
    return false;
  }
  Private2.hitTestMenus = hitTestMenus;
  function computeCollapsed(items) {
    let result2 = new Array(items.length);
    ArrayExt.fill(result2, false);
    let k1 = 0;
    let n = items.length;
    for (; k1 < n; ++k1) {
      let item = items[k1];
      if (!item.isVisible) {
        continue;
      }
      if (item.type !== "separator") {
        break;
      }
      result2[k1] = true;
    }
    let k2 = n - 1;
    for (; k2 >= 0; --k2) {
      let item = items[k2];
      if (!item.isVisible) {
        continue;
      }
      if (item.type !== "separator") {
        break;
      }
      result2[k2] = true;
    }
    let hide = false;
    while (++k1 < k2) {
      let item = items[k1];
      if (!item.isVisible) {
        continue;
      }
      if (item.type !== "separator") {
        hide = false;
      } else if (hide) {
        result2[k1] = true;
      } else {
        hide = true;
      }
    }
    return result2;
  }
  Private2.computeCollapsed = computeCollapsed;
  function _getWindowData() {
    return {
      pageXOffset: window.pageXOffset,
      pageYOffset: window.pageYOffset,
      clientWidth: document.documentElement.clientWidth,
      clientHeight: document.documentElement.clientHeight
    };
  }
  function openRootMenu(menu, x2, y, forceX, forceY, host, ref2) {
    const windowData = getWindowData();
    let px = windowData.pageXOffset;
    let py = windowData.pageYOffset;
    let cw = windowData.clientWidth;
    let ch = windowData.clientHeight;
    MessageLoop.sendMessage(menu, Widget.Msg.UpdateRequest);
    let maxHeight = ch - (forceY ? y : 0);
    let node2 = menu.node;
    let style2 = node2.style;
    style2.opacity = "0";
    style2.maxHeight = `${maxHeight}px`;
    Widget.attach(menu, host || document.body, ref2);
    let { width, height } = node2.getBoundingClientRect();
    if (!forceX && x2 + width > px + cw) {
      x2 = px + cw - width;
    }
    if (!forceY && y + height > py + ch) {
      if (y > py + ch) {
        y = py + ch - height;
      } else {
        y = y - height;
      }
    }
    style2.transform = `translate(${Math.max(0, x2)}px, ${Math.max(0, y)}px`;
    style2.opacity = "1";
  }
  Private2.openRootMenu = openRootMenu;
  function openSubmenu(submenu, itemNode) {
    const windowData = getWindowData();
    let px = windowData.pageXOffset;
    let py = windowData.pageYOffset;
    let cw = windowData.clientWidth;
    let ch = windowData.clientHeight;
    MessageLoop.sendMessage(submenu, Widget.Msg.UpdateRequest);
    let maxHeight = ch;
    let node2 = submenu.node;
    let style2 = node2.style;
    style2.opacity = "0";
    style2.maxHeight = `${maxHeight}px`;
    Widget.attach(submenu, document.body);
    let { width, height } = node2.getBoundingClientRect();
    let box = ElementExt.boxSizing(submenu.node);
    let itemRect = itemNode.getBoundingClientRect();
    let x2 = itemRect.right - Private2.SUBMENU_OVERLAP;
    if (x2 + width > px + cw) {
      x2 = itemRect.left + Private2.SUBMENU_OVERLAP - width;
    }
    let y = itemRect.top - box.borderTop - box.paddingTop;
    if (y + height > py + ch) {
      y = itemRect.bottom + box.borderBottom + box.paddingBottom - height;
    }
    style2.transform = `translate(${Math.max(0, x2)}px, ${Math.max(0, y)}px`;
    style2.opacity = "1";
  }
  Private2.openSubmenu = openSubmenu;
  function findMnemonic(items, key2, start) {
    let index = -1;
    let auto = -1;
    let multiple = false;
    let upperKey = key2.toUpperCase();
    for (let i2 = 0, n = items.length; i2 < n; ++i2) {
      let k = (i2 + start) % n;
      let item = items[k];
      if (!canActivate(item)) {
        continue;
      }
      let label = item.label;
      if (label.length === 0) {
        continue;
      }
      let mn = item.mnemonic;
      if (mn >= 0 && mn < label.length) {
        if (label[mn].toUpperCase() === upperKey) {
          if (index === -1) {
            index = k;
          } else {
            multiple = true;
          }
        }
        continue;
      }
      if (auto === -1 && label[0].toUpperCase() === upperKey) {
        auto = k;
      }
    }
    return { index, multiple, auto };
  }
  Private2.findMnemonic = findMnemonic;
  class MenuItem {
    /**
     * Construct a new menu item.
     */
    constructor(commands, options) {
      this._commands = commands;
      this.type = options.type || "command";
      this.command = options.command || "";
      this.args = options.args || JSONExt.emptyObject;
      this.submenu = options.submenu || null;
    }
    /**
     * The display label for the menu item.
     */
    get label() {
      if (this.type === "command") {
        return this._commands.label(this.command, this.args);
      }
      if (this.type === "submenu" && this.submenu) {
        return this.submenu.title.label;
      }
      return "";
    }
    /**
     * The mnemonic index for the menu item.
     */
    get mnemonic() {
      if (this.type === "command") {
        return this._commands.mnemonic(this.command, this.args);
      }
      if (this.type === "submenu" && this.submenu) {
        return this.submenu.title.mnemonic;
      }
      return -1;
    }
    /**
     * The icon renderer for the menu item.
     */
    get icon() {
      if (this.type === "command") {
        return this._commands.icon(this.command, this.args);
      }
      if (this.type === "submenu" && this.submenu) {
        return this.submenu.title.icon;
      }
      return void 0;
    }
    /**
     * The icon class for the menu item.
     */
    get iconClass() {
      if (this.type === "command") {
        return this._commands.iconClass(this.command, this.args);
      }
      if (this.type === "submenu" && this.submenu) {
        return this.submenu.title.iconClass;
      }
      return "";
    }
    /**
     * The icon label for the menu item.
     */
    get iconLabel() {
      if (this.type === "command") {
        return this._commands.iconLabel(this.command, this.args);
      }
      if (this.type === "submenu" && this.submenu) {
        return this.submenu.title.iconLabel;
      }
      return "";
    }
    /**
     * The display caption for the menu item.
     */
    get caption() {
      if (this.type === "command") {
        return this._commands.caption(this.command, this.args);
      }
      if (this.type === "submenu" && this.submenu) {
        return this.submenu.title.caption;
      }
      return "";
    }
    /**
     * The extra class name for the menu item.
     */
    get className() {
      if (this.type === "command") {
        return this._commands.className(this.command, this.args);
      }
      if (this.type === "submenu" && this.submenu) {
        return this.submenu.title.className;
      }
      return "";
    }
    /**
     * The dataset for the menu item.
     */
    get dataset() {
      if (this.type === "command") {
        return this._commands.dataset(this.command, this.args);
      }
      if (this.type === "submenu" && this.submenu) {
        return this.submenu.title.dataset;
      }
      return {};
    }
    /**
     * Whether the menu item is enabled.
     */
    get isEnabled() {
      if (this.type === "command") {
        return this._commands.isEnabled(this.command, this.args);
      }
      if (this.type === "submenu") {
        return this.submenu !== null;
      }
      return true;
    }
    /**
     * Whether the menu item is toggled.
     */
    get isToggled() {
      if (this.type === "command") {
        return this._commands.isToggled(this.command, this.args);
      }
      return false;
    }
    /**
     * Whether the menu item is visible.
     */
    get isVisible() {
      if (this.type === "command") {
        return this._commands.isVisible(this.command, this.args);
      }
      if (this.type === "submenu") {
        return this.submenu !== null;
      }
      return true;
    }
    /**
     * The key binding for the menu item.
     */
    get keyBinding() {
      if (this.type === "command") {
        let { command, args } = this;
        return ArrayExt.findLastValue(this._commands.keyBindings, (kb) => {
          return kb.command === command && JSONExt.deepEqual(kb.args, args);
        }) || null;
      }
      return null;
    }
  }
})(Private$9$1 || (Private$9$1 = {}));
var Private$8$1;
(function(Private2) {
  function createItem(options, id) {
    let selector = validateSelector(options.selector);
    let rank = options.rank !== void 0 ? options.rank : Infinity;
    return { ...options, selector, rank, id };
  }
  Private2.createItem = createItem;
  function matchItems(items, event2, groupByTarget, sortBySelector) {
    let target2 = event2.target;
    if (!target2) {
      return null;
    }
    let currentTarget = event2.currentTarget;
    if (!currentTarget) {
      return null;
    }
    if (!currentTarget.contains(target2)) {
      target2 = document.elementFromPoint(event2.clientX, event2.clientY);
      if (!target2 || !currentTarget.contains(target2)) {
        return null;
      }
    }
    let result2 = [];
    let availableItems = items.slice();
    while (target2 !== null) {
      let matches2 = [];
      for (let i2 = 0, n = availableItems.length; i2 < n; ++i2) {
        let item = availableItems[i2];
        if (!item) {
          continue;
        }
        if (!Selector$1.matches(target2, item.selector)) {
          continue;
        }
        matches2.push(item);
        availableItems[i2] = null;
      }
      if (matches2.length !== 0) {
        if (groupByTarget) {
          matches2.sort(sortBySelector ? itemCmp : itemCmpRank);
        }
        result2.push(...matches2);
      }
      if (target2 === currentTarget) {
        break;
      }
      target2 = target2.parentElement;
    }
    if (!groupByTarget) {
      result2.sort(sortBySelector ? itemCmp : itemCmpRank);
    }
    return result2;
  }
  Private2.matchItems = matchItems;
  function validateSelector(selector) {
    if (selector.indexOf(",") !== -1) {
      throw new Error(`Selector cannot contain commas: ${selector}`);
    }
    if (!Selector$1.isValid(selector)) {
      throw new Error(`Invalid selector: ${selector}`);
    }
    return selector;
  }
  function itemCmpRank(a, b) {
    let r1 = a.rank;
    let r2 = b.rank;
    if (r1 !== r2) {
      return r1 < r2 ? -1 : 1;
    }
    return a.id - b.id;
  }
  function itemCmp(a, b) {
    let s1 = Selector$1.calculateSpecificity(a.selector);
    let s2 = Selector$1.calculateSpecificity(b.selector);
    if (s1 !== s2) {
      return s2 - s1;
    }
    return itemCmpRank(a, b);
  }
})(Private$8$1 || (Private$8$1 = {}));
const ARROW_KEYS = [
  "ArrowLeft",
  "ArrowUp",
  "ArrowRight",
  "ArrowDown",
  "Home",
  "End"
];
class TabBar extends Widget {
  /**
   * Construct a new tab bar.
   *
   * @param options - The options for initializing the tab bar.
   */
  constructor(options = {}) {
    super({ node: Private$7$1.createNode() });
    this._currentIndex = -1;
    this._titles = [];
    this._titlesEditable = false;
    this._previousTitle = null;
    this._dragData = null;
    this._addButtonEnabled = false;
    this._tabMoved = new Signal(this);
    this._currentChanged = new Signal(this);
    this._addRequested = new Signal(this);
    this._tabCloseRequested = new Signal(this);
    this._tabDetachRequested = new Signal(this);
    this._tabActivateRequested = new Signal(this);
    this.addClass("lm-TabBar");
    this.contentNode.setAttribute("role", "tablist");
    this.setFlag(Widget.Flag.DisallowLayout);
    this._document = options.document || document;
    this.tabsMovable = options.tabsMovable || false;
    this.titlesEditable = options.titlesEditable || false;
    this.allowDeselect = options.allowDeselect || false;
    this.addButtonEnabled = options.addButtonEnabled || false;
    this.insertBehavior = options.insertBehavior || "select-tab-if-needed";
    this.name = options.name || "";
    this.orientation = options.orientation || "horizontal";
    this.removeBehavior = options.removeBehavior || "select-tab-after";
    this.renderer = options.renderer || TabBar.defaultRenderer;
  }
  /**
   * Dispose of the resources held by the widget.
   */
  dispose() {
    this._releaseMouse();
    this._titles.length = 0;
    this._previousTitle = null;
    super.dispose();
  }
  /**
   * A signal emitted when the current tab is changed.
   *
   * #### Notes
   * This signal is emitted when the currently selected tab is changed
   * either through user or programmatic interaction.
   *
   * Notably, this signal is not emitted when the index of the current
   * tab changes due to tabs being inserted, removed, or moved. It is
   * only emitted when the actual current tab node is changed.
   */
  get currentChanged() {
    return this._currentChanged;
  }
  /**
   * A signal emitted when a tab is moved by the user.
   *
   * #### Notes
   * This signal is emitted when a tab is moved by user interaction.
   *
   * This signal is not emitted when a tab is moved programmatically.
   */
  get tabMoved() {
    return this._tabMoved;
  }
  /**
   * A signal emitted when a tab is clicked by the user.
   *
   * #### Notes
   * If the clicked tab is not the current tab, the clicked tab will be
   * made current and the `currentChanged` signal will be emitted first.
   *
   * This signal is emitted even if the clicked tab is the current tab.
   */
  get tabActivateRequested() {
    return this._tabActivateRequested;
  }
  /**
   * A signal emitted when the tab bar add button is clicked.
   */
  get addRequested() {
    return this._addRequested;
  }
  /**
   * A signal emitted when a tab close icon is clicked.
   *
   * #### Notes
   * This signal is not emitted unless the tab title is `closable`.
   */
  get tabCloseRequested() {
    return this._tabCloseRequested;
  }
  /**
   * A signal emitted when a tab is dragged beyond the detach threshold.
   *
   * #### Notes
   * This signal is emitted when the user drags a tab with the mouse,
   * and mouse is dragged beyond the detach threshold.
   *
   * The consumer of the signal should call `releaseMouse` and remove
   * the tab in order to complete the detach.
   *
   * This signal is only emitted once per drag cycle.
   */
  get tabDetachRequested() {
    return this._tabDetachRequested;
  }
  /**
   * The document to use with the tab bar.
   *
   * The default is the global `document` instance.
   */
  get document() {
    return this._document;
  }
  /**
   * Whether the titles can be user-edited.
   *
   */
  get titlesEditable() {
    return this._titlesEditable;
  }
  /**
   * Set whether titles can be user edited.
   *
   */
  set titlesEditable(value) {
    this._titlesEditable = value;
  }
  /**
   * Get the currently selected title.
   *
   * #### Notes
   * This will be `null` if no tab is selected.
   */
  get currentTitle() {
    return this._titles[this._currentIndex] || null;
  }
  /**
   * Set the currently selected title.
   *
   * #### Notes
   * If the title does not exist, the title will be set to `null`.
   */
  set currentTitle(value) {
    this.currentIndex = value ? this._titles.indexOf(value) : -1;
  }
  /**
   * Get the index of the currently selected tab.
   *
   * #### Notes
   * This will be `-1` if no tab is selected.
   */
  get currentIndex() {
    return this._currentIndex;
  }
  /**
   * Set the index of the currently selected tab.
   *
   * #### Notes
   * If the value is out of range, the index will be set to `-1`.
   */
  set currentIndex(value) {
    if (value < 0 || value >= this._titles.length) {
      value = -1;
    }
    if (this._currentIndex === value) {
      return;
    }
    let pi = this._currentIndex;
    let pt = this._titles[pi] || null;
    let ci = value;
    let ct = this._titles[ci] || null;
    this._currentIndex = ci;
    this._previousTitle = pt;
    this.update();
    this._currentChanged.emit({
      previousIndex: pi,
      previousTitle: pt,
      currentIndex: ci,
      currentTitle: ct
    });
  }
  /**
   * Get the name of the tab bar.
   */
  get name() {
    return this._name;
  }
  /**
   * Set the name of the tab bar.
   */
  set name(value) {
    this._name = value;
    if (value) {
      this.contentNode.setAttribute("aria-label", value);
    } else {
      this.contentNode.removeAttribute("aria-label");
    }
  }
  /**
   * Get the orientation of the tab bar.
   *
   * #### Notes
   * This controls whether the tabs are arranged in a row or column.
   */
  get orientation() {
    return this._orientation;
  }
  /**
   * Set the orientation of the tab bar.
   *
   * #### Notes
   * This controls whether the tabs are arranged in a row or column.
   */
  set orientation(value) {
    if (this._orientation === value) {
      return;
    }
    this._releaseMouse();
    this._orientation = value;
    this.dataset["orientation"] = value;
    this.contentNode.setAttribute("aria-orientation", value);
  }
  /**
   * Whether the add button is enabled.
   */
  get addButtonEnabled() {
    return this._addButtonEnabled;
  }
  /**
   * Set whether the add button is enabled.
   */
  set addButtonEnabled(value) {
    if (this._addButtonEnabled === value) {
      return;
    }
    this._addButtonEnabled = value;
    if (value) {
      this.addButtonNode.classList.remove("lm-mod-hidden");
    } else {
      this.addButtonNode.classList.add("lm-mod-hidden");
    }
  }
  /**
   * A read-only array of the titles in the tab bar.
   */
  get titles() {
    return this._titles;
  }
  /**
   * The tab bar content node.
   *
   * #### Notes
   * This is the node which holds the tab nodes.
   *
   * Modifying this node directly can lead to undefined behavior.
   */
  get contentNode() {
    return this.node.getElementsByClassName("lm-TabBar-content")[0];
  }
  /**
   * The tab bar add button node.
   *
   * #### Notes
   * This is the node which holds the add button.
   *
   * Modifying this node directly can lead to undefined behavior.
   */
  get addButtonNode() {
    return this.node.getElementsByClassName("lm-TabBar-addButton")[0];
  }
  /**
   * Add a tab to the end of the tab bar.
   *
   * @param value - The title which holds the data for the tab,
   *   or an options object to convert to a title.
   *
   * @returns The title object added to the tab bar.
   *
   * #### Notes
   * If the title is already added to the tab bar, it will be moved.
   */
  addTab(value) {
    return this.insertTab(this._titles.length, value);
  }
  /**
   * Insert a tab into the tab bar at the specified index.
   *
   * @param index - The index at which to insert the tab.
   *
   * @param value - The title which holds the data for the tab,
   *   or an options object to convert to a title.
   *
   * @returns The title object added to the tab bar.
   *
   * #### Notes
   * The index will be clamped to the bounds of the tabs.
   *
   * If the title is already added to the tab bar, it will be moved.
   */
  insertTab(index, value) {
    this._releaseMouse();
    let title = Private$7$1.asTitle(value);
    let i2 = this._titles.indexOf(title);
    let j = Math.max(0, Math.min(index, this._titles.length));
    if (i2 === -1) {
      ArrayExt.insert(this._titles, j, title);
      title.changed.connect(this._onTitleChanged, this);
      this.update();
      this._adjustCurrentForInsert(j, title);
      return title;
    }
    if (j === this._titles.length) {
      j--;
    }
    if (i2 === j) {
      return title;
    }
    ArrayExt.move(this._titles, i2, j);
    this.update();
    this._adjustCurrentForMove(i2, j);
    return title;
  }
  /**
   * Remove a tab from the tab bar.
   *
   * @param title - The title for the tab to remove.
   *
   * #### Notes
   * This is a no-op if the title is not in the tab bar.
   */
  removeTab(title) {
    this.removeTabAt(this._titles.indexOf(title));
  }
  /**
   * Remove the tab at a given index from the tab bar.
   *
   * @param index - The index of the tab to remove.
   *
   * #### Notes
   * This is a no-op if the index is out of range.
   */
  removeTabAt(index) {
    this._releaseMouse();
    let title = ArrayExt.removeAt(this._titles, index);
    if (!title) {
      return;
    }
    title.changed.disconnect(this._onTitleChanged, this);
    if (title === this._previousTitle) {
      this._previousTitle = null;
    }
    this.update();
    this._adjustCurrentForRemove(index, title);
  }
  /**
   * Remove all tabs from the tab bar.
   */
  clearTabs() {
    if (this._titles.length === 0) {
      return;
    }
    this._releaseMouse();
    for (let title of this._titles) {
      title.changed.disconnect(this._onTitleChanged, this);
    }
    let pi = this.currentIndex;
    let pt = this.currentTitle;
    this._currentIndex = -1;
    this._previousTitle = null;
    this._titles.length = 0;
    this.update();
    if (pi === -1) {
      return;
    }
    this._currentChanged.emit({
      previousIndex: pi,
      previousTitle: pt,
      currentIndex: -1,
      currentTitle: null
    });
  }
  /**
   * Release the mouse and restore the non-dragged tab positions.
   *
   * #### Notes
   * This will cause the tab bar to stop handling mouse events and to
   * restore the tabs to their non-dragged positions.
   */
  releaseMouse() {
    this._releaseMouse();
  }
  /**
   * Handle the DOM events for the tab bar.
   *
   * @param event - The DOM event sent to the tab bar.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the tab bar's DOM node.
   *
   * This should not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "pointerdown":
        this._evtPointerDown(event2);
        break;
      case "pointermove":
        this._evtPointerMove(event2);
        break;
      case "pointerup":
        this._evtPointerUp(event2);
        break;
      case "dblclick":
        this._evtDblClick(event2);
        break;
      case "keydown":
        event2.eventPhase === Event.CAPTURING_PHASE ? this._evtKeyDownCapturing(event2) : this._evtKeyDown(event2);
        break;
      case "contextmenu":
        event2.preventDefault();
        event2.stopPropagation();
        break;
    }
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    this.node.addEventListener("pointerdown", this);
    this.node.addEventListener("dblclick", this);
    this.node.addEventListener("keydown", this);
  }
  /**
   * A message handler invoked on an `'after-detach'` message.
   */
  onAfterDetach(msg) {
    this.node.removeEventListener("pointerdown", this);
    this.node.removeEventListener("dblclick", this);
    this.node.removeEventListener("keydown", this);
    this._releaseMouse();
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   */
  onUpdateRequest(msg) {
    var _a;
    let titles = this._titles;
    let renderer = this.renderer;
    let currentTitle = this.currentTitle;
    let content = new Array(titles.length);
    const tabHandlingTabindex = (_a = this._getCurrentTabindex()) !== null && _a !== void 0 ? _a : this._currentIndex > -1 ? this._currentIndex : 0;
    for (let i2 = 0, n = titles.length; i2 < n; ++i2) {
      let title = titles[i2];
      let current = title === currentTitle;
      let zIndex = current ? n : n - i2 - 1;
      let tabIndex = tabHandlingTabindex === i2 ? 0 : -1;
      content[i2] = renderer.renderTab({ title, current, zIndex, tabIndex });
    }
    VirtualDOM.render(content, this.contentNode);
  }
  /**
   * Get the index of the tab which handles tabindex="0".
   * If the add button handles tabindex="0", -1 is returned.
   * If none of the previous handles tabindex="0", null is returned.
   */
  _getCurrentTabindex() {
    let index = null;
    const elemTabindex = this.contentNode.querySelector('li[tabindex="0"]');
    if (elemTabindex) {
      index = [...this.contentNode.children].indexOf(elemTabindex);
    } else if (this._addButtonEnabled && this.addButtonNode.getAttribute("tabindex") === "0") {
      index = -1;
    }
    return index;
  }
  /**
   * Handle the `'dblclick'` event for the tab bar.
   */
  _evtDblClick(event2) {
    if (!this.titlesEditable) {
      return;
    }
    let tabs = this.contentNode.children;
    let index = ArrayExt.findFirstIndex(tabs, (tab) => {
      return ElementExt.hitTest(tab, event2.clientX, event2.clientY);
    });
    if (index === -1) {
      return;
    }
    let title = this.titles[index];
    let label = tabs[index].querySelector(".lm-TabBar-tabLabel");
    if (label && label.contains(event2.target)) {
      let value = title.label || "";
      let oldValue = label.innerHTML;
      label.innerHTML = "";
      let input2 = document.createElement("input");
      input2.classList.add("lm-TabBar-tabInput");
      input2.value = value;
      label.appendChild(input2);
      let onblur = () => {
        input2.removeEventListener("blur", onblur);
        label.innerHTML = oldValue;
        this.node.addEventListener("keydown", this);
      };
      input2.addEventListener("dblclick", (event3) => event3.stopPropagation());
      input2.addEventListener("blur", onblur);
      input2.addEventListener("keydown", (event3) => {
        if (event3.key === "Enter") {
          if (input2.value !== "") {
            title.label = title.caption = input2.value;
          }
          onblur();
        } else if (event3.key === "Escape") {
          onblur();
        }
      });
      this.node.removeEventListener("keydown", this);
      input2.select();
      input2.focus();
      if (label.children.length > 0) {
        label.children[0].focus();
      }
    }
  }
  /**
   * Handle the `'keydown'` event for the tab bar at capturing phase.
   */
  _evtKeyDownCapturing(event2) {
    if (event2.eventPhase !== Event.CAPTURING_PHASE) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    if (event2.key === "Escape") {
      this._releaseMouse();
    }
  }
  /**
   * Handle the `'keydown'` event for the tab bar at target phase.
   */
  _evtKeyDown(event2) {
    var _a, _b, _c;
    if (event2.key === "Tab" || event2.eventPhase === Event.CAPTURING_PHASE) {
      return;
    }
    if (event2.key === "Enter" || event2.key === "Spacebar" || event2.key === " ") {
      const focusedElement = document.activeElement;
      if (this.addButtonEnabled && this.addButtonNode.contains(focusedElement)) {
        event2.preventDefault();
        event2.stopPropagation();
        this._addRequested.emit();
      } else {
        const index = ArrayExt.findFirstIndex(this.contentNode.children, (tab) => tab.contains(focusedElement));
        if (index >= 0) {
          event2.preventDefault();
          event2.stopPropagation();
          this.currentIndex = index;
        }
      }
    } else if (ARROW_KEYS.includes(event2.key)) {
      const focusable = [...this.contentNode.children];
      if (this.addButtonEnabled) {
        focusable.push(this.addButtonNode);
      }
      if (focusable.length <= 1) {
        return;
      }
      event2.preventDefault();
      event2.stopPropagation();
      let focusedIndex = focusable.indexOf(document.activeElement);
      if (focusedIndex === -1) {
        focusedIndex = this._currentIndex;
      }
      let nextFocused;
      if (event2.key === "ArrowRight" && this._orientation === "horizontal" || event2.key === "ArrowDown" && this._orientation === "vertical") {
        nextFocused = (_a = focusable[focusedIndex + 1]) !== null && _a !== void 0 ? _a : focusable[0];
      } else if (event2.key === "ArrowLeft" && this._orientation === "horizontal" || event2.key === "ArrowUp" && this._orientation === "vertical") {
        nextFocused = (_b = focusable[focusedIndex - 1]) !== null && _b !== void 0 ? _b : focusable[focusable.length - 1];
      } else if (event2.key === "Home") {
        nextFocused = focusable[0];
      } else if (event2.key === "End") {
        nextFocused = focusable[focusable.length - 1];
      }
      if (nextFocused) {
        (_c = focusable[focusedIndex]) === null || _c === void 0 ? void 0 : _c.setAttribute("tabindex", "-1");
        nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.setAttribute("tabindex", "0");
        nextFocused.focus();
      }
    }
  }
  /**
   * Handle the `'pointerdown'` event for the tab bar.
   */
  _evtPointerDown(event2) {
    if (event2.button !== 0 && event2.button !== 1) {
      return;
    }
    if (this._dragData) {
      return;
    }
    if (event2.target.classList.contains("lm-TabBar-tabInput")) {
      return;
    }
    let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event2.target);
    let tabs = this.contentNode.children;
    let index = ArrayExt.findFirstIndex(tabs, (tab) => {
      return ElementExt.hitTest(tab, event2.clientX, event2.clientY);
    });
    if (index === -1 && !addButtonClicked) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    this._dragData = {
      tab: tabs[index],
      index,
      pressX: event2.clientX,
      pressY: event2.clientY,
      tabPos: -1,
      tabSize: -1,
      tabPressPos: -1,
      targetIndex: -1,
      tabLayout: null,
      contentRect: null,
      override: null,
      dragActive: false,
      dragAborted: false,
      detachRequested: false
    };
    this.document.addEventListener("pointerup", this, true);
    if (event2.button === 1 || addButtonClicked) {
      return;
    }
    let icon = tabs[index].querySelector(this.renderer.closeIconSelector);
    if (icon && icon.contains(event2.target)) {
      return;
    }
    if (this.tabsMovable) {
      this.document.addEventListener("pointermove", this, true);
      this.document.addEventListener("keydown", this, true);
      this.document.addEventListener("contextmenu", this, true);
    }
    if (this.allowDeselect && this.currentIndex === index) {
      this.currentIndex = -1;
    } else {
      this.currentIndex = index;
    }
    if (this.currentIndex === -1) {
      return;
    }
    this._tabActivateRequested.emit({
      index: this.currentIndex,
      title: this.currentTitle
    });
  }
  /**
   * Handle the `'pointermove'` event for the tab bar.
   */
  _evtPointerMove(event2) {
    let data = this._dragData;
    if (!data) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    let tabs = this.contentNode.children;
    if (!data.dragActive && !Private$7$1.dragExceeded(data, event2)) {
      return;
    }
    if (!data.dragActive) {
      let tabRect = data.tab.getBoundingClientRect();
      if (this._orientation === "horizontal") {
        data.tabPos = data.tab.offsetLeft;
        data.tabSize = tabRect.width;
        data.tabPressPos = data.pressX - tabRect.left;
      } else {
        data.tabPos = data.tab.offsetTop;
        data.tabSize = tabRect.height;
        data.tabPressPos = data.pressY - tabRect.top;
      }
      data.tabPressOffset = {
        x: data.pressX - tabRect.left,
        y: data.pressY - tabRect.top
      };
      data.tabLayout = Private$7$1.snapTabLayout(tabs, this._orientation);
      data.contentRect = this.contentNode.getBoundingClientRect();
      data.override = Drag.overrideCursor("default");
      data.tab.classList.add("lm-mod-dragging");
      this.addClass("lm-mod-dragging");
      data.dragActive = true;
    }
    if (!data.detachRequested && Private$7$1.detachExceeded(data, event2)) {
      data.detachRequested = true;
      let index = data.index;
      let clientX = event2.clientX;
      let clientY = event2.clientY;
      let tab = tabs[index];
      let title = this._titles[index];
      this._tabDetachRequested.emit({
        index,
        title,
        tab,
        clientX,
        clientY,
        offset: data.tabPressOffset
      });
      if (data.dragAborted) {
        return;
      }
    }
    Private$7$1.layoutTabs(tabs, data, event2, this._orientation);
  }
  /**
   * Handle the `'pointerup'` event for the document.
   */
  _evtPointerUp(event2) {
    if (event2.button !== 0 && event2.button !== 1) {
      return;
    }
    const data = this._dragData;
    if (!data) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    this.document.removeEventListener("pointermove", this, true);
    this.document.removeEventListener("pointerup", this, true);
    this.document.removeEventListener("keydown", this, true);
    this.document.removeEventListener("contextmenu", this, true);
    if (!data.dragActive) {
      this._dragData = null;
      let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event2.target);
      if (addButtonClicked) {
        this._addRequested.emit(void 0);
        return;
      }
      let tabs = this.contentNode.children;
      let index = ArrayExt.findFirstIndex(tabs, (tab) => {
        return ElementExt.hitTest(tab, event2.clientX, event2.clientY);
      });
      if (index !== data.index) {
        return;
      }
      let title = this._titles[index];
      if (!title.closable) {
        return;
      }
      if (event2.button === 1) {
        this._tabCloseRequested.emit({ index, title });
        return;
      }
      let icon = tabs[index].querySelector(this.renderer.closeIconSelector);
      if (icon && icon.contains(event2.target)) {
        this._tabCloseRequested.emit({ index, title });
        return;
      }
      return;
    }
    if (event2.button !== 0) {
      return;
    }
    Private$7$1.finalizeTabPosition(data, this._orientation);
    data.tab.classList.remove("lm-mod-dragging");
    let duration = Private$7$1.parseTransitionDuration(data.tab);
    setTimeout(() => {
      if (data.dragAborted) {
        return;
      }
      this._dragData = null;
      Private$7$1.resetTabPositions(this.contentNode.children, this._orientation);
      data.override.dispose();
      this.removeClass("lm-mod-dragging");
      let i2 = data.index;
      let j = data.targetIndex;
      if (j === -1 || i2 === j) {
        return;
      }
      ArrayExt.move(this._titles, i2, j);
      this._adjustCurrentForMove(i2, j);
      this._tabMoved.emit({
        fromIndex: i2,
        toIndex: j,
        title: this._titles[j]
      });
      MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);
    }, duration);
  }
  /**
   * Release the mouse and restore the non-dragged tab positions.
   */
  _releaseMouse() {
    let data = this._dragData;
    if (!data) {
      return;
    }
    this._dragData = null;
    this.document.removeEventListener("pointermove", this, true);
    this.document.removeEventListener("pointerup", this, true);
    this.document.removeEventListener("keydown", this, true);
    this.document.removeEventListener("contextmenu", this, true);
    data.dragAborted = true;
    if (!data.dragActive) {
      return;
    }
    Private$7$1.resetTabPositions(this.contentNode.children, this._orientation);
    data.override.dispose();
    data.tab.classList.remove("lm-mod-dragging");
    this.removeClass("lm-mod-dragging");
  }
  /**
   * Adjust the current index for a tab insert operation.
   *
   * This method accounts for the tab bar's insertion behavior when
   * adjusting the current index and emitting the changed signal.
   */
  _adjustCurrentForInsert(i2, title) {
    let ct = this.currentTitle;
    let ci = this._currentIndex;
    let bh = this.insertBehavior;
    if (bh === "select-tab" || bh === "select-tab-if-needed" && ci === -1) {
      this._currentIndex = i2;
      this._previousTitle = ct;
      this._currentChanged.emit({
        previousIndex: ci,
        previousTitle: ct,
        currentIndex: i2,
        currentTitle: title
      });
      return;
    }
    if (ci >= i2) {
      this._currentIndex++;
    }
  }
  /**
   * Adjust the current index for a tab move operation.
   *
   * This method will not cause the actual current tab to change.
   * It silently adjusts the index to account for the given move.
   */
  _adjustCurrentForMove(i2, j) {
    if (this._currentIndex === i2) {
      this._currentIndex = j;
    } else if (this._currentIndex < i2 && this._currentIndex >= j) {
      this._currentIndex++;
    } else if (this._currentIndex > i2 && this._currentIndex <= j) {
      this._currentIndex--;
    }
  }
  /**
   * Adjust the current index for a tab remove operation.
   *
   * This method accounts for the tab bar's remove behavior when
   * adjusting the current index and emitting the changed signal.
   */
  _adjustCurrentForRemove(i2, title) {
    let ci = this._currentIndex;
    let bh = this.removeBehavior;
    if (ci !== i2) {
      if (ci > i2) {
        this._currentIndex--;
      }
      return;
    }
    if (this._titles.length === 0) {
      this._currentIndex = -1;
      this._currentChanged.emit({
        previousIndex: i2,
        previousTitle: title,
        currentIndex: -1,
        currentTitle: null
      });
      return;
    }
    if (bh === "select-tab-after") {
      this._currentIndex = Math.min(i2, this._titles.length - 1);
      this._currentChanged.emit({
        previousIndex: i2,
        previousTitle: title,
        currentIndex: this._currentIndex,
        currentTitle: this.currentTitle
      });
      return;
    }
    if (bh === "select-tab-before") {
      this._currentIndex = Math.max(0, i2 - 1);
      this._currentChanged.emit({
        previousIndex: i2,
        previousTitle: title,
        currentIndex: this._currentIndex,
        currentTitle: this.currentTitle
      });
      return;
    }
    if (bh === "select-previous-tab") {
      if (this._previousTitle) {
        this._currentIndex = this._titles.indexOf(this._previousTitle);
        this._previousTitle = null;
      } else {
        this._currentIndex = Math.min(i2, this._titles.length - 1);
      }
      this._currentChanged.emit({
        previousIndex: i2,
        previousTitle: title,
        currentIndex: this._currentIndex,
        currentTitle: this.currentTitle
      });
      return;
    }
    this._currentIndex = -1;
    this._currentChanged.emit({
      previousIndex: i2,
      previousTitle: title,
      currentIndex: -1,
      currentTitle: null
    });
  }
  /**
   * Handle the `changed` signal of a title object.
   */
  _onTitleChanged(sender) {
    this.update();
  }
}
(function(TabBar2) {
  class Renderer {
    constructor() {
      this.closeIconSelector = ".lm-TabBar-tabCloseIcon";
      this._tabID = 0;
      this._tabKeys = /* @__PURE__ */ new WeakMap();
      this._uuid = ++Renderer._nInstance;
    }
    /**
     * Render the virtual element for a tab.
     *
     * @param data - The data to use for rendering the tab.
     *
     * @returns A virtual element representing the tab.
     */
    renderTab(data) {
      let title = data.title.caption;
      let key2 = this.createTabKey(data);
      let id = key2;
      let style2 = this.createTabStyle(data);
      let className = this.createTabClass(data);
      let dataset = this.createTabDataset(data);
      let aria = this.createTabARIA(data);
      if (data.title.closable) {
        return h.li({ id, key: key2, className, title, style: style2, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data), this.renderCloseIcon(data));
      } else {
        return h.li({ id, key: key2, className, title, style: style2, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data));
      }
    }
    /**
     * Render the icon element for a tab.
     *
     * @param data - The data to use for rendering the tab.
     *
     * @returns A virtual element representing the tab icon.
     */
    renderIcon(data) {
      const { title } = data;
      let className = this.createIconClass(data);
      return h.div({ className }, title.icon, title.iconLabel);
    }
    /**
     * Render the label element for a tab.
     *
     * @param data - The data to use for rendering the tab.
     *
     * @returns A virtual element representing the tab label.
     */
    renderLabel(data) {
      return h.div({ className: "lm-TabBar-tabLabel" }, data.title.label);
    }
    /**
     * Render the close icon element for a tab.
     *
     * @param data - The data to use for rendering the tab.
     *
     * @returns A virtual element representing the tab close icon.
     */
    renderCloseIcon(data) {
      return h.div({ className: "lm-TabBar-tabCloseIcon" });
    }
    /**
     * Create a unique render key for the tab.
     *
     * @param data - The data to use for the tab.
     *
     * @returns The unique render key for the tab.
     *
     * #### Notes
     * This method caches the key against the tab title the first time
     * the key is generated. This enables efficient rendering of moved
     * tabs and avoids subtle hover style artifacts.
     */
    createTabKey(data) {
      let key2 = this._tabKeys.get(data.title);
      if (key2 === void 0) {
        key2 = `tab-key-${this._uuid}-${this._tabID++}`;
        this._tabKeys.set(data.title, key2);
      }
      return key2;
    }
    /**
     * Create the inline style object for a tab.
     *
     * @param data - The data to use for the tab.
     *
     * @returns The inline style data for the tab.
     */
    createTabStyle(data) {
      return { zIndex: `${data.zIndex}` };
    }
    /**
     * Create the class name for the tab.
     *
     * @param data - The data to use for the tab.
     *
     * @returns The full class name for the tab.
     */
    createTabClass(data) {
      let name2 = "lm-TabBar-tab";
      if (data.title.className) {
        name2 += ` ${data.title.className}`;
      }
      if (data.title.closable) {
        name2 += " lm-mod-closable";
      }
      if (data.current) {
        name2 += " lm-mod-current";
      }
      return name2;
    }
    /**
     * Create the dataset for a tab.
     *
     * @param data - The data to use for the tab.
     *
     * @returns The dataset for the tab.
     */
    createTabDataset(data) {
      return data.title.dataset;
    }
    /**
     * Create the ARIA attributes for a tab.
     *
     * @param data - The data to use for the tab.
     *
     * @returns The ARIA attributes for the tab.
     */
    createTabARIA(data) {
      var _a;
      return {
        role: "tab",
        "aria-selected": data.current.toString(),
        tabindex: `${(_a = data.tabIndex) !== null && _a !== void 0 ? _a : "-1"}`
      };
    }
    /**
     * Create the class name for the tab icon.
     *
     * @param data - The data to use for the tab.
     *
     * @returns The full class name for the tab icon.
     */
    createIconClass(data) {
      let name2 = "lm-TabBar-tabIcon";
      let extra = data.title.iconClass;
      return extra ? `${name2} ${extra}` : name2;
    }
  }
  Renderer._nInstance = 0;
  TabBar2.Renderer = Renderer;
  TabBar2.defaultRenderer = new Renderer();
  TabBar2.addButtonSelector = ".lm-TabBar-addButton";
})(TabBar || (TabBar = {}));
var Private$7$1;
(function(Private2) {
  Private2.DRAG_THRESHOLD = 5;
  Private2.DETACH_THRESHOLD = 20;
  function createNode() {
    let node2 = document.createElement("div");
    let content = document.createElement("ul");
    content.setAttribute("role", "tablist");
    content.className = "lm-TabBar-content";
    node2.appendChild(content);
    let add = document.createElement("div");
    add.className = "lm-TabBar-addButton lm-mod-hidden";
    add.setAttribute("tabindex", "-1");
    add.setAttribute("role", "button");
    node2.appendChild(add);
    return node2;
  }
  Private2.createNode = createNode;
  function asTitle(value) {
    return value instanceof Title ? value : new Title(value);
  }
  Private2.asTitle = asTitle;
  function parseTransitionDuration(tab) {
    let style2 = window.getComputedStyle(tab);
    return 1e3 * (parseFloat(style2.transitionDuration) || 0);
  }
  Private2.parseTransitionDuration = parseTransitionDuration;
  function snapTabLayout(tabs, orientation) {
    let layout = new Array(tabs.length);
    for (let i2 = 0, n = tabs.length; i2 < n; ++i2) {
      let node2 = tabs[i2];
      let style2 = window.getComputedStyle(node2);
      if (orientation === "horizontal") {
        layout[i2] = {
          pos: node2.offsetLeft,
          size: node2.offsetWidth,
          margin: parseFloat(style2.marginLeft) || 0
        };
      } else {
        layout[i2] = {
          pos: node2.offsetTop,
          size: node2.offsetHeight,
          margin: parseFloat(style2.marginTop) || 0
        };
      }
    }
    return layout;
  }
  Private2.snapTabLayout = snapTabLayout;
  function dragExceeded(data, event2) {
    let dx = Math.abs(event2.clientX - data.pressX);
    let dy = Math.abs(event2.clientY - data.pressY);
    return dx >= Private2.DRAG_THRESHOLD || dy >= Private2.DRAG_THRESHOLD;
  }
  Private2.dragExceeded = dragExceeded;
  function detachExceeded(data, event2) {
    let rect = data.contentRect;
    return event2.clientX < rect.left - Private2.DETACH_THRESHOLD || event2.clientX >= rect.right + Private2.DETACH_THRESHOLD || event2.clientY < rect.top - Private2.DETACH_THRESHOLD || event2.clientY >= rect.bottom + Private2.DETACH_THRESHOLD;
  }
  Private2.detachExceeded = detachExceeded;
  function layoutTabs(tabs, data, event2, orientation) {
    let pressPos;
    let localPos;
    let clientPos;
    let clientSize;
    if (orientation === "horizontal") {
      pressPos = data.pressX;
      localPos = event2.clientX - data.contentRect.left;
      clientPos = event2.clientX;
      clientSize = data.contentRect.width;
    } else {
      pressPos = data.pressY;
      localPos = event2.clientY - data.contentRect.top;
      clientPos = event2.clientY;
      clientSize = data.contentRect.height;
    }
    let targetIndex = data.index;
    let targetPos = localPos - data.tabPressPos;
    let targetEnd = targetPos + data.tabSize;
    for (let i2 = 0, n = tabs.length; i2 < n; ++i2) {
      let pxPos;
      let layout = data.tabLayout[i2];
      let threshold = layout.pos + (layout.size >> 1);
      if (i2 < data.index && targetPos < threshold) {
        pxPos = `${data.tabSize + data.tabLayout[i2 + 1].margin}px`;
        targetIndex = Math.min(targetIndex, i2);
      } else if (i2 > data.index && targetEnd > threshold) {
        pxPos = `${-data.tabSize - layout.margin}px`;
        targetIndex = Math.max(targetIndex, i2);
      } else if (i2 === data.index) {
        let ideal = clientPos - pressPos;
        let limit2 = clientSize - (data.tabPos + data.tabSize);
        pxPos = `${Math.max(-data.tabPos, Math.min(ideal, limit2))}px`;
      } else {
        pxPos = "";
      }
      if (orientation === "horizontal") {
        tabs[i2].style.left = pxPos;
      } else {
        tabs[i2].style.top = pxPos;
      }
    }
    data.targetIndex = targetIndex;
  }
  Private2.layoutTabs = layoutTabs;
  function finalizeTabPosition(data, orientation) {
    let clientSize;
    if (orientation === "horizontal") {
      clientSize = data.contentRect.width;
    } else {
      clientSize = data.contentRect.height;
    }
    let ideal;
    if (data.targetIndex === data.index) {
      ideal = 0;
    } else if (data.targetIndex > data.index) {
      let tgt = data.tabLayout[data.targetIndex];
      ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;
    } else {
      let tgt = data.tabLayout[data.targetIndex];
      ideal = tgt.pos - data.tabPos;
    }
    let limit2 = clientSize - (data.tabPos + data.tabSize);
    let final = Math.max(-data.tabPos, Math.min(ideal, limit2));
    if (orientation === "horizontal") {
      data.tab.style.left = `${final}px`;
    } else {
      data.tab.style.top = `${final}px`;
    }
  }
  Private2.finalizeTabPosition = finalizeTabPosition;
  function resetTabPositions(tabs, orientation) {
    for (const tab of tabs) {
      if (orientation === "horizontal") {
        tab.style.left = "";
      } else {
        tab.style.top = "";
      }
    }
  }
  Private2.resetTabPositions = resetTabPositions;
})(Private$7$1 || (Private$7$1 = {}));
class DockLayout extends Layout {
  /**
   * Construct a new dock layout.
   *
   * @param options - The options for initializing the layout.
   */
  constructor(options) {
    super();
    this._spacing = 4;
    this._dirty = false;
    this._root = null;
    this._box = null;
    this._items = /* @__PURE__ */ new Map();
    this.renderer = options.renderer;
    if (options.spacing !== void 0) {
      this._spacing = Utils$1.clampDimension(options.spacing);
    }
    this._document = options.document || document;
    this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget.HiddenMode.Display;
  }
  /**
   * Dispose of the resources held by the layout.
   *
   * #### Notes
   * This will clear and dispose all widgets in the layout.
   */
  dispose() {
    let widgets = this[Symbol.iterator]();
    this._items.forEach((item) => {
      item.dispose();
    });
    this._box = null;
    this._root = null;
    this._items.clear();
    for (const widget of widgets) {
      widget.dispose();
    }
    super.dispose();
  }
  /**
   * The method for hiding child widgets.
   *
   * #### Notes
   * If there is only one child widget, `Display` hiding mode will be used
   * regardless of this setting.
   */
  get hiddenMode() {
    return this._hiddenMode;
  }
  set hiddenMode(v) {
    if (this._hiddenMode === v) {
      return;
    }
    this._hiddenMode = v;
    for (const bar of this.tabBars()) {
      if (bar.titles.length > 1) {
        for (const title of bar.titles) {
          title.owner.hiddenMode = this._hiddenMode;
        }
      }
    }
  }
  /**
   * Get the inter-element spacing for the dock layout.
   */
  get spacing() {
    return this._spacing;
  }
  /**
   * Set the inter-element spacing for the dock layout.
   */
  set spacing(value) {
    value = Utils$1.clampDimension(value);
    if (this._spacing === value) {
      return;
    }
    this._spacing = value;
    if (!this.parent) {
      return;
    }
    this.parent.fit();
  }
  /**
   * Whether the dock layout is empty.
   */
  get isEmpty() {
    return this._root === null;
  }
  /**
   * Create an iterator over all widgets in the layout.
   *
   * @returns A new iterator over the widgets in the layout.
   *
   * #### Notes
   * This iterator includes the generated tab bars.
   */
  [Symbol.iterator]() {
    return this._root ? this._root.iterAllWidgets() : empty();
  }
  /**
   * Create an iterator over the user widgets in the layout.
   *
   * @returns A new iterator over the user widgets in the layout.
   *
   * #### Notes
   * This iterator does not include the generated tab bars.
   */
  widgets() {
    return this._root ? this._root.iterUserWidgets() : empty();
  }
  /**
   * Create an iterator over the selected widgets in the layout.
   *
   * @returns A new iterator over the selected user widgets.
   *
   * #### Notes
   * This iterator yields the widgets corresponding to the current tab
   * of each tab bar in the layout.
   */
  selectedWidgets() {
    return this._root ? this._root.iterSelectedWidgets() : empty();
  }
  /**
   * Create an iterator over the tab bars in the layout.
   *
   * @returns A new iterator over the tab bars in the layout.
   *
   * #### Notes
   * This iterator does not include the user widgets.
   */
  tabBars() {
    return this._root ? this._root.iterTabBars() : empty();
  }
  /**
   * Create an iterator over the handles in the layout.
   *
   * @returns A new iterator over the handles in the layout.
   */
  handles() {
    return this._root ? this._root.iterHandles() : empty();
  }
  /**
   * Move a handle to the given offset position.
   *
   * @param handle - The handle to move.
   *
   * @param offsetX - The desired offset X position of the handle.
   *
   * @param offsetY - The desired offset Y position of the handle.
   *
   * #### Notes
   * If the given handle is not contained in the layout, this is no-op.
   *
   * The handle will be moved as close as possible to the desired
   * position without violating any of the layout constraints.
   *
   * Only one of the coordinates is used depending on the orientation
   * of the handle. This method accepts both coordinates to make it
   * easy to invoke from a mouse move event without needing to know
   * the handle orientation.
   */
  moveHandle(handle, offsetX, offsetY) {
    let hidden2 = handle.classList.contains("lm-mod-hidden");
    if (!this._root || hidden2) {
      return;
    }
    let data = this._root.findSplitNode(handle);
    if (!data) {
      return;
    }
    let delta;
    if (data.node.orientation === "horizontal") {
      delta = offsetX - handle.offsetLeft;
    } else {
      delta = offsetY - handle.offsetTop;
    }
    if (delta === 0) {
      return;
    }
    data.node.holdSizes();
    BoxEngine.adjust(data.node.sizers, data.index, delta);
    if (this.parent) {
      this.parent.update();
    }
  }
  /**
   * Save the current configuration of the dock layout.
   *
   * @returns A new config object for the current layout state.
   *
   * #### Notes
   * The return value can be provided to the `restoreLayout` method
   * in order to restore the layout to its current configuration.
   */
  saveLayout() {
    if (!this._root) {
      return { main: null };
    }
    this._root.holdAllSizes();
    return { main: this._root.createConfig() };
  }
  /**
   * Restore the layout to a previously saved configuration.
   *
   * @param config - The layout configuration to restore.
   *
   * #### Notes
   * Widgets which currently belong to the layout but which are not
   * contained in the config will be unparented.
   */
  restoreLayout(config2) {
    let widgetSet = /* @__PURE__ */ new Set();
    let mainConfig;
    if (config2.main) {
      mainConfig = Private$6$1.normalizeAreaConfig(config2.main, widgetSet);
    } else {
      mainConfig = null;
    }
    let oldWidgets = this.widgets();
    let oldTabBars = this.tabBars();
    let oldHandles = this.handles();
    this._root = null;
    for (const widget of oldWidgets) {
      if (!widgetSet.has(widget)) {
        widget.parent = null;
      }
    }
    for (const tabBar of oldTabBars) {
      tabBar.dispose();
    }
    for (const handle of oldHandles) {
      if (handle.parentNode) {
        handle.parentNode.removeChild(handle);
      }
    }
    for (const widget of widgetSet) {
      widget.parent = this.parent;
    }
    if (mainConfig) {
      this._root = Private$6$1.realizeAreaConfig(mainConfig, {
        // Ignoring optional `document` argument as we must reuse `this._document`
        createTabBar: (document2) => this._createTabBar(),
        createHandle: () => this._createHandle()
      }, this._document);
    } else {
      this._root = null;
    }
    if (!this.parent) {
      return;
    }
    widgetSet.forEach((widget) => {
      this.attachWidget(widget);
    });
    this.parent.fit();
  }
  /**
   * Add a widget to the dock layout.
   *
   * @param widget - The widget to add to the dock layout.
   *
   * @param options - The additional options for adding the widget.
   *
   * #### Notes
   * The widget will be moved if it is already contained in the layout.
   *
   * An error will be thrown if the reference widget is invalid.
   */
  addWidget(widget, options = {}) {
    let ref2 = options.ref || null;
    let mode = options.mode || "tab-after";
    let refNode = null;
    if (this._root && ref2) {
      refNode = this._root.findTabNode(ref2);
    }
    if (ref2 && !refNode) {
      throw new Error("Reference widget is not in the layout.");
    }
    widget.parent = this.parent;
    switch (mode) {
      case "tab-after":
        this._insertTab(widget, ref2, refNode, true);
        break;
      case "tab-before":
        this._insertTab(widget, ref2, refNode, false);
        break;
      case "split-top":
        this._insertSplit(widget, ref2, refNode, "vertical", false);
        break;
      case "split-left":
        this._insertSplit(widget, ref2, refNode, "horizontal", false);
        break;
      case "split-right":
        this._insertSplit(widget, ref2, refNode, "horizontal", true);
        break;
      case "split-bottom":
        this._insertSplit(widget, ref2, refNode, "vertical", true);
        break;
      case "merge-top":
        this._insertSplit(widget, ref2, refNode, "vertical", false, true);
        break;
      case "merge-left":
        this._insertSplit(widget, ref2, refNode, "horizontal", false, true);
        break;
      case "merge-right":
        this._insertSplit(widget, ref2, refNode, "horizontal", true, true);
        break;
      case "merge-bottom":
        this._insertSplit(widget, ref2, refNode, "vertical", true, true);
        break;
    }
    if (!this.parent) {
      return;
    }
    this.attachWidget(widget);
    this.parent.fit();
  }
  /**
   * Remove a widget from the layout.
   *
   * @param widget - The widget to remove from the layout.
   *
   * #### Notes
   * A widget is automatically removed from the layout when its `parent`
   * is set to `null`. This method should only be invoked directly when
   * removing a widget from a layout which has yet to be installed on a
   * parent widget.
   *
   * This method does *not* modify the widget's `parent`.
   */
  removeWidget(widget) {
    this._removeWidget(widget);
    if (!this.parent) {
      return;
    }
    this.detachWidget(widget);
    this.parent.fit();
  }
  /**
   * Find the tab area which contains the given client position.
   *
   * @param clientX - The client X position of interest.
   *
   * @param clientY - The client Y position of interest.
   *
   * @returns The geometry of the tab area at the given position, or
   *   `null` if there is no tab area at the given position.
   */
  hitTestTabAreas(clientX, clientY) {
    if (!this._root || !this.parent || !this.parent.isVisible) {
      return null;
    }
    if (!this._box) {
      this._box = ElementExt.boxSizing(this.parent.node);
    }
    let rect = this.parent.node.getBoundingClientRect();
    let x2 = clientX - rect.left - this._box.borderLeft;
    let y = clientY - rect.top - this._box.borderTop;
    let tabNode = this._root.hitTestTabNodes(x2, y);
    if (!tabNode) {
      return null;
    }
    let { tabBar, top: top2, left, width, height } = tabNode;
    let borderWidth = this._box.borderLeft + this._box.borderRight;
    let borderHeight = this._box.borderTop + this._box.borderBottom;
    let right = rect.width - borderWidth - (left + width);
    let bottom = rect.height - borderHeight - (top2 + height);
    return { tabBar, x: x2, y, top: top2, left, right, bottom, width, height };
  }
  /**
   * Perform layout initialization which requires the parent widget.
   */
  init() {
    super.init();
    for (const widget of this) {
      this.attachWidget(widget);
    }
    for (const handle of this.handles()) {
      this.parent.node.appendChild(handle);
    }
    this.parent.fit();
  }
  /**
   * Attach the widget to the layout parent widget.
   *
   * @param widget - The widget to attach to the parent.
   *
   * #### Notes
   * This is a no-op if the widget is already attached.
   */
  attachWidget(widget) {
    if (this.parent.node === widget.node.parentNode) {
      return;
    }
    this._items.set(widget, new LayoutItem(widget));
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
    }
    this.parent.node.appendChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
    }
  }
  /**
   * Detach the widget from the layout parent widget.
   *
   * @param widget - The widget to detach from the parent.
   *
   * #### Notes
   * This is a no-op if the widget is not attached.
   */
  detachWidget(widget) {
    if (this.parent.node !== widget.node.parentNode) {
      return;
    }
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
    }
    this.parent.node.removeChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
    }
    let item = this._items.get(widget);
    if (item) {
      this._items.delete(widget);
      item.dispose();
    }
  }
  /**
   * A message handler invoked on a `'before-show'` message.
   */
  onBeforeShow(msg) {
    super.onBeforeShow(msg);
    this.parent.update();
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    super.onBeforeAttach(msg);
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-shown'` message.
   */
  onChildShown(msg) {
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-hidden'` message.
   */
  onChildHidden(msg) {
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'resize'` message.
   */
  onResize(msg) {
    if (this.parent.isVisible) {
      this._update(msg.width, msg.height);
    }
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   */
  onUpdateRequest(msg) {
    if (this.parent.isVisible) {
      this._update(-1, -1);
    }
  }
  /**
   * A message handler invoked on a `'fit-request'` message.
   */
  onFitRequest(msg) {
    if (this.parent.isAttached) {
      this._fit();
    }
  }
  /**
   * Remove the specified widget from the layout structure.
   *
   * #### Notes
   * This is a no-op if the widget is not in the layout tree.
   *
   * This does not detach the widget from the parent node.
   */
  _removeWidget(widget) {
    if (!this._root) {
      return;
    }
    let tabNode = this._root.findTabNode(widget);
    if (!tabNode) {
      return;
    }
    Private$6$1.removeAria(widget);
    if (tabNode.tabBar.titles.length > 1) {
      tabNode.tabBar.removeTab(widget.title);
      if (this._hiddenMode === Widget.HiddenMode.Scale && tabNode.tabBar.titles.length == 1) {
        const existingWidget = tabNode.tabBar.titles[0].owner;
        existingWidget.hiddenMode = Widget.HiddenMode.Display;
      }
      return;
    }
    tabNode.tabBar.dispose();
    if (this._root === tabNode) {
      this._root = null;
      return;
    }
    this._root.holdAllSizes();
    let splitNode = tabNode.parent;
    tabNode.parent = null;
    let i2 = ArrayExt.removeFirstOf(splitNode.children, tabNode);
    let handle = ArrayExt.removeAt(splitNode.handles, i2);
    ArrayExt.removeAt(splitNode.sizers, i2);
    if (handle.parentNode) {
      handle.parentNode.removeChild(handle);
    }
    if (splitNode.children.length > 1) {
      splitNode.syncHandles();
      return;
    }
    let maybeParent = splitNode.parent;
    splitNode.parent = null;
    let childNode = splitNode.children[0];
    let childHandle = splitNode.handles[0];
    splitNode.children.length = 0;
    splitNode.handles.length = 0;
    splitNode.sizers.length = 0;
    if (childHandle.parentNode) {
      childHandle.parentNode.removeChild(childHandle);
    }
    if (this._root === splitNode) {
      childNode.parent = null;
      this._root = childNode;
      return;
    }
    let parentNode = maybeParent;
    let j = parentNode.children.indexOf(splitNode);
    if (childNode instanceof Private$6$1.TabLayoutNode) {
      childNode.parent = parentNode;
      parentNode.children[j] = childNode;
      return;
    }
    let splitHandle = ArrayExt.removeAt(parentNode.handles, j);
    ArrayExt.removeAt(parentNode.children, j);
    ArrayExt.removeAt(parentNode.sizers, j);
    if (splitHandle.parentNode) {
      splitHandle.parentNode.removeChild(splitHandle);
    }
    for (let i3 = 0, n = childNode.children.length; i3 < n; ++i3) {
      let gChild = childNode.children[i3];
      let gHandle = childNode.handles[i3];
      let gSizer = childNode.sizers[i3];
      ArrayExt.insert(parentNode.children, j + i3, gChild);
      ArrayExt.insert(parentNode.handles, j + i3, gHandle);
      ArrayExt.insert(parentNode.sizers, j + i3, gSizer);
      gChild.parent = parentNode;
    }
    childNode.children.length = 0;
    childNode.handles.length = 0;
    childNode.sizers.length = 0;
    childNode.parent = null;
    parentNode.syncHandles();
  }
  /**
   * Create the tab layout node to hold the widget.
   */
  _createTabNode(widget) {
    let tabNode = new Private$6$1.TabLayoutNode(this._createTabBar());
    tabNode.tabBar.addTab(widget.title);
    Private$6$1.addAria(widget, tabNode.tabBar);
    return tabNode;
  }
  /**
   * Insert a widget next to an existing tab.
   *
   * #### Notes
   * This does not attach the widget to the parent widget.
   */
  _insertTab(widget, ref2, refNode, after) {
    if (widget === ref2) {
      return;
    }
    if (!this._root) {
      let tabNode = new Private$6$1.TabLayoutNode(this._createTabBar());
      tabNode.tabBar.addTab(widget.title);
      this._root = tabNode;
      Private$6$1.addAria(widget, tabNode.tabBar);
      return;
    }
    if (!refNode) {
      refNode = this._root.findFirstTabNode();
    }
    if (refNode.tabBar.titles.indexOf(widget.title) === -1) {
      this._removeWidget(widget);
      widget.hide();
    }
    let index;
    if (ref2) {
      index = refNode.tabBar.titles.indexOf(ref2.title);
    } else {
      index = refNode.tabBar.currentIndex;
    }
    if (this._hiddenMode === Widget.HiddenMode.Scale) {
      if (refNode.tabBar.titles.length === 0) {
        widget.hiddenMode = Widget.HiddenMode.Display;
      } else if (refNode.tabBar.titles.length == 1) {
        const existingWidget = refNode.tabBar.titles[0].owner;
        existingWidget.hiddenMode = Widget.HiddenMode.Scale;
      } else {
        widget.hiddenMode = Widget.HiddenMode.Scale;
      }
    } else {
      widget.hiddenMode = this._hiddenMode;
    }
    refNode.tabBar.insertTab(index + (after ? 1 : 0), widget.title);
    Private$6$1.addAria(widget, refNode.tabBar);
  }
  /**
   * Insert a widget as a new split area.
   *
   * #### Notes
   * This does not attach the widget to the parent widget.
   */
  _insertSplit(widget, ref2, refNode, orientation, after, merge = false) {
    if (widget === ref2 && refNode && refNode.tabBar.titles.length === 1) {
      return;
    }
    this._removeWidget(widget);
    if (!this._root) {
      this._root = this._createTabNode(widget);
      return;
    }
    if (!refNode || !refNode.parent) {
      let root2 = this._splitRoot(orientation);
      let i3 = after ? root2.children.length : 0;
      root2.normalizeSizes();
      let sizer = Private$6$1.createSizer(refNode ? 1 : Private$6$1.GOLDEN_RATIO);
      let tabNode2 = this._createTabNode(widget);
      ArrayExt.insert(root2.children, i3, tabNode2);
      ArrayExt.insert(root2.sizers, i3, sizer);
      ArrayExt.insert(root2.handles, i3, this._createHandle());
      tabNode2.parent = root2;
      root2.normalizeSizes();
      root2.syncHandles();
      return;
    }
    let splitNode = refNode.parent;
    if (splitNode.orientation === orientation) {
      let i3 = splitNode.children.indexOf(refNode);
      if (merge) {
        let j3 = i3 + (after ? 1 : -1);
        let sibling = splitNode.children[j3];
        if (sibling instanceof Private$6$1.TabLayoutNode) {
          this._insertTab(widget, null, sibling, true);
          ++sibling.tabBar.currentIndex;
          return;
        }
      }
      splitNode.normalizeSizes();
      let s = splitNode.sizers[i3].sizeHint /= 2;
      let j2 = i3 + (after ? 1 : 0);
      let tabNode2 = this._createTabNode(widget);
      ArrayExt.insert(splitNode.children, j2, tabNode2);
      ArrayExt.insert(splitNode.sizers, j2, Private$6$1.createSizer(s));
      ArrayExt.insert(splitNode.handles, j2, this._createHandle());
      tabNode2.parent = splitNode;
      splitNode.syncHandles();
      return;
    }
    let i2 = ArrayExt.removeFirstOf(splitNode.children, refNode);
    let childNode = new Private$6$1.SplitLayoutNode(orientation);
    childNode.normalized = true;
    childNode.children.push(refNode);
    childNode.sizers.push(Private$6$1.createSizer(0.5));
    childNode.handles.push(this._createHandle());
    refNode.parent = childNode;
    let j = after ? 1 : 0;
    let tabNode = this._createTabNode(widget);
    ArrayExt.insert(childNode.children, j, tabNode);
    ArrayExt.insert(childNode.sizers, j, Private$6$1.createSizer(0.5));
    ArrayExt.insert(childNode.handles, j, this._createHandle());
    tabNode.parent = childNode;
    childNode.syncHandles();
    ArrayExt.insert(splitNode.children, i2, childNode);
    childNode.parent = splitNode;
  }
  /**
   * Ensure the root is a split node with the given orientation.
   */
  _splitRoot(orientation) {
    let oldRoot = this._root;
    if (oldRoot instanceof Private$6$1.SplitLayoutNode) {
      if (oldRoot.orientation === orientation) {
        return oldRoot;
      }
    }
    let newRoot = this._root = new Private$6$1.SplitLayoutNode(orientation);
    if (oldRoot) {
      newRoot.children.push(oldRoot);
      newRoot.sizers.push(Private$6$1.createSizer(0));
      newRoot.handles.push(this._createHandle());
      oldRoot.parent = newRoot;
    }
    return newRoot;
  }
  /**
   * Fit the layout to the total size required by the widgets.
   */
  _fit() {
    let minW = 0;
    let minH = 0;
    if (this._root) {
      let limits = this._root.fit(this._spacing, this._items);
      minW = limits.minWidth;
      minH = limits.minHeight;
    }
    let box = this._box = ElementExt.boxSizing(this.parent.node);
    minW += box.horizontalSum;
    minH += box.verticalSum;
    let style2 = this.parent.node.style;
    style2.minWidth = `${minW}px`;
    style2.minHeight = `${minH}px`;
    this._dirty = true;
    if (this.parent.parent) {
      MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
    }
    if (this._dirty) {
      MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
    }
  }
  /**
   * Update the layout position and size of the widgets.
   *
   * The parent offset dimensions should be `-1` if unknown.
   */
  _update(offsetWidth, offsetHeight) {
    this._dirty = false;
    if (!this._root) {
      return;
    }
    if (offsetWidth < 0) {
      offsetWidth = this.parent.node.offsetWidth;
    }
    if (offsetHeight < 0) {
      offsetHeight = this.parent.node.offsetHeight;
    }
    if (!this._box) {
      this._box = ElementExt.boxSizing(this.parent.node);
    }
    let x2 = this._box.paddingTop;
    let y = this._box.paddingLeft;
    let width = offsetWidth - this._box.horizontalSum;
    let height = offsetHeight - this._box.verticalSum;
    this._root.update(x2, y, width, height, this._spacing, this._items);
  }
  /**
   * Create a new tab bar for use by the dock layout.
   *
   * #### Notes
   * The tab bar will be attached to the parent if it exists.
   */
  _createTabBar() {
    let tabBar = this.renderer.createTabBar(this._document);
    tabBar.orientation = "horizontal";
    if (this.parent) {
      this.attachWidget(tabBar);
    }
    return tabBar;
  }
  /**
   * Create a new handle for the dock layout.
   *
   * #### Notes
   * The handle will be attached to the parent if it exists.
   */
  _createHandle() {
    let handle = this.renderer.createHandle();
    let style2 = handle.style;
    style2.position = "absolute";
    style2.contain = "strict";
    style2.top = "0";
    style2.left = "0";
    style2.width = "0";
    style2.height = "0";
    if (this.parent) {
      this.parent.node.appendChild(handle);
    }
    return handle;
  }
}
var Private$6$1;
(function(Private2) {
  Private2.GOLDEN_RATIO = 0.618;
  function createSizer(hint) {
    let sizer = new BoxSizer();
    sizer.sizeHint = hint;
    sizer.size = hint;
    return sizer;
  }
  Private2.createSizer = createSizer;
  function normalizeAreaConfig(config2, widgetSet) {
    let result2;
    if (config2.type === "tab-area") {
      result2 = normalizeTabAreaConfig(config2, widgetSet);
    } else {
      result2 = normalizeSplitAreaConfig(config2, widgetSet);
    }
    return result2;
  }
  Private2.normalizeAreaConfig = normalizeAreaConfig;
  function realizeAreaConfig(config2, renderer, document2) {
    let node2;
    if (config2.type === "tab-area") {
      node2 = realizeTabAreaConfig(config2, renderer, document2);
    } else {
      node2 = realizeSplitAreaConfig(config2, renderer, document2);
    }
    return node2;
  }
  Private2.realizeAreaConfig = realizeAreaConfig;
  class TabLayoutNode {
    /**
     * Construct a new tab layout node.
     *
     * @param tabBar - The tab bar to use for the layout node.
     */
    constructor(tabBar) {
      this.parent = null;
      this._top = 0;
      this._left = 0;
      this._width = 0;
      this._height = 0;
      let tabSizer = new BoxSizer();
      let widgetSizer = new BoxSizer();
      tabSizer.stretch = 0;
      widgetSizer.stretch = 1;
      this.tabBar = tabBar;
      this.sizers = [tabSizer, widgetSizer];
    }
    /**
     * The most recent value for the `top` edge of the layout box.
     */
    get top() {
      return this._top;
    }
    /**
     * The most recent value for the `left` edge of the layout box.
     */
    get left() {
      return this._left;
    }
    /**
     * The most recent value for the `width` of the layout box.
     */
    get width() {
      return this._width;
    }
    /**
     * The most recent value for the `height` of the layout box.
     */
    get height() {
      return this._height;
    }
    /**
     * Create an iterator for all widgets in the layout tree.
     */
    *iterAllWidgets() {
      yield this.tabBar;
      yield* this.iterUserWidgets();
    }
    /**
     * Create an iterator for the user widgets in the layout tree.
     */
    *iterUserWidgets() {
      for (const title of this.tabBar.titles) {
        yield title.owner;
      }
    }
    /**
     * Create an iterator for the selected widgets in the layout tree.
     */
    *iterSelectedWidgets() {
      let title = this.tabBar.currentTitle;
      if (title) {
        yield title.owner;
      }
    }
    /**
     * Create an iterator for the tab bars in the layout tree.
     */
    *iterTabBars() {
      yield this.tabBar;
    }
    /**
     * Create an iterator for the handles in the layout tree.
     */
    // eslint-disable-next-line require-yield
    *iterHandles() {
      return;
    }
    /**
     * Find the tab layout node which contains the given widget.
     */
    findTabNode(widget) {
      return this.tabBar.titles.indexOf(widget.title) !== -1 ? this : null;
    }
    /**
     * Find the split layout node which contains the given handle.
     */
    findSplitNode(handle) {
      return null;
    }
    /**
     * Find the first tab layout node in a layout tree.
     */
    findFirstTabNode() {
      return this;
    }
    /**
     * Find the tab layout node which contains the local point.
     */
    hitTestTabNodes(x2, y) {
      if (x2 < this._left || x2 >= this._left + this._width) {
        return null;
      }
      if (y < this._top || y >= this._top + this._height) {
        return null;
      }
      return this;
    }
    /**
     * Create a configuration object for the layout tree.
     */
    createConfig() {
      let widgets = this.tabBar.titles.map((title) => title.owner);
      let currentIndex = this.tabBar.currentIndex;
      return { type: "tab-area", widgets, currentIndex };
    }
    /**
     * Recursively hold all of the sizes in the layout tree.
     *
     * This ignores the sizers of tab layout nodes.
     */
    holdAllSizes() {
      return;
    }
    /**
     * Fit the layout tree.
     */
    fit(spacing, items) {
      let minWidth = 0;
      let minHeight = 0;
      let maxWidth = Infinity;
      let maxHeight = Infinity;
      let tabBarItem = items.get(this.tabBar);
      let current = this.tabBar.currentTitle;
      let widgetItem = current ? items.get(current.owner) : void 0;
      let [tabBarSizer, widgetSizer] = this.sizers;
      if (tabBarItem) {
        tabBarItem.fit();
      }
      if (widgetItem) {
        widgetItem.fit();
      }
      if (tabBarItem && !tabBarItem.isHidden) {
        minWidth = Math.max(minWidth, tabBarItem.minWidth);
        minHeight += tabBarItem.minHeight;
        tabBarSizer.minSize = tabBarItem.minHeight;
        tabBarSizer.maxSize = tabBarItem.maxHeight;
      } else {
        tabBarSizer.minSize = 0;
        tabBarSizer.maxSize = 0;
      }
      if (widgetItem && !widgetItem.isHidden) {
        minWidth = Math.max(minWidth, widgetItem.minWidth);
        minHeight += widgetItem.minHeight;
        widgetSizer.minSize = widgetItem.minHeight;
        widgetSizer.maxSize = Infinity;
      } else {
        widgetSizer.minSize = 0;
        widgetSizer.maxSize = Infinity;
      }
      return { minWidth, minHeight, maxWidth, maxHeight };
    }
    /**
     * Update the layout tree.
     */
    update(left, top2, width, height, spacing, items) {
      this._top = top2;
      this._left = left;
      this._width = width;
      this._height = height;
      let tabBarItem = items.get(this.tabBar);
      let current = this.tabBar.currentTitle;
      let widgetItem = current ? items.get(current.owner) : void 0;
      BoxEngine.calc(this.sizers, height);
      if (tabBarItem && !tabBarItem.isHidden) {
        let size2 = this.sizers[0].size;
        tabBarItem.update(left, top2, width, size2);
        top2 += size2;
      }
      if (widgetItem && !widgetItem.isHidden) {
        let size2 = this.sizers[1].size;
        widgetItem.update(left, top2, width, size2);
      }
    }
  }
  Private2.TabLayoutNode = TabLayoutNode;
  class SplitLayoutNode {
    /**
     * Construct a new split layout node.
     *
     * @param orientation - The orientation of the node.
     */
    constructor(orientation) {
      this.parent = null;
      this.normalized = false;
      this.children = [];
      this.sizers = [];
      this.handles = [];
      this.orientation = orientation;
    }
    /**
     * Create an iterator for all widgets in the layout tree.
     */
    *iterAllWidgets() {
      for (const child of this.children) {
        yield* child.iterAllWidgets();
      }
    }
    /**
     * Create an iterator for the user widgets in the layout tree.
     */
    *iterUserWidgets() {
      for (const child of this.children) {
        yield* child.iterUserWidgets();
      }
    }
    /**
     * Create an iterator for the selected widgets in the layout tree.
     */
    *iterSelectedWidgets() {
      for (const child of this.children) {
        yield* child.iterSelectedWidgets();
      }
    }
    /**
     * Create an iterator for the tab bars in the layout tree.
     */
    *iterTabBars() {
      for (const child of this.children) {
        yield* child.iterTabBars();
      }
    }
    /**
     * Create an iterator for the handles in the layout tree.
     */
    *iterHandles() {
      yield* this.handles;
      for (const child of this.children) {
        yield* child.iterHandles();
      }
    }
    /**
     * Find the tab layout node which contains the given widget.
     */
    findTabNode(widget) {
      for (let i2 = 0, n = this.children.length; i2 < n; ++i2) {
        let result2 = this.children[i2].findTabNode(widget);
        if (result2) {
          return result2;
        }
      }
      return null;
    }
    /**
     * Find the split layout node which contains the given handle.
     */
    findSplitNode(handle) {
      let index = this.handles.indexOf(handle);
      if (index !== -1) {
        return { index, node: this };
      }
      for (let i2 = 0, n = this.children.length; i2 < n; ++i2) {
        let result2 = this.children[i2].findSplitNode(handle);
        if (result2) {
          return result2;
        }
      }
      return null;
    }
    /**
     * Find the first tab layout node in a layout tree.
     */
    findFirstTabNode() {
      if (this.children.length === 0) {
        return null;
      }
      return this.children[0].findFirstTabNode();
    }
    /**
     * Find the tab layout node which contains the local point.
     */
    hitTestTabNodes(x2, y) {
      for (let i2 = 0, n = this.children.length; i2 < n; ++i2) {
        let result2 = this.children[i2].hitTestTabNodes(x2, y);
        if (result2) {
          return result2;
        }
      }
      return null;
    }
    /**
     * Create a configuration object for the layout tree.
     */
    createConfig() {
      let orientation = this.orientation;
      let sizes = this.createNormalizedSizes();
      let children2 = this.children.map((child) => child.createConfig());
      return { type: "split-area", orientation, children: children2, sizes };
    }
    /**
     * Sync the visibility and orientation of the handles.
     */
    syncHandles() {
      this.handles.forEach((handle, i2) => {
        handle.setAttribute("data-orientation", this.orientation);
        if (i2 === this.handles.length - 1) {
          handle.classList.add("lm-mod-hidden");
        } else {
          handle.classList.remove("lm-mod-hidden");
        }
      });
    }
    /**
     * Hold the current sizes of the box sizers.
     *
     * This sets the size hint of each sizer to its current size.
     */
    holdSizes() {
      for (const sizer of this.sizers) {
        sizer.sizeHint = sizer.size;
      }
    }
    /**
     * Recursively hold all of the sizes in the layout tree.
     *
     * This ignores the sizers of tab layout nodes.
     */
    holdAllSizes() {
      for (const child of this.children) {
        child.holdAllSizes();
      }
      this.holdSizes();
    }
    /**
     * Normalize the sizes of the split layout node.
     */
    normalizeSizes() {
      let n = this.sizers.length;
      if (n === 0) {
        return;
      }
      this.holdSizes();
      let sum = this.sizers.reduce((v, sizer) => v + sizer.sizeHint, 0);
      if (sum === 0) {
        for (const sizer of this.sizers) {
          sizer.size = sizer.sizeHint = 1 / n;
        }
      } else {
        for (const sizer of this.sizers) {
          sizer.size = sizer.sizeHint /= sum;
        }
      }
      this.normalized = true;
    }
    /**
     * Snap the normalized sizes of the split layout node.
     */
    createNormalizedSizes() {
      let n = this.sizers.length;
      if (n === 0) {
        return [];
      }
      let sizes = this.sizers.map((sizer) => sizer.size);
      let sum = sizes.reduce((v, size2) => v + size2, 0);
      if (sum === 0) {
        for (let i2 = sizes.length - 1; i2 > -1; i2--) {
          sizes[i2] = 1 / n;
        }
      } else {
        for (let i2 = sizes.length - 1; i2 > -1; i2--) {
          sizes[i2] /= sum;
        }
      }
      return sizes;
    }
    /**
     * Fit the layout tree.
     */
    fit(spacing, items) {
      let horizontal = this.orientation === "horizontal";
      let fixed = Math.max(0, this.children.length - 1) * spacing;
      let minWidth = horizontal ? fixed : 0;
      let minHeight = horizontal ? 0 : fixed;
      let maxWidth = Infinity;
      let maxHeight = Infinity;
      for (let i2 = 0, n = this.children.length; i2 < n; ++i2) {
        let limits = this.children[i2].fit(spacing, items);
        if (horizontal) {
          minHeight = Math.max(minHeight, limits.minHeight);
          minWidth += limits.minWidth;
          this.sizers[i2].minSize = limits.minWidth;
        } else {
          minWidth = Math.max(minWidth, limits.minWidth);
          minHeight += limits.minHeight;
          this.sizers[i2].minSize = limits.minHeight;
        }
      }
      return { minWidth, minHeight, maxWidth, maxHeight };
    }
    /**
     * Update the layout tree.
     */
    update(left, top2, width, height, spacing, items) {
      let horizontal = this.orientation === "horizontal";
      let fixed = Math.max(0, this.children.length - 1) * spacing;
      let space = Math.max(0, (horizontal ? width : height) - fixed);
      if (this.normalized) {
        for (const sizer of this.sizers) {
          sizer.sizeHint *= space;
        }
        this.normalized = false;
      }
      BoxEngine.calc(this.sizers, space);
      for (let i2 = 0, n = this.children.length; i2 < n; ++i2) {
        let child = this.children[i2];
        let size2 = this.sizers[i2].size;
        let handleStyle = this.handles[i2].style;
        if (horizontal) {
          child.update(left, top2, size2, height, spacing, items);
          left += size2;
          handleStyle.top = `${top2}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${spacing}px`;
          handleStyle.height = `${height}px`;
          left += spacing;
        } else {
          child.update(left, top2, width, size2, spacing, items);
          top2 += size2;
          handleStyle.top = `${top2}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${width}px`;
          handleStyle.height = `${spacing}px`;
          top2 += spacing;
        }
      }
    }
  }
  Private2.SplitLayoutNode = SplitLayoutNode;
  function addAria(widget, tabBar) {
    widget.node.setAttribute("role", "tabpanel");
    let renderer = tabBar.renderer;
    if (renderer instanceof TabBar.Renderer) {
      let tabId = renderer.createTabKey({
        title: widget.title,
        current: false,
        zIndex: 0
      });
      widget.node.setAttribute("aria-labelledby", tabId);
    }
  }
  Private2.addAria = addAria;
  function removeAria(widget) {
    widget.node.removeAttribute("role");
    widget.node.removeAttribute("aria-labelledby");
  }
  Private2.removeAria = removeAria;
  function normalizeTabAreaConfig(config2, widgetSet) {
    if (config2.widgets.length === 0) {
      return null;
    }
    let widgets = [];
    for (const widget of config2.widgets) {
      if (!widgetSet.has(widget)) {
        widgetSet.add(widget);
        widgets.push(widget);
      }
    }
    if (widgets.length === 0) {
      return null;
    }
    let index = config2.currentIndex;
    if (index !== -1 && (index < 0 || index >= widgets.length)) {
      index = 0;
    }
    return { type: "tab-area", widgets, currentIndex: index };
  }
  function normalizeSplitAreaConfig(config2, widgetSet) {
    let orientation = config2.orientation;
    let children2 = [];
    let sizes = [];
    for (let i2 = 0, n = config2.children.length; i2 < n; ++i2) {
      let child = normalizeAreaConfig(config2.children[i2], widgetSet);
      if (!child) {
        continue;
      }
      if (child.type === "tab-area" || child.orientation !== orientation) {
        children2.push(child);
        sizes.push(Math.abs(config2.sizes[i2] || 0));
      } else {
        children2.push(...child.children);
        sizes.push(...child.sizes);
      }
    }
    if (children2.length === 0) {
      return null;
    }
    if (children2.length === 1) {
      return children2[0];
    }
    return { type: "split-area", orientation, children: children2, sizes };
  }
  function realizeTabAreaConfig(config2, renderer, document2) {
    let tabBar = renderer.createTabBar(document2);
    for (const widget of config2.widgets) {
      widget.hide();
      tabBar.addTab(widget.title);
      Private2.addAria(widget, tabBar);
    }
    tabBar.currentIndex = config2.currentIndex;
    return new TabLayoutNode(tabBar);
  }
  function realizeSplitAreaConfig(config2, renderer, document2) {
    let node2 = new SplitLayoutNode(config2.orientation);
    config2.children.forEach((child, i2) => {
      let childNode = realizeAreaConfig(child, renderer, document2);
      let sizer = createSizer(config2.sizes[i2]);
      let handle = renderer.createHandle();
      node2.children.push(childNode);
      node2.handles.push(handle);
      node2.sizers.push(sizer);
      childNode.parent = node2;
    });
    node2.syncHandles();
    node2.normalizeSizes();
    return node2;
  }
})(Private$6$1 || (Private$6$1 = {}));
class DockPanel extends Widget {
  /**
   * Construct a new dock panel.
   *
   * @param options - The options for initializing the panel.
   */
  constructor(options = {}) {
    super();
    this._drag = null;
    this._tabsMovable = true;
    this._tabsConstrained = false;
    this._addButtonEnabled = false;
    this._pressData = null;
    this._layoutModified = new Signal(this);
    this._addRequested = new Signal(this);
    this.addClass("lm-DockPanel");
    this._document = options.document || document;
    this._mode = options.mode || "multiple-document";
    this._renderer = options.renderer || DockPanel.defaultRenderer;
    this._edges = options.edges || Private$5$1.DEFAULT_EDGES;
    if (options.tabsMovable !== void 0) {
      this._tabsMovable = options.tabsMovable;
    }
    if (options.tabsConstrained !== void 0) {
      this._tabsConstrained = options.tabsConstrained;
    }
    if (options.addButtonEnabled !== void 0) {
      this._addButtonEnabled = options.addButtonEnabled;
    }
    this.dataset["mode"] = this._mode;
    let renderer = {
      createTabBar: () => this._createTabBar(),
      createHandle: () => this._createHandle()
    };
    this.layout = new DockLayout({
      document: this._document,
      renderer,
      spacing: options.spacing,
      hiddenMode: options.hiddenMode
    });
    this.overlay = options.overlay || new DockPanel.Overlay();
    this.node.appendChild(this.overlay.node);
  }
  /**
   * Dispose of the resources held by the panel.
   */
  dispose() {
    this._releaseMouse();
    this.overlay.hide(0);
    if (this._drag) {
      this._drag.dispose();
    }
    super.dispose();
  }
  /**
   * The method for hiding widgets.
   */
  get hiddenMode() {
    return this.layout.hiddenMode;
  }
  /**
   * Set the method for hiding widgets.
   */
  set hiddenMode(v) {
    this.layout.hiddenMode = v;
  }
  /**
   * A signal emitted when the layout configuration is modified.
   *
   * #### Notes
   * This signal is emitted whenever the current layout configuration
   * may have changed.
   *
   * This signal is emitted asynchronously in a collapsed fashion, so
   * that multiple synchronous modifications results in only a single
   * emit of the signal.
   */
  get layoutModified() {
    return this._layoutModified;
  }
  /**
   * A signal emitted when the add button on a tab bar is clicked.
   *
   */
  get addRequested() {
    return this._addRequested;
  }
  /**
   * The renderer used by the dock panel.
   */
  get renderer() {
    return this.layout.renderer;
  }
  /**
   * Get the spacing between the widgets.
   */
  get spacing() {
    return this.layout.spacing;
  }
  /**
   * Set the spacing between the widgets.
   */
  set spacing(value) {
    this.layout.spacing = value;
  }
  /**
   * Get the mode for the dock panel.
   */
  get mode() {
    return this._mode;
  }
  /**
   * Set the mode for the dock panel.
   *
   * #### Notes
   * Changing the mode is a destructive operation with respect to the
   * panel's layout configuration. If layout state must be preserved,
   * save the current layout config before changing the mode.
   */
  set mode(value) {
    if (this._mode === value) {
      return;
    }
    this._mode = value;
    this.dataset["mode"] = value;
    let layout = this.layout;
    switch (value) {
      case "multiple-document":
        for (const tabBar of layout.tabBars()) {
          tabBar.show();
        }
        break;
      case "single-document":
        layout.restoreLayout(Private$5$1.createSingleDocumentConfig(this));
        break;
      default:
        throw "unreachable";
    }
    MessageLoop.postMessage(this, Private$5$1.LayoutModified);
  }
  /**
   * Whether the tabs can be dragged / moved at runtime.
   */
  get tabsMovable() {
    return this._tabsMovable;
  }
  /**
   * Enable / Disable draggable / movable tabs.
   */
  set tabsMovable(value) {
    this._tabsMovable = value;
    for (const tabBar of this.tabBars()) {
      tabBar.tabsMovable = value;
    }
  }
  /**
   * Whether the tabs are constrained to their source dock panel
   */
  get tabsConstrained() {
    return this._tabsConstrained;
  }
  /**
   * Constrain/Allow tabs to be dragged outside of this dock panel
   */
  set tabsConstrained(value) {
    this._tabsConstrained = value;
  }
  /**
   * Whether the add buttons for each tab bar are enabled.
   */
  get addButtonEnabled() {
    return this._addButtonEnabled;
  }
  /**
   * Set whether the add buttons for each tab bar are enabled.
   */
  set addButtonEnabled(value) {
    this._addButtonEnabled = value;
    for (const tabBar of this.tabBars()) {
      tabBar.addButtonEnabled = value;
    }
  }
  /**
   * Whether the dock panel is empty.
   */
  get isEmpty() {
    return this.layout.isEmpty;
  }
  /**
   * Create an iterator over the user widgets in the panel.
   *
   * @returns A new iterator over the user widgets in the panel.
   *
   * #### Notes
   * This iterator does not include the generated tab bars.
   */
  *widgets() {
    yield* this.layout.widgets();
  }
  /**
   * Create an iterator over the selected widgets in the panel.
   *
   * @returns A new iterator over the selected user widgets.
   *
   * #### Notes
   * This iterator yields the widgets corresponding to the current tab
   * of each tab bar in the panel.
   */
  *selectedWidgets() {
    yield* this.layout.selectedWidgets();
  }
  /**
   * Create an iterator over the tab bars in the panel.
   *
   * @returns A new iterator over the tab bars in the panel.
   *
   * #### Notes
   * This iterator does not include the user widgets.
   */
  *tabBars() {
    yield* this.layout.tabBars();
  }
  /**
   * Create an iterator over the handles in the panel.
   *
   * @returns A new iterator over the handles in the panel.
   */
  *handles() {
    yield* this.layout.handles();
  }
  /**
   * Select a specific widget in the dock panel.
   *
   * @param widget - The widget of interest.
   *
   * #### Notes
   * This will make the widget the current widget in its tab area.
   */
  selectWidget(widget) {
    let tabBar = find$3(this.tabBars(), (bar) => {
      return bar.titles.indexOf(widget.title) !== -1;
    });
    if (!tabBar) {
      throw new Error("Widget is not contained in the dock panel.");
    }
    tabBar.currentTitle = widget.title;
  }
  /**
   * Activate a specified widget in the dock panel.
   *
   * @param widget - The widget of interest.
   *
   * #### Notes
   * This will select and activate the given widget.
   */
  activateWidget(widget) {
    this.selectWidget(widget);
    widget.activate();
  }
  /**
   * Save the current layout configuration of the dock panel.
   *
   * @returns A new config object for the current layout state.
   *
   * #### Notes
   * The return value can be provided to the `restoreLayout` method
   * in order to restore the layout to its current configuration.
   */
  saveLayout() {
    return this.layout.saveLayout();
  }
  /**
   * Restore the layout to a previously saved configuration.
   *
   * @param config - The layout configuration to restore.
   *
   * #### Notes
   * Widgets which currently belong to the layout but which are not
   * contained in the config will be unparented.
   *
   * The dock panel automatically reverts to `'multiple-document'`
   * mode when a layout config is restored.
   */
  restoreLayout(config2) {
    this._mode = "multiple-document";
    this.layout.restoreLayout(config2);
    if (Platform.IS_EDGE || Platform.IS_IE) {
      MessageLoop.flush();
    }
    MessageLoop.postMessage(this, Private$5$1.LayoutModified);
  }
  /**
   * Add a widget to the dock panel.
   *
   * @param widget - The widget to add to the dock panel.
   *
   * @param options - The additional options for adding the widget.
   *
   * #### Notes
   * If the panel is in single document mode, the options are ignored
   * and the widget is always added as tab in the hidden tab bar.
   */
  addWidget(widget, options = {}) {
    if (this._mode === "single-document") {
      this.layout.addWidget(widget);
    } else {
      this.layout.addWidget(widget, options);
    }
    MessageLoop.postMessage(this, Private$5$1.LayoutModified);
  }
  /**
   * Process a message sent to the widget.
   *
   * @param msg - The message sent to the widget.
   */
  processMessage(msg) {
    if (msg.type === "layout-modified") {
      this._layoutModified.emit(void 0);
    } else {
      super.processMessage(msg);
    }
  }
  /**
   * Handle the DOM events for the dock panel.
   *
   * @param event - The DOM event sent to the panel.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the panel's DOM node. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "lm-dragenter":
        this._evtDragEnter(event2);
        break;
      case "lm-dragleave":
        this._evtDragLeave(event2);
        break;
      case "lm-dragover":
        this._evtDragOver(event2);
        break;
      case "lm-drop":
        this._evtDrop(event2);
        break;
      case "pointerdown":
        this._evtPointerDown(event2);
        break;
      case "pointermove":
        this._evtPointerMove(event2);
        break;
      case "pointerup":
        this._evtPointerUp(event2);
        break;
      case "keydown":
        this._evtKeyDown(event2);
        break;
      case "contextmenu":
        event2.preventDefault();
        event2.stopPropagation();
        break;
    }
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    this.node.addEventListener("lm-dragenter", this);
    this.node.addEventListener("lm-dragleave", this);
    this.node.addEventListener("lm-dragover", this);
    this.node.addEventListener("lm-drop", this);
    this.node.addEventListener("pointerdown", this);
  }
  /**
   * A message handler invoked on an `'after-detach'` message.
   */
  onAfterDetach(msg) {
    this.node.removeEventListener("lm-dragenter", this);
    this.node.removeEventListener("lm-dragleave", this);
    this.node.removeEventListener("lm-dragover", this);
    this.node.removeEventListener("lm-drop", this);
    this.node.removeEventListener("pointerdown", this);
    this._releaseMouse();
  }
  /**
   * A message handler invoked on a `'child-added'` message.
   */
  onChildAdded(msg) {
    if (Private$5$1.isGeneratedTabBarProperty.get(msg.child)) {
      return;
    }
    msg.child.addClass("lm-DockPanel-widget");
  }
  /**
   * A message handler invoked on a `'child-removed'` message.
   */
  onChildRemoved(msg) {
    if (Private$5$1.isGeneratedTabBarProperty.get(msg.child)) {
      return;
    }
    msg.child.removeClass("lm-DockPanel-widget");
    MessageLoop.postMessage(this, Private$5$1.LayoutModified);
  }
  /**
   * Handle the `'lm-dragenter'` event for the dock panel.
   */
  _evtDragEnter(event2) {
    if (event2.mimeData.hasData("application/vnd.lumino.widget-factory")) {
      event2.preventDefault();
      event2.stopPropagation();
    }
  }
  /**
   * Handle the `'lm-dragleave'` event for the dock panel.
   */
  _evtDragLeave(event2) {
    event2.preventDefault();
    if (this._tabsConstrained && event2.source !== this)
      return;
    event2.stopPropagation();
    this.overlay.hide(1);
  }
  /**
   * Handle the `'lm-dragover'` event for the dock panel.
   */
  _evtDragOver(event2) {
    event2.preventDefault();
    if (this._tabsConstrained && event2.source !== this || this._showOverlay(event2.clientX, event2.clientY) === "invalid") {
      event2.dropAction = "none";
    } else {
      event2.stopPropagation();
      event2.dropAction = event2.proposedAction;
    }
  }
  /**
   * Handle the `'lm-drop'` event for the dock panel.
   */
  _evtDrop(event2) {
    event2.preventDefault();
    this.overlay.hide(0);
    if (event2.proposedAction === "none") {
      event2.dropAction = "none";
      return;
    }
    let { clientX, clientY } = event2;
    let { zone, target: target2 } = Private$5$1.findDropTarget(this, clientX, clientY, this._edges);
    if (this._tabsConstrained && event2.source !== this || zone === "invalid") {
      event2.dropAction = "none";
      return;
    }
    let mimeData = event2.mimeData;
    let factory = mimeData.getData("application/vnd.lumino.widget-factory");
    if (typeof factory !== "function") {
      event2.dropAction = "none";
      return;
    }
    let widget = factory();
    if (!(widget instanceof Widget)) {
      event2.dropAction = "none";
      return;
    }
    if (widget.contains(this)) {
      event2.dropAction = "none";
      return;
    }
    let ref2 = target2 ? Private$5$1.getDropRef(target2.tabBar) : null;
    switch (zone) {
      case "root-all":
        this.addWidget(widget);
        break;
      case "root-top":
        this.addWidget(widget, { mode: "split-top" });
        break;
      case "root-left":
        this.addWidget(widget, { mode: "split-left" });
        break;
      case "root-right":
        this.addWidget(widget, { mode: "split-right" });
        break;
      case "root-bottom":
        this.addWidget(widget, { mode: "split-bottom" });
        break;
      case "widget-all":
        this.addWidget(widget, { mode: "tab-after", ref: ref2 });
        break;
      case "widget-top":
        this.addWidget(widget, { mode: "split-top", ref: ref2 });
        break;
      case "widget-left":
        this.addWidget(widget, { mode: "split-left", ref: ref2 });
        break;
      case "widget-right":
        this.addWidget(widget, { mode: "split-right", ref: ref2 });
        break;
      case "widget-bottom":
        this.addWidget(widget, { mode: "split-bottom", ref: ref2 });
        break;
      case "widget-tab":
        this.addWidget(widget, { mode: "tab-after", ref: ref2 });
        break;
      default:
        throw "unreachable";
    }
    event2.dropAction = event2.proposedAction;
    event2.stopPropagation();
    this.activateWidget(widget);
  }
  /**
   * Handle the `'keydown'` event for the dock panel.
   */
  _evtKeyDown(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    if (event2.keyCode === 27) {
      this._releaseMouse();
      MessageLoop.postMessage(this, Private$5$1.LayoutModified);
    }
  }
  /**
   * Handle the `'pointerdown'` event for the dock panel.
   */
  _evtPointerDown(event2) {
    if (event2.button !== 0) {
      return;
    }
    let layout = this.layout;
    let target2 = event2.target;
    let handle = find$3(layout.handles(), (handle2) => handle2.contains(target2));
    if (!handle) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    this._document.addEventListener("keydown", this, true);
    this._document.addEventListener("pointerup", this, true);
    this._document.addEventListener("pointermove", this, true);
    this._document.addEventListener("contextmenu", this, true);
    let rect = handle.getBoundingClientRect();
    let deltaX = event2.clientX - rect.left;
    let deltaY = event2.clientY - rect.top;
    let style2 = window.getComputedStyle(handle);
    let override = Drag.overrideCursor(style2.cursor, this._document);
    this._pressData = { handle, deltaX, deltaY, override };
  }
  /**
   * Handle the `'pointermove'` event for the dock panel.
   */
  _evtPointerMove(event2) {
    if (!this._pressData) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    let rect = this.node.getBoundingClientRect();
    let xPos = event2.clientX - rect.left - this._pressData.deltaX;
    let yPos = event2.clientY - rect.top - this._pressData.deltaY;
    let layout = this.layout;
    layout.moveHandle(this._pressData.handle, xPos, yPos);
  }
  /**
   * Handle the `'pointerup'` event for the dock panel.
   */
  _evtPointerUp(event2) {
    if (event2.button !== 0) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    this._releaseMouse();
    MessageLoop.postMessage(this, Private$5$1.LayoutModified);
  }
  /**
   * Release the mouse grab for the dock panel.
   */
  _releaseMouse() {
    if (!this._pressData) {
      return;
    }
    this._pressData.override.dispose();
    this._pressData = null;
    this._document.removeEventListener("keydown", this, true);
    this._document.removeEventListener("pointerup", this, true);
    this._document.removeEventListener("pointermove", this, true);
    this._document.removeEventListener("contextmenu", this, true);
  }
  /**
   * Show the overlay indicator at the given client position.
   *
   * Returns the drop zone at the specified client position.
   *
   * #### Notes
   * If the position is not over a valid zone, the overlay is hidden.
   */
  _showOverlay(clientX, clientY) {
    let { zone, target: target2 } = Private$5$1.findDropTarget(this, clientX, clientY, this._edges);
    if (zone === "invalid") {
      this.overlay.hide(100);
      return zone;
    }
    let top2;
    let left;
    let right;
    let bottom;
    let box = ElementExt.boxSizing(this.node);
    let rect = this.node.getBoundingClientRect();
    switch (zone) {
      case "root-all":
        top2 = box.paddingTop;
        left = box.paddingLeft;
        right = box.paddingRight;
        bottom = box.paddingBottom;
        break;
      case "root-top":
        top2 = box.paddingTop;
        left = box.paddingLeft;
        right = box.paddingRight;
        bottom = rect.height * Private$5$1.GOLDEN_RATIO;
        break;
      case "root-left":
        top2 = box.paddingTop;
        left = box.paddingLeft;
        right = rect.width * Private$5$1.GOLDEN_RATIO;
        bottom = box.paddingBottom;
        break;
      case "root-right":
        top2 = box.paddingTop;
        left = rect.width * Private$5$1.GOLDEN_RATIO;
        right = box.paddingRight;
        bottom = box.paddingBottom;
        break;
      case "root-bottom":
        top2 = rect.height * Private$5$1.GOLDEN_RATIO;
        left = box.paddingLeft;
        right = box.paddingRight;
        bottom = box.paddingBottom;
        break;
      case "widget-all":
        top2 = target2.top;
        left = target2.left;
        right = target2.right;
        bottom = target2.bottom;
        break;
      case "widget-top":
        top2 = target2.top;
        left = target2.left;
        right = target2.right;
        bottom = target2.bottom + target2.height / 2;
        break;
      case "widget-left":
        top2 = target2.top;
        left = target2.left;
        right = target2.right + target2.width / 2;
        bottom = target2.bottom;
        break;
      case "widget-right":
        top2 = target2.top;
        left = target2.left + target2.width / 2;
        right = target2.right;
        bottom = target2.bottom;
        break;
      case "widget-bottom":
        top2 = target2.top + target2.height / 2;
        left = target2.left;
        right = target2.right;
        bottom = target2.bottom;
        break;
      case "widget-tab": {
        const tabHeight = target2.tabBar.node.getBoundingClientRect().height;
        top2 = target2.top;
        left = target2.left;
        right = target2.right;
        bottom = target2.bottom + target2.height - tabHeight;
        break;
      }
      default:
        throw "unreachable";
    }
    this.overlay.show({ top: top2, left, right, bottom });
    return zone;
  }
  /**
   * Create a new tab bar for use by the panel.
   */
  _createTabBar() {
    let tabBar = this._renderer.createTabBar(this._document);
    Private$5$1.isGeneratedTabBarProperty.set(tabBar, true);
    if (this._mode === "single-document") {
      tabBar.hide();
    }
    tabBar.tabsMovable = this._tabsMovable;
    tabBar.allowDeselect = false;
    tabBar.addButtonEnabled = this._addButtonEnabled;
    tabBar.removeBehavior = "select-previous-tab";
    tabBar.insertBehavior = "select-tab-if-needed";
    tabBar.tabMoved.connect(this._onTabMoved, this);
    tabBar.currentChanged.connect(this._onCurrentChanged, this);
    tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
    tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);
    tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
    tabBar.addRequested.connect(this._onTabAddRequested, this);
    return tabBar;
  }
  /**
   * Create a new handle for use by the panel.
   */
  _createHandle() {
    return this._renderer.createHandle();
  }
  /**
   * Handle the `tabMoved` signal from a tab bar.
   */
  _onTabMoved() {
    MessageLoop.postMessage(this, Private$5$1.LayoutModified);
  }
  /**
   * Handle the `currentChanged` signal from a tab bar.
   */
  _onCurrentChanged(sender, args) {
    let { previousTitle, currentTitle } = args;
    if (previousTitle) {
      previousTitle.owner.hide();
    }
    if (currentTitle) {
      currentTitle.owner.show();
    }
    if (Platform.IS_EDGE || Platform.IS_IE) {
      MessageLoop.flush();
    }
    MessageLoop.postMessage(this, Private$5$1.LayoutModified);
  }
  /**
   * Handle the `addRequested` signal from a tab bar.
   */
  _onTabAddRequested(sender) {
    this._addRequested.emit(sender);
  }
  /**
   * Handle the `tabActivateRequested` signal from a tab bar.
   */
  _onTabActivateRequested(sender, args) {
    args.title.owner.activate();
  }
  /**
   * Handle the `tabCloseRequested` signal from a tab bar.
   */
  _onTabCloseRequested(sender, args) {
    args.title.owner.close();
  }
  /**
   * Handle the `tabDetachRequested` signal from a tab bar.
   */
  _onTabDetachRequested(sender, args) {
    if (this._drag) {
      return;
    }
    sender.releaseMouse();
    let { title, tab, clientX, clientY, offset } = args;
    let mimeData = new MimeData();
    let factory = () => title.owner;
    mimeData.setData("application/vnd.lumino.widget-factory", factory);
    let dragImage = tab.cloneNode(true);
    if (offset) {
      dragImage.style.top = `-${offset.y}px`;
      dragImage.style.left = `-${offset.x}px`;
    }
    this._drag = new Drag({
      document: this._document,
      mimeData,
      dragImage,
      proposedAction: "move",
      supportedActions: "move",
      source: this
    });
    tab.classList.add("lm-mod-hidden");
    let cleanup = () => {
      this._drag = null;
      tab.classList.remove("lm-mod-hidden");
    };
    this._drag.start(clientX, clientY).then(cleanup);
  }
}
(function(DockPanel2) {
  class Overlay {
    /**
     * Construct a new overlay.
     */
    constructor() {
      this._timer = -1;
      this._hidden = true;
      this.node = document.createElement("div");
      this.node.classList.add("lm-DockPanel-overlay");
      this.node.classList.add("lm-mod-hidden");
      this.node.style.position = "absolute";
      this.node.style.contain = "strict";
    }
    /**
     * Show the overlay using the given overlay geometry.
     *
     * @param geo - The desired geometry for the overlay.
     */
    show(geo) {
      let style2 = this.node.style;
      style2.top = `${geo.top}px`;
      style2.left = `${geo.left}px`;
      style2.right = `${geo.right}px`;
      style2.bottom = `${geo.bottom}px`;
      clearTimeout(this._timer);
      this._timer = -1;
      if (!this._hidden) {
        return;
      }
      this._hidden = false;
      this.node.classList.remove("lm-mod-hidden");
    }
    /**
     * Hide the overlay node.
     *
     * @param delay - The delay (in ms) before hiding the overlay.
     *   A delay value <= 0 will hide the overlay immediately.
     */
    hide(delay) {
      if (this._hidden) {
        return;
      }
      if (delay <= 0) {
        clearTimeout(this._timer);
        this._timer = -1;
        this._hidden = true;
        this.node.classList.add("lm-mod-hidden");
        return;
      }
      if (this._timer !== -1) {
        return;
      }
      this._timer = window.setTimeout(() => {
        this._timer = -1;
        this._hidden = true;
        this.node.classList.add("lm-mod-hidden");
      }, delay);
    }
  }
  DockPanel2.Overlay = Overlay;
  class Renderer {
    /**
     * Create a new tab bar for use with a dock panel.
     *
     * @returns A new tab bar for a dock panel.
     */
    createTabBar(document2) {
      let bar = new TabBar({ document: document2 });
      bar.addClass("lm-DockPanel-tabBar");
      return bar;
    }
    /**
     * Create a new handle node for use with a dock panel.
     *
     * @returns A new handle node for a dock panel.
     */
    createHandle() {
      let handle = document.createElement("div");
      handle.className = "lm-DockPanel-handle";
      return handle;
    }
  }
  DockPanel2.Renderer = Renderer;
  DockPanel2.defaultRenderer = new Renderer();
})(DockPanel || (DockPanel = {}));
var Private$5$1;
(function(Private2) {
  Private2.GOLDEN_RATIO = 0.618;
  Private2.DEFAULT_EDGES = {
    /**
     * The size of the top edge dock zone for the root panel, in pixels.
     * This is different from the others to distinguish between the top
     * tab bar and the top root zone.
     */
    top: 12,
    /**
     * The size of the edge dock zone for the root panel, in pixels.
     */
    right: 40,
    /**
     * The size of the edge dock zone for the root panel, in pixels.
     */
    bottom: 40,
    /**
     * The size of the edge dock zone for the root panel, in pixels.
     */
    left: 40
  };
  Private2.LayoutModified = new ConflatableMessage("layout-modified");
  Private2.isGeneratedTabBarProperty = new AttachedProperty({
    name: "isGeneratedTabBar",
    create: () => false
  });
  function createSingleDocumentConfig(panel) {
    if (panel.isEmpty) {
      return { main: null };
    }
    let widgets = Array.from(panel.widgets());
    let selected = panel.selectedWidgets().next().value;
    let currentIndex = selected ? widgets.indexOf(selected) : -1;
    return { main: { type: "tab-area", widgets, currentIndex } };
  }
  Private2.createSingleDocumentConfig = createSingleDocumentConfig;
  function findDropTarget(panel, clientX, clientY, edges) {
    if (!ElementExt.hitTest(panel.node, clientX, clientY)) {
      return { zone: "invalid", target: null };
    }
    let layout = panel.layout;
    if (layout.isEmpty) {
      return { zone: "root-all", target: null };
    }
    if (panel.mode === "multiple-document") {
      let panelRect = panel.node.getBoundingClientRect();
      let pl = clientX - panelRect.left + 1;
      let pt = clientY - panelRect.top + 1;
      let pr = panelRect.right - clientX;
      let pb = panelRect.bottom - clientY;
      let pd = Math.min(pt, pr, pb, pl);
      switch (pd) {
        case pt:
          if (pt < edges.top) {
            return { zone: "root-top", target: null };
          }
          break;
        case pr:
          if (pr < edges.right) {
            return { zone: "root-right", target: null };
          }
          break;
        case pb:
          if (pb < edges.bottom) {
            return { zone: "root-bottom", target: null };
          }
          break;
        case pl:
          if (pl < edges.left) {
            return { zone: "root-left", target: null };
          }
          break;
        default:
          throw "unreachable";
      }
    }
    let target2 = layout.hitTestTabAreas(clientX, clientY);
    if (!target2) {
      return { zone: "invalid", target: null };
    }
    if (panel.mode === "single-document") {
      return { zone: "widget-all", target: target2 };
    }
    let al = target2.x - target2.left + 1;
    let at = target2.y - target2.top + 1;
    let ar = target2.left + target2.width - target2.x;
    let ab = target2.top + target2.height - target2.y;
    const tabHeight = target2.tabBar.node.getBoundingClientRect().height;
    if (at < tabHeight) {
      return { zone: "widget-tab", target: target2 };
    }
    let rx = Math.round(target2.width / 3);
    let ry = Math.round(target2.height / 3);
    if (al > rx && ar > rx && at > ry && ab > ry) {
      return { zone: "widget-all", target: target2 };
    }
    al /= rx;
    at /= ry;
    ar /= rx;
    ab /= ry;
    let ad = Math.min(al, at, ar, ab);
    let zone;
    switch (ad) {
      case al:
        zone = "widget-left";
        break;
      case at:
        zone = "widget-top";
        break;
      case ar:
        zone = "widget-right";
        break;
      case ab:
        zone = "widget-bottom";
        break;
      default:
        throw "unreachable";
    }
    return { zone, target: target2 };
  }
  Private2.findDropTarget = findDropTarget;
  function getDropRef(tabBar) {
    if (tabBar.titles.length === 0) {
      return null;
    }
    if (tabBar.currentTitle) {
      return tabBar.currentTitle.owner;
    }
    return tabBar.titles[tabBar.titles.length - 1].owner;
  }
  Private2.getDropRef = getDropRef;
})(Private$5$1 || (Private$5$1 = {}));
class FocusTracker {
  constructor() {
    this._counter = 0;
    this._widgets = [];
    this._activeWidget = null;
    this._currentWidget = null;
    this._numbers = /* @__PURE__ */ new Map();
    this._nodes = /* @__PURE__ */ new Map();
    this._activeChanged = new Signal(this);
    this._currentChanged = new Signal(this);
  }
  /**
   * Dispose of the resources held by the tracker.
   */
  dispose() {
    if (this._counter < 0) {
      return;
    }
    this._counter = -1;
    Signal.clearData(this);
    for (const widget of this._widgets) {
      widget.node.removeEventListener("focus", this, true);
      widget.node.removeEventListener("blur", this, true);
    }
    this._activeWidget = null;
    this._currentWidget = null;
    this._nodes.clear();
    this._numbers.clear();
    this._widgets.length = 0;
  }
  /**
   * A signal emitted when the current widget has changed.
   */
  get currentChanged() {
    return this._currentChanged;
  }
  /**
   * A signal emitted when the active widget has changed.
   */
  get activeChanged() {
    return this._activeChanged;
  }
  /**
   * A flag indicating whether the tracker is disposed.
   */
  get isDisposed() {
    return this._counter < 0;
  }
  /**
   * The current widget in the tracker.
   *
   * #### Notes
   * The current widget is the widget among the tracked widgets which
   * has the *descendant node* which has most recently been focused.
   *
   * The current widget will not be updated if the node loses focus. It
   * will only be updated when a different tracked widget gains focus.
   *
   * If the current widget is removed from the tracker, the previous
   * current widget will be restored.
   *
   * This behavior is intended to follow a user's conceptual model of
   * a semantically "current" widget, where the "last thing of type X"
   * to be interacted with is the "current instance of X", regardless
   * of whether that instance still has focus.
   */
  get currentWidget() {
    return this._currentWidget;
  }
  /**
   * The active widget in the tracker.
   *
   * #### Notes
   * The active widget is the widget among the tracked widgets which
   * has the *descendant node* which is currently focused.
   */
  get activeWidget() {
    return this._activeWidget;
  }
  /**
   * A read only array of the widgets being tracked.
   */
  get widgets() {
    return this._widgets;
  }
  /**
   * Get the focus number for a particular widget in the tracker.
   *
   * @param widget - The widget of interest.
   *
   * @returns The focus number for the given widget, or `-1` if the
   *   widget has not had focus since being added to the tracker, or
   *   is not contained by the tracker.
   *
   * #### Notes
   * The focus number indicates the relative order in which the widgets
   * have gained focus. A widget with a larger number has gained focus
   * more recently than a widget with a smaller number.
   *
   * The `currentWidget` will always have the largest focus number.
   *
   * All widgets start with a focus number of `-1`, which indicates that
   * the widget has not been focused since being added to the tracker.
   */
  focusNumber(widget) {
    let n = this._numbers.get(widget);
    return n === void 0 ? -1 : n;
  }
  /**
   * Test whether the focus tracker contains a given widget.
   *
   * @param widget - The widget of interest.
   *
   * @returns `true` if the widget is tracked, `false` otherwise.
   */
  has(widget) {
    return this._numbers.has(widget);
  }
  /**
   * Add a widget to the focus tracker.
   *
   * @param widget - The widget of interest.
   *
   * #### Notes
   * A widget will be automatically removed from the tracker if it
   * is disposed after being added.
   *
   * If the widget is already tracked, this is a no-op.
   */
  add(widget) {
    if (this._numbers.has(widget)) {
      return;
    }
    let focused = widget.node.contains(document.activeElement);
    let n = focused ? this._counter++ : -1;
    this._widgets.push(widget);
    this._numbers.set(widget, n);
    this._nodes.set(widget.node, widget);
    widget.node.addEventListener("focus", this, true);
    widget.node.addEventListener("blur", this, true);
    widget.disposed.connect(this._onWidgetDisposed, this);
    if (focused) {
      this._setWidgets(widget, widget);
    }
  }
  /**
   * Remove a widget from the focus tracker.
   *
   * #### Notes
   * If the widget is the `currentWidget`, the previous current widget
   * will become the new `currentWidget`.
   *
   * A widget will be automatically removed from the tracker if it
   * is disposed after being added.
   *
   * If the widget is not tracked, this is a no-op.
   */
  remove(widget) {
    if (!this._numbers.has(widget)) {
      return;
    }
    widget.disposed.disconnect(this._onWidgetDisposed, this);
    widget.node.removeEventListener("focus", this, true);
    widget.node.removeEventListener("blur", this, true);
    ArrayExt.removeFirstOf(this._widgets, widget);
    this._nodes.delete(widget.node);
    this._numbers.delete(widget);
    if (this._currentWidget !== widget) {
      return;
    }
    let valid = this._widgets.filter((w) => this._numbers.get(w) !== -1);
    let previous = max$1(valid, (first, second) => {
      let a = this._numbers.get(first);
      let b = this._numbers.get(second);
      return a - b;
    }) || null;
    this._setWidgets(previous, null);
  }
  /**
   * Handle the DOM events for the focus tracker.
   *
   * @param event - The DOM event sent to the panel.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the tracked nodes. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "focus":
        this._evtFocus(event2);
        break;
      case "blur":
        this._evtBlur(event2);
        break;
    }
  }
  /**
   * Set the current and active widgets for the tracker.
   */
  _setWidgets(current, active) {
    let oldCurrent = this._currentWidget;
    this._currentWidget = current;
    let oldActive = this._activeWidget;
    this._activeWidget = active;
    if (oldCurrent !== current) {
      this._currentChanged.emit({ oldValue: oldCurrent, newValue: current });
    }
    if (oldActive !== active) {
      this._activeChanged.emit({ oldValue: oldActive, newValue: active });
    }
  }
  /**
   * Handle the `'focus'` event for a tracked widget.
   */
  _evtFocus(event2) {
    let widget = this._nodes.get(event2.currentTarget);
    if (widget !== this._currentWidget) {
      this._numbers.set(widget, this._counter++);
    }
    this._setWidgets(widget, widget);
  }
  /**
   * Handle the `'blur'` event for a tracked widget.
   */
  _evtBlur(event2) {
    let widget = this._nodes.get(event2.currentTarget);
    let focusTarget = event2.relatedTarget;
    if (!focusTarget) {
      this._setWidgets(this._currentWidget, null);
      return;
    }
    if (widget.node.contains(focusTarget)) {
      return;
    }
    if (!find$3(this._widgets, (w) => w.node.contains(focusTarget))) {
      this._setWidgets(this._currentWidget, null);
      return;
    }
  }
  /**
   * Handle the `disposed` signal for a tracked widget.
   */
  _onWidgetDisposed(sender) {
    this.remove(sender);
  }
}
class GridLayout extends Layout {
  /**
   * Construct a new grid layout.
   *
   * @param options - The options for initializing the layout.
   */
  constructor(options = {}) {
    super(options);
    this._dirty = false;
    this._rowSpacing = 4;
    this._columnSpacing = 4;
    this._items = [];
    this._rowStarts = [];
    this._columnStarts = [];
    this._rowSizers = [new BoxSizer()];
    this._columnSizers = [new BoxSizer()];
    this._box = null;
    if (options.rowCount !== void 0) {
      Private$4$1.reallocSizers(this._rowSizers, options.rowCount);
    }
    if (options.columnCount !== void 0) {
      Private$4$1.reallocSizers(this._columnSizers, options.columnCount);
    }
    if (options.rowSpacing !== void 0) {
      this._rowSpacing = Private$4$1.clampValue(options.rowSpacing);
    }
    if (options.columnSpacing !== void 0) {
      this._columnSpacing = Private$4$1.clampValue(options.columnSpacing);
    }
  }
  /**
   * Dispose of the resources held by the layout.
   */
  dispose() {
    for (const item of this._items) {
      let widget = item.widget;
      item.dispose();
      widget.dispose();
    }
    this._box = null;
    this._items.length = 0;
    this._rowStarts.length = 0;
    this._rowSizers.length = 0;
    this._columnStarts.length = 0;
    this._columnSizers.length = 0;
    super.dispose();
  }
  /**
   * Get the number of rows in the layout.
   */
  get rowCount() {
    return this._rowSizers.length;
  }
  /**
   * Set the number of rows in the layout.
   *
   * #### Notes
   * The minimum row count is `1`.
   */
  set rowCount(value) {
    if (value === this.rowCount) {
      return;
    }
    Private$4$1.reallocSizers(this._rowSizers, value);
    if (this.parent) {
      this.parent.fit();
    }
  }
  /**
   * Get the number of columns in the layout.
   */
  get columnCount() {
    return this._columnSizers.length;
  }
  /**
   * Set the number of columns in the layout.
   *
   * #### Notes
   * The minimum column count is `1`.
   */
  set columnCount(value) {
    if (value === this.columnCount) {
      return;
    }
    Private$4$1.reallocSizers(this._columnSizers, value);
    if (this.parent) {
      this.parent.fit();
    }
  }
  /**
   * Get the row spacing for the layout.
   */
  get rowSpacing() {
    return this._rowSpacing;
  }
  /**
   * Set the row spacing for the layout.
   */
  set rowSpacing(value) {
    value = Private$4$1.clampValue(value);
    if (this._rowSpacing === value) {
      return;
    }
    this._rowSpacing = value;
    if (this.parent) {
      this.parent.fit();
    }
  }
  /**
   * Get the column spacing for the layout.
   */
  get columnSpacing() {
    return this._columnSpacing;
  }
  /**
   * Set the col spacing for the layout.
   */
  set columnSpacing(value) {
    value = Private$4$1.clampValue(value);
    if (this._columnSpacing === value) {
      return;
    }
    this._columnSpacing = value;
    if (this.parent) {
      this.parent.fit();
    }
  }
  /**
   * Get the stretch factor for a specific row.
   *
   * @param index - The row index of interest.
   *
   * @returns The stretch factor for the row.
   *
   * #### Notes
   * This returns `-1` if the index is out of range.
   */
  rowStretch(index) {
    let sizer = this._rowSizers[index];
    return sizer ? sizer.stretch : -1;
  }
  /**
   * Set the stretch factor for a specific row.
   *
   * @param index - The row index of interest.
   *
   * @param value - The stretch factor for the row.
   *
   * #### Notes
   * This is a no-op if the index is out of range.
   */
  setRowStretch(index, value) {
    let sizer = this._rowSizers[index];
    if (!sizer) {
      return;
    }
    value = Private$4$1.clampValue(value);
    if (sizer.stretch === value) {
      return;
    }
    sizer.stretch = value;
    if (this.parent) {
      this.parent.update();
    }
  }
  /**
   * Get the stretch factor for a specific column.
   *
   * @param index - The column index of interest.
   *
   * @returns The stretch factor for the column.
   *
   * #### Notes
   * This returns `-1` if the index is out of range.
   */
  columnStretch(index) {
    let sizer = this._columnSizers[index];
    return sizer ? sizer.stretch : -1;
  }
  /**
   * Set the stretch factor for a specific column.
   *
   * @param index - The column index of interest.
   *
   * @param value - The stretch factor for the column.
   *
   * #### Notes
   * This is a no-op if the index is out of range.
   */
  setColumnStretch(index, value) {
    let sizer = this._columnSizers[index];
    if (!sizer) {
      return;
    }
    value = Private$4$1.clampValue(value);
    if (sizer.stretch === value) {
      return;
    }
    sizer.stretch = value;
    if (this.parent) {
      this.parent.update();
    }
  }
  /**
   * Create an iterator over the widgets in the layout.
   *
   * @returns A new iterator over the widgets in the layout.
   */
  *[Symbol.iterator]() {
    for (const item of this._items) {
      yield item.widget;
    }
  }
  /**
   * Add a widget to the grid layout.
   *
   * @param widget - The widget to add to the layout.
   *
   * #### Notes
   * If the widget is already contained in the layout, this is no-op.
   */
  addWidget(widget) {
    let i2 = ArrayExt.findFirstIndex(this._items, (it) => it.widget === widget);
    if (i2 !== -1) {
      return;
    }
    this._items.push(new LayoutItem(widget));
    if (this.parent) {
      this.attachWidget(widget);
    }
  }
  /**
   * Remove a widget from the grid layout.
   *
   * @param widget - The widget to remove from the layout.
   *
   * #### Notes
   * A widget is automatically removed from the layout when its `parent`
   * is set to `null`. This method should only be invoked directly when
   * removing a widget from a layout which has yet to be installed on a
   * parent widget.
   *
   * This method does *not* modify the widget's `parent`.
   */
  removeWidget(widget) {
    let i2 = ArrayExt.findFirstIndex(this._items, (it) => it.widget === widget);
    if (i2 === -1) {
      return;
    }
    let item = ArrayExt.removeAt(this._items, i2);
    if (this.parent) {
      this.detachWidget(widget);
    }
    item.dispose();
  }
  /**
   * Perform layout initialization which requires the parent widget.
   */
  init() {
    super.init();
    for (const widget of this) {
      this.attachWidget(widget);
    }
  }
  /**
   * Attach a widget to the parent's DOM node.
   *
   * @param widget - The widget to attach to the parent.
   */
  attachWidget(widget) {
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
    }
    this.parent.node.appendChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
    }
    this.parent.fit();
  }
  /**
   * Detach a widget from the parent's DOM node.
   *
   * @param widget - The widget to detach from the parent.
   */
  detachWidget(widget) {
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
    }
    this.parent.node.removeChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
    }
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'before-show'` message.
   */
  onBeforeShow(msg) {
    super.onBeforeShow(msg);
    this.parent.update();
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    super.onBeforeAttach(msg);
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-shown'` message.
   */
  onChildShown(msg) {
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-hidden'` message.
   */
  onChildHidden(msg) {
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'resize'` message.
   */
  onResize(msg) {
    if (this.parent.isVisible) {
      this._update(msg.width, msg.height);
    }
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   */
  onUpdateRequest(msg) {
    if (this.parent.isVisible) {
      this._update(-1, -1);
    }
  }
  /**
   * A message handler invoked on a `'fit-request'` message.
   */
  onFitRequest(msg) {
    if (this.parent.isAttached) {
      this._fit();
    }
  }
  /**
   * Fit the layout to the total size required by the widgets.
   */
  _fit() {
    for (let i2 = 0, n = this.rowCount; i2 < n; ++i2) {
      this._rowSizers[i2].minSize = 0;
    }
    for (let i2 = 0, n = this.columnCount; i2 < n; ++i2) {
      this._columnSizers[i2].minSize = 0;
    }
    let items = this._items.filter((it) => !it.isHidden);
    for (let i2 = 0, n = items.length; i2 < n; ++i2) {
      items[i2].fit();
    }
    let maxRow = this.rowCount - 1;
    let maxCol = this.columnCount - 1;
    items.sort(Private$4$1.rowSpanCmp);
    for (let i2 = 0, n = items.length; i2 < n; ++i2) {
      let item = items[i2];
      let config2 = GridLayout.getCellConfig(item.widget);
      let r1 = Math.min(config2.row, maxRow);
      let r2 = Math.min(config2.row + config2.rowSpan - 1, maxRow);
      Private$4$1.distributeMin(this._rowSizers, r1, r2, item.minHeight);
    }
    items.sort(Private$4$1.columnSpanCmp);
    for (let i2 = 0, n = items.length; i2 < n; ++i2) {
      let item = items[i2];
      let config2 = GridLayout.getCellConfig(item.widget);
      let c1 = Math.min(config2.column, maxCol);
      let c2 = Math.min(config2.column + config2.columnSpan - 1, maxCol);
      Private$4$1.distributeMin(this._columnSizers, c1, c2, item.minWidth);
    }
    if (this.fitPolicy === "set-no-constraint") {
      MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
      return;
    }
    let minH = maxRow * this._rowSpacing;
    let minW = maxCol * this._columnSpacing;
    for (let i2 = 0, n = this.rowCount; i2 < n; ++i2) {
      minH += this._rowSizers[i2].minSize;
    }
    for (let i2 = 0, n = this.columnCount; i2 < n; ++i2) {
      minW += this._columnSizers[i2].minSize;
    }
    let box = this._box = ElementExt.boxSizing(this.parent.node);
    minW += box.horizontalSum;
    minH += box.verticalSum;
    let style2 = this.parent.node.style;
    style2.minWidth = `${minW}px`;
    style2.minHeight = `${minH}px`;
    this._dirty = true;
    if (this.parent.parent) {
      MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
    }
    if (this._dirty) {
      MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
    }
  }
  /**
   * Update the layout position and size of the widgets.
   *
   * The parent offset dimensions should be `-1` if unknown.
   */
  _update(offsetWidth, offsetHeight) {
    this._dirty = false;
    if (offsetWidth < 0) {
      offsetWidth = this.parent.node.offsetWidth;
    }
    if (offsetHeight < 0) {
      offsetHeight = this.parent.node.offsetHeight;
    }
    if (!this._box) {
      this._box = ElementExt.boxSizing(this.parent.node);
    }
    let top2 = this._box.paddingTop;
    let left = this._box.paddingLeft;
    let width = offsetWidth - this._box.horizontalSum;
    let height = offsetHeight - this._box.verticalSum;
    let maxRow = this.rowCount - 1;
    let maxCol = this.columnCount - 1;
    let fixedRowSpace = maxRow * this._rowSpacing;
    let fixedColSpace = maxCol * this._columnSpacing;
    BoxEngine.calc(this._rowSizers, Math.max(0, height - fixedRowSpace));
    BoxEngine.calc(this._columnSizers, Math.max(0, width - fixedColSpace));
    for (let i2 = 0, pos = top2, n = this.rowCount; i2 < n; ++i2) {
      this._rowStarts[i2] = pos;
      pos += this._rowSizers[i2].size + this._rowSpacing;
    }
    for (let i2 = 0, pos = left, n = this.columnCount; i2 < n; ++i2) {
      this._columnStarts[i2] = pos;
      pos += this._columnSizers[i2].size + this._columnSpacing;
    }
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      let item = this._items[i2];
      if (item.isHidden) {
        continue;
      }
      let config2 = GridLayout.getCellConfig(item.widget);
      let r1 = Math.min(config2.row, maxRow);
      let c1 = Math.min(config2.column, maxCol);
      let r2 = Math.min(config2.row + config2.rowSpan - 1, maxRow);
      let c2 = Math.min(config2.column + config2.columnSpan - 1, maxCol);
      let x2 = this._columnStarts[c1];
      let y = this._rowStarts[r1];
      let w = this._columnStarts[c2] + this._columnSizers[c2].size - x2;
      let h2 = this._rowStarts[r2] + this._rowSizers[r2].size - y;
      item.update(x2, y, w, h2);
    }
  }
}
(function(GridLayout2) {
  function getCellConfig(widget) {
    return Private$4$1.cellConfigProperty.get(widget);
  }
  GridLayout2.getCellConfig = getCellConfig;
  function setCellConfig(widget, value) {
    Private$4$1.cellConfigProperty.set(widget, Private$4$1.normalizeConfig(value));
  }
  GridLayout2.setCellConfig = setCellConfig;
})(GridLayout || (GridLayout = {}));
var Private$4$1;
(function(Private2) {
  Private2.cellConfigProperty = new AttachedProperty({
    name: "cellConfig",
    create: () => ({ row: 0, column: 0, rowSpan: 1, columnSpan: 1 }),
    changed: onChildCellConfigChanged
  });
  function normalizeConfig(config2) {
    let row = Math.max(0, Math.floor(config2.row || 0));
    let column = Math.max(0, Math.floor(config2.column || 0));
    let rowSpan = Math.max(1, Math.floor(config2.rowSpan || 0));
    let columnSpan = Math.max(1, Math.floor(config2.columnSpan || 0));
    return { row, column, rowSpan, columnSpan };
  }
  Private2.normalizeConfig = normalizeConfig;
  function clampValue(value) {
    return Math.max(0, Math.floor(value));
  }
  Private2.clampValue = clampValue;
  function rowSpanCmp(a, b) {
    let c1 = Private2.cellConfigProperty.get(a.widget);
    let c2 = Private2.cellConfigProperty.get(b.widget);
    return c1.rowSpan - c2.rowSpan;
  }
  Private2.rowSpanCmp = rowSpanCmp;
  function columnSpanCmp(a, b) {
    let c1 = Private2.cellConfigProperty.get(a.widget);
    let c2 = Private2.cellConfigProperty.get(b.widget);
    return c1.columnSpan - c2.columnSpan;
  }
  Private2.columnSpanCmp = columnSpanCmp;
  function reallocSizers(sizers, count) {
    count = Math.max(1, Math.floor(count));
    while (sizers.length < count) {
      sizers.push(new BoxSizer());
    }
    if (sizers.length > count) {
      sizers.length = count;
    }
  }
  Private2.reallocSizers = reallocSizers;
  function distributeMin(sizers, i1, i2, minSize) {
    if (i2 < i1) {
      return;
    }
    if (i1 === i2) {
      let sizer = sizers[i1];
      sizer.minSize = Math.max(sizer.minSize, minSize);
      return;
    }
    let totalMin = 0;
    for (let i3 = i1; i3 <= i2; ++i3) {
      totalMin += sizers[i3].minSize;
    }
    if (totalMin >= minSize) {
      return;
    }
    let portion = (minSize - totalMin) / (i2 - i1 + 1);
    for (let i3 = i1; i3 <= i2; ++i3) {
      sizers[i3].minSize += portion;
    }
  }
  Private2.distributeMin = distributeMin;
  function onChildCellConfigChanged(child) {
    if (child.parent && child.parent.layout instanceof GridLayout) {
      child.parent.fit();
    }
  }
})(Private$4$1 || (Private$4$1 = {}));
class MenuBar extends Widget {
  /**
   * Construct a new menu bar.
   *
   * @param options - The options for initializing the menu bar.
   */
  constructor(options = {}) {
    super({ node: Private$3$1.createNode() });
    this._activeIndex = -1;
    this._tabFocusIndex = 0;
    this._menus = [];
    this._childMenu = null;
    this._overflowMenu = null;
    this._menuItemSizes = [];
    this._overflowIndex = -1;
    this.addClass("lm-MenuBar");
    this.setFlag(Widget.Flag.DisallowLayout);
    this.renderer = options.renderer || MenuBar.defaultRenderer;
    this._forceItemsPosition = options.forceItemsPosition || {
      forceX: true,
      forceY: true
    };
    this._overflowMenuOptions = options.overflowMenuOptions || {
      isVisible: true
    };
  }
  /**
   * Dispose of the resources held by the widget.
   */
  dispose() {
    this._closeChildMenu();
    this._menus.length = 0;
    super.dispose();
  }
  /**
   * The child menu of the menu bar.
   *
   * #### Notes
   * This will be `null` if the menu bar does not have an open menu.
   */
  get childMenu() {
    return this._childMenu;
  }
  /**
   * The overflow index of the menu bar.
   */
  get overflowIndex() {
    return this._overflowIndex;
  }
  /**
   * The overflow menu of the menu bar.
   */
  get overflowMenu() {
    return this._overflowMenu;
  }
  /**
   * Get the menu bar content node.
   *
   * #### Notes
   * This is the node which holds the menu title nodes.
   *
   * Modifying this node directly can lead to undefined behavior.
   */
  get contentNode() {
    return this.node.getElementsByClassName("lm-MenuBar-content")[0];
  }
  /**
   * Get the currently active menu.
   */
  get activeMenu() {
    return this._menus[this._activeIndex] || null;
  }
  /**
   * Set the currently active menu.
   *
   * #### Notes
   * If the menu does not exist, the menu will be set to `null`.
   */
  set activeMenu(value) {
    this.activeIndex = value ? this._menus.indexOf(value) : -1;
  }
  /**
   * Get the index of the currently active menu.
   *
   * #### Notes
   * This will be `-1` if no menu is active.
   */
  get activeIndex() {
    return this._activeIndex;
  }
  /**
   * Set the index of the currently active menu.
   *
   * #### Notes
   * If the menu cannot be activated, the index will be set to `-1`.
   */
  set activeIndex(value) {
    if (value < 0 || value >= this._menus.length) {
      value = -1;
    }
    if (value > -1 && this._menus[value].items.length === 0) {
      value = -1;
    }
    if (this._activeIndex === value) {
      return;
    }
    this._activeIndex = value;
    this.update();
  }
  /**
   * A read-only array of the menus in the menu bar.
   */
  get menus() {
    return this._menus;
  }
  /**
   * Open the active menu and activate its first menu item.
   *
   * #### Notes
   * If there is no active menu, this is a no-op.
   */
  openActiveMenu() {
    if (this._activeIndex === -1) {
      return;
    }
    this._openChildMenu();
    if (this._childMenu) {
      this._childMenu.activeIndex = -1;
      this._childMenu.activateNextItem();
    }
  }
  /**
   * Add a menu to the end of the menu bar.
   *
   * @param menu - The menu to add to the menu bar.
   *
   * #### Notes
   * If the menu is already added to the menu bar, it will be moved.
   */
  addMenu(menu, update = true) {
    this.insertMenu(this._menus.length, menu, update);
  }
  /**
   * Insert a menu into the menu bar at the specified index.
   *
   * @param index - The index at which to insert the menu.
   *
   * @param menu - The menu to insert into the menu bar.
   *
   * #### Notes
   * The index will be clamped to the bounds of the menus.
   *
   * If the menu is already added to the menu bar, it will be moved.
   */
  insertMenu(index, menu, update = true) {
    this._closeChildMenu();
    let i2 = this._menus.indexOf(menu);
    let j = Math.max(0, Math.min(index, this._menus.length));
    if (i2 === -1) {
      ArrayExt.insert(this._menus, j, menu);
      menu.addClass("lm-MenuBar-menu");
      menu.aboutToClose.connect(this._onMenuAboutToClose, this);
      menu.menuRequested.connect(this._onMenuMenuRequested, this);
      menu.title.changed.connect(this._onTitleChanged, this);
      if (update) {
        this.update();
      }
      return;
    }
    if (j === this._menus.length) {
      j--;
    }
    if (i2 === j) {
      return;
    }
    ArrayExt.move(this._menus, i2, j);
    if (update) {
      this.update();
    }
  }
  /**
   * Remove a menu from the menu bar.
   *
   * @param menu - The menu to remove from the menu bar.
   *
   * #### Notes
   * This is a no-op if the menu is not in the menu bar.
   */
  removeMenu(menu, update = true) {
    this.removeMenuAt(this._menus.indexOf(menu), update);
  }
  /**
   * Remove the menu at a given index from the menu bar.
   *
   * @param index - The index of the menu to remove.
   *
   * #### Notes
   * This is a no-op if the index is out of range.
   */
  removeMenuAt(index, update = true) {
    this._closeChildMenu();
    let menu = ArrayExt.removeAt(this._menus, index);
    if (!menu) {
      return;
    }
    menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
    menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
    menu.title.changed.disconnect(this._onTitleChanged, this);
    menu.removeClass("lm-MenuBar-menu");
    if (update) {
      this.update();
    }
  }
  /**
   * Remove all menus from the menu bar.
   */
  clearMenus() {
    if (this._menus.length === 0) {
      return;
    }
    this._closeChildMenu();
    for (let menu of this._menus) {
      menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
      menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
      menu.title.changed.disconnect(this._onTitleChanged, this);
      menu.removeClass("lm-MenuBar-menu");
    }
    this._menus.length = 0;
    this.update();
  }
  /**
   * Handle the DOM events for the menu bar.
   *
   * @param event - The DOM event sent to the menu bar.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the menu bar's DOM nodes. It
   * should not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "keydown":
        this._evtKeyDown(event2);
        break;
      case "mousedown":
        this._evtMouseDown(event2);
        break;
      case "mousemove":
        this._evtMouseMove(event2);
        break;
      case "focusout":
        this._evtFocusOut(event2);
        break;
      case "contextmenu":
        event2.preventDefault();
        event2.stopPropagation();
        break;
    }
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    this.node.addEventListener("keydown", this);
    this.node.addEventListener("mousedown", this);
    this.node.addEventListener("mousemove", this);
    this.node.addEventListener("focusout", this);
    this.node.addEventListener("contextmenu", this);
  }
  /**
   * A message handler invoked on an `'after-detach'` message.
   */
  onAfterDetach(msg) {
    this.node.removeEventListener("keydown", this);
    this.node.removeEventListener("mousedown", this);
    this.node.removeEventListener("mousemove", this);
    this.node.removeEventListener("focusout", this);
    this.node.removeEventListener("contextmenu", this);
    this._closeChildMenu();
  }
  /**
   * A message handler invoked on an `'activate-request'` message.
   */
  onActivateRequest(msg) {
    if (this.isAttached) {
      this._focusItemAt(0);
    }
  }
  /**
   * A message handler invoked on a `'resize'` message.
   */
  onResize(msg) {
    this.update();
    super.onResize(msg);
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   */
  onUpdateRequest(msg) {
    var _a;
    let menus = this._menus;
    let renderer = this.renderer;
    let activeIndex = this._activeIndex;
    let tabFocusIndex = this._tabFocusIndex >= 0 && this._tabFocusIndex < menus.length ? this._tabFocusIndex : 0;
    let length2 = this._overflowIndex > -1 ? this._overflowIndex : menus.length;
    let totalMenuSize = 0;
    let isVisible2 = false;
    length2 = this._overflowMenu !== null ? length2 - 1 : length2;
    let content = new Array(length2);
    for (let i2 = 0; i2 < length2; ++i2) {
      content[i2] = renderer.renderItem({
        title: menus[i2].title,
        active: i2 === activeIndex,
        tabbable: i2 === tabFocusIndex,
        disabled: menus[i2].items.length === 0,
        onfocus: () => {
          this._tabFocusIndex = i2;
          this.activeIndex = i2;
        }
      });
      totalMenuSize += this._menuItemSizes[i2];
      if (menus[i2].title.label === this._overflowMenuOptions.title) {
        isVisible2 = true;
        length2--;
      }
    }
    if (this._overflowMenuOptions.isVisible) {
      if (this._overflowIndex > -1 && !isVisible2) {
        if (this._overflowMenu === null) {
          const overflowMenuTitle = (_a = this._overflowMenuOptions.title) !== null && _a !== void 0 ? _a : "...";
          this._overflowMenu = new Menu({ commands: new CommandRegistry() });
          this._overflowMenu.title.label = overflowMenuTitle;
          this._overflowMenu.title.mnemonic = 0;
          this.addMenu(this._overflowMenu, false);
        }
        for (let i2 = menus.length - 2; i2 >= length2; i2--) {
          const submenu = this.menus[i2];
          submenu.title.mnemonic = 0;
          this._overflowMenu.insertItem(0, {
            type: "submenu",
            submenu
          });
          this.removeMenu(submenu, false);
        }
        content[length2] = renderer.renderItem({
          title: this._overflowMenu.title,
          active: length2 === activeIndex && menus[length2].items.length !== 0,
          tabbable: length2 === tabFocusIndex,
          disabled: menus[length2].items.length === 0,
          onfocus: () => {
            this._tabFocusIndex = length2;
            this.activeIndex = length2;
          }
        });
        length2++;
      } else if (this._overflowMenu !== null) {
        let overflowMenuItems = this._overflowMenu.items;
        let screenSize = this.node.offsetWidth;
        let n = this._overflowMenu.items.length;
        for (let i2 = 0; i2 < n; ++i2) {
          let index = menus.length - 1 - i2;
          if (screenSize - totalMenuSize > this._menuItemSizes[index]) {
            let menu = overflowMenuItems[0].submenu;
            this._overflowMenu.removeItemAt(0);
            this.insertMenu(length2, menu, false);
            content[length2] = renderer.renderItem({
              title: menu.title,
              active: false,
              tabbable: length2 === tabFocusIndex,
              disabled: menus[length2].items.length === 0,
              onfocus: () => {
                this._tabFocusIndex = length2;
                this.activeIndex = length2;
              }
            });
            length2++;
          }
        }
        if (this._overflowMenu.items.length === 0) {
          this.removeMenu(this._overflowMenu, false);
          content.pop();
          this._overflowMenu = null;
          this._overflowIndex = -1;
        }
      }
    }
    VirtualDOM.render(content, this.contentNode);
    this._updateOverflowIndex();
  }
  /**
   * Calculate and update the current overflow index.
   */
  _updateOverflowIndex() {
    if (!this._overflowMenuOptions.isVisible) {
      return;
    }
    const itemMenus = this.contentNode.childNodes;
    let screenSize = this.node.offsetWidth;
    let totalMenuSize = 0;
    let index = -1;
    let n = itemMenus.length;
    if (this._menuItemSizes.length == 0) {
      for (let i2 = 0; i2 < n; i2++) {
        let item = itemMenus[i2];
        totalMenuSize += item.offsetWidth;
        this._menuItemSizes.push(item.offsetWidth);
        if (totalMenuSize > screenSize && index === -1) {
          index = i2;
        }
      }
    } else {
      for (let i2 = 0; i2 < this._menuItemSizes.length; i2++) {
        totalMenuSize += this._menuItemSizes[i2];
        if (totalMenuSize > screenSize) {
          index = i2;
          break;
        }
      }
    }
    this._overflowIndex = index;
  }
  /**
   * Handle the `'keydown'` event for the menu bar.
   *
   * #### Notes
   * All keys are trapped except the tab key that is ignored.
   */
  _evtKeyDown(event2) {
    let kc = event2.keyCode;
    if (kc === 9) {
      this.activeIndex = -1;
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    if (kc === 13 || kc === 32 || kc === 38 || kc === 40) {
      this.activeIndex = this._tabFocusIndex;
      if (this.activeIndex !== this._tabFocusIndex) {
        return;
      }
      this.openActiveMenu();
      return;
    }
    if (kc === 27) {
      this._closeChildMenu();
      this._focusItemAt(this.activeIndex);
      return;
    }
    if (kc === 37 || kc === 39) {
      let direction = kc === 37 ? -1 : 1;
      let start2 = this._tabFocusIndex + direction;
      let n = this._menus.length;
      for (let i2 = 0; i2 < n; i2++) {
        let index = (n + start2 + direction * i2) % n;
        if (this._menus[index].items.length) {
          this._focusItemAt(index);
          return;
        }
      }
      return;
    }
    let key2 = getKeyboardLayout().keyForKeydownEvent(event2);
    if (!key2) {
      return;
    }
    let start = this._activeIndex + 1;
    let result2 = Private$3$1.findMnemonic(this._menus, key2, start);
    if (result2.index !== -1 && !result2.multiple) {
      this.activeIndex = result2.index;
      this.openActiveMenu();
    } else if (result2.index !== -1) {
      this.activeIndex = result2.index;
      this._focusItemAt(this.activeIndex);
    } else if (result2.auto !== -1) {
      this.activeIndex = result2.auto;
      this._focusItemAt(this.activeIndex);
    }
  }
  /**
   * Handle the `'mousedown'` event for the menu bar.
   */
  _evtMouseDown(event2) {
    if (!ElementExt.hitTest(this.node, event2.clientX, event2.clientY)) {
      return;
    }
    event2.stopPropagation();
    event2.stopImmediatePropagation();
    let index = ArrayExt.findFirstIndex(this.contentNode.children, (node2) => {
      return ElementExt.hitTest(node2, event2.clientX, event2.clientY);
    });
    if (index === -1) {
      this._closeChildMenu();
      return;
    }
    if (event2.button !== 0) {
      return;
    }
    if (this._childMenu) {
      this._closeChildMenu();
      this.activeIndex = index;
    } else {
      event2.preventDefault();
      const position = this._positionForMenu(index);
      Menu.saveWindowData();
      this.activeIndex = index;
      this._openChildMenu(position);
    }
  }
  /**
   * Handle the `'mousemove'` event for the menu bar.
   */
  _evtMouseMove(event2) {
    let index = ArrayExt.findFirstIndex(this.contentNode.children, (node2) => {
      return ElementExt.hitTest(node2, event2.clientX, event2.clientY);
    });
    if (index === this._activeIndex) {
      return;
    }
    if (index === -1 && this._childMenu) {
      return;
    }
    const position = index >= 0 && this._childMenu ? this._positionForMenu(index) : null;
    Menu.saveWindowData();
    this.activeIndex = index;
    if (position) {
      this._openChildMenu(position);
    }
  }
  /**
   * Find initial position for the menu based on menubar item position.
   *
   * NOTE: this should be called before updating active index to avoid
   * an additional layout and style invalidation as changing active
   * index modifies DOM.
   */
  _positionForMenu(index) {
    let itemNode = this.contentNode.children[index];
    let { left, bottom } = itemNode.getBoundingClientRect();
    return {
      top: bottom,
      left
    };
  }
  /**
   * Handle the `'focusout'` event for the menu bar.
   */
  _evtFocusOut(event2) {
    if (!this._childMenu && !this.node.contains(event2.relatedTarget)) {
      this.activeIndex = -1;
    }
  }
  /**
   * Focus an item in the menu bar.
   *
   * #### Notes
   * Does not open the associated menu.
   */
  _focusItemAt(index) {
    const itemNode = this.contentNode.childNodes[index];
    if (itemNode) {
      itemNode.focus();
    }
  }
  /**
   * Open the child menu at the active index immediately.
   *
   * If a different child menu is already open, it will be closed,
   * even if there is no active menu.
   */
  _openChildMenu(options = {}) {
    let newMenu = this.activeMenu;
    if (!newMenu) {
      this._closeChildMenu();
      return;
    }
    let oldMenu = this._childMenu;
    if (oldMenu === newMenu) {
      return;
    }
    this._childMenu = newMenu;
    if (oldMenu) {
      oldMenu.close();
    } else {
      document.addEventListener("mousedown", this, true);
    }
    this._tabFocusIndex = this.activeIndex;
    MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);
    let { left, top: top2 } = options;
    if (typeof left === "undefined" || typeof top2 === "undefined") {
      ({ left, top: top2 } = this._positionForMenu(this._activeIndex));
    }
    if (!oldMenu) {
      this.addClass("lm-mod-active");
    }
    if (newMenu.items.length > 0) {
      newMenu.open(left, top2, this._forceItemsPosition);
    }
  }
  /**
   * Close the child menu immediately.
   *
   * This is a no-op if a child menu is not open.
   */
  _closeChildMenu() {
    if (!this._childMenu) {
      return;
    }
    this.removeClass("lm-mod-active");
    document.removeEventListener("mousedown", this, true);
    let menu = this._childMenu;
    this._childMenu = null;
    menu.close();
    this.activeIndex = -1;
  }
  /**
   * Handle the `aboutToClose` signal of a menu.
   */
  _onMenuAboutToClose(sender) {
    if (sender !== this._childMenu) {
      return;
    }
    this.removeClass("lm-mod-active");
    document.removeEventListener("mousedown", this, true);
    this._childMenu = null;
    this.activeIndex = -1;
  }
  /**
   * Handle the `menuRequested` signal of a child menu.
   */
  _onMenuMenuRequested(sender, args) {
    if (sender !== this._childMenu) {
      return;
    }
    let i2 = this._activeIndex;
    let n = this._menus.length;
    switch (args) {
      case "next":
        this.activeIndex = i2 === n - 1 ? 0 : i2 + 1;
        break;
      case "previous":
        this.activeIndex = i2 === 0 ? n - 1 : i2 - 1;
        break;
    }
    this.openActiveMenu();
  }
  /**
   * Handle the `changed` signal of a title object.
   */
  _onTitleChanged() {
    this.update();
  }
}
(function(MenuBar2) {
  class Renderer {
    /**
     * Render the virtual element for a menu bar item.
     *
     * @param data - The data to use for rendering the item.
     *
     * @returns A virtual element representing the item.
     */
    renderItem(data) {
      let className = this.createItemClass(data);
      let dataset = this.createItemDataset(data);
      let aria = this.createItemARIA(data);
      return h.li({
        className,
        dataset,
        ...data.disabled ? {} : { tabindex: data.tabbable ? "0" : "-1" },
        onfocus: data.onfocus,
        ...aria
      }, this.renderIcon(data), this.renderLabel(data));
    }
    /**
     * Render the icon element for a menu bar item.
     *
     * @param data - The data to use for rendering the icon.
     *
     * @returns A virtual element representing the item icon.
     */
    renderIcon(data) {
      let className = this.createIconClass(data);
      return h.div({ className }, data.title.icon, data.title.iconLabel);
    }
    /**
     * Render the label element for a menu item.
     *
     * @param data - The data to use for rendering the label.
     *
     * @returns A virtual element representing the item label.
     */
    renderLabel(data) {
      let content = this.formatLabel(data);
      return h.div({ className: "lm-MenuBar-itemLabel" }, content);
    }
    /**
     * Create the class name for the menu bar item.
     *
     * @param data - The data to use for the class name.
     *
     * @returns The full class name for the menu item.
     */
    createItemClass(data) {
      let name2 = "lm-MenuBar-item";
      if (data.title.className) {
        name2 += ` ${data.title.className}`;
      }
      if (data.active && !data.disabled) {
        name2 += " lm-mod-active";
      }
      return name2;
    }
    /**
     * Create the dataset for a menu bar item.
     *
     * @param data - The data to use for the item.
     *
     * @returns The dataset for the menu bar item.
     */
    createItemDataset(data) {
      return data.title.dataset;
    }
    /**
     * Create the aria attributes for menu bar item.
     *
     * @param data - The data to use for the aria attributes.
     *
     * @returns The aria attributes object for the item.
     */
    createItemARIA(data) {
      return {
        role: "menuitem",
        "aria-haspopup": "true",
        "aria-disabled": data.disabled ? "true" : "false"
      };
    }
    /**
     * Create the class name for the menu bar item icon.
     *
     * @param data - The data to use for the class name.
     *
     * @returns The full class name for the item icon.
     */
    createIconClass(data) {
      let name2 = "lm-MenuBar-itemIcon";
      let extra = data.title.iconClass;
      return extra ? `${name2} ${extra}` : name2;
    }
    /**
     * Create the render content for the label node.
     *
     * @param data - The data to use for the label content.
     *
     * @returns The content to add to the label node.
     */
    formatLabel(data) {
      let { label, mnemonic } = data.title;
      if (mnemonic < 0 || mnemonic >= label.length) {
        return label;
      }
      let prefix = label.slice(0, mnemonic);
      let suffix = label.slice(mnemonic + 1);
      let char = label[mnemonic];
      let span = h.span({ className: "lm-MenuBar-itemMnemonic" }, char);
      return [prefix, span, suffix];
    }
  }
  MenuBar2.Renderer = Renderer;
  MenuBar2.defaultRenderer = new Renderer();
})(MenuBar || (MenuBar = {}));
var Private$3$1;
(function(Private2) {
  function createNode() {
    let node2 = document.createElement("div");
    let content = document.createElement("ul");
    content.className = "lm-MenuBar-content";
    node2.appendChild(content);
    content.setAttribute("role", "menubar");
    return node2;
  }
  Private2.createNode = createNode;
  function findMnemonic(menus, key2, start) {
    let index = -1;
    let auto = -1;
    let multiple = false;
    let upperKey = key2.toUpperCase();
    for (let i2 = 0, n = menus.length; i2 < n; ++i2) {
      let k = (i2 + start) % n;
      let title = menus[k].title;
      if (title.label.length === 0) {
        continue;
      }
      let mn = title.mnemonic;
      if (mn >= 0 && mn < title.label.length) {
        if (title.label[mn].toUpperCase() === upperKey) {
          if (index === -1) {
            index = k;
          } else {
            multiple = true;
          }
        }
        continue;
      }
      if (auto === -1 && title.label[0].toUpperCase() === upperKey) {
        auto = k;
      }
    }
    return { index, multiple, auto };
  }
  Private2.findMnemonic = findMnemonic;
})(Private$3$1 || (Private$3$1 = {}));
var Private$2$1;
(function(Private2) {
  function createNode() {
    let node2 = document.createElement("div");
    let decrement = document.createElement("div");
    let increment = document.createElement("div");
    let track = document.createElement("div");
    let thumb = document.createElement("div");
    decrement.className = "lm-ScrollBar-button";
    increment.className = "lm-ScrollBar-button";
    decrement.dataset["action"] = "decrement";
    increment.dataset["action"] = "increment";
    track.className = "lm-ScrollBar-track";
    thumb.className = "lm-ScrollBar-thumb";
    track.appendChild(thumb);
    node2.appendChild(decrement);
    node2.appendChild(track);
    node2.appendChild(increment);
    return node2;
  }
  Private2.createNode = createNode;
  function findPart(scrollBar, target2) {
    if (scrollBar.thumbNode.contains(target2)) {
      return "thumb";
    }
    if (scrollBar.trackNode.contains(target2)) {
      return "track";
    }
    if (scrollBar.decrementNode.contains(target2)) {
      return "decrement";
    }
    if (scrollBar.incrementNode.contains(target2)) {
      return "increment";
    }
    return null;
  }
  Private2.findPart = findPart;
})(Private$2$1 || (Private$2$1 = {}));
class StackedLayout extends PanelLayout {
  constructor(options = {}) {
    super(options);
    this._dirty = false;
    this._items = [];
    this._box = null;
    this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget.HiddenMode.Display;
  }
  /**
   * The method for hiding widgets.
   *
   * #### Notes
   * If there is only one child widget, `Display` hiding mode will be used
   * regardless of this setting.
   */
  get hiddenMode() {
    return this._hiddenMode;
  }
  /**
   * Set the method for hiding widgets.
   *
   * #### Notes
   * If there is only one child widget, `Display` hiding mode will be used
   * regardless of this setting.
   */
  set hiddenMode(v) {
    if (this._hiddenMode === v) {
      return;
    }
    this._hiddenMode = v;
    if (this.widgets.length > 1) {
      this.widgets.forEach((w) => {
        w.hiddenMode = this._hiddenMode;
      });
    }
  }
  /**
   * Dispose of the resources held by the layout.
   */
  dispose() {
    for (const item of this._items) {
      item.dispose();
    }
    this._box = null;
    this._items.length = 0;
    super.dispose();
  }
  /**
   * Attach a widget to the parent's DOM node.
   *
   * @param index - The current index of the widget in the layout.
   *
   * @param widget - The widget to attach to the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  attachWidget(index, widget) {
    if (this._hiddenMode === Widget.HiddenMode.Scale && this._items.length > 0) {
      if (this._items.length === 1) {
        this.widgets[0].hiddenMode = Widget.HiddenMode.Scale;
      }
      widget.hiddenMode = Widget.HiddenMode.Scale;
    } else {
      widget.hiddenMode = Widget.HiddenMode.Display;
    }
    ArrayExt.insert(this._items, index, new LayoutItem(widget));
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
    }
    this.parent.node.appendChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
    }
    this.parent.fit();
  }
  /**
   * Move a widget in the parent's DOM node.
   *
   * @param fromIndex - The previous index of the widget in the layout.
   *
   * @param toIndex - The current index of the widget in the layout.
   *
   * @param widget - The widget to move in the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  moveWidget(fromIndex, toIndex, widget) {
    ArrayExt.move(this._items, fromIndex, toIndex);
    this.parent.update();
  }
  /**
   * Detach a widget from the parent's DOM node.
   *
   * @param index - The previous index of the widget in the layout.
   *
   * @param widget - The widget to detach from the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  detachWidget(index, widget) {
    let item = ArrayExt.removeAt(this._items, index);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
    }
    this.parent.node.removeChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
    }
    item.widget.node.style.zIndex = "";
    if (this._hiddenMode === Widget.HiddenMode.Scale) {
      widget.hiddenMode = Widget.HiddenMode.Display;
      if (this._items.length === 1) {
        this._items[0].widget.hiddenMode = Widget.HiddenMode.Display;
      }
    }
    item.dispose();
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'before-show'` message.
   */
  onBeforeShow(msg) {
    super.onBeforeShow(msg);
    this.parent.update();
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    super.onBeforeAttach(msg);
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-shown'` message.
   */
  onChildShown(msg) {
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-hidden'` message.
   */
  onChildHidden(msg) {
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'resize'` message.
   */
  onResize(msg) {
    if (this.parent.isVisible) {
      this._update(msg.width, msg.height);
    }
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   */
  onUpdateRequest(msg) {
    if (this.parent.isVisible) {
      this._update(-1, -1);
    }
  }
  /**
   * A message handler invoked on a `'fit-request'` message.
   */
  onFitRequest(msg) {
    if (this.parent.isAttached) {
      this._fit();
    }
  }
  /**
   * Fit the layout to the total size required by the widgets.
   */
  _fit() {
    let minW = 0;
    let minH = 0;
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      let item = this._items[i2];
      if (item.isHidden) {
        continue;
      }
      item.fit();
      minW = Math.max(minW, item.minWidth);
      minH = Math.max(minH, item.minHeight);
    }
    let box = this._box = ElementExt.boxSizing(this.parent.node);
    minW += box.horizontalSum;
    minH += box.verticalSum;
    let style2 = this.parent.node.style;
    style2.minWidth = `${minW}px`;
    style2.minHeight = `${minH}px`;
    this._dirty = true;
    if (this.parent.parent) {
      MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
    }
    if (this._dirty) {
      MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
    }
  }
  /**
   * Update the layout position and size of the widgets.
   *
   * The parent offset dimensions should be `-1` if unknown.
   */
  _update(offsetWidth, offsetHeight) {
    this._dirty = false;
    let nVisible = 0;
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      nVisible += +!this._items[i2].isHidden;
    }
    if (nVisible === 0) {
      return;
    }
    if (offsetWidth < 0) {
      offsetWidth = this.parent.node.offsetWidth;
    }
    if (offsetHeight < 0) {
      offsetHeight = this.parent.node.offsetHeight;
    }
    if (!this._box) {
      this._box = ElementExt.boxSizing(this.parent.node);
    }
    let top2 = this._box.paddingTop;
    let left = this._box.paddingLeft;
    let width = offsetWidth - this._box.horizontalSum;
    let height = offsetHeight - this._box.verticalSum;
    for (let i2 = 0, n = this._items.length; i2 < n; ++i2) {
      let item = this._items[i2];
      if (item.isHidden) {
        continue;
      }
      item.widget.node.style.zIndex = `${i2}`;
      item.update(left, top2, width, height);
    }
  }
}
var Private$1$1;
(function(Private2) {
  function createLayout(options) {
    return options.layout || new StackedLayout();
  }
  Private2.createLayout = createLayout;
})(Private$1$1 || (Private$1$1 = {}));
var Private$r;
(function(Private2) {
  function orientationFromPlacement(plc) {
    return placementToOrientationMap[plc];
  }
  Private2.orientationFromPlacement = orientationFromPlacement;
  function directionFromPlacement(plc) {
    return placementToDirectionMap[plc];
  }
  Private2.directionFromPlacement = directionFromPlacement;
  const placementToOrientationMap = {
    top: "horizontal",
    left: "vertical",
    right: "vertical",
    bottom: "horizontal"
  };
  const placementToDirectionMap = {
    top: "top-to-bottom",
    left: "left-to-right",
    right: "right-to-left",
    bottom: "bottom-to-top"
  };
})(Private$r || (Private$r = {}));
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports) {
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
        else break a;
      }
    }
    function h2(a) {
      return 0 === a.length ? null : a[0];
    }
    function k(a) {
      if (0 === a.length) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
          var m2 = 2 * (d + 1) - 1, C2 = a[m2], n = m2 + 1, x2 = a[n];
          if (0 > g(C2, c)) n < e && 0 > g(x2, C2) ? (a[d] = x2, a[n] = c, d = n) : (a[d] = C2, a[m2] = c, d = m2);
          else if (n < e && 0 > g(x2, c)) a[d] = x2, a[n] = c, d = n;
          else break a;
        }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l = performance;
      exports.unstable_now = function() {
        return l.now();
      };
    } else {
      var p = Date, q = p.now();
      exports.unstable_now = function() {
        return p.now() - q;
      };
    }
    var r = [], t = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h2(t); null !== b; ) {
        if (null === b.callback) k(t);
        else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
        else break;
        b = h2(t);
      }
    }
    function H(a) {
      B = false;
      G(a);
      if (!A) if (null !== h2(r)) A = true, I(J);
      else {
        var b = h2(t);
        null !== b && K(H, b.startTime - a);
      }
    }
    function J(a, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c = y;
      try {
        G(b);
        for (v = h2(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
          var d = v.callback;
          if ("function" === typeof d) {
            v.callback = null;
            y = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports.unstable_now();
            "function" === typeof e ? v.callback = e : v === h2(r) && k(r);
            G(b);
          } else k(r);
          v = h2(r);
        }
        if (null !== v) var w = true;
        else {
          var m2 = h2(t);
          null !== m2 && K(H, m2.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y = c, z = false;
      }
    }
    var N = false, O = null, L = -1, P = 5, Q = -1;
    function M() {
      return exports.unstable_now() - Q < P ? false : true;
    }
    function R() {
      if (null !== O) {
        var a = exports.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    var S;
    if ("function" === typeof F) S = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = function() {
        U.postMessage(null);
      };
    } else S = function() {
      D(R, 0);
    };
    function I(a) {
      O = a;
      N || (N = true, S());
    }
    function K(a, b) {
      L = D(function() {
        a(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h2(r);
    };
    exports.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports.unstable_scheduleCallback = function(a, b, c) {
      var d = exports.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d ? (a.sortIndex = c, f(t, a), null === h2(r) && a === h2(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
      return a;
    };
    exports.unstable_shouldYield = M;
    exports.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var scheduler_development = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_development;
function requireScheduler_development() {
  if (hasRequiredScheduler_development) return scheduler_development;
  hasRequiredScheduler_development = 1;
  (function(exports) {
    if (process.env.NODE_ENV !== "production") {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node2) {
          var index = heap.length;
          heap.push(node2);
          siftUp(heap, node2, index);
        }
        function peek(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last2 = heap.pop();
          if (last2 !== first) {
            heap[0] = last2;
            siftDown(heap, last2, 0);
          }
          return first;
        }
        function siftUp(heap, node2, i2) {
          var index = i2;
          while (index > 0) {
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (compare2(parent, node2) > 0) {
              heap[parentIndex] = node2;
              heap[index] = parent;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node2, i2) {
          var index = i2;
          var length2 = heap.length;
          var halfLength = length2 >>> 1;
          while (index < halfLength) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare2(left, node2) < 0) {
              if (rightIndex < length2 && compare2(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node2;
                index = rightIndex;
              } else {
                heap[index] = left;
                heap[leftIndex] = node2;
                index = leftIndex;
              }
            } else if (rightIndex < length2 && compare2(right, node2) < 0) {
              heap[index] = right;
              heap[rightIndex] = node2;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare2(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            var currentTime;
            if (enableProfiling) ;
            else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime2 = currentTime + delay;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port2 = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port2.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  })(scheduler_development);
  return scheduler_development;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  if (process.env.NODE_ENV === "production") {
    scheduler.exports = requireScheduler_production_min();
  } else {
    scheduler.exports = requireScheduler_development();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = reactExports, ca = requireScheduler();
  function p(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a, b) {
    ha(a, b);
    ha(a + "Capture", b);
  }
  function ha(a, b) {
    ea[a] = b;
    for (a = 0; a < b.length; a++) da.add(b[a]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a) {
    if (ja.call(ma, a)) return true;
    if (ja.call(la, a)) return false;
    if (ka.test(a)) return ma[a] = true;
    la[a] = true;
    return false;
  }
  function pa(a, b, c, d) {
    if (null !== c && 0 === c.type) return false;
    switch (typeof b) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d) return false;
        if (null !== c) return !c.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;
      default:
        return false;
    }
  }
  function qa(a, b, c, d) {
    if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
    if (d) return false;
    if (null !== c) switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return false;
  }
  function v(a, b, c, d, e, f, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = e;
    this.mustUseProperty = c;
    this.propertyName = a;
    this.type = b;
    this.sanitizeURL = f;
    this.removeEmptyString = g;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    z[a] = new v(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b = a[0];
    z[b] = new v(b, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    z[a] = new v(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    z[a] = new v(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    z[a] = new v(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    z[a] = new v(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b = a.replace(
      ra,
      sa
    );
    z[b] = new v(b, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
  });
  z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
  });
  function ta(a, b, c, d) {
    var e = z.hasOwnProperty(b) ? z[b] : null;
    if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a) {
    if (null === a || "object" !== typeof a) return null;
    a = Ja && a[Ja] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var A = Object.assign, La;
  function Ma(a) {
    if (void 0 === La) try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
    return "\n" + La + a;
  }
  var Na = false;
  function Oa(a, b) {
    if (!a || Na) return "";
    Na = true;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d = l;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d = l;
        }
        a.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l) {
          d = l;
        }
        a();
      }
    } catch (l) {
      if (l && d && "string" === typeof l.stack) {
        for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h2 = f.length - 1; 1 <= g && 0 <= h2 && e[g] !== f[h2]; ) h2--;
        for (; 1 <= g && 0 <= h2; g--, h2--) if (e[g] !== f[h2]) {
          if (1 !== g || 1 !== h2) {
            do
              if (g--, h2--, 0 > h2 || e[g] !== f[h2]) {
                var k = "\n" + e[g].replace(" at new ", " at ");
                a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                return k;
              }
            while (1 <= g && 0 <= h2);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c;
    }
    return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
  }
  function Pa(a) {
    switch (a.tag) {
      case 5:
        return Ma(a.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Oa(a.type, false), a;
      case 11:
        return a = Oa(a.type.render, false), a;
      case 1:
        return a = Oa(a.type, true), a;
      default:
        return "";
    }
  }
  function Qa(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch (a) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a) switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
      case Ha:
        b = a._payload;
        a = a._init;
        try {
          return Qa(a(b));
        } catch (c) {
        }
    }
    return null;
  }
  function Ra(a) {
    var b = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b) return b.displayName || b.name || null;
        if ("string" === typeof b) return b;
    }
    return null;
  }
  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ta(a) {
    var b = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Ua(a) {
    var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
    if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
      var e = c.get, f = c.set;
      Object.defineProperty(a, b, { configurable: true, get: function() {
        return e.call(this);
      }, set: function(a2) {
        d = "" + a2;
        f.call(this, a2);
      } });
      Object.defineProperty(a, b, { enumerable: c.enumerable });
      return { getValue: function() {
        return d;
      }, setValue: function(a2) {
        d = "" + a2;
      }, stopTracking: function() {
        a._valueTracker = null;
        delete a[b];
      } };
    }
  }
  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }
  function Wa(a) {
    if (!a) return false;
    var b = a._valueTracker;
    if (!b) return true;
    var c = b.getValue();
    var d = "";
    a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
    a = d;
    return a !== c ? (b.setValue(a), true) : false;
  }
  function Xa(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a) return null;
    try {
      return a.activeElement || a.body;
    } catch (b) {
      return a.body;
    }
  }
  function Ya(a, b) {
    var c = b.checked;
    return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
  }
  function Za(a, b) {
    var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
    c = Sa(null != b.value ? b.value : c);
    a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }
  function ab(a, b) {
    b = b.checked;
    null != b && ta(a, "checked", b, false);
  }
  function bb(a, b) {
    ab(a, b);
    var c = Sa(b.value), d = b.type;
    if (null != c) if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
    else if ("submit" === d || "reset" === d) {
      a.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
  }
  function db(a, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
      b = "" + a._wrapperState.initialValue;
      c || b === a.value || (a.value = b);
      a.defaultValue = b;
    }
    c = a.name;
    "" !== c && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c && (a.name = c);
  }
  function cb(a, b, c) {
    if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
  }
  var eb = Array.isArray;
  function fb(a, b, c, d) {
    a = a.options;
    if (b) {
      b = {};
      for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
      for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
    } else {
      c = "" + Sa(c);
      b = null;
      for (e = 0; e < a.length; e++) {
        if (a[e].value === c) {
          a[e].selected = true;
          d && (a[e].defaultSelected = true);
          return;
        }
        null !== b || a[e].disabled || (b = a[e]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
    return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function hb(a, b) {
    var c = b.value;
    if (null == c) {
      c = b.children;
      b = b.defaultValue;
      if (null != c) {
        if (null != b) throw Error(p(92));
        if (eb(c)) {
          if (1 < c.length) throw Error(p(93));
          c = c[0];
        }
        b = c;
      }
      null == b && (b = "");
      c = b;
    }
    a._wrapperState = { initialValue: Sa(c) };
  }
  function ib(a, b) {
    var c = Sa(b.value), d = Sa(b.defaultValue);
    null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
    null != d && (a.defaultValue = "" + d);
  }
  function jb(a) {
    var b = a.textContent;
    b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
  }
  function kb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a, b) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
  }
  var mb, nb = function(a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b, c, d, e);
      });
    } : a;
  }(function(a, b) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
      for (; b.firstChild; ) a.appendChild(b.firstChild);
    }
  });
  function ob(a, b) {
    if (b) {
      var c = a.firstChild;
      if (c && c === a.lastChild && 3 === c.nodeType) {
        c.nodeValue = b;
        return;
      }
    }
    a.textContent = b;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a) {
    qb.forEach(function(b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1);
      pb[b] = pb[a];
    });
  });
  function rb(a, b, c) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
  }
  function sb(a, b) {
    a = a.style;
    for (var c in b) if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
  }
  var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a, b) {
    if (b) {
      if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(p(60));
        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
      }
      if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
    }
  }
  function vb(a, b) {
    if (-1 === a.indexOf("-")) return "string" === typeof b.is;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb) throw Error(p(280));
      var b = a.stateNode;
      b && (b = Db(b), yb(a.stateNode, a.type, b));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b = Ab;
      Ab = zb = null;
      Bb(a);
      if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
    }
  }
  function Gb(a, b) {
    return a(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a, b, c) {
    if (Ib) return a(b, c);
    Ib = true;
    try {
      return Gb(a, b, c);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a, b) {
    var c = a.stateNode;
    if (null === c) return null;
    var d = Db(c);
    if (null === d) return null;
    c = d[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
    if (a) return null;
    if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
    return c;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
  function Nb(a, b, c, d, e, f, g, h2, k) {
    var l = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c, l);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
    Ob = true;
    Pb = a;
  } };
  function Tb(a, b, c, d, e, f, g, h2, k) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a, b, c, d, e, f, g, h2, k) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p(198));
      Qb || (Qb = true, Rb = l);
    }
  }
  function Vb(a) {
    var b = a, c = a;
    if (a.alternate) for (; b.return; ) b = b.return;
    else {
      a = b;
      do
        b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
      while (a);
    }
    return 3 === b.tag ? c : null;
  }
  function Wb(a) {
    if (13 === a.tag) {
      var b = a.memoizedState;
      null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
      if (null !== b) return b.dehydrated;
    }
    return null;
  }
  function Xb(a) {
    if (Vb(a) !== a) throw Error(p(188));
  }
  function Yb(a) {
    var b = a.alternate;
    if (!b) {
      b = Vb(a);
      if (null === b) throw Error(p(188));
      return b !== a ? null : a;
    }
    for (var c = a, d = b; ; ) {
      var e = c.return;
      if (null === e) break;
      var f = e.alternate;
      if (null === f) {
        d = e.return;
        if (null !== d) {
          c = d;
          continue;
        }
        break;
      }
      if (e.child === f.child) {
        for (f = e.child; f; ) {
          if (f === c) return Xb(e), a;
          if (f === d) return Xb(e), b;
          f = f.sibling;
        }
        throw Error(p(188));
      }
      if (c.return !== d.return) c = e, d = f;
      else {
        for (var g = false, h2 = e.child; h2; ) {
          if (h2 === c) {
            g = true;
            c = e;
            d = f;
            break;
          }
          if (h2 === d) {
            g = true;
            d = e;
            c = f;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g) {
          for (h2 = f.child; h2; ) {
            if (h2 === c) {
              g = true;
              c = f;
              d = e;
              break;
            }
            if (h2 === d) {
              g = true;
              d = f;
              c = e;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g) throw Error(p(189));
        }
      }
      if (c.alternate !== d) throw Error(p(190));
    }
    if (3 !== c.tag) throw Error(p(188));
    return c.stateNode.current === c ? a : b;
  }
  function Zb(a) {
    a = Yb(a);
    return null !== a ? $b(a) : null;
  }
  function $b(a) {
    if (5 === a.tag || 6 === a.tag) return a;
    for (a = a.child; null !== a; ) {
      var b = $b(a);
      if (null !== b) return b;
      a = a.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function uc(a, b) {
    var c = a.pendingLanes;
    if (0 === c) return 0;
    var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
    if (0 !== g) {
      var h2 = g & ~e;
      0 !== h2 ? d = tc(h2) : (f &= g, 0 !== f && (d = tc(f)));
    } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
    if (0 === d) return 0;
    if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
    0 !== (d & 4) && (d |= c & 16);
    b = a.entangledLanes;
    if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
    return d;
  }
  function vc(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a, b) {
    for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
      var g = 31 - oc(f), h2 = 1 << g, k = e[g];
      if (-1 === k) {
        if (0 === (h2 & c) || 0 !== (h2 & d)) e[g] = vc(h2, b);
      } else k <= b && (a.expiredLanes |= h2);
      f &= ~h2;
    }
  }
  function xc(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a;
  }
  function zc(a) {
    for (var b = [], c = 0; 31 > c; c++) b.push(a);
    return b;
  }
  function Ac(a, b, c) {
    a.pendingLanes |= b;
    536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
    a = a.eventTimes;
    b = 31 - oc(b);
    a[b] = c;
  }
  function Bc(a, b) {
    var c = a.pendingLanes & ~b;
    a.pendingLanes = b;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= b;
    a.mutableReadLanes &= b;
    a.entangledLanes &= b;
    b = a.entanglements;
    var d = a.eventTimes;
    for (a = a.expirationTimes; 0 < c; ) {
      var e = 31 - oc(c), f = 1 << e;
      b[e] = 0;
      d[e] = -1;
      a[e] = -1;
      c &= ~f;
    }
  }
  function Cc(a, b) {
    var c = a.entangledLanes |= b;
    for (a = a.entanglements; c; ) {
      var d = 31 - oc(c), e = 1 << d;
      e & b | a[d] & b && (a[d] |= b);
      c &= ~e;
    }
  }
  var C2 = 0;
  function Dc(a) {
    a &= -a;
    return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a, b) {
    switch (a) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a, b, c, d, e, f) {
    if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
    a.eventSystemFlags |= d;
    b = a.targetContainers;
    null !== e && -1 === b.indexOf(e) && b.push(e);
    return a;
  }
  function Uc(a, b, c, d, e) {
    switch (b) {
      case "focusin":
        return Lc = Tc(Lc, a, b, c, d, e), true;
      case "dragenter":
        return Mc = Tc(Mc, a, b, c, d, e), true;
      case "mouseover":
        return Nc = Tc(Nc, a, b, c, d, e), true;
      case "pointerover":
        var f = e.pointerId;
        Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
        return true;
      case "gotpointercapture":
        return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
    }
    return false;
  }
  function Vc(a) {
    var b = Wc(a.target);
    if (null !== b) {
      var c = Vb(b);
      if (null !== c) {
        if (b = c.tag, 13 === b) {
          if (b = Wb(c), null !== b) {
            a.blockedOn = b;
            Ic(a.priority, function() {
              Gc(c);
            });
            return;
          }
        } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Xc(a) {
    if (null !== a.blockedOn) return false;
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null === c) {
        c = a.nativeEvent;
        var d = new c.constructor(c.type, c);
        wb = d;
        c.target.dispatchEvent(d);
        wb = null;
      } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
      b.shift();
    }
    return true;
  }
  function Zc(a, b, c) {
    Xc(a) && c.delete(b);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a, b) {
    a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a) {
    function b(b2) {
      return ad(b2, a);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a);
      for (var c = 1; c < Kc.length; c++) {
        var d = Kc[c];
        d.blockedOn === a && (d.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a);
    null !== Mc && ad(Mc, a);
    null !== Nc && ad(Nc, a);
    Oc.forEach(b);
    Pc.forEach(b);
    for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
    for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a, b, c, d) {
    var e = C2, f = cd.transition;
    cd.transition = null;
    try {
      C2 = 1, fd(a, b, c, d);
    } finally {
      C2 = e, cd.transition = f;
    }
  }
  function gd(a, b, c, d) {
    var e = C2, f = cd.transition;
    cd.transition = null;
    try {
      C2 = 4, fd(a, b, c, d);
    } finally {
      C2 = e, cd.transition = f;
    }
  }
  function fd(a, b, c, d) {
    if (dd) {
      var e = Yc(a, b, c, d);
      if (null === e) hd(a, b, d, id, c), Sc(a, d);
      else if (Uc(e, a, b, c, d)) d.stopPropagation();
      else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
        for (; null !== e; ) {
          var f = Cb(e);
          null !== f && Ec(f);
          f = Yc(a, b, c, d);
          null === f && hd(a, b, d, id, c);
          if (f === e) break;
          e = f;
        }
        null !== e && d.stopPropagation();
      } else hd(a, b, d, null, c);
    }
  }
  var id = null;
  function Yc(a, b, c, d) {
    id = null;
    a = xb(d);
    a = Wc(a);
    if (null !== a) if (b = Vb(a), null === b) a = null;
    else if (c = b.tag, 13 === c) {
      a = Wb(b);
      if (null !== a) return a;
      a = null;
    } else if (3 === c) {
      if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
      a = null;
    } else b !== a && (a = null);
    id = a;
    return null;
  }
  function jd(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
    for (a = 0; a < c && b[a] === e[a]; a++) ;
    var g = c - a;
    for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
    return md = e.slice(a, 1 < d ? 1 - d : void 0);
  }
  function od(a) {
    var b = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a) {
    function b(b2, d, e, f, g) {
      this._reactName = b2;
      this._targetInst = e;
      this.type = d;
      this.nativeEvent = f;
      this.target = g;
      this.currentTarget = null;
      for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
      this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A(b.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a2 = this.nativeEvent;
      a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a2 = this.nativeEvent;
      a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    if ("movementX" in a) return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : xd;
  } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A({}, ud, { key: function(a) {
    if (a.key) {
      var b = Md[a.key] || a.key;
      if ("Unidentified" !== b) return b;
    }
    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
    return "keypress" === a.type ? od(a) : 0;
  }, keyCode: function(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a, b) {
    switch (a) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }
  var ie2 = false;
  function je(a, b) {
    switch (a) {
      case "compositionend":
        return he(b);
      case "keypress":
        if (32 !== b.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a = b.data, a === ee && fe ? null : a;
      default:
        return null;
    }
  }
  function ke(a, b) {
    if (ie2) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie2 = false, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b.locale ? null : b.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
  }
  function ne(a, b, c, d) {
    Eb(d);
    b = oe(b, "onChange");
    0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
  }
  var pe = null, qe = null;
  function re(a) {
    se(a, 0);
  }
  function te(a) {
    var b = ue(a);
    if (Wa(b)) return a;
  }
  function ve(a, b) {
    if ("change" === a) return b;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a, xb(a));
      Jb(re, b);
    }
  }
  function Ce(a, b, c) {
    "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }
  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
  }
  function Ee(a, b) {
    if ("click" === a) return te(b);
  }
  function Fe(a, b) {
    if ("input" === a || "change" === a) return te(b);
  }
  function Ge(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a, b) {
    if (He(a, b)) return true;
    if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
    var c = Object.keys(a), d = Object.keys(b);
    if (c.length !== d.length) return false;
    for (d = 0; d < c.length; d++) {
      var e = c[d];
      if (!ja.call(b, e) || !He(a[e], b[e])) return false;
    }
    return true;
  }
  function Je(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function Ke(a, b) {
    var c = Je(a);
    a = 0;
    for (var d; c; ) {
      if (3 === c.nodeType) {
        d = a + c.textContent.length;
        if (a <= b && d >= b) return { node: c, offset: b - a };
        a = d;
      }
      a: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Je(c);
    }
  }
  function Le(a, b) {
    return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
  }
  function Me() {
    for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
      try {
        var c = "string" === typeof b.contentWindow.location.href;
      } catch (d) {
        c = false;
      }
      if (c) a = b.contentWindow;
      else break;
      b = Xa(a.document);
    }
    return b;
  }
  function Ne(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
  }
  function Oe(a) {
    var b = Me(), c = a.focusedElem, d = a.selectionRange;
    if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
      if (null !== d && Ne(c)) {
        if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
        else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var e = c.textContent.length, f = Math.min(d.start, e);
          d = void 0 === d.end ? f : Math.min(d.end, e);
          !a.extend && f > d && (e = d, d = f, f = e);
          e = Ke(c, f);
          var g = Ke(
            c,
            d
          );
          e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
        }
      }
      b = [];
      for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      "function" === typeof c.focus && c.focus();
      for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a, b, c) {
    var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
    Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
  }
  function Ve(a, b) {
    var c = {};
    c[a.toLowerCase()] = b.toLowerCase();
    c["Webkit" + a] = "webkit" + b;
    c["Moz" + a] = "moz" + b;
    return c;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a) {
    if (Xe[a]) return Xe[a];
    if (!We[a]) return a;
    var b = We[a], c;
    for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
    return a;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a, b) {
    df.set(a, b);
    fa(b, [a]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a, b, c) {
    var d = a.type || "unknown-event";
    a.currentTarget = c;
    Ub(d, b, void 0, a);
    a.currentTarget = null;
  }
  function se(a, b) {
    b = 0 !== (b & 4);
    for (var c = 0; c < a.length; c++) {
      var d = a[c], e = d.event;
      d = d.listeners;
      a: {
        var f = void 0;
        if (b) for (var g = d.length - 1; 0 <= g; g--) {
          var h2 = d[g], k = h2.instance, l = h2.currentTarget;
          h2 = h2.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h2, l);
          f = k;
        }
        else for (g = 0; g < d.length; g++) {
          h2 = d[g];
          k = h2.instance;
          l = h2.currentTarget;
          h2 = h2.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h2, l);
          f = k;
        }
      }
    }
    if (Qb) throw a = Rb, Qb = false, Rb = null, a;
  }
  function D(a, b) {
    var c = b[of];
    void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
    var d = a + "__bubble";
    c.has(d) || (pf(b, a, 2, false), c.add(d));
  }
  function qf(a, b, c) {
    var d = 0;
    b && (d |= 4);
    pf(c, a, d, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a) {
    if (!a[rf]) {
      a[rf] = true;
      da.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
      });
      var b = 9 === a.nodeType ? a : a.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
    }
  }
  function pf(a, b, c, d) {
    switch (jd(b)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c = e.bind(null, b, c, a);
    e = void 0;
    !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
    d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
  }
  function hd(a, b, c, d, e) {
    var f = d;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
      if (null === d) return;
      var g = d.tag;
      if (3 === g || 4 === g) {
        var h2 = d.stateNode.containerInfo;
        if (h2 === e || 8 === h2.nodeType && h2.parentNode === e) break;
        if (4 === g) for (g = d.return; null !== g; ) {
          var k = g.tag;
          if (3 === k || 4 === k) {
            if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
          }
          g = g.return;
        }
        for (; null !== h2; ) {
          g = Wc(h2);
          if (null === g) return;
          k = g.tag;
          if (5 === k || 6 === k) {
            d = f = g;
            continue a;
          }
          h2 = h2.parentNode;
        }
      }
      d = d.return;
    }
    Jb(function() {
      var d2 = f, e2 = xb(c), g2 = [];
      a: {
        var h3 = df.get(a);
        if (void 0 !== h3) {
          var k2 = td, n = a;
          switch (a) {
            case "keypress":
              if (0 === od(c)) break a;
            case "keydown":
            case "keyup":
              k2 = Rd;
              break;
            case "focusin":
              n = "focus";
              k2 = Fd;
              break;
            case "focusout":
              n = "blur";
              k2 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k2 = Fd;
              break;
            case "click":
              if (2 === c.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k2 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k2 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k2 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k2 = Hd;
              break;
            case cf:
              k2 = Xd;
              break;
            case "scroll":
              k2 = vd;
              break;
            case "wheel":
              k2 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k2 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k2 = Td;
          }
          var t = 0 !== (b & 4), J = !t && "scroll" === a, x2 = t ? null !== h3 ? h3 + "Capture" : null : h3;
          t = [];
          for (var w = d2, u; null !== w; ) {
            u = w;
            var F = u.stateNode;
            5 === u.tag && null !== F && (u = F, null !== x2 && (F = Kb(w, x2), null != F && t.push(tf(w, F, u))));
            if (J) break;
            w = w.return;
          }
          0 < t.length && (h3 = new k2(h3, n, null, c, e2), g2.push({ event: h3, listeners: t }));
        }
      }
      if (0 === (b & 7)) {
        a: {
          h3 = "mouseover" === a || "pointerover" === a;
          k2 = "mouseout" === a || "pointerout" === a;
          if (h3 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
          if (k2 || h3) {
            h3 = e2.window === e2 ? e2 : (h3 = e2.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k2) {
              if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
            } else k2 = null, n = d2;
            if (k2 !== n) {
              t = Bd;
              F = "onMouseLeave";
              x2 = "onMouseEnter";
              w = "mouse";
              if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x2 = "onPointerEnter", w = "pointer";
              J = null == k2 ? h3 : ue(k2);
              u = null == n ? h3 : ue(n);
              h3 = new t(F, w + "leave", k2, c, e2);
              h3.target = J;
              h3.relatedTarget = u;
              F = null;
              Wc(e2) === d2 && (t = new t(x2, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
              J = F;
              if (k2 && n) b: {
                t = k2;
                x2 = n;
                w = 0;
                for (u = t; u; u = vf(u)) w++;
                u = 0;
                for (F = x2; F; F = vf(F)) u++;
                for (; 0 < w - u; ) t = vf(t), w--;
                for (; 0 < u - w; ) x2 = vf(x2), u--;
                for (; w--; ) {
                  if (t === x2 || null !== x2 && t === x2.alternate) break b;
                  t = vf(t);
                  x2 = vf(x2);
                }
                t = null;
              }
              else t = null;
              null !== k2 && wf(g2, h3, k2, t, false);
              null !== n && null !== J && wf(g2, J, n, t, true);
            }
          }
        }
        a: {
          h3 = d2 ? ue(d2) : window;
          k2 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k2 || "input" === k2 && "file" === h3.type) var na = ve;
          else if (me(h3)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k2 = h3.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
          if (na && (na = na(a, d2))) {
            ne(g2, na, c, e2);
            break a;
          }
          xa && xa(a, h3, d2);
          "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa = d2 ? ue(d2) : window;
        switch (a) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g2, c, e2);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g2, c, e2);
        }
        var $a;
        if (ae) b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie2 ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c.locale && (ie2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie2 && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie2 = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
      }
      se(g2, b);
    });
  }
  function tf(a, b, c) {
    return { instance: a, listener: b, currentTarget: c };
  }
  function oe(a, b) {
    for (var c = b + "Capture", d = []; null !== a; ) {
      var e = a, f = e.stateNode;
      5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
      a = a.return;
    }
    return d;
  }
  function vf(a) {
    if (null === a) return null;
    do
      a = a.return;
    while (a && 5 !== a.tag);
    return a ? a : null;
  }
  function wf(a, b, c, d, e) {
    for (var f = b._reactName, g = []; null !== c && c !== d; ) {
      var h2 = c, k = h2.alternate, l = h2.stateNode;
      if (null !== k && k === d) break;
      5 === h2.tag && null !== l && (h2 = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h2))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h2))));
      c = c.return;
    }
    0 !== g.length && a.push({ event: b, listeners: g });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a) {
    return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
  }
  function Af(a, b, c) {
    b = zf(b);
    if (zf(a) !== b && c) throw Error(p(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a, b) {
    return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
  function If(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Kf(a, b) {
    var c = b, d = 0;
    do {
      var e = c.nextSibling;
      a.removeChild(c);
      if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
        if (0 === d) {
          a.removeChild(e);
          bd(b);
          return;
        }
        d--;
      } else "$" !== c && "$?" !== c && "$!" !== c || d++;
      c = e;
    } while (c);
    bd(b);
  }
  function Lf(a) {
    for (; null != a; a = a.nextSibling) {
      var b = a.nodeType;
      if (1 === b || 3 === b) break;
      if (8 === b) {
        b = a.data;
        if ("$" === b || "$!" === b || "$?" === b) break;
        if ("/$" === b) return null;
      }
    }
    return a;
  }
  function Mf(a) {
    a = a.previousSibling;
    for (var b = 0; a; ) {
      if (8 === a.nodeType) {
        var c = a.data;
        if ("$" === c || "$!" === c || "$?" === c) {
          if (0 === b) return a;
          b--;
        } else "/$" === c && b++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a) {
    var b = a[Of];
    if (b) return b;
    for (var c = a.parentNode; c; ) {
      if (b = c[uf] || c[Of]) {
        c = b.alternate;
        if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
          if (c = a[Of]) return c;
          a = Mf(a);
        }
        return b;
      }
      a = c;
      c = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    a = a[Of] || a[uf];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }
  function ue(a) {
    if (5 === a.tag || 6 === a.tag) return a.stateNode;
    throw Error(p(33));
  }
  function Db(a) {
    return a[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a) {
    return { current: a };
  }
  function E(a) {
    0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a, b) {
    Tf++;
    Sf[Tf] = a.current;
    a.current = b;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Vf;
    var d = a.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f;
    for (f in c) e[f] = b[f];
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }
  function Zf(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a, b, c) {
    if (H.current !== Vf) throw Error(p(168));
    G(H, b);
    G(Wf, c);
  }
  function bg(a, b, c) {
    var d = a.stateNode;
    b = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c;
    d = d.getChildContext();
    for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
    return A({}, c, d);
  }
  function cg(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a, b, c) {
    var d = a.stateNode;
    if (!d) throw Error(p(169));
    c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
    G(Wf, c);
  }
  var eg = null, fg = false, gg = false;
  function hg(a) {
    null === eg ? eg = [a] : eg.push(a);
  }
  function ig(a) {
    fg = true;
    hg(a);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a = 0, b = C2;
      try {
        var c = eg;
        for (C2 = 1; a < c.length; a++) {
          var d = c[a];
          do
            d = d(true);
          while (null !== d);
        }
        eg = null;
        fg = false;
      } catch (e) {
        throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
      } finally {
        C2 = b, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a, b) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a;
    ng = b;
  }
  function ug(a, b, c) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a;
    var d = rg;
    a = sg;
    var e = 32 - oc(d) - 1;
    d &= ~(1 << e);
    c += 1;
    var f = 32 - oc(b) + e;
    if (30 < f) {
      var g = e - e % 5;
      f = (d & (1 << g) - 1).toString(32);
      d >>= g;
      e -= g;
      rg = 1 << 32 - oc(b) + e | c << e | d;
      sg = f + a;
    } else rg = 1 << f | c << e | d, sg = a;
  }
  function vg(a) {
    null !== a.return && (tg(a, 1), ug(a, 1, 0));
  }
  function wg(a) {
    for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a, b) {
    var c = Bg(5, null, null, 0);
    c.elementType = "DELETED";
    c.stateNode = b;
    c.return = a;
    b = a.deletions;
    null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
  }
  function Cg(a, b) {
    switch (a.tag) {
      case 5:
        var c = a.type;
        b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
      case 6:
        return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
      case 13:
        return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a) {
    return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
  }
  function Eg(a) {
    if (I) {
      var b = yg;
      if (b) {
        var c = b;
        if (!Cg(a, b)) {
          if (Dg(a)) throw Error(p(418));
          b = Lf(c.nextSibling);
          var d = xg;
          b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
        }
      } else {
        if (Dg(a)) throw Error(p(418));
        a.flags = a.flags & -4097 | 2;
        I = false;
        xg = a;
      }
    }
  }
  function Fg(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
    xg = a;
  }
  function Gg(a) {
    if (a !== xg) return false;
    if (!I) return Fg(a), I = true, false;
    var b;
    (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
    if (b && (b = yg)) {
      if (Dg(a)) throw Hg(), Error(p(418));
      for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
    }
    Fg(a);
    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(p(317));
      a: {
        a = a.nextSibling;
        for (b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("/$" === c) {
              if (0 === b) {
                yg = Lf(a.nextSibling);
                break a;
              }
              b--;
            } else "$" !== c && "$!" !== c && "$?" !== c || b++;
          }
          a = a.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a = yg; a; ) a = Lf(a.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a) {
    null === zg ? zg = [a] : zg.push(a);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a, b, c) {
    a = c.ref;
    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c._owner) {
        c = c._owner;
        if (c) {
          if (1 !== c.tag) throw Error(p(309));
          var d = c.stateNode;
        }
        if (!d) throw Error(p(147, a));
        var e = d, f = "" + a;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
        b = function(a2) {
          var b2 = e.refs;
          null === a2 ? delete b2[f] : b2[f] = a2;
        };
        b._stringRef = f;
        return b;
      }
      if ("string" !== typeof a) throw Error(p(284));
      if (!c._owner) throw Error(p(290, a));
    }
    return a;
  }
  function Mg(a, b) {
    a = Object.prototype.toString.call(b);
    throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
  }
  function Ng(a) {
    var b = a._init;
    return b(a._payload);
  }
  function Og(a) {
    function b(b2, c2) {
      if (a) {
        var d2 = b2.deletions;
        null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
      }
    }
    function c(c2, d2) {
      if (!a) return null;
      for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
      return null;
    }
    function d(a2, b2) {
      for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
      return a2;
    }
    function e(a2, b2) {
      a2 = Pg(a2, b2);
      a2.index = 0;
      a2.sibling = null;
      return a2;
    }
    function f(b2, c2, d2) {
      b2.index = d2;
      if (!a) return b2.flags |= 1048576, c2;
      d2 = b2.alternate;
      if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
      b2.flags |= 2;
      return c2;
    }
    function g(b2) {
      a && null === b2.alternate && (b2.flags |= 2);
      return b2;
    }
    function h2(a2, b2, c2, d2) {
      if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function k(a2, b2, c2, d2) {
      var f2 = c2.type;
      if (f2 === ya) return m2(a2, b2, c2.props.children, d2, c2.key);
      if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
      d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
      d2.ref = Lg(a2, b2, c2);
      d2.return = a2;
      return d2;
    }
    function l(a2, b2, c2, d2) {
      if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c2.children || []);
      b2.return = a2;
      return b2;
    }
    function m2(a2, b2, c2, d2, f2) {
      if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function q(a2, b2, c2) {
      if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
      if ("object" === typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va:
            return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
          case wa:
            return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
          case Ha:
            var d2 = b2._init;
            return q(a2, d2(b2._payload), c2);
        }
        if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
        Mg(a2, b2);
      }
      return null;
    }
    function r(a2, b2, c2, d2) {
      var e2 = null !== b2 ? b2.key : null;
      if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h2(a2, b2, "" + c2, d2);
      if ("object" === typeof c2 && null !== c2) {
        switch (c2.$$typeof) {
          case va:
            return c2.key === e2 ? k(a2, b2, c2, d2) : null;
          case wa:
            return c2.key === e2 ? l(a2, b2, c2, d2) : null;
          case Ha:
            return e2 = c2._init, r(
              a2,
              b2,
              e2(c2._payload),
              d2
            );
        }
        if (eb(c2) || Ka(c2)) return null !== e2 ? null : m2(a2, b2, c2, d2, null);
        Mg(a2, c2);
      }
      return null;
    }
    function y(a2, b2, c2, d2, e2) {
      if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h2(b2, a2, "" + d2, e2);
      if ("object" === typeof d2 && null !== d2) {
        switch (d2.$$typeof) {
          case va:
            return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
          case wa:
            return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
          case Ha:
            var f2 = d2._init;
            return y(a2, b2, c2, f2(d2._payload), e2);
        }
        if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m2(b2, a2, d2, e2, null);
        Mg(b2, d2);
      }
      return null;
    }
    function n(e2, g2, h3, k2) {
      for (var l2 = null, m3 = null, u = g2, w = g2 = 0, x2 = null; null !== u && w < h3.length; w++) {
        u.index > w ? (x2 = u, u = null) : x2 = u.sibling;
        var n2 = r(e2, u, h3[w], k2);
        if (null === n2) {
          null === u && (u = x2);
          break;
        }
        a && u && null === n2.alternate && b(e2, u);
        g2 = f(n2, g2, w);
        null === m3 ? l2 = n2 : m3.sibling = n2;
        m3 = n2;
        u = x2;
      }
      if (w === h3.length) return c(e2, u), I && tg(e2, w), l2;
      if (null === u) {
        for (; w < h3.length; w++) u = q(e2, h3[w], k2), null !== u && (g2 = f(u, g2, w), null === m3 ? l2 = u : m3.sibling = u, m3 = u);
        I && tg(e2, w);
        return l2;
      }
      for (u = d(e2, u); w < h3.length; w++) x2 = y(u, e2, w, h3[w], k2), null !== x2 && (a && null !== x2.alternate && u.delete(null === x2.key ? w : x2.key), g2 = f(x2, g2, w), null === m3 ? l2 = x2 : m3.sibling = x2, m3 = x2);
      a && u.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function t(e2, g2, h3, k2) {
      var l2 = Ka(h3);
      if ("function" !== typeof l2) throw Error(p(150));
      h3 = l2.call(h3);
      if (null == h3) throw Error(p(151));
      for (var u = l2 = null, m3 = g2, w = g2 = 0, x2 = null, n2 = h3.next(); null !== m3 && !n2.done; w++, n2 = h3.next()) {
        m3.index > w ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t2 = r(e2, m3, n2.value, k2);
        if (null === t2) {
          null === m3 && (m3 = x2);
          break;
        }
        a && m3 && null === t2.alternate && b(e2, m3);
        g2 = f(t2, g2, w);
        null === u ? l2 = t2 : u.sibling = t2;
        u = t2;
        m3 = x2;
      }
      if (n2.done) return c(
        e2,
        m3
      ), I && tg(e2, w), l2;
      if (null === m3) {
        for (; !n2.done; w++, n2 = h3.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        I && tg(e2, w);
        return l2;
      }
      for (m3 = d(e2, m3); !n2.done; w++, n2 = h3.next()) n2 = y(m3, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m3.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
      a && m3.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function J(a2, d2, f2, h3) {
      "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
      if ("object" === typeof f2 && null !== f2) {
        switch (f2.$$typeof) {
          case va:
            a: {
              for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                if (l2.key === k2) {
                  k2 = f2.type;
                  if (k2 === ya) {
                    if (7 === l2.tag) {
                      c(a2, l2.sibling);
                      d2 = e(l2, f2.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                  } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                    c(a2, l2.sibling);
                    d2 = e(l2, f2.props);
                    d2.ref = Lg(a2, l2, f2);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                  c(a2, l2);
                  break;
                } else b(a2, l2);
                l2 = l2.sibling;
              }
              f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h3, f2.key), d2.return = a2, a2 = d2) : (h3 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h3), h3.ref = Lg(a2, d2, f2), h3.return = a2, a2 = h3);
            }
            return g(a2);
          case wa:
            a: {
              for (l2 = f2.key; null !== d2; ) {
                if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f2.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
                else b(a2, d2);
                d2 = d2.sibling;
              }
              d2 = Sg(f2, a2.mode, h3);
              d2.return = a2;
              a2 = d2;
            }
            return g(a2);
          case Ha:
            return l2 = f2._init, J(a2, d2, l2(f2._payload), h3);
        }
        if (eb(f2)) return n(a2, d2, f2, h3);
        if (Ka(f2)) return t(a2, d2, f2, h3);
        Mg(a2, f2);
      }
      return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h3), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
    }
    return J;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a) {
    var b = Wg.current;
    E(Wg);
    a._currentValue = b;
  }
  function bh(a, b, c) {
    for (; null !== a; ) {
      var d = a.alternate;
      (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
      if (a === c) break;
      a = a.return;
    }
  }
  function ch(a, b) {
    Xg = a;
    Zg = Yg = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
  }
  function eh(a) {
    var b = a._currentValue;
    if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
      if (null === Xg) throw Error(p(308));
      Yg = a;
      Xg.dependencies = { lanes: 0, firstContext: a };
    } else Yg = Yg.next = a;
    return b;
  }
  var fh = null;
  function gh(a) {
    null === fh ? fh = [a] : fh.push(a);
  }
  function hh(a, b, c, d) {
    var e = b.interleaved;
    null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
    b.interleaved = c;
    return ih(a, d);
  }
  function ih(a, b) {
    a.lanes |= b;
    var c = a.alternate;
    null !== c && (c.lanes |= b);
    c = a;
    for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
    return 3 === c.tag ? c.stateNode : null;
  }
  var jh = false;
  function kh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a, b) {
    a = a.updateQueue;
    b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function mh(a, b) {
    return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a, b, c) {
    var d = a.updateQueue;
    if (null === d) return null;
    d = d.shared;
    if (0 !== (K & 2)) {
      var e = d.pending;
      null === e ? b.next = b : (b.next = e.next, e.next = b);
      d.pending = b;
      return ih(a, c);
    }
    e = d.interleaved;
    null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
    d.interleaved = b;
    return ih(a, c);
  }
  function oh(a, b, c) {
    b = b.updateQueue;
    if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  function ph(a, b) {
    var c = a.updateQueue, d = a.alternate;
    if (null !== d && (d = d.updateQueue, c === d)) {
      var e = null, f = null;
      c = c.firstBaseUpdate;
      if (null !== c) {
        do {
          var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          null === f ? e = f = g : f = f.next = g;
          c = c.next;
        } while (null !== c);
        null === f ? e = f = b : f = f.next = b;
      } else e = f = b;
      c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
      a.updateQueue = c;
      return;
    }
    a = c.lastBaseUpdate;
    null === a ? c.firstBaseUpdate = b : a.next = b;
    c.lastBaseUpdate = b;
  }
  function qh(a, b, c, d) {
    var e = a.updateQueue;
    jh = false;
    var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h2 = e.shared.pending;
    if (null !== h2) {
      e.shared.pending = null;
      var k = h2, l = k.next;
      k.next = null;
      null === g ? f = l : g.next = l;
      g = k;
      var m2 = a.alternate;
      null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g && (null === h2 ? m2.firstBaseUpdate = l : h2.next = l, m2.lastBaseUpdate = k));
    }
    if (null !== f) {
      var q = e.baseState;
      g = 0;
      m2 = l = k = null;
      h2 = f;
      do {
        var r = h2.lane, y = h2.eventTime;
        if ((d & r) === r) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n = a, t = h2;
            r = b;
            y = c;
            switch (t.tag) {
              case 1:
                n = t.payload;
                if ("function" === typeof n) {
                  q = n.call(y, q, r);
                  break a;
                }
                q = n;
                break a;
              case 3:
                n.flags = n.flags & -65537 | 128;
              case 0:
                n = t.payload;
                r = "function" === typeof n ? n.call(y, q, r) : n;
                if (null === r || void 0 === r) break a;
                q = A({}, q, r);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h2] : r.push(h2));
        } else y = { eventTime: y, lane: r, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l = m2 = y, k = q) : m2 = m2.next = y, g |= r;
        h2 = h2.next;
        if (null === h2) if (h2 = e.shared.pending, null === h2) break;
        else r = h2, h2 = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
      } while (1);
      null === m2 && (k = q);
      e.baseState = k;
      e.firstBaseUpdate = l;
      e.lastBaseUpdate = m2;
      b = e.shared.interleaved;
      if (null !== b) {
        e = b;
        do
          g |= e.lane, e = e.next;
        while (e !== b);
      } else null === f && (e.shared.lanes = 0);
      rh |= g;
      a.lanes = g;
      a.memoizedState = q;
    }
  }
  function sh(a, b, c) {
    a = b.effects;
    b.effects = null;
    if (null !== a) for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (null !== e) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e) throw Error(p(191, e));
        e.call(d);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a) {
    if (a === th) throw Error(p(174));
    return a;
  }
  function yh(a, b) {
    G(wh, b);
    G(vh, a);
    G(uh, th);
    a = b.nodeType;
    switch (a) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
    }
    E(uh);
    G(uh, b);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a) {
    xh(wh.current);
    var b = xh(uh.current);
    var c = lb(b, a.type);
    b !== c && (G(vh, a), G(uh, c));
  }
  function Bh(a) {
    vh.current === a && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a) {
    for (var b = a; null !== b; ) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 128)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }
      if (b === a) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a) return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P() {
    throw Error(p(321));
  }
  function Mh(a, b) {
    if (null === b) return false;
    for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
    return true;
  }
  function Nh(a, b, c, d, e, f) {
    Hh = f;
    M = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
    a = c(d, e);
    if (Jh) {
      f = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f) throw Error(p(301));
        f += 1;
        O = N = null;
        b.updateQueue = null;
        Fh.current = Qh;
        a = c(d, e);
      } while (Jh);
    }
    Fh.current = Rh;
    b = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b) throw Error(p(300));
    return a;
  }
  function Sh() {
    var a = 0 !== Kh;
    Kh = 0;
    return a;
  }
  function Th() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a = M.alternate;
      a = null !== a ? a.memoizedState : null;
    } else a = N.next;
    var b = null === O ? M.memoizedState : O.next;
    if (null !== b) O = b, N = a;
    else {
      if (null === a) throw Error(p(310));
      N = a;
      a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
    }
    return O;
  }
  function Vh(a, b) {
    return "function" === typeof b ? b(a) : b;
  }
  function Wh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = N, e = d.baseQueue, f = c.pending;
    if (null !== f) {
      if (null !== e) {
        var g = e.next;
        e.next = f.next;
        f.next = g;
      }
      d.baseQueue = e = f;
      c.pending = null;
    }
    if (null !== e) {
      f = e.next;
      d = d.baseState;
      var h2 = g = null, k = null, l = f;
      do {
        var m2 = l.lane;
        if ((Hh & m2) === m2) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
        else {
          var q = {
            lane: m2,
            action: l.action,
            hasEagerState: l.hasEagerState,
            eagerState: l.eagerState,
            next: null
          };
          null === k ? (h2 = k = q, g = d) : k = k.next = q;
          M.lanes |= m2;
          rh |= m2;
        }
        l = l.next;
      } while (null !== l && l !== f);
      null === k ? g = d : k.next = h2;
      He(d, b.memoizedState) || (dh = true);
      b.memoizedState = d;
      b.baseState = g;
      b.baseQueue = k;
      c.lastRenderedState = d;
    }
    a = c.interleaved;
    if (null !== a) {
      e = a;
      do
        f = e.lane, M.lanes |= f, rh |= f, e = e.next;
      while (e !== a);
    } else null === e && (c.lanes = 0);
    return [b.memoizedState, c.dispatch];
  }
  function Xh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = c.dispatch, e = c.pending, f = b.memoizedState;
    if (null !== e) {
      c.pending = null;
      var g = e = e.next;
      do
        f = a(f, g.action), g = g.next;
      while (g !== e);
      He(f, b.memoizedState) || (dh = true);
      b.memoizedState = f;
      null === b.baseQueue && (b.baseState = f);
      c.lastRenderedState = f;
    }
    return [f, d];
  }
  function Yh() {
  }
  function Zh(a, b) {
    var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
    f && (d.memoizedState = e, dh = true);
    d = d.queue;
    $h(ai.bind(null, c, d, a), [a]);
    if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
      c.flags |= 2048;
      bi(9, ci.bind(null, c, d, e, b), void 0, null);
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(c, b, e);
    }
    return e;
  }
  function di(a, b, c) {
    a.flags |= 16384;
    a = { getSnapshot: b, value: c };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
  }
  function ci(a, b, c, d) {
    b.value = c;
    b.getSnapshot = d;
    ei(b) && fi(a);
  }
  function ai(a, b, c) {
    return c(function() {
      ei(b) && fi(a);
    });
  }
  function ei(a) {
    var b = a.getSnapshot;
    a = a.value;
    try {
      var c = b();
      return !He(a, c);
    } catch (d) {
      return true;
    }
  }
  function fi(a) {
    var b = ih(a, 1);
    null !== b && gi(b, a, 1, -1);
  }
  function hi(a) {
    var b = Th();
    "function" === typeof a && (a = a());
    b.memoizedState = b.baseState = a;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
    b.queue = a;
    a = a.dispatch = ii.bind(null, M, a);
    return [b.memoizedState, a];
  }
  function bi(a, b, c, d) {
    a = { tag: a, create: b, destroy: c, deps: d, next: null };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
    return a;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a, b, c, d) {
    var e = Th();
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
  }
  function li(a, b, c, d) {
    var e = Uh();
    d = void 0 === d ? null : d;
    var f = void 0;
    if (null !== N) {
      var g = N.memoizedState;
      f = g.destroy;
      if (null !== d && Mh(d, g.deps)) {
        e.memoizedState = bi(b, c, f, d);
        return;
      }
    }
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, f, d);
  }
  function mi(a, b) {
    return ki(8390656, 8, a, b);
  }
  function $h(a, b) {
    return li(2048, 8, a, b);
  }
  function ni(a, b) {
    return li(4, 2, a, b);
  }
  function oi(a, b) {
    return li(4, 4, a, b);
  }
  function pi(a, b) {
    if ("function" === typeof b) return a = a(), b(a), function() {
      b(null);
    };
    if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
      b.current = null;
    };
  }
  function qi(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return li(4, 4, pi.bind(null, b, a), c);
  }
  function ri() {
  }
  function si(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    c.memoizedState = [a, b];
    return a;
  }
  function ti(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    a = a();
    c.memoizedState = [a, b];
    return a;
  }
  function ui(a, b, c) {
    if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
    He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
    return b;
  }
  function vi(a, b) {
    var c = C2;
    C2 = 0 !== c && 4 > c ? c : 4;
    a(true);
    var d = Gh.transition;
    Gh.transition = {};
    try {
      a(false), b();
    } finally {
      C2 = c, Gh.transition = d;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a, b, c) {
    var d = yi(a);
    c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, c);
    else if (c = hh(a, b, c, d), null !== c) {
      var e = R();
      gi(c, a, d, e);
      Bi(c, b, d);
    }
  }
  function ii(a, b, c) {
    var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, e);
    else {
      var f = a.alternate;
      if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
        var g = b.lastRenderedState, h2 = f(g, c);
        e.hasEagerState = true;
        e.eagerState = h2;
        if (He(h2, g)) {
          var k = b.interleaved;
          null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
          b.interleaved = e;
          return;
        }
      } catch (l) {
      } finally {
      }
      c = hh(a, b, e, d);
      null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
    }
  }
  function zi(a) {
    var b = a.alternate;
    return a === M || null !== b && b === M;
  }
  function Ai(a, b) {
    Jh = Ih = true;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
  function Bi(a, b, c) {
    if (0 !== (c & 4194240)) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
    Th().memoizedState = [a, void 0 === b ? null : b];
    return a;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b, a),
      c
    );
  }, useLayoutEffect: function(a, b) {
    return ki(4194308, 4, a, b);
  }, useInsertionEffect: function(a, b) {
    return ki(4, 2, a, b);
  }, useMemo: function(a, b) {
    var c = Th();
    b = void 0 === b ? null : b;
    a = a();
    c.memoizedState = [a, b];
    return a;
  }, useReducer: function(a, b, c) {
    var d = Th();
    b = void 0 !== c ? c(b) : b;
    d.memoizedState = d.baseState = b;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
    d.queue = a;
    a = a.dispatch = xi.bind(null, M, a);
    return [d.memoizedState, a];
  }, useRef: function(a) {
    var b = Th();
    a = { current: a };
    return b.memoizedState = a;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
    return Th().memoizedState = a;
  }, useTransition: function() {
    var a = hi(false), b = a[0];
    a = vi.bind(null, a[1]);
    Th().memoizedState = a;
    return [b, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, b, c) {
    var d = M, e = Th();
    if (I) {
      if (void 0 === c) throw Error(p(407));
      c = c();
    } else {
      c = b();
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(d, b, c);
    }
    e.memoizedState = c;
    var f = { value: c, getSnapshot: b };
    e.queue = f;
    mi(ai.bind(
      null,
      d,
      f,
      a
    ), [a]);
    d.flags |= 2048;
    bi(9, ci.bind(null, d, f, c, b), void 0, null);
    return c;
  }, useId: function() {
    var a = Th(), b = Q.identifierPrefix;
    if (I) {
      var c = sg;
      var d = rg;
      c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
      b = ":" + b + "R" + c;
      c = Kh++;
      0 < c && (b += "H" + c.toString(32));
      b += ":";
    } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
    return a.memoizedState = b;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b = Uh();
      return ui(b, N.memoizedState, a);
    },
    useTransition: function() {
      var a = Wh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a) {
    var b = Uh();
    return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
  }, useTransition: function() {
    var a = Xh(Vh)[0], b = Uh().memoizedState;
    return [a, b];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a, b) {
    if (a && a.defaultProps) {
      b = A({}, b);
      a = a.defaultProps;
      for (var c in a) void 0 === b[c] && (b[c] = a[c]);
      return b;
    }
    return b;
  }
  function Di(a, b, c, d) {
    b = a.memoizedState;
    c = c(d, b);
    c = null === c || void 0 === c ? b : A({}, b, c);
    a.memoizedState = c;
    0 === a.lanes && (a.updateQueue.baseState = c);
  }
  var Ei = { isMounted: function(a) {
    return (a = a._reactInternals) ? Vb(a) === a : false;
  }, enqueueSetState: function(a, b, c) {
    a = a._reactInternals;
    var d = R(), e = yi(a), f = mh(d, e);
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueReplaceState: function(a, b, c) {
    a = a._reactInternals;
    var d = R(), e = yi(a), f = mh(d, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueForceUpdate: function(a, b) {
    a = a._reactInternals;
    var c = R(), d = yi(a), e = mh(c, d);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = nh(a, e, d);
    null !== b && (gi(b, a, d, c), oh(b, a, d));
  } };
  function Fi(a, b, c, d, e, f, g) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
  }
  function Gi(a, b, c) {
    var d = false, e = Vf;
    var f = b.contextType;
    "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
    b = new b(c, f);
    a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Ei;
    a.stateNode = b;
    b._reactInternals = a;
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }
  function Hi(a, b, c, d) {
    a = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
    b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
  }
  function Ii(a, b, c, d) {
    var e = a.stateNode;
    e.props = c;
    e.state = a.memoizedState;
    e.refs = {};
    kh(a);
    var f = b.contextType;
    "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
    e.state = a.memoizedState;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
    "function" === typeof e.componentDidMount && (a.flags |= 4194308);
  }
  function Ji(a, b) {
    try {
      var c = "", d = b;
      do
        c += Pa(d), d = d.return;
      while (d);
      var e = c;
    } catch (f) {
      e = "\nError generating stack: " + f.message + "\n" + f.stack;
    }
    return { value: a, source: b, stack: e, digest: null };
  }
  function Ki(a, b, c) {
    return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
  }
  function Li(a, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    c.payload = { element: null };
    var d = b.value;
    c.callback = function() {
      Oi || (Oi = true, Pi = d);
      Li(a, b);
    };
    return c;
  }
  function Qi(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    var d = a.type.getDerivedStateFromError;
    if ("function" === typeof d) {
      var e = b.value;
      c.payload = function() {
        return d(e);
      };
      c.callback = function() {
        Li(a, b);
      };
    }
    var f = a.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
      Li(a, b);
      "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c2 = b.stack;
      this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
    });
    return c;
  }
  function Si(a, b, c) {
    var d = a.pingCache;
    if (null === d) {
      d = a.pingCache = new Mi();
      var e = /* @__PURE__ */ new Set();
      d.set(b, e);
    } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
    e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
  }
  function Ui(a) {
    do {
      var b;
      if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
      if (b) return a;
      a = a.return;
    } while (null !== a);
    return null;
  }
  function Vi(a, b, c, d, e) {
    if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
    a.flags |= 65536;
    a.lanes = e;
    return a;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a, b, c, d) {
    b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
  }
  function Yi(a, b, c, d, e) {
    c = c.render;
    var f = b.ref;
    ch(b, e);
    d = Nh(a, b, c, d, f, e);
    c = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && c && vg(b);
    b.flags |= 1;
    Xi(a, b, d, e);
    return b.child;
  }
  function $i(a, b, c, d, e) {
    if (null === a) {
      var f = c.type;
      if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
      a = Rg(c.type, null, d, b, b.mode, e);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    f = a.child;
    if (0 === (a.lanes & e)) {
      var g = f.memoizedProps;
      c = c.compare;
      c = null !== c ? c : Ie;
      if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
    }
    b.flags |= 1;
    a = Pg(f, d);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  function bj(a, b, c, d, e) {
    if (null !== a) {
      var f = a.memoizedProps;
      if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
      else return b.lanes = a.lanes, Zi(a, b, e);
    }
    return cj(a, b, c, d, e);
  }
  function dj(a, b, c) {
    var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
    if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
    else {
      if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d = null !== f ? f.baseLanes : c;
      G(ej, fj);
      fj |= d;
    }
    else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
    Xi(a, b, e, c);
    return b.child;
  }
  function gj(a, b) {
    var c = b.ref;
    if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
  }
  function cj(a, b, c, d, e) {
    var f = Zf(c) ? Xf : H.current;
    f = Yf(b, f);
    ch(b, e);
    c = Nh(a, b, c, d, f, e);
    d = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && d && vg(b);
    b.flags |= 1;
    Xi(a, b, c, e);
    return b.child;
  }
  function hj(a, b, c, d, e) {
    if (Zf(c)) {
      var f = true;
      cg(b);
    } else f = false;
    ch(b, e);
    if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
    else if (null === a) {
      var g = b.stateNode, h2 = b.memoizedProps;
      g.props = h2;
      var k = g.context, l = c.contextType;
      "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
      var m2 = c.getDerivedStateFromProps, q = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
      q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== d || k !== l) && Hi(b, g, d, l);
      jh = false;
      var r = b.memoizedState;
      g.state = r;
      qh(b, d, g, e);
      k = b.memoizedState;
      h2 !== d || r !== k || Wf.current || jh ? ("function" === typeof m2 && (Di(b, c, m2, d), k = b.memoizedState), (h2 = jh || Fi(b, c, h2, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h2) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
    } else {
      g = b.stateNode;
      lh(a, b);
      h2 = b.memoizedProps;
      l = b.type === b.elementType ? h2 : Ci(b.type, h2);
      g.props = l;
      q = b.pendingProps;
      r = g.context;
      k = c.contextType;
      "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
      var y = c.getDerivedStateFromProps;
      (m2 = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== q || r !== k) && Hi(b, g, d, k);
      jh = false;
      r = b.memoizedState;
      g.state = r;
      qh(b, d, g, e);
      var n = b.memoizedState;
      h2 !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
    }
    return jj(a, b, c, d, f, e);
  }
  function jj(a, b, c, d, e, f) {
    gj(a, b);
    var g = 0 !== (b.flags & 128);
    if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
    d = b.stateNode;
    Wi.current = b;
    var h2 = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
    b.flags |= 1;
    null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h2, f)) : Xi(a, b, h2, f);
    b.memoizedState = d.state;
    e && dg(b, c, true);
    return b.child;
  }
  function kj(a) {
    var b = a.stateNode;
    b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
    yh(a, b.containerInfo);
  }
  function lj(a, b, c, d, e) {
    Ig();
    Jg(e);
    b.flags |= 256;
    Xi(a, b, c, d);
    return b.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function oj(a, b, c) {
    var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h2;
    (h2 = g) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
    if (h2) f = true, b.flags &= -129;
    else if (null === a || null !== a.memoizedState) e |= 1;
    G(L, e & 1);
    if (null === a) {
      Eg(b);
      a = b.memoizedState;
      if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
      g = d.children;
      a = d.fallback;
      return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
    }
    e = a.memoizedState;
    if (null !== e && (h2 = e.dehydrated, null !== h2)) return rj(a, b, g, d, h2, e, c);
    if (f) {
      f = d.fallback;
      g = b.mode;
      e = a.child;
      h2 = e.sibling;
      var k = { mode: "hidden", children: d.children };
      0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
      null !== h2 ? f = Pg(h2, f) : (f = Tg(f, g, c, null), f.flags |= 2);
      f.return = b;
      d.return = b;
      d.sibling = f;
      b.child = d;
      d = f;
      f = b.child;
      g = a.child.memoizedState;
      g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
      f.memoizedState = g;
      f.childLanes = a.childLanes & ~c;
      b.memoizedState = mj;
      return d;
    }
    f = a.child;
    a = f.sibling;
    d = Pg(f, { mode: "visible", children: d.children });
    0 === (b.mode & 1) && (d.lanes = c);
    d.return = b;
    d.sibling = null;
    null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
    b.child = d;
    b.memoizedState = null;
    return d;
  }
  function qj(a, b) {
    b = pj({ mode: "visible", children: b }, a.mode, 0, null);
    b.return = a;
    return a.child = b;
  }
  function sj(a, b, c, d) {
    null !== d && Jg(d);
    Ug(b, a.child, null, c);
    a = qj(b, b.pendingProps.children);
    a.flags |= 2;
    b.memoizedState = null;
    return a;
  }
  function rj(a, b, c, d, e, f, g) {
    if (c) {
      if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
      if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
      f = d.fallback;
      e = b.mode;
      d = pj({ mode: "visible", children: d.children }, e, 0, null);
      f = Tg(f, e, g, null);
      f.flags |= 2;
      d.return = b;
      f.return = b;
      d.sibling = f;
      b.child = d;
      0 !== (b.mode & 1) && Ug(b, a.child, null, g);
      b.child.memoizedState = nj(g);
      b.memoizedState = mj;
      return f;
    }
    if (0 === (b.mode & 1)) return sj(a, b, g, null);
    if ("$!" === e.data) {
      d = e.nextSibling && e.nextSibling.dataset;
      if (d) var h2 = d.dgst;
      d = h2;
      f = Error(p(419));
      d = Ki(f, d, void 0);
      return sj(a, b, g, d);
    }
    h2 = 0 !== (g & a.childLanes);
    if (dh || h2) {
      d = Q;
      if (null !== d) {
        switch (g & -g) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
        0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
      }
      tj();
      d = Ki(Error(p(421)));
      return sj(a, b, g, d);
    }
    if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
    a = f.treeContext;
    yg = Lf(e.nextSibling);
    xg = b;
    I = true;
    zg = null;
    null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
    b = qj(b, d.children);
    b.flags |= 4096;
    return b;
  }
  function vj(a, b, c) {
    a.lanes |= b;
    var d = a.alternate;
    null !== d && (d.lanes |= b);
    bh(a.return, b, c);
  }
  function wj(a, b, c, d, e) {
    var f = a.memoizedState;
    null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
  }
  function xj(a, b, c) {
    var d = b.pendingProps, e = d.revealOrder, f = d.tail;
    Xi(a, b, d.children, c);
    d = L.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
    else {
      if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
        if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
        else if (19 === a.tag) vj(a, c, b);
        else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b) break a;
        for (; null === a.sibling; ) {
          if (null === a.return || a.return === b) break a;
          a = a.return;
        }
        a.sibling.return = a.return;
        a = a.sibling;
      }
      d &= 1;
    }
    G(L, d);
    if (0 === (b.mode & 1)) b.memoizedState = null;
    else switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        wj(b, false, e, c, f);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a = e.alternate;
          if (null !== a && null === Ch(a)) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        wj(b, true, c, null, f);
        break;
      case "together":
        wj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a, b) {
    0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi(a, b, c) {
    null !== a && (b.dependencies = a.dependencies);
    rh |= b.lanes;
    if (0 === (c & b.childLanes)) return null;
    if (null !== a && b.child !== a.child) throw Error(p(153));
    if (null !== b.child) {
      a = b.child;
      c = Pg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  function yj(a, b, c) {
    switch (b.tag) {
      case 3:
        kj(b);
        Ig();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf(b.type) && cg(b);
        break;
      case 4:
        yh(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d = b.type._context, e = b.memoizedProps.value;
        G(Wg, d._currentValue);
        d._currentValue = e;
        break;
      case 13:
        d = b.memoizedState;
        if (null !== d) {
          if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
          if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
          G(L, L.current & 1);
          a = Zi(a, b, c);
          return null !== a ? a.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d = 0 !== (c & b.childLanes);
        if (0 !== (a.flags & 128)) {
          if (d) return xj(a, b, c);
          b.flags |= 128;
        }
        e = b.memoizedState;
        null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
        G(L, L.current);
        if (d) break;
        else return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a, b, c);
    }
    return Zi(a, b, c);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a, b) {
    for (var c = b.child; null !== c; ) {
      if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
      else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;
      for (; null === c.sibling; ) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }
      c.sibling.return = c.return;
      c = c.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a, b, c, d) {
    var e = a.memoizedProps;
    if (e !== d) {
      a = b.stateNode;
      xh(uh.current);
      var f = null;
      switch (c) {
        case "input":
          e = Ya(a, e);
          d = Ya(a, d);
          f = [];
          break;
        case "select":
          e = A({}, e, { value: void 0 });
          d = A({}, d, { value: void 0 });
          f = [];
          break;
        case "textarea":
          e = gb(a, e);
          d = gb(a, d);
          f = [];
          break;
        default:
          "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
      }
      ub(c, d);
      var g;
      c = null;
      for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h2 = e[l];
        for (g in h2) h2.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
      for (l in d) {
        var k = d[l];
        h2 = null != e ? e[l] : void 0;
        if (d.hasOwnProperty(l) && k !== h2 && (null != k || null != h2)) if ("style" === l) if (h2) {
          for (g in h2) !h2.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          for (g in k) k.hasOwnProperty(g) && h2[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
        } else c || (f || (f = []), f.push(
          l,
          c
        )), c = k;
        else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k && h2 !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h2 === k || (f = [])) : (f = f || []).push(l, k));
      }
      c && (f = f || []).push("style", c);
      var l = f;
      if (b.updateQueue = l) b.flags |= 4;
    }
  };
  Cj = function(a, b, c, d) {
    c !== d && (b.flags |= 4);
  };
  function Dj(a, b) {
    if (!I) switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
  }
  function S(a) {
    var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
    if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
    else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
    a.subtreeFlags |= d;
    a.childLanes = c;
    return b;
  }
  function Ej(a, b, c) {
    var d = b.pendingProps;
    wg(b);
    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b), null;
      case 1:
        return Zf(b.type) && $f(), S(b), null;
      case 3:
        d = b.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
        if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a, b);
        S(b);
        return null;
      case 5:
        Bh(b);
        var e = xh(wh.current);
        c = b.type;
        if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d) {
            if (null === b.stateNode) throw Error(p(166));
            S(b);
            return null;
          }
          a = xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.type;
            var f = b.memoizedProps;
            d[Of] = b;
            d[Pf] = f;
            a = 0 !== (b.mode & 1);
            switch (c) {
              case "dialog":
                D("cancel", d);
                D("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], d);
                break;
              case "source":
                D("error", d);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d
                );
                D("load", d);
                break;
              case "details":
                D("toggle", d);
                break;
              case "input":
                Za(d, f);
                D("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!f.multiple };
                D("invalid", d);
                break;
              case "textarea":
                hb(d, f), D("invalid", d);
            }
            ub(c, f);
            e = null;
            for (var g in f) if (f.hasOwnProperty(g)) {
              var h2 = f[g];
              "children" === g ? "string" === typeof h2 ? d.textContent !== h2 && (true !== f.suppressHydrationWarning && Af(d.textContent, h2, a), e = ["children", h2]) : "number" === typeof h2 && d.textContent !== "" + h2 && (true !== f.suppressHydrationWarning && Af(
                d.textContent,
                h2,
                a
              ), e = ["children", "" + h2]) : ea.hasOwnProperty(g) && null != h2 && "onScroll" === g && D("scroll", d);
            }
            switch (c) {
              case "input":
                Va(d);
                db(d, f, true);
                break;
              case "textarea":
                Va(d);
                jb(d);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f.onClick && (d.onclick = Bf);
            }
            d = e;
            b.updateQueue = d;
            null !== d && (b.flags |= 4);
          } else {
            g = 9 === e.nodeType ? e : e.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
            "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
            a[Of] = b;
            a[Pf] = d;
            zj(a, b, false, false);
            b.stateNode = a;
            a: {
              g = vb(c, d);
              switch (c) {
                case "dialog":
                  D("cancel", a);
                  D("close", a);
                  e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a);
                  e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], a);
                  e = d;
                  break;
                case "source":
                  D("error", a);
                  e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a
                  );
                  D("load", a);
                  e = d;
                  break;
                case "details":
                  D("toggle", a);
                  e = d;
                  break;
                case "input":
                  Za(a, d);
                  e = Ya(a, d);
                  D("invalid", a);
                  break;
                case "option":
                  e = d;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!d.multiple };
                  e = A({}, d, { value: void 0 });
                  D("invalid", a);
                  break;
                case "textarea":
                  hb(a, d);
                  e = gb(a, d);
                  D("invalid", a);
                  break;
                default:
                  e = d;
              }
              ub(c, e);
              h2 = e;
              for (f in h2) if (h2.hasOwnProperty(f)) {
                var k = h2[f];
                "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
              }
              switch (c) {
                case "input":
                  Va(a);
                  db(a, d, false);
                  break;
                case "textarea":
                  Va(a);
                  jb(a);
                  break;
                case "option":
                  null != d.value && a.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a.multiple = !!d.multiple;
                  f = d.value;
                  null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                    a,
                    !!d.multiple,
                    d.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e.onClick && (a.onclick = Bf);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break a;
                case "img":
                  d = true;
                  break a;
                default:
                  d = false;
              }
            }
            d && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        S(b);
        return null;
      case 6:
        if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
        else {
          if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
          c = xh(wh.current);
          xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.memoizedProps;
            d[Of] = b;
            if (f = d.nodeValue !== c) {
              if (a = xg, null !== a) switch (a.tag) {
                case 3:
                  Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
              }
            }
            f && (b.flags |= 4);
          } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
        }
        S(b);
        return null;
      case 13:
        E(L);
        d = b.memoizedState;
        if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
          else if (f = Gg(b), null !== d && null !== d.dehydrated) {
            if (null === a) {
              if (!f) throw Error(p(318));
              f = b.memoizedState;
              f = null !== f ? f.dehydrated : null;
              if (!f) throw Error(p(317));
              f[Of] = b;
            } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S(b);
            f = false;
          } else null !== zg && (Fj(zg), zg = null), f = true;
          if (!f) return b.flags & 65536 ? b : null;
        }
        if (0 !== (b.flags & 128)) return b.lanes = c, b;
        d = null !== d;
        d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b.updateQueue && (b.flags |= 4);
        S(b);
        return null;
      case 4:
        return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
      case 10:
        return ah(b.type._context), S(b), null;
      case 17:
        return Zf(b.type) && $f(), S(b), null;
      case 19:
        E(L);
        f = b.memoizedState;
        if (null === f) return S(b), null;
        d = 0 !== (b.flags & 128);
        g = f.rendering;
        if (null === g) if (d) Dj(f, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
            g = Ch(a);
            if (null !== g) {
              b.flags |= 128;
              Dj(f, false);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c;
              for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
              G(L, L.current & 1 | 2);
              return b.child;
            }
            a = a.sibling;
          }
          null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
        }
        else {
          if (!d) if (a = Ch(g), null !== a) {
            if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
          } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
          f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
        }
        if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
        S(b);
        return null;
      case 22:
      case 23:
        return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p(156, b.tag));
  }
  function Ij(a, b) {
    wg(b);
    switch (b.tag) {
      case 1:
        return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        E(L);
        a = b.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          if (null === b.alternate) throw Error(p(340));
          Ig();
        }
        a = b.flags;
        return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a, b) {
    var c = a.ref;
    if (null !== c) if ("function" === typeof c) try {
      c(null);
    } catch (d) {
      W(a, b, d);
    }
    else c.current = null;
  }
  function Mj(a, b, c) {
    try {
      c();
    } catch (d) {
      W(a, b, d);
    }
  }
  var Nj = false;
  function Oj(a, b) {
    Cf = dd;
    a = Me();
    if (Ne(a)) {
      if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
      else a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && 0 !== d.rangeCount) {
          c = d.anchorNode;
          var e = d.anchorOffset, f = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f.nodeType;
          } catch (F) {
            c = null;
            break a;
          }
          var g = 0, h2 = -1, k = -1, l = 0, m2 = 0, q = a, r = null;
          b: for (; ; ) {
            for (var y; ; ) {
              q !== c || 0 !== e && 3 !== q.nodeType || (h2 = g + e);
              q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
              3 === q.nodeType && (g += q.nodeValue.length);
              if (null === (y = q.firstChild)) break;
              r = q;
              q = y;
            }
            for (; ; ) {
              if (q === a) break b;
              r === c && ++l === e && (h2 = g);
              r === f && ++m2 === d && (k = g);
              if (null !== (y = q.nextSibling)) break;
              q = r;
              r = q.parentNode;
            }
            q = y;
          }
          c = -1 === h2 || -1 === k ? null : { start: h2, end: k };
        } else c = null;
      }
      c = c || { start: 0, end: 0 };
    } else c = null;
    Df = { focusedElem: a, selectionRange: c };
    dd = false;
    for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
    else for (; null !== V; ) {
      b = V;
      try {
        var n = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n) {
              var t = n.memoizedProps, J = n.memoizedState, x2 = b.stateNode, w = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
              x2.__reactInternalSnapshotBeforeUpdate = w;
            }
            break;
          case 3:
            var u = b.stateNode.containerInfo;
            1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p(163));
        }
      } catch (F) {
        W(b, b.return, F);
      }
      a = b.sibling;
      if (null !== a) {
        a.return = b.return;
        V = a;
        break;
      }
      V = b.return;
    }
    n = Nj;
    Nj = false;
    return n;
  }
  function Pj(a, b, c) {
    var d = b.updateQueue;
    d = null !== d ? d.lastEffect : null;
    if (null !== d) {
      var e = d = d.next;
      do {
        if ((e.tag & a) === a) {
          var f = e.destroy;
          e.destroy = void 0;
          void 0 !== f && Mj(b, c, f);
        }
        e = e.next;
      } while (e !== d);
    }
  }
  function Qj(a, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;
    if (null !== b) {
      var c = b = b.next;
      do {
        if ((c.tag & a) === a) {
          var d = c.create;
          c.destroy = d();
        }
        c = c.next;
      } while (c !== b);
    }
  }
  function Rj(a) {
    var b = a.ref;
    if (null !== b) {
      var c = a.stateNode;
      switch (a.tag) {
        case 5:
          a = c;
          break;
        default:
          a = c;
      }
      "function" === typeof b ? b(a) : b.current = a;
    }
  }
  function Sj(a) {
    var b = a.alternate;
    null !== b && (a.alternate = null, Sj(b));
    a.child = null;
    a.deletions = null;
    a.sibling = null;
    5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
    a.stateNode = null;
    a.return = null;
    a.dependencies = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.stateNode = null;
    a.updateQueue = null;
  }
  function Tj(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }
  function Uj(a) {
    a: for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return)) return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2) continue a;
        if (null === a.child || 4 === a.tag) continue a;
        else a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Vj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
    else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
  }
  function Wj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
    else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
  }
  var X = null, Xj = false;
  function Yj(a, b, c) {
    for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
  }
  function Zj(a, b, c) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h2) {
    }
    switch (c.tag) {
      case 5:
        U || Lj(c, b);
      case 6:
        var d = X, e = Xj;
        X = null;
        Yj(a, b, c);
        X = d;
        Xj = e;
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
        break;
      case 4:
        d = X;
        e = Xj;
        X = c.stateNode.containerInfo;
        Xj = true;
        Yj(a, b, c);
        X = d;
        Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
          e = d = d.next;
          do {
            var f = e, g = f.destroy;
            f = f.tag;
            void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
            e = e.next;
          } while (e !== d);
        }
        Yj(a, b, c);
        break;
      case 1:
        if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h2) {
          W(c, b, h2);
        }
        Yj(a, b, c);
        break;
      case 21:
        Yj(a, b, c);
        break;
      case 22:
        c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
        break;
      default:
        Yj(a, b, c);
    }
  }
  function ak(a) {
    var b = a.updateQueue;
    if (null !== b) {
      a.updateQueue = null;
      var c = a.stateNode;
      null === c && (c = a.stateNode = new Kj());
      b.forEach(function(b2) {
        var d = bk.bind(null, a, b2);
        c.has(b2) || (c.add(b2), b2.then(d, d));
      });
    }
  }
  function ck(a, b) {
    var c = b.deletions;
    if (null !== c) for (var d = 0; d < c.length; d++) {
      var e = c[d];
      try {
        var f = a, g = b, h2 = g;
        a: for (; null !== h2; ) {
          switch (h2.tag) {
            case 5:
              X = h2.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h2.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h2.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h2 = h2.return;
        }
        if (null === X) throw Error(p(160));
        Zj(f, g, e);
        X = null;
        Xj = false;
        var k = e.alternate;
        null !== k && (k.return = null);
        e.return = null;
      } catch (l) {
        W(e, b, l);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
  }
  function dk(a, b) {
    var c = a.alternate, d = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b, a);
        ek(a);
        if (d & 4) {
          try {
            Pj(3, a, a.return), Qj(3, a);
          } catch (t) {
            W(a, a.return, t);
          }
          try {
            Pj(5, a, a.return);
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 1:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        break;
      case 5:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        if (a.flags & 32) {
          var e = a.stateNode;
          try {
            ob(e, "");
          } catch (t) {
            W(a, a.return, t);
          }
        }
        if (d & 4 && (e = a.stateNode, null != e)) {
          var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h2 = a.type, k = a.updateQueue;
          a.updateQueue = null;
          if (null !== k) try {
            "input" === h2 && "radio" === f.type && null != f.name && ab(e, f);
            vb(h2, g);
            var l = vb(h2, f);
            for (g = 0; g < k.length; g += 2) {
              var m2 = k[g], q = k[g + 1];
              "style" === m2 ? sb(e, q) : "dangerouslySetInnerHTML" === m2 ? nb(e, q) : "children" === m2 ? ob(e, q) : ta(e, m2, q, l);
            }
            switch (h2) {
              case "input":
                bb(e, f);
                break;
              case "textarea":
                ib(e, f);
                break;
              case "select":
                var r = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f.multiple;
                var y = f.value;
                null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                  e,
                  !!f.multiple,
                  f.defaultValue,
                  true
                ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
            }
            e[Pf] = f;
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 6:
        ck(b, a);
        ek(a);
        if (d & 4) {
          if (null === a.stateNode) throw Error(p(162));
          e = a.stateNode;
          f = a.memoizedProps;
          try {
            e.nodeValue = f;
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 3:
        ck(b, a);
        ek(a);
        if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
          bd(b.containerInfo);
        } catch (t) {
          W(a, a.return, t);
        }
        break;
      case 4:
        ck(b, a);
        ek(a);
        break;
      case 13:
        ck(b, a);
        ek(a);
        e = a.child;
        e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
        d & 4 && ak(a);
        break;
      case 22:
        m2 = null !== c && null !== c.memoizedState;
        a.mode & 1 ? (U = (l = U) || m2, ck(b, a), U = l) : ck(b, a);
        ek(a);
        if (d & 8192) {
          l = null !== a.memoizedState;
          if ((a.stateNode.isHidden = l) && !m2 && 0 !== (a.mode & 1)) for (V = a, m2 = a.child; null !== m2; ) {
            for (q = V = m2; null !== V; ) {
              r = V;
              y = r.child;
              switch (r.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r, r.return);
                  break;
                case 1:
                  Lj(r, r.return);
                  var n = r.stateNode;
                  if ("function" === typeof n.componentWillUnmount) {
                    d = r;
                    c = r.return;
                    try {
                      b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                    } catch (t) {
                      W(d, c, t);
                    }
                  }
                  break;
                case 5:
                  Lj(r, r.return);
                  break;
                case 22:
                  if (null !== r.memoizedState) {
                    gk(q);
                    continue;
                  }
              }
              null !== y ? (y.return = r, V = y) : gk(q);
            }
            m2 = m2.sibling;
          }
          a: for (m2 = null, q = a; ; ) {
            if (5 === q.tag) {
              if (null === m2) {
                m2 = q;
                try {
                  e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h2 = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h2.style.display = rb("display", g));
                } catch (t) {
                  W(a, a.return, t);
                }
              }
            } else if (6 === q.tag) {
              if (null === m2) try {
                q.stateNode.nodeValue = l ? "" : q.memoizedProps;
              } catch (t) {
                W(a, a.return, t);
              }
            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
              q.child.return = q;
              q = q.child;
              continue;
            }
            if (q === a) break a;
            for (; null === q.sibling; ) {
              if (null === q.return || q.return === a) break a;
              m2 === q && (m2 = null);
              q = q.return;
            }
            m2 === q && (m2 = null);
            q.sibling.return = q.return;
            q = q.sibling;
          }
        }
        break;
      case 19:
        ck(b, a);
        ek(a);
        d & 4 && ak(a);
        break;
      case 21:
        break;
      default:
        ck(
          b,
          a
        ), ek(a);
    }
  }
  function ek(a) {
    var b = a.flags;
    if (b & 2) {
      try {
        a: {
          for (var c = a.return; null !== c; ) {
            if (Tj(c)) {
              var d = c;
              break a;
            }
            c = c.return;
          }
          throw Error(p(160));
        }
        switch (d.tag) {
          case 5:
            var e = d.stateNode;
            d.flags & 32 && (ob(e, ""), d.flags &= -33);
            var f = Uj(a);
            Wj(a, f, e);
            break;
          case 3:
          case 4:
            var g = d.stateNode.containerInfo, h2 = Uj(a);
            Vj(a, h2, g);
            break;
          default:
            throw Error(p(161));
        }
      } catch (k) {
        W(a, a.return, k);
      }
      a.flags &= -3;
    }
    b & 4096 && (a.flags &= -4097);
  }
  function hk(a, b, c) {
    V = a;
    ik(a);
  }
  function ik(a, b, c) {
    for (var d = 0 !== (a.mode & 1); null !== V; ) {
      var e = V, f = e.child;
      if (22 === e.tag && d) {
        var g = null !== e.memoizedState || Jj;
        if (!g) {
          var h2 = e.alternate, k = null !== h2 && null !== h2.memoizedState || U;
          h2 = Jj;
          var l = U;
          Jj = g;
          if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
          for (; null !== f; ) V = f, ik(f), f = f.sibling;
          V = e;
          Jj = h2;
          U = l;
        }
        kk(a);
      } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
    }
  }
  function kk(a) {
    for (; null !== V; ) {
      var b = V;
      if (0 !== (b.flags & 8772)) {
        var c = b.alternate;
        try {
          if (0 !== (b.flags & 8772)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b);
              break;
            case 1:
              var d = b.stateNode;
              if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
              else {
                var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
              }
              var f = b.updateQueue;
              null !== f && sh(b, f, d);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c = null;
                if (null !== b.child) switch (b.child.tag) {
                  case 5:
                    c = b.child.stateNode;
                    break;
                  case 1:
                    c = b.child.stateNode;
                }
                sh(b, g, c);
              }
              break;
            case 5:
              var h2 = b.stateNode;
              if (null === c && b.flags & 4) {
                c = h2;
                var k = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k.autoFocus && c.focus();
                    break;
                  case "img":
                    k.src && (c.src = k.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l = b.alternate;
                if (null !== l) {
                  var m2 = l.memoizedState;
                  if (null !== m2) {
                    var q = m2.dehydrated;
                    null !== q && bd(q);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
          U || b.flags & 512 && Rj(b);
        } catch (r) {
          W(b, b.return, r);
        }
      }
      if (b === a) {
        V = null;
        break;
      }
      c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function gk(a) {
    for (; null !== V; ) {
      var b = V;
      if (b === a) {
        V = null;
        break;
      }
      var c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function jk(a) {
    for (; null !== V; ) {
      var b = V;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c = b.return;
            try {
              Qj(4, b);
            } catch (k) {
              W(b, c, k);
            }
            break;
          case 1:
            var d = b.stateNode;
            if ("function" === typeof d.componentDidMount) {
              var e = b.return;
              try {
                d.componentDidMount();
              } catch (k) {
                W(b, e, k);
              }
            }
            var f = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, f, k);
            }
            break;
          case 5:
            var g = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, g, k);
            }
        }
      } catch (k) {
        W(b, b.return, k);
      }
      if (b === a) {
        V = null;
        break;
      }
      var h2 = b.sibling;
      if (null !== h2) {
        h2.return = b.return;
        V = h2;
        break;
      }
      V = b.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a) {
    if (0 === (a.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a = C2;
    if (0 !== a) return a;
    a = window.event;
    a = void 0 === a ? 16 : jd(a.type);
    return a;
  }
  function gi(a, b, c, d) {
    if (50 < yk) throw yk = 0, zk = null, Error(p(185));
    Ac(a, c, d);
    if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a, b) {
    var c = a.callbackNode;
    wc(a, b);
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
    else if (b = d & -d, a.callbackPriority !== b) {
      null != c && bc(c);
      if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c = null;
      else {
        switch (Dc(d)) {
          case 1:
            c = fc;
            break;
          case 4:
            c = gc;
            break;
          case 16:
            c = hc;
            break;
          case 536870912:
            c = jc;
            break;
          default:
            c = hc;
        }
        c = Fk(c, Gk.bind(null, a));
      }
      a.callbackPriority = b;
      a.callbackNode = c;
    }
  }
  function Gk(a, b) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p(327));
    var c = a.callbackNode;
    if (Hk() && a.callbackNode !== c) return null;
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) return null;
    if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
    else {
      b = d;
      var e = K;
      K |= 2;
      var f = Jk();
      if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a, h2);
        }
      while (1);
      $g();
      mk.current = f;
      K = e;
      null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
    }
    if (0 !== b) {
      2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
      if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
      if (6 === b) Ck(a, d);
      else {
        e = a.current.alternate;
        if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        a.finishedWork = e;
        a.finishedLanes = d;
        switch (b) {
          case 0:
          case 1:
            throw Error(p(345));
          case 2:
            Pk(a, tk, uk);
            break;
          case 3:
            Ck(a, d);
            if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
              if (0 !== uc(a, 0)) break;
              e = a.suspendedLanes;
              if ((e & d) !== d) {
                R();
                a.pingedLanes |= a.suspendedLanes & e;
                break;
              }
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 4:
            Ck(a, d);
            if ((d & 4194240) === d) break;
            b = a.eventTimes;
            for (e = -1; 0 < d; ) {
              var g = 31 - oc(d);
              f = 1 << g;
              g = b[g];
              g > e && (e = g);
              d &= ~f;
            }
            d = e;
            d = B() - d;
            d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
            if (10 < d) {
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 5:
            Pk(a, tk, uk);
            break;
          default:
            throw Error(p(329));
        }
      }
    }
    Dk(a, B());
    return a.callbackNode === c ? Gk.bind(null, a) : null;
  }
  function Nk(a, b) {
    var c = sk;
    a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
    a = Ik(a, b);
    2 !== a && (b = tk, tk = c, null !== b && Fj(b));
    return a;
  }
  function Fj(a) {
    null === tk ? tk = a : tk.push.apply(tk, a);
  }
  function Ok(a) {
    for (var b = a; ; ) {
      if (b.flags & 16384) {
        var c = b.updateQueue;
        if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
          var e = c[d], f = e.getSnapshot;
          e = e.value;
          try {
            if (!He(f(), e)) return false;
          } catch (g) {
            return false;
          }
        }
      }
      c = b.child;
      if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
      else {
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return true;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
    }
    return true;
  }
  function Ck(a, b) {
    b &= ~rk;
    b &= ~qk;
    a.suspendedLanes |= b;
    a.pingedLanes &= ~b;
    for (a = a.expirationTimes; 0 < b; ) {
      var c = 31 - oc(b), d = 1 << c;
      a[c] = -1;
      b &= ~d;
    }
  }
  function Ek(a) {
    if (0 !== (K & 6)) throw Error(p(327));
    Hk();
    var b = uc(a, 0);
    if (0 === (b & 1)) return Dk(a, B()), null;
    var c = Ik(a, b);
    if (0 !== a.tag && 2 === c) {
      var d = xc(a);
      0 !== d && (b = d, c = Nk(a, d));
    }
    if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
    if (6 === c) throw Error(p(345));
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b;
    Pk(a, tk, uk);
    Dk(a, B());
    return null;
  }
  function Qk(a, b) {
    var c = K;
    K |= 1;
    try {
      return a(b);
    } finally {
      K = c, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b = K;
    K |= 1;
    var c = ok.transition, d = C2;
    try {
      if (ok.transition = null, C2 = 1, a) return a();
    } finally {
      C2 = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a, b) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c = a.timeoutHandle;
    -1 !== c && (a.timeoutHandle = -1, Gf(c));
    if (null !== Y) for (c = Y.return; null !== c; ) {
      var d = c;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c = c.return;
    }
    Q = a;
    Y = a = Pg(a.current, null);
    Z = fj = b;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
        c.interleaved = null;
        var e = d.next, f = c.pending;
        if (null !== f) {
          var g = f.next;
          f.next = e;
          d.next = g;
        }
        c.pending = d;
      }
      fh = null;
    }
    return a;
  }
  function Mk(a, b) {
    do {
      var c = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d = M.memoizedState; null !== d; ) {
            var e = d.queue;
            null !== e && (e.pending = null);
            d = d.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c || null === c.return) {
          T = 1;
          pk = b;
          Y = null;
          break;
        }
        a: {
          var f = a, g = c.return, h2 = c, k = b;
          b = Z;
          h2.flags |= 32768;
          if (null !== k && "object" === typeof k && "function" === typeof k.then) {
            var l = k, m2 = h2, q = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q || 11 === q || 15 === q)) {
              var r = m2.alternate;
              r ? (m2.updateQueue = r.updateQueue, m2.memoizedState = r.memoizedState, m2.lanes = r.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y = Ui(g);
            if (null !== y) {
              y.flags &= -257;
              Vi(y, g, h2, f, b);
              y.mode & 1 && Si(f, l, b);
              b = y;
              k = l;
              var n = b.updateQueue;
              if (null === n) {
                var t = /* @__PURE__ */ new Set();
                t.add(k);
                b.updateQueue = t;
              } else n.add(k);
              break a;
            } else {
              if (0 === (b & 1)) {
                Si(f, l, b);
                tj();
                break a;
              }
              k = Error(p(426));
            }
          } else if (I && h2.mode & 1) {
            var J = Ui(g);
            if (null !== J) {
              0 === (J.flags & 65536) && (J.flags |= 256);
              Vi(J, g, h2, f, b);
              Jg(Ji(k, h2));
              break a;
            }
          }
          f = k = Ji(k, h2);
          4 !== T && (T = 2);
          null === sk ? sk = [f] : sk.push(f);
          f = g;
          do {
            switch (f.tag) {
              case 3:
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var x2 = Ni(f, k, b);
                ph(f, x2);
                break a;
              case 1:
                h2 = k;
                var w = f.type, u = f.stateNode;
                if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var F = Qi(f, h2, b);
                  ph(f, F);
                  break a;
                }
            }
            f = f.return;
          } while (null !== f);
        }
        Sk(c);
      } catch (na) {
        b = na;
        Y === c && null !== c && (Y = c = c.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a = mk.current;
    mk.current = Rh;
    return null === a ? Rh : a;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a, b) {
    var c = K;
    K |= 2;
    var d = Jk();
    if (Q !== a || Z !== b) uk = null, Kk(a, b);
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a, e);
      }
    while (1);
    $g();
    K = c;
    mk.current = d;
    if (null !== Y) throw Error(p(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a) {
    var b = Vk(a.alternate, a, fj);
    a.memoizedProps = a.pendingProps;
    null === b ? Sk(a) : Y = b;
    nk.current = null;
  }
  function Sk(a) {
    var b = a;
    do {
      var c = b.alternate;
      a = b.return;
      if (0 === (b.flags & 32768)) {
        if (c = Ej(c, b, fj), null !== c) {
          Y = c;
          return;
        }
      } else {
        c = Ij(c, b);
        if (null !== c) {
          c.flags &= 32767;
          Y = c;
          return;
        }
        if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b = b.sibling;
      if (null !== b) {
        Y = b;
        return;
      }
      Y = b = a;
    } while (null !== b);
    0 === T && (T = 5);
  }
  function Pk(a, b, c) {
    var d = C2, e = ok.transition;
    try {
      ok.transition = null, C2 = 1, Wk(a, b, c, d);
    } finally {
      ok.transition = e, C2 = d;
    }
    return null;
  }
  function Wk(a, b, c, d) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p(327));
    c = a.finishedWork;
    var e = a.finishedLanes;
    if (null === c) return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c === a.current) throw Error(p(177));
    a.callbackNode = null;
    a.callbackPriority = 0;
    var f = c.lanes | c.childLanes;
    Bc(a, f);
    a === Q && (Y = Q = null, Z = 0);
    0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f = 0 !== (c.flags & 15990);
    if (0 !== (c.subtreeFlags & 15990) || f) {
      f = ok.transition;
      ok.transition = null;
      var g = C2;
      C2 = 1;
      var h2 = K;
      K |= 4;
      nk.current = null;
      Oj(a, c);
      dk(c, a);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a.current = c;
      hk(c);
      dc();
      K = h2;
      C2 = g;
      ok.transition = f;
    } else a.current = c;
    vk && (vk = false, wk = a, xk = e);
    f = a.pendingLanes;
    0 === f && (Ri = null);
    mc(c.stateNode);
    Dk(a, B());
    if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
    if (Oi) throw Oi = false, a = Pi, Pi = null, a;
    0 !== (xk & 1) && 0 !== a.tag && Hk();
    f = a.pendingLanes;
    0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a = Dc(xk), b = ok.transition, c = C2;
      try {
        ok.transition = null;
        C2 = 16 > a ? 16 : a;
        if (null === wk) var d = false;
        else {
          a = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p(331));
          var e = K;
          K |= 4;
          for (V = a.current; null !== V; ) {
            var f = V, g = f.child;
            if (0 !== (V.flags & 16)) {
              var h2 = f.deletions;
              if (null !== h2) {
                for (var k = 0; k < h2.length; k++) {
                  var l = h2[k];
                  for (V = l; null !== V; ) {
                    var m2 = V;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f);
                    }
                    var q = m2.child;
                    if (null !== q) q.return = m2, V = q;
                    else for (; null !== V; ) {
                      m2 = V;
                      var r = m2.sibling, y = m2.return;
                      Sj(m2);
                      if (m2 === l) {
                        V = null;
                        break;
                      }
                      if (null !== r) {
                        r.return = y;
                        V = r;
                        break;
                      }
                      V = y;
                    }
                  }
                }
                var n = f.alternate;
                if (null !== n) {
                  var t = n.child;
                  if (null !== t) {
                    n.child = null;
                    do {
                      var J = t.sibling;
                      t.sibling = null;
                      t = J;
                    } while (null !== t);
                  }
                }
                V = f;
              }
            }
            if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
            else b: for (; null !== V; ) {
              f = V;
              if (0 !== (f.flags & 2048)) switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f, f.return);
              }
              var x2 = f.sibling;
              if (null !== x2) {
                x2.return = f.return;
                V = x2;
                break b;
              }
              V = f.return;
            }
          }
          var w = a.current;
          for (V = w; null !== V; ) {
            g = V;
            var u = g.child;
            if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
            else b: for (g = w; null !== V; ) {
              h2 = V;
              if (0 !== (h2.flags & 2048)) try {
                switch (h2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h2);
                }
              } catch (na) {
                W(h2, h2.return, na);
              }
              if (h2 === g) {
                V = null;
                break b;
              }
              var F = h2.sibling;
              if (null !== F) {
                F.return = h2.return;
                V = F;
                break b;
              }
              V = h2.return;
            }
          }
          K = e;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
          d = true;
        }
        return d;
      } finally {
        C2 = c, ok.transition = b;
      }
    }
    return false;
  }
  function Xk(a, b, c) {
    b = Ji(c, b);
    b = Ni(a, b, 1);
    a = nh(a, b, 1);
    b = R();
    null !== a && (Ac(a, 1, b), Dk(a, b));
  }
  function W(a, b, c) {
    if (3 === a.tag) Xk(a, a, c);
    else for (; null !== b; ) {
      if (3 === b.tag) {
        Xk(b, a, c);
        break;
      } else if (1 === b.tag) {
        var d = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
          a = Ji(c, a);
          a = Qi(b, a, 1);
          b = nh(b, a, 1);
          a = R();
          null !== b && (Ac(b, 1, a), Dk(b, a));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti(a, b, c) {
    var d = a.pingCache;
    null !== d && d.delete(b);
    b = R();
    a.pingedLanes |= a.suspendedLanes & c;
    Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
    Dk(a, b);
  }
  function Yk(a, b) {
    0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c = R();
    a = ih(a, b);
    null !== a && (Ac(a, b, c), Dk(a, c));
  }
  function uj(a) {
    var b = a.memoizedState, c = 0;
    null !== b && (c = b.retryLane);
    Yk(a, c);
  }
  function bk(a, b) {
    var c = 0;
    switch (a.tag) {
      case 13:
        var d = a.stateNode;
        var e = a.memoizedState;
        null !== e && (c = e.retryLane);
        break;
      case 19:
        d = a.stateNode;
        break;
      default:
        throw Error(p(314));
    }
    null !== d && d.delete(b);
    Yk(a, c);
  }
  var Vk;
  Vk = function(a, b, c) {
    if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
      dh = 0 !== (a.flags & 131072) ? true : false;
    }
    else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
    b.lanes = 0;
    switch (b.tag) {
      case 2:
        var d = b.type;
        ij(a, b);
        a = b.pendingProps;
        var e = Yf(b, H.current);
        ch(b, c);
        e = Nh(null, b, d, a, e, c);
        var f = Sh();
        b.flags |= 1;
        "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
        return b;
      case 16:
        d = b.elementType;
        a: {
          ij(a, b);
          a = b.pendingProps;
          e = d._init;
          d = e(d._payload);
          b.type = d;
          e = b.tag = Zk(d);
          a = Ci(d, a);
          switch (e) {
            case 0:
              b = cj(null, b, d, a, c);
              break a;
            case 1:
              b = hj(null, b, d, a, c);
              break a;
            case 11:
              b = Yi(null, b, d, a, c);
              break a;
            case 14:
              b = $i(null, b, d, Ci(d.type, a), c);
              break a;
          }
          throw Error(p(
            306,
            d,
            ""
          ));
        }
        return b;
      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
      case 3:
        a: {
          kj(b);
          if (null === a) throw Error(p(387));
          d = b.pendingProps;
          f = b.memoizedState;
          e = f.element;
          lh(a, b);
          qh(b, d, null, c);
          var g = b.memoizedState;
          d = g.element;
          if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e = Ji(Error(p(423)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ji(Error(p(424)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            Ig();
            if (d === e) {
              b = Zi(a, b, c);
              break a;
            }
            Xi(a, b, d, c);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
      case 6:
        return null === a && Eg(b), null;
      case 13:
        return oj(a, b, c);
      case 4:
        return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
      case 7:
        return Xi(a, b, b.pendingProps, c), b.child;
      case 8:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 12:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 10:
        a: {
          d = b.type._context;
          e = b.pendingProps;
          f = b.memoizedProps;
          g = e.value;
          G(Wg, d._currentValue);
          d._currentValue = g;
          if (null !== f) if (He(f.value, g)) {
            if (f.children === e.children && !Wf.current) {
              b = Zi(a, b, c);
              break a;
            }
          } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
            var h2 = f.dependencies;
            if (null !== h2) {
              g = f.child;
              for (var k = h2.firstContext; null !== k; ) {
                if (k.context === d) {
                  if (1 === f.tag) {
                    k = mh(-1, c & -c);
                    k.tag = 2;
                    var l = f.updateQueue;
                    if (null !== l) {
                      l = l.shared;
                      var m2 = l.pending;
                      null === m2 ? k.next = k : (k.next = m2.next, m2.next = k);
                      l.pending = k;
                    }
                  }
                  f.lanes |= c;
                  k = f.alternate;
                  null !== k && (k.lanes |= c);
                  bh(
                    f.return,
                    c,
                    b
                  );
                  h2.lanes |= c;
                  break;
                }
                k = k.next;
              }
            } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
            else if (18 === f.tag) {
              g = f.return;
              if (null === g) throw Error(p(341));
              g.lanes |= c;
              h2 = g.alternate;
              null !== h2 && (h2.lanes |= c);
              bh(g, c, b);
              g = f.sibling;
            } else g = f.child;
            if (null !== g) g.return = f;
            else for (g = f; null !== g; ) {
              if (g === b) {
                g = null;
                break;
              }
              f = g.sibling;
              if (null !== f) {
                f.return = g.return;
                g = f;
                break;
              }
              g = g.return;
            }
            f = g;
          }
          Xi(a, b, e.children, c);
          b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
      case 14:
        return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
      case 15:
        return bj(a, b, b.type, b.pendingProps, c);
      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
      case 19:
        return xj(a, b, c);
      case 22:
        return dj(a, b, c);
    }
    throw Error(p(156, b.tag));
  };
  function Fk(a, b) {
    return ac(a, b);
  }
  function $k(a, b, c, d) {
    this.tag = a;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a, b, c, d) {
    return new $k(a, b, c, d);
  }
  function aj(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }
  function Zk(a) {
    if ("function" === typeof a) return aj(a) ? 1 : 0;
    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Da) return 11;
      if (a === Ga) return 14;
    }
    return 2;
  }
  function Pg(a, b) {
    var c = a.alternate;
    null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
    c.flags = a.flags & 14680064;
    c.childLanes = a.childLanes;
    c.lanes = a.lanes;
    c.child = a.child;
    c.memoizedProps = a.memoizedProps;
    c.memoizedState = a.memoizedState;
    c.updateQueue = a.updateQueue;
    b = a.dependencies;
    c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
    c.sibling = a.sibling;
    c.index = a.index;
    c.ref = a.ref;
    return c;
  }
  function Rg(a, b, c, d, e, f) {
    var g = 2;
    d = a;
    if ("function" === typeof a) aj(a) && (g = 1);
    else if ("string" === typeof a) g = 5;
    else a: switch (a) {
      case ya:
        return Tg(c.children, e, f, b);
      case za:
        g = 8;
        e |= 8;
        break;
      case Aa:
        return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
      case Ea:
        return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
      case Fa:
        return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
      case Ia:
        return pj(c, e, f, b);
      default:
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case Ba:
            g = 10;
            break a;
          case Ca:
            g = 9;
            break a;
          case Da:
            g = 11;
            break a;
          case Ga:
            g = 14;
            break a;
          case Ha:
            g = 16;
            d = null;
            break a;
        }
        throw Error(p(130, null == a ? a : typeof a, ""));
    }
    b = Bg(g, c, b, e);
    b.elementType = a;
    b.type = d;
    b.lanes = f;
    return b;
  }
  function Tg(a, b, c, d) {
    a = Bg(7, a, d, b);
    a.lanes = c;
    return a;
  }
  function pj(a, b, c, d) {
    a = Bg(22, a, d, b);
    a.elementType = Ia;
    a.lanes = c;
    a.stateNode = { isHidden: false };
    return a;
  }
  function Qg(a, b, c) {
    a = Bg(6, a, null, b);
    a.lanes = c;
    return a;
  }
  function Sg(a, b, c) {
    b = Bg(4, null !== a.children ? a.children : [], a.key, b);
    b.lanes = c;
    b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
    return b;
  }
  function al(a, b, c, d, e) {
    this.tag = b;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d;
    this.onRecoverableError = e;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a, b, c, d, e, f, g, h2, k) {
    a = new al(a, b, c, h2, k);
    1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
    f = Bg(3, null, null, b);
    a.current = f;
    f.stateNode = a;
    f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f);
    return a;
  }
  function cl(a, b, c) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
  }
  function dl(a) {
    if (!a) return Vf;
    a = a._reactInternals;
    a: {
      if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
      var b = a;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p(171));
    }
    if (1 === a.tag) {
      var c = a.type;
      if (Zf(c)) return bg(a, c, b);
    }
    return b;
  }
  function el(a, b, c, d, e, f, g, h2, k) {
    a = bl(c, d, true, a, e, f, g, h2, k);
    a.context = dl(null);
    c = a.current;
    d = R();
    e = yi(c);
    f = mh(d, e);
    f.callback = void 0 !== b && null !== b ? b : null;
    nh(c, f, e);
    a.current.lanes = e;
    Ac(a, e, d);
    Dk(a, d);
    return a;
  }
  function fl(a, b, c, d) {
    var e = b.current, f = R(), g = yi(e);
    c = dl(c);
    null === b.context ? b.context = c : b.pendingContext = c;
    b = mh(f, g);
    b.payload = { element: a };
    d = void 0 === d ? null : d;
    null !== d && (b.callback = d);
    a = nh(e, b, g);
    null !== a && (gi(a, e, g, f), oh(a, e, g));
    return g;
  }
  function gl(a) {
    a = a.current;
    if (!a.child) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function hl(a, b) {
    a = a.memoizedState;
    if (null !== a && null !== a.dehydrated) {
      var c = a.retryLane;
      a.retryLane = 0 !== c && c < b ? c : b;
    }
  }
  function il(a, b) {
    hl(a, b);
    (a = a.alternate) && hl(a, b);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a) {
    console.error(a);
  };
  function ll(a) {
    this._internalRoot = a;
  }
  ml.prototype.render = ll.prototype.render = function(a) {
    var b = this._internalRoot;
    if (null === b) throw Error(p(409));
    fl(a, b, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a = this._internalRoot;
    if (null !== a) {
      this._internalRoot = null;
      var b = a.containerInfo;
      Rk(function() {
        fl(null, a, null, null);
      });
      b[uf] = null;
    }
  };
  function ml(a) {
    this._internalRoot = a;
  }
  ml.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var b = Hc();
      a = { blockedOn: null, target: a, priority: b };
      for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
      Qc.splice(c, 0, a);
      0 === c && Vc(a);
    }
  };
  function nl(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
  }
  function ol(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }
  function pl() {
  }
  function ql(a, b, c, d, e) {
    if (e) {
      if ("function" === typeof d) {
        var f = d;
        d = function() {
          var a2 = gl(g);
          f.call(a2);
        };
      }
      var g = el(b, d, a, 0, null, false, false, "", pl);
      a._reactRootContainer = g;
      a[uf] = g.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk();
      return g;
    }
    for (; e = a.lastChild; ) a.removeChild(e);
    if ("function" === typeof d) {
      var h2 = d;
      d = function() {
        var a2 = gl(k);
        h2.call(a2);
      };
    }
    var k = bl(a, 0, false, null, null, false, false, "", pl);
    a._reactRootContainer = k;
    a[uf] = k.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk(function() {
      fl(b, k, c, d);
    });
    return k;
  }
  function rl(a, b, c, d, e) {
    var f = c._reactRootContainer;
    if (f) {
      var g = f;
      if ("function" === typeof e) {
        var h2 = e;
        e = function() {
          var a2 = gl(g);
          h2.call(a2);
        };
      }
      fl(b, g, a, e);
    } else g = ql(c, b, a, e, d);
    return gl(g);
  }
  Ec = function(a) {
    switch (a.tag) {
      case 3:
        var b = a.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c = tc(b.pendingLanes);
          0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih(a, 1);
          if (null !== b2) {
            var c2 = R();
            gi(b2, a, 1, c2);
          }
        }), il(a, 1);
    }
  };
  Fc = function(a) {
    if (13 === a.tag) {
      var b = ih(a, 134217728);
      if (null !== b) {
        var c = R();
        gi(b, a, 134217728, c);
      }
      il(a, 134217728);
    }
  };
  Gc = function(a) {
    if (13 === a.tag) {
      var b = yi(a), c = ih(a, b);
      if (null !== c) {
        var d = R();
        gi(c, a, b, d);
      }
      il(a, b);
    }
  };
  Hc = function() {
    return C2;
  };
  Ic = function(a, b) {
    var c = C2;
    try {
      return C2 = a, b();
    } finally {
      C2 = c;
    }
  };
  yb = function(a, b, c) {
    switch (b) {
      case "input":
        bb(a, c);
        b = c.name;
        if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode; ) c = c.parentNode;
          c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
          for (b = 0; b < c.length; b++) {
            var d = c[b];
            if (d !== a && d.form === a.form) {
              var e = Db(d);
              if (!e) throw Error(p(90));
              Wa(d);
              bb(d, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c);
        break;
      case "select":
        b = c.value, null != b && fb(a, !!c.multiple, b, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a, b) {
    var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b)) throw Error(p(200));
    return cl(a, b, null, c);
  };
  reactDom_production_min.createRoot = function(a, b) {
    if (!nl(a)) throw Error(p(299));
    var c = false, d = "", e = kl;
    null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
    b = bl(a, 1, false, null, null, c, false, d, e);
    a[uf] = b.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    return new ll(b);
  };
  reactDom_production_min.findDOMNode = function(a) {
    if (null == a) return null;
    if (1 === a.nodeType) return a;
    var b = a._reactInternals;
    if (void 0 === b) {
      if ("function" === typeof a.render) throw Error(p(188));
      a = Object.keys(a).join(",");
      throw Error(p(268, a));
    }
    a = Zb(b);
    a = null === a ? null : a.stateNode;
    return a;
  };
  reactDom_production_min.flushSync = function(a) {
    return Rk(a);
  };
  reactDom_production_min.hydrate = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, true, c);
  };
  reactDom_production_min.hydrateRoot = function(a, b, c) {
    if (!nl(a)) throw Error(p(405));
    var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
    null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
    b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
    a[uf] = b.current;
    sf(a);
    if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
      c,
      e
    );
    return new ml(b);
  };
  reactDom_production_min.render = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, false, c);
  };
  reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!ol(a)) throw Error(p(40));
    return a._reactRootContainer ? (Rk(function() {
      rl(null, null, a, false, function() {
        a._reactRootContainer = null;
        a[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
    if (!ol(c)) throw Error(p(200));
    if (null == a || void 0 === a._reactInternals) throw Error(p(38));
    return rl(a, b, c, false, d);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var reactDom_development = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_development;
function requireReactDom_development() {
  if (hasRequiredReactDom_development) return reactDom_development;
  hasRequiredReactDom_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React2 = reactExports;
      var Scheduler = requireScheduler();
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var suppressWarning = false;
      function setSuppressWarning(newSuppressWarning) {
        {
          suppressWarning = newSuppressWarning;
        }
      }
      function warn2(format2) {
        {
          if (!suppressWarning) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
      }
      function error(format2) {
        {
          if (!suppressWarning) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format2 += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var FunctionComponent = 0;
      var ClassComponent = 1;
      var IndeterminateComponent = 2;
      var HostRoot = 3;
      var HostPortal = 4;
      var HostComponent = 5;
      var HostText = 6;
      var Fragment = 7;
      var Mode = 8;
      var ContextConsumer = 9;
      var ContextProvider = 10;
      var ForwardRef = 11;
      var Profiler = 12;
      var SuspenseComponent = 13;
      var MemoComponent = 14;
      var SimpleMemoComponent = 15;
      var LazyComponent = 16;
      var IncompleteClassComponent = 17;
      var DehydratedFragment = 18;
      var SuspenseListComponent = 19;
      var ScopeComponent = 21;
      var OffscreenComponent = 22;
      var LegacyHiddenComponent = 23;
      var CacheComponent = 24;
      var TracingMarkerComponent = 25;
      var enableClientRenderFallbackOnTextMismatch = true;
      var enableNewReconciler = false;
      var enableLazyContextPropagation = false;
      var enableLegacyHidden = false;
      var enableSuspenseAvoidThisFallback = false;
      var disableCommentsAsDOMContainers = true;
      var enableCustomElementPropertySupport = false;
      var warnAboutStringRefs = true;
      var enableSchedulingProfiler = true;
      var enableProfilerTimer = true;
      var enableProfilerCommitHooks = true;
      var allNativeEvents = /* @__PURE__ */ new Set();
      var registrationNameDependencies = {};
      var possibleRegistrationNames = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        {
          if (registrationNameDependencies[registrationName]) {
            error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
          }
        }
        registrationNameDependencies[registrationName] = dependencies;
        {
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          if (registrationName === "onDoubleClick") {
            possibleRegistrationNames.ondblclick = registrationName;
          }
        }
        for (var i2 = 0; i2 < dependencies.length; i2++) {
          allNativeEvents.add(dependencies[i2]);
        }
      }
      var canUseDOM2 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkPropStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkFormFieldValueStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null) {
          return propertyInfo.type === RESERVED;
        }
        if (isCustomComponentTag) {
          return false;
        }
        if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
          return true;
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name2.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag) {
        if (value === null || typeof value === "undefined") {
          return true;
        }
        if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag)) {
          return true;
        }
        if (isCustomComponentTag) {
          return false;
        }
        if (propertyInfo !== null) {
          switch (propertyInfo.type) {
            case BOOLEAN:
              return !value;
            case OVERLOADED_BOOLEAN:
              return value === false;
            case NUMERIC:
              return isNaN(value);
            case POSITIVE_NUMERIC:
              return isNaN(value) || value < 1;
          }
        }
        return false;
      }
      function getPropertyInfo(name2) {
        return properties.hasOwnProperty(name2) ? properties[name2] : null;
      }
      function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name2;
        this.type = type;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        // TODO: This prevents the assignment of defaultValue to regular
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          RESERVED,
          false,
          // mustUseProperty
          name2,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name2 = _ref[0], attributeName = _ref[1];
        properties[name2] = new PropertyInfoRecord(
          name2,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name2.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name2,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "allowFullScreen",
        "async",
        // Note: there is a special case that prevents it from being written to the DOM
        // on the client side because the browsers are inconsistent. Instead we call focus().
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        // Microdata
        "itemScope"
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          BOOLEAN,
          false,
          // mustUseProperty
          name2.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "checked",
        // Note: `option.selected` is not updated if `select.multiple` is
        // disabled with `removeAttribute`. We have special logic for handling this.
        "multiple",
        "muted",
        "selected"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          BOOLEAN,
          true,
          // mustUseProperty
          name2,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "capture",
        "download"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          OVERLOADED_BOOLEAN,
          false,
          // mustUseProperty
          name2,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "cols",
        "rows",
        "size",
        "span"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          POSITIVE_NUMERIC,
          false,
          // mustUseProperty
          name2,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["rowSpan", "start"].forEach(function(name2) {
        properties[name2] = new PropertyInfoRecord(
          name2,
          NUMERIC,
          false,
          // mustUseProperty
          name2.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize2 = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize2);
        properties[name2] = new PropertyInfoRecord(
          name2,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize2);
        properties[name2] = new PropertyInfoRecord(
          name2,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/1999/xlink",
          false,
          // sanitizeURL
          false
        );
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name2 = attributeName.replace(CAMELIZE, capitalize2);
        properties[name2] = new PropertyInfoRecord(
          name2,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          false,
          // sanitizeURL
          false
        );
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        false,
        // mustUseProperty
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        true,
        // sanitizeURL
        false
      );
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          true,
          // sanitizeURL
          true
        );
      });
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url2) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url2)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url2));
          }
        }
      }
      function getValueForProperty(node2, name2, expected, propertyInfo) {
        {
          if (propertyInfo.mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            return node2[propertyName];
          } else {
            {
              checkAttributeStringCoercion(expected, name2);
            }
            if (propertyInfo.sanitizeURL) {
              sanitizeURL("" + expected);
            }
            var attributeName = propertyInfo.attributeName;
            var stringValue = null;
            if (propertyInfo.type === OVERLOADED_BOOLEAN) {
              if (node2.hasAttribute(attributeName)) {
                var value = node2.getAttribute(attributeName);
                if (value === "") {
                  return true;
                }
                if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                  return value;
                }
                if (value === "" + expected) {
                  return expected;
                }
                return value;
              }
            } else if (node2.hasAttribute(attributeName)) {
              if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                return node2.getAttribute(attributeName);
              }
              if (propertyInfo.type === BOOLEAN) {
                return expected;
              }
              stringValue = node2.getAttribute(attributeName);
            }
            if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
              return stringValue === null ? expected : stringValue;
            } else if (stringValue === "" + expected) {
              return expected;
            } else {
              return stringValue;
            }
          }
        }
      }
      function getValueForAttribute(node2, name2, expected, isCustomComponentTag) {
        {
          if (!isAttributeNameSafe(name2)) {
            return;
          }
          if (!node2.hasAttribute(name2)) {
            return expected === void 0 ? void 0 : null;
          }
          var value = node2.getAttribute(name2);
          {
            checkAttributeStringCoercion(expected, name2);
          }
          if (value === "" + expected) {
            return expected;
          }
          return value;
        }
      }
      function setValueForProperty(node2, name2, value, isCustomComponentTag) {
        var propertyInfo = getPropertyInfo(name2);
        if (shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag)) {
          return;
        }
        if (shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag)) {
          value = null;
        }
        if (isCustomComponentTag || propertyInfo === null) {
          if (isAttributeNameSafe(name2)) {
            var _attributeName = name2;
            if (value === null) {
              node2.removeAttribute(_attributeName);
            } else {
              {
                checkAttributeStringCoercion(value, name2);
              }
              node2.setAttribute(_attributeName, "" + value);
            }
          }
          return;
        }
        var mustUseProperty = propertyInfo.mustUseProperty;
        if (mustUseProperty) {
          var propertyName = propertyInfo.propertyName;
          if (value === null) {
            var type = propertyInfo.type;
            node2[propertyName] = type === BOOLEAN ? false : "";
          } else {
            node2[propertyName] = value;
          }
          return;
        }
        var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
        if (value === null) {
          node2.removeAttribute(attributeName);
        } else {
          var _type = propertyInfo.type;
          var attributeValue;
          if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
            attributeValue = "";
          } else {
            {
              {
                checkAttributeStringCoercion(value, attributeName);
              }
              attributeValue = "" + value;
            }
            if (propertyInfo.sanitizeURL) {
              sanitizeURL(attributeValue.toString());
            }
          }
          if (attributeNamespace) {
            node2.setAttributeNS(attributeNamespace, attributeName, attributeValue);
          } else {
            node2.setAttribute(attributeName, attributeValue);
          }
        }
      }
      var REACT_ELEMENT_TYPE2 = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_CACHE_TYPE = Symbol.for("react.cache");
      var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var assign2 = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign2({}, props, {
                value: prevLog
              }),
              info: assign2({}, props, {
                value: prevInfo
              }),
              warn: assign2({}, props, {
                value: prevWarn
              }),
              error: assign2({}, props, {
                value: prevError
              }),
              group: assign2({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign2({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign2({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name2, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name2;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name2 = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x2) {
              }
            }
          }
        }
        return "";
      }
      function describeFiber(fiber) {
        fiber._debugOwner ? fiber._debugOwner.type : null;
        fiber._debugSource;
        switch (fiber.tag) {
          case HostComponent:
            return describeBuiltInComponentFrame(fiber.type);
          case LazyComponent:
            return describeBuiltInComponentFrame("Lazy");
          case SuspenseComponent:
            return describeBuiltInComponentFrame("Suspense");
          case SuspenseListComponent:
            return describeBuiltInComponentFrame("SuspenseList");
          case FunctionComponent:
          case IndeterminateComponent:
          case SimpleMemoComponent:
            return describeFunctionComponentFrame(fiber.type);
          case ForwardRef:
            return describeFunctionComponentFrame(fiber.type.render);
          case ClassComponent:
            return describeClassComponentFrame(fiber.type);
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          var node2 = workInProgress2;
          do {
            info += describeFiber(node2);
            node2 = node2.return;
          } while (node2);
          return info;
        } catch (x2) {
          return "\nError generating stack: " + x2.message + "\n" + x2.stack;
        }
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x2) {
                return null;
              }
            }
          }
        }
        return null;
      }
      function getWrappedName$1(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getContextName$1(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromFiber(fiber) {
        var tag = fiber.tag, type = fiber.type;
        switch (tag) {
          case CacheComponent:
            return "Cache";
          case ContextConsumer:
            var context = type;
            return getContextName$1(context) + ".Consumer";
          case ContextProvider:
            var provider = type;
            return getContextName$1(provider._context) + ".Provider";
          case DehydratedFragment:
            return "DehydratedFragment";
          case ForwardRef:
            return getWrappedName$1(type, type.render, "ForwardRef");
          case Fragment:
            return "Fragment";
          case HostComponent:
            return type;
          case HostPortal:
            return "Portal";
          case HostRoot:
            return "Root";
          case HostText:
            return "Text";
          case LazyComponent:
            return getComponentNameFromType(type);
          case Mode:
            if (type === REACT_STRICT_MODE_TYPE) {
              return "StrictMode";
            }
            return "Mode";
          case OffscreenComponent:
            return "Offscreen";
          case Profiler:
            return "Profiler";
          case ScopeComponent:
            return "Scope";
          case SuspenseComponent:
            return "Suspense";
          case SuspenseListComponent:
            return "SuspenseList";
          case TracingMarkerComponent:
            return "TracingMarker";
          case ClassComponent:
          case FunctionComponent:
          case IncompleteClassComponent:
          case IndeterminateComponent:
          case MemoComponent:
          case SimpleMemoComponent:
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            break;
        }
        return null;
      }
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      var current = null;
      var isRendering = false;
      function getCurrentFiberOwnerNameInDevOrNull() {
        {
          if (current === null) {
            return null;
          }
          var owner = current._debugOwner;
          if (owner !== null && typeof owner !== "undefined") {
            return getComponentNameFromFiber(owner);
          }
        }
        return null;
      }
      function getCurrentFiberStackInDev() {
        {
          if (current === null) {
            return "";
          }
          return getStackByFiberInDevAndProd(current);
        }
      }
      function resetCurrentFiber() {
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          current = null;
          isRendering = false;
        }
      }
      function setCurrentFiber(fiber) {
        {
          ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
          current = fiber;
          isRendering = false;
        }
      }
      function getCurrentFiber() {
        {
          return current;
        }
      }
      function setIsRendering(rendering) {
        {
          isRendering = rendering;
        }
      }
      function toString2(value) {
        return "" + value;
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            {
              checkFormFieldValueStringCoercion(value);
            }
            return value;
          default:
            return "";
        }
      }
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
      }
      function getTracker(node2) {
        return node2._valueTracker;
      }
      function detachTracker(node2) {
        node2._valueTracker = null;
      }
      function getValueFromNode(node2) {
        var value = "";
        if (!node2) {
          return value;
        }
        if (isCheckable(node2)) {
          value = node2.checked ? "true" : "false";
        } else {
          value = node2.value;
        }
        return value;
      }
      function trackValueOnNode(node2) {
        var valueField = isCheckable(node2) ? "checked" : "value";
        var descriptor = Object.getOwnPropertyDescriptor(node2.constructor.prototype, valueField);
        {
          checkFormFieldValueStringCoercion(node2[valueField]);
        }
        var currentValue = "" + node2[valueField];
        if (node2.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
          return;
        }
        var get2 = descriptor.get, set3 = descriptor.set;
        Object.defineProperty(node2, valueField, {
          configurable: true,
          get: function() {
            return get2.call(this);
          },
          set: function(value) {
            {
              checkFormFieldValueStringCoercion(value);
            }
            currentValue = "" + value;
            set3.call(this, value);
          }
        });
        Object.defineProperty(node2, valueField, {
          enumerable: descriptor.enumerable
        });
        var tracker = {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            {
              checkFormFieldValueStringCoercion(value);
            }
            currentValue = "" + value;
          },
          stopTracking: function() {
            detachTracker(node2);
            delete node2[valueField];
          }
        };
        return tracker;
      }
      function track(node2) {
        if (getTracker(node2)) {
          return;
        }
        node2._valueTracker = trackValueOnNode(node2);
      }
      function updateValueIfChanged(node2) {
        if (!node2) {
          return false;
        }
        var tracker = getTracker(node2);
        if (!tracker) {
          return true;
        }
        var lastValue = tracker.getValue();
        var nextValue = getValueFromNode(node2);
        if (nextValue !== lastValue) {
          tracker.setValue(nextValue);
          return true;
        }
        return false;
      }
      function getActiveElement(doc2) {
        doc2 = doc2 || (typeof document !== "undefined" ? document : void 0);
        if (typeof doc2 === "undefined") {
          return null;
        }
        try {
          return doc2.activeElement || doc2.body;
        } catch (e) {
          return doc2.body;
        }
      }
      var didWarnValueDefaultValue = false;
      var didWarnCheckedDefaultChecked = false;
      var didWarnControlledToUncontrolled = false;
      var didWarnUncontrolledToControlled = false;
      function isControlled(props) {
        var usesChecked = props.type === "checkbox" || props.type === "radio";
        return usesChecked ? props.checked != null : props.value != null;
      }
      function getHostProps(element, props) {
        var node2 = element;
        var checked = props.checked;
        var hostProps = assign2({}, props, {
          defaultChecked: void 0,
          defaultValue: void 0,
          value: void 0,
          checked: checked != null ? checked : node2._wrapperState.initialChecked
        });
        return hostProps;
      }
      function initWrapperState(element, props) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
            didWarnCheckedDefaultChecked = true;
          }
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
            error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
            didWarnValueDefaultValue = true;
          }
        }
        var node2 = element;
        var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
        node2._wrapperState = {
          initialChecked: props.checked != null ? props.checked : props.defaultChecked,
          initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
          controlled: isControlled(props)
        };
      }
      function updateChecked(element, props) {
        var node2 = element;
        var checked = props.checked;
        if (checked != null) {
          setValueForProperty(node2, "checked", checked, false);
        }
      }
      function updateWrapper(element, props) {
        var node2 = element;
        {
          var controlled = isControlled(props);
          if (!node2._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
            error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnUncontrolledToControlled = true;
          }
          if (node2._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
            error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnControlledToUncontrolled = true;
          }
        }
        updateChecked(element, props);
        var value = getToStringValue(props.value);
        var type = props.type;
        if (value != null) {
          if (type === "number") {
            if (value === 0 && node2.value === "" || // We explicitly want to coerce to number here if possible.
            // eslint-disable-next-line
            node2.value != value) {
              node2.value = toString2(value);
            }
          } else if (node2.value !== toString2(value)) {
            node2.value = toString2(value);
          }
        } else if (type === "submit" || type === "reset") {
          node2.removeAttribute("value");
          return;
        }
        {
          if (props.hasOwnProperty("value")) {
            setDefaultValue(node2, props.type, value);
          } else if (props.hasOwnProperty("defaultValue")) {
            setDefaultValue(node2, props.type, getToStringValue(props.defaultValue));
          }
        }
        {
          if (props.checked == null && props.defaultChecked != null) {
            node2.defaultChecked = !!props.defaultChecked;
          }
        }
      }
      function postMountWrapper(element, props, isHydrating2) {
        var node2 = element;
        if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
          var type = props.type;
          var isButton = type === "submit" || type === "reset";
          if (isButton && (props.value === void 0 || props.value === null)) {
            return;
          }
          var initialValue = toString2(node2._wrapperState.initialValue);
          if (!isHydrating2) {
            {
              if (initialValue !== node2.value) {
                node2.value = initialValue;
              }
            }
          }
          {
            node2.defaultValue = initialValue;
          }
        }
        var name2 = node2.name;
        if (name2 !== "") {
          node2.name = "";
        }
        {
          node2.defaultChecked = !node2.defaultChecked;
          node2.defaultChecked = !!node2._wrapperState.initialChecked;
        }
        if (name2 !== "") {
          node2.name = name2;
        }
      }
      function restoreControlledState(element, props) {
        var node2 = element;
        updateWrapper(node2, props);
        updateNamedCousins(node2, props);
      }
      function updateNamedCousins(rootNode, props) {
        var name2 = props.name;
        if (props.type === "radio" && name2 != null) {
          var queryRoot = rootNode;
          while (queryRoot.parentNode) {
            queryRoot = queryRoot.parentNode;
          }
          {
            checkAttributeStringCoercion(name2, "name");
          }
          var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name2) + '][type="radio"]');
          for (var i2 = 0; i2 < group.length; i2++) {
            var otherNode = group[i2];
            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
              continue;
            }
            var otherProps = getFiberCurrentPropsFromNode(otherNode);
            if (!otherProps) {
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            }
            updateValueIfChanged(otherNode);
            updateWrapper(otherNode, otherProps);
          }
        }
      }
      function setDefaultValue(node2, type, value) {
        if (
          // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
          type !== "number" || getActiveElement(node2.ownerDocument) !== node2
        ) {
          if (value == null) {
            node2.defaultValue = toString2(node2._wrapperState.initialValue);
          } else if (node2.defaultValue !== toString2(value)) {
            node2.defaultValue = toString2(value);
          }
        }
      }
      var didWarnSelectedSetOnOption = false;
      var didWarnInvalidChild = false;
      var didWarnInvalidInnerHTML = false;
      function validateProps(element, props) {
        {
          if (props.value == null) {
            if (typeof props.children === "object" && props.children !== null) {
              React2.Children.forEach(props.children, function(child) {
                if (child == null) {
                  return;
                }
                if (typeof child === "string" || typeof child === "number") {
                  return;
                }
                if (!didWarnInvalidChild) {
                  didWarnInvalidChild = true;
                  error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                }
              });
            } else if (props.dangerouslySetInnerHTML != null) {
              if (!didWarnInvalidInnerHTML) {
                didWarnInvalidInnerHTML = true;
                error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
              }
            }
          }
          if (props.selected != null && !didWarnSelectedSetOnOption) {
            error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
            didWarnSelectedSetOnOption = true;
          }
        }
      }
      function postMountWrapper$1(element, props) {
        if (props.value != null) {
          element.setAttribute("value", toString2(getToStringValue(props.value)));
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray2(a) {
        return isArrayImpl(a);
      }
      var didWarnValueDefaultValue$1;
      {
        didWarnValueDefaultValue$1 = false;
      }
      function getDeclarationErrorAddendum() {
        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
        if (ownerName) {
          return "\n\nCheck the render method of `" + ownerName + "`.";
        }
        return "";
      }
      var valuePropNames = ["value", "defaultValue"];
      function checkSelectPropTypes(props) {
        {
          checkControlledValueProps("select", props);
          for (var i2 = 0; i2 < valuePropNames.length; i2++) {
            var propName = valuePropNames[i2];
            if (props[propName] == null) {
              continue;
            }
            var propNameIsArray = isArray2(props[propName]);
            if (props.multiple && !propNameIsArray) {
              error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
            } else if (!props.multiple && propNameIsArray) {
              error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
            }
          }
        }
      }
      function updateOptions(node2, multiple, propValue, setDefaultSelected) {
        var options2 = node2.options;
        if (multiple) {
          var selectedValues = propValue;
          var selectedValue = {};
          for (var i2 = 0; i2 < selectedValues.length; i2++) {
            selectedValue["$" + selectedValues[i2]] = true;
          }
          for (var _i = 0; _i < options2.length; _i++) {
            var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
            if (options2[_i].selected !== selected) {
              options2[_i].selected = selected;
            }
            if (selected && setDefaultSelected) {
              options2[_i].defaultSelected = true;
            }
          }
        } else {
          var _selectedValue = toString2(getToStringValue(propValue));
          var defaultSelected = null;
          for (var _i2 = 0; _i2 < options2.length; _i2++) {
            if (options2[_i2].value === _selectedValue) {
              options2[_i2].selected = true;
              if (setDefaultSelected) {
                options2[_i2].defaultSelected = true;
              }
              return;
            }
            if (defaultSelected === null && !options2[_i2].disabled) {
              defaultSelected = options2[_i2];
            }
          }
          if (defaultSelected !== null) {
            defaultSelected.selected = true;
          }
        }
      }
      function getHostProps$1(element, props) {
        return assign2({}, props, {
          value: void 0
        });
      }
      function initWrapperState$1(element, props) {
        var node2 = element;
        {
          checkSelectPropTypes(props);
        }
        node2._wrapperState = {
          wasMultiple: !!props.multiple
        };
        {
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
            error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnValueDefaultValue$1 = true;
          }
        }
      }
      function postMountWrapper$2(element, props) {
        var node2 = element;
        node2.multiple = !!props.multiple;
        var value = props.value;
        if (value != null) {
          updateOptions(node2, !!props.multiple, value, false);
        } else if (props.defaultValue != null) {
          updateOptions(node2, !!props.multiple, props.defaultValue, true);
        }
      }
      function postUpdateWrapper(element, props) {
        var node2 = element;
        var wasMultiple = node2._wrapperState.wasMultiple;
        node2._wrapperState.wasMultiple = !!props.multiple;
        var value = props.value;
        if (value != null) {
          updateOptions(node2, !!props.multiple, value, false);
        } else if (wasMultiple !== !!props.multiple) {
          if (props.defaultValue != null) {
            updateOptions(node2, !!props.multiple, props.defaultValue, true);
          } else {
            updateOptions(node2, !!props.multiple, props.multiple ? [] : "", false);
          }
        }
      }
      function restoreControlledState$1(element, props) {
        var node2 = element;
        var value = props.value;
        if (value != null) {
          updateOptions(node2, !!props.multiple, value, false);
        }
      }
      var didWarnValDefaultVal = false;
      function getHostProps$2(element, props) {
        var node2 = element;
        if (props.dangerouslySetInnerHTML != null) {
          throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
        }
        var hostProps = assign2({}, props, {
          value: void 0,
          defaultValue: void 0,
          children: toString2(node2._wrapperState.initialValue)
        });
        return hostProps;
      }
      function initWrapperState$2(element, props) {
        var node2 = element;
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
            error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
            didWarnValDefaultVal = true;
          }
        }
        var initialValue = props.value;
        if (initialValue == null) {
          var children2 = props.children, defaultValue = props.defaultValue;
          if (children2 != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            {
              if (defaultValue != null) {
                throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
              }
              if (isArray2(children2)) {
                if (children2.length > 1) {
                  throw new Error("<textarea> can only have at most one child.");
                }
                children2 = children2[0];
              }
              defaultValue = children2;
            }
          }
          if (defaultValue == null) {
            defaultValue = "";
          }
          initialValue = defaultValue;
        }
        node2._wrapperState = {
          initialValue: getToStringValue(initialValue)
        };
      }
      function updateWrapper$1(element, props) {
        var node2 = element;
        var value = getToStringValue(props.value);
        var defaultValue = getToStringValue(props.defaultValue);
        if (value != null) {
          var newValue = toString2(value);
          if (newValue !== node2.value) {
            node2.value = newValue;
          }
          if (props.defaultValue == null && node2.defaultValue !== newValue) {
            node2.defaultValue = newValue;
          }
        }
        if (defaultValue != null) {
          node2.defaultValue = toString2(defaultValue);
        }
      }
      function postMountWrapper$3(element, props) {
        var node2 = element;
        var textContent2 = node2.textContent;
        if (textContent2 === node2._wrapperState.initialValue) {
          if (textContent2 !== "" && textContent2 !== null) {
            node2.value = textContent2;
          }
        }
      }
      function restoreControlledState$2(element, props) {
        updateWrapper$1(element, props);
      }
      var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
      var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
      var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
      function getIntrinsicNamespace(type) {
        switch (type) {
          case "svg":
            return SVG_NAMESPACE;
          case "math":
            return MATH_NAMESPACE;
          default:
            return HTML_NAMESPACE;
        }
      }
      function getChildNamespace(parentNamespace, type) {
        if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
          return getIntrinsicNamespace(type);
        }
        if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
          return HTML_NAMESPACE;
        }
        return parentNamespace;
      }
      var createMicrosoftUnsafeLocalFunction = function(func) {
        if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
          return function(arg0, arg1, arg2, arg3) {
            MSApp.execUnsafeLocalFunction(function() {
              return func(arg0, arg1, arg2, arg3);
            });
          };
        } else {
          return func;
        }
      };
      var reusableSVGContainer;
      var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node2, html2) {
        if (node2.namespaceURI === SVG_NAMESPACE) {
          if (!("innerHTML" in node2)) {
            reusableSVGContainer = reusableSVGContainer || document.createElement("div");
            reusableSVGContainer.innerHTML = "<svg>" + html2.valueOf().toString() + "</svg>";
            var svgNode = reusableSVGContainer.firstChild;
            while (node2.firstChild) {
              node2.removeChild(node2.firstChild);
            }
            while (svgNode.firstChild) {
              node2.appendChild(svgNode.firstChild);
            }
            return;
          }
        }
        node2.innerHTML = html2;
      });
      var ELEMENT_NODE = 1;
      var TEXT_NODE = 3;
      var COMMENT_NODE = 8;
      var DOCUMENT_NODE = 9;
      var DOCUMENT_FRAGMENT_NODE = 11;
      var setTextContent = function(node2, text2) {
        if (text2) {
          var firstChild = node2.firstChild;
          if (firstChild && firstChild === node2.lastChild && firstChild.nodeType === TEXT_NODE) {
            firstChild.nodeValue = text2;
            return;
          }
        }
        node2.textContent = text2;
      };
      var shorthandToLonghand = {
        animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
        background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
        borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
        borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
        borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
        borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
        borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
        borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
        borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
        borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
        fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
        gap: ["columnGap", "rowGap"],
        grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
        wordWrap: ["overflowWrap"]
      };
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key2) {
        return prefix2 + key2.charAt(0).toUpperCase() + key2.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      function dangerousStyleValue(name2, value, isCustomProperty) {
        var isEmpty2 = value == null || typeof value === "boolean" || value === "";
        if (isEmpty2) {
          return "";
        }
        if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2])) {
          return value + "px";
        }
        {
          checkCSSPropertyStringCoercion(value, name2);
        }
        return ("" + value).trim();
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern = /^ms-/;
      function hyphenateStyleName(name2) {
        return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern$1 = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name2) {
          if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
            return;
          }
          warnedStyleNames[name2] = true;
          error(
            "Unsupported style property %s. Did you mean %s?",
            name2,
            // As Andi Smith suggests
            // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
            // is converted to lowercase `ms`.
            camelize(name2.replace(msPattern$1, "ms-"))
          );
        };
        var warnBadVendoredStyleName = function(name2) {
          if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
            return;
          }
          warnedStyleNames[name2] = true;
          error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name2, value) {
          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
            return;
          }
          warnedStyleValues[value] = true;
          error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name2, value) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error("`NaN` is an invalid value for the `%s` css style property.", name2);
        };
        var warnStyleValueIsInfinity = function(name2, value) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error("`Infinity` is an invalid value for the `%s` css style property.", name2);
        };
        warnValidStyle = function(name2, value) {
          if (name2.indexOf("-") > -1) {
            warnHyphenatedStyleName(name2);
          } else if (badVendoredStyleNamePattern.test(name2)) {
            warnBadVendoredStyleName(name2);
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name2, value);
          }
          if (typeof value === "number") {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name2, value);
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name2, value);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      function createDangerousStringForStyles(styles) {
        {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var styleValue = styles[styleName];
            if (styleValue != null) {
              var isCustomProperty = styleName.indexOf("--") === 0;
              serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
      }
      function setValueForStyles(node2, styles) {
        var style3 = node2.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var isCustomProperty = styleName.indexOf("--") === 0;
          {
            if (!isCustomProperty) {
              warnValidStyle$1(styleName, styles[styleName]);
            }
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
          if (styleName === "float") {
            styleName = "cssFloat";
          }
          if (isCustomProperty) {
            style3.setProperty(styleName, styleValue);
          } else {
            style3[styleName] = styleValue;
          }
        }
      }
      function isValueEmpty(value) {
        return value == null || typeof value === "boolean" || value === "";
      }
      function expandShorthandMap(styles) {
        var expanded = {};
        for (var key2 in styles) {
          var longhands = shorthandToLonghand[key2] || [key2];
          for (var i2 = 0; i2 < longhands.length; i2++) {
            expanded[longhands[i2]] = key2;
          }
        }
        return expanded;
      }
      function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
        {
          if (!nextStyles) {
            return;
          }
          var expandedUpdates = expandShorthandMap(styleUpdates);
          var expandedStyles = expandShorthandMap(nextStyles);
          var warnedAbout = {};
          for (var key2 in expandedUpdates) {
            var originalKey = expandedUpdates[key2];
            var correctOriginalKey = expandedStyles[key2];
            if (correctOriginalKey && originalKey !== correctOriginalKey) {
              var warningKey = originalKey + "," + correctOriginalKey;
              if (warnedAbout[warningKey]) {
                continue;
              }
              warnedAbout[warningKey] = true;
              error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
            }
          }
        }
      }
      var omittedCloseTags = {
        area: true,
        base: true,
        br: true,
        col: true,
        embed: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true
        // NOTE: menuitem's close tag should be omitted, but that causes problems.
      };
      var voidElementTags = assign2({
        menuitem: true
      }, omittedCloseTags);
      var HTML = "__html";
      function assertValidProps(tag, props) {
        if (!props) {
          return;
        }
        if (voidElementTags[tag]) {
          if (props.children != null || props.dangerouslySetInnerHTML != null) {
            throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          }
        }
        if (props.dangerouslySetInnerHTML != null) {
          if (props.children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
        }
        {
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
          }
        }
        if (props.style != null && typeof props.style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var possibleStandardNames = {
        // HTML
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        // SVG
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var ariaProperties = {
        "aria-current": 0,
        // state
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        // state
        "aria-hidden": 0,
        // state
        "aria-invalid": 0,
        // state
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        // Widget Attributes
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        // Live Region Attributes
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        // Drag-and-Drop Attributes
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        // Relationship Attributes
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty2(tagName, name2) {
        {
          if (hasOwnProperty.call(warnedProperties, name2) && warnedProperties[name2]) {
            return true;
          }
          if (rARIACamel.test(name2)) {
            var ariaName = "aria-" + name2.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
              warnedProperties[name2] = true;
              return true;
            }
            if (name2 !== correctName) {
              error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
              warnedProperties[name2] = true;
              return true;
            }
          }
          if (rARIA.test(name2)) {
            var lowerCasedName = name2.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name2] = true;
              return false;
            }
            if (name2 !== standardName) {
              error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
              warnedProperties[name2] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key2 in props) {
            var isValid = validateProperty2(type, key2);
            if (!isValid) {
              invalidProps.push(key2);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          } else if (invalidProps.length > 1) {
            error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === "select" && props.multiple) {
              error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            } else {
              error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
            }
          }
        }
      }
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name2, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
            return true;
          }
          var lowerCasedName = name2.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (eventRegistry != null) {
            var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies2.hasOwnProperty(name2)) {
              return true;
            }
            var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
            if (registrationName != null) {
              error("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name2)) {
              error("Unknown event handler property `%s`. It will be ignored.", name2);
              warnedProperties$1[name2] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name2)) {
            if (INVALID_EVENT_NAME_REGEX.test(name2)) {
              error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2);
            }
            warnedProperties$1[name2] = true;
            return true;
          }
          if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name2] = true;
            return true;
          }
          if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
            warnedProperties$1[name2] = true;
            return true;
          }
          if (typeof value === "number" && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2);
            warnedProperties$1[name2] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name2);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name2) {
              error("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
              warnedProperties$1[name2] = true;
              return true;
            }
          } else if (!isReserved && name2 !== lowerCasedName) {
            error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName);
            warnedProperties$1[name2] = true;
            return true;
          }
          if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
            if (value) {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2);
            } else {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2);
            }
            warnedProperties$1[name2] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
            warnedProperties$1[name2] = true;
            return false;
          }
          if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
            warnedProperties$1[name2] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key2 in props) {
            var isValid = validateProperty$1(type, key2, props[key2], eventRegistry);
            if (!isValid) {
              unknownProps.push(key2);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          } else if (unknownProps.length > 1) {
            error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          }
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnUnknownProperties(type, props, eventRegistry);
      }
      var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
      var IS_NON_DELEGATED = 1 << 1;
      var IS_CAPTURE_PHASE = 1 << 2;
      var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
      var currentReplayingEvent = null;
      function setReplayingEvent(event2) {
        {
          if (currentReplayingEvent !== null) {
            error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        currentReplayingEvent = event2;
      }
      function resetReplayingEvent() {
        {
          if (currentReplayingEvent === null) {
            error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        currentReplayingEvent = null;
      }
      function isReplayingEvent(event2) {
        return event2 === currentReplayingEvent;
      }
      function getEventTarget(nativeEvent) {
        var target2 = nativeEvent.target || nativeEvent.srcElement || window;
        if (target2.correspondingUseElement) {
          target2 = target2.correspondingUseElement;
        }
        return target2.nodeType === TEXT_NODE ? target2.parentNode : target2;
      }
      var restoreImpl = null;
      var restoreTarget = null;
      var restoreQueue = null;
      function restoreStateOfTarget(target2) {
        var internalInstance = getInstanceFromNode(target2);
        if (!internalInstance) {
          return;
        }
        if (typeof restoreImpl !== "function") {
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        }
        var stateNode = internalInstance.stateNode;
        if (stateNode) {
          var _props = getFiberCurrentPropsFromNode(stateNode);
          restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
        }
      }
      function setRestoreImplementation(impl) {
        restoreImpl = impl;
      }
      function enqueueStateRestore(target2) {
        if (restoreTarget) {
          if (restoreQueue) {
            restoreQueue.push(target2);
          } else {
            restoreQueue = [target2];
          }
        } else {
          restoreTarget = target2;
        }
      }
      function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
      }
      function restoreStateIfNeeded() {
        if (!restoreTarget) {
          return;
        }
        var target2 = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target2);
        if (queuedTargets) {
          for (var i2 = 0; i2 < queuedTargets.length; i2++) {
            restoreStateOfTarget(queuedTargets[i2]);
          }
        }
      }
      var batchedUpdatesImpl = function(fn, bookkeeping) {
        return fn(bookkeeping);
      };
      var flushSyncImpl = function() {
      };
      var isInsideEventHandler = false;
      function finishEventHandler() {
        var controlledComponentsHavePendingUpdates = needsStateRestore();
        if (controlledComponentsHavePendingUpdates) {
          flushSyncImpl();
          restoreStateIfNeeded();
        }
      }
      function batchedUpdates(fn, a, b) {
        if (isInsideEventHandler) {
          return fn(a, b);
        }
        isInsideEventHandler = true;
        try {
          return batchedUpdatesImpl(fn, a, b);
        } finally {
          isInsideEventHandler = false;
          finishEventHandler();
        }
      }
      function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
        batchedUpdatesImpl = _batchedUpdatesImpl;
        flushSyncImpl = _flushSyncImpl;
      }
      function isInteractive(tag) {
        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
      }
      function shouldPreventMouseEvent(name2, type, props) {
        switch (name2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            return !!(props.disabled && isInteractive(type));
          default:
            return false;
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (stateNode === null) {
          return null;
        }
        var props = getFiberCurrentPropsFromNode(stateNode);
        if (props === null) {
          return null;
        }
        var listener = props[registrationName];
        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
          return null;
        }
        if (listener && typeof listener !== "function") {
          throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
        }
        return listener;
      }
      var passiveBrowserEventsSupported = false;
      if (canUseDOM2) {
        try {
          var options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      }
      function invokeGuardedCallbackProd(name2, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);
        try {
          func.apply(context, funcArgs);
        } catch (error2) {
          this.onError(error2);
        }
      }
      var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
      {
        if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
          var fakeNode = document.createElement("react");
          invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name2, func, context, a, b, c, d, e, f) {
            if (typeof document === "undefined" || document === null) {
              throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
            }
            var evt = document.createEvent("Event");
            var didCall = false;
            var didError = true;
            var windowEvent = window.event;
            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
            function restoreAfterDispatch() {
              fakeNode.removeEventListener(evtType, callCallback2, false);
              if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                window.event = windowEvent;
              }
            }
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            function callCallback2() {
              didCall = true;
              restoreAfterDispatch();
              func.apply(context, funcArgs);
              didError = false;
            }
            var error2;
            var didSetError = false;
            var isCrossOriginError = false;
            function handleWindowError(event2) {
              error2 = event2.error;
              didSetError = true;
              if (error2 === null && event2.colno === 0 && event2.lineno === 0) {
                isCrossOriginError = true;
              }
              if (event2.defaultPrevented) {
                if (error2 != null && typeof error2 === "object") {
                  try {
                    error2._suppressLogging = true;
                  } catch (inner) {
                  }
                }
              }
            }
            var evtType = "react-" + (name2 ? name2 : "invokeguardedcallback");
            window.addEventListener("error", handleWindowError);
            fakeNode.addEventListener(evtType, callCallback2, false);
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);
            if (windowEventDescriptor) {
              Object.defineProperty(window, "event", windowEventDescriptor);
            }
            if (didCall && didError) {
              if (!didSetError) {
                error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
              } else if (isCrossOriginError) {
                error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
              }
              this.onError(error2);
            }
            window.removeEventListener("error", handleWindowError);
            if (!didCall) {
              restoreAfterDispatch();
              return invokeGuardedCallbackProd.apply(this, arguments);
            }
          };
        }
      }
      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
      var hasError = false;
      var caughtError = null;
      var hasRethrowError = false;
      var rethrowError = null;
      var reporter = {
        onError: function(error2) {
          hasError = true;
          caughtError = error2;
        }
      };
      function invokeGuardedCallback(name2, func, context, a, b, c, d, e, f) {
        hasError = false;
        caughtError = null;
        invokeGuardedCallbackImpl$1.apply(reporter, arguments);
      }
      function invokeGuardedCallbackAndCatchFirstError(name2, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback.apply(this, arguments);
        if (hasError) {
          var error2 = clearCaughtError();
          if (!hasRethrowError) {
            hasRethrowError = true;
            rethrowError = error2;
          }
        }
      }
      function rethrowCaughtError() {
        if (hasRethrowError) {
          var error2 = rethrowError;
          hasRethrowError = false;
          rethrowError = null;
          throw error2;
        }
      }
      function hasCaughtError() {
        return hasError;
      }
      function clearCaughtError() {
        if (hasError) {
          var error2 = caughtError;
          hasError = false;
          caughtError = null;
          return error2;
        } else {
          throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      function get(key2) {
        return key2._reactInternals;
      }
      function has2(key2) {
        return key2._reactInternals !== void 0;
      }
      function set2(key2, value) {
        key2._reactInternals = value;
      }
      var NoFlags = (
        /*                      */
        0
      );
      var PerformedWork = (
        /*                */
        1
      );
      var Placement = (
        /*                    */
        2
      );
      var Update = (
        /*                       */
        4
      );
      var ChildDeletion = (
        /*                */
        16
      );
      var ContentReset = (
        /*                 */
        32
      );
      var Callback = (
        /*                     */
        64
      );
      var DidCapture = (
        /*                   */
        128
      );
      var ForceClientRender = (
        /*            */
        256
      );
      var Ref = (
        /*                          */
        512
      );
      var Snapshot = (
        /*                     */
        1024
      );
      var Passive = (
        /*                      */
        2048
      );
      var Hydrating = (
        /*                    */
        4096
      );
      var Visibility = (
        /*                   */
        8192
      );
      var StoreConsistency = (
        /*             */
        16384
      );
      var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
      var HostEffectMask = (
        /*               */
        32767
      );
      var Incomplete = (
        /*                   */
        32768
      );
      var ShouldCapture = (
        /*                */
        65536
      );
      var ForceUpdateForLegacySuspense = (
        /* */
        131072
      );
      var Forked = (
        /*                       */
        1048576
      );
      var RefStatic = (
        /*                    */
        2097152
      );
      var LayoutStatic = (
        /*                 */
        4194304
      );
      var PassiveStatic = (
        /*                */
        8388608
      );
      var MountLayoutDev = (
        /*               */
        16777216
      );
      var MountPassiveDev = (
        /*              */
        33554432
      );
      var BeforeMutationMask = (
        // TODO: Remove Update flag from before mutation phase by re-landing Visibility
        // flag logic (see #20043)
        Update | Snapshot | 0
      );
      var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
      var LayoutMask = Update | Callback | Ref | Visibility;
      var PassiveMask = Passive | ChildDeletion;
      var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      function getNearestMountedFiber(fiber) {
        var node2 = fiber;
        var nearestMounted = fiber;
        if (!fiber.alternate) {
          var nextNode = node2;
          do {
            node2 = nextNode;
            if ((node2.flags & (Placement | Hydrating)) !== NoFlags) {
              nearestMounted = node2.return;
            }
            nextNode = node2.return;
          } while (nextNode);
        } else {
          while (node2.return) {
            node2 = node2.return;
          }
        }
        if (node2.tag === HostRoot) {
          return nearestMounted;
        }
        return null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState === null) {
            var current2 = fiber.alternate;
            if (current2 !== null) {
              suspenseState = current2.memoizedState;
            }
          }
          if (suspenseState !== null) {
            return suspenseState.dehydrated;
          }
        }
        return null;
      }
      function getContainerFromFiber(fiber) {
        return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
      }
      function isFiberMounted(fiber) {
        return getNearestMountedFiber(fiber) === fiber;
      }
      function isMounted(component) {
        {
          var owner = ReactCurrentOwner.current;
          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance = ownerFiber.stateNode;
            if (!instance._warnedAboutRefsInRender) {
              error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
            }
            instance._warnedAboutRefsInRender = true;
          }
        }
        var fiber = get(component);
        if (!fiber) {
          return false;
        }
        return getNearestMountedFiber(fiber) === fiber;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber) {
          throw new Error("Unable to find node on an unmounted component.");
        }
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          var nearestMounted = getNearestMountedFiber(fiber);
          if (nearestMounted === null) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (nearestMounted !== fiber) {
            return null;
          }
          return fiber;
        }
        var a = fiber;
        var b = alternate;
        while (true) {
          var parentA = a.return;
          if (parentA === null) {
            break;
          }
          var parentB = parentA.alternate;
          if (parentB === null) {
            var nextParent = parentA.return;
            if (nextParent !== null) {
              a = b = nextParent;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            var child = parentA.child;
            while (child) {
              if (child === a) {
                assertIsMounted(parentA);
                return fiber;
              }
              if (child === b) {
                assertIsMounted(parentA);
                return alternate;
              }
              child = child.sibling;
            }
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a.return !== b.return) {
            a = parentA;
            b = parentB;
          } else {
            var didFindChild = false;
            var _child = parentA.child;
            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) {
              _child = parentB.child;
              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
              }
            }
          }
          if (a.alternate !== b) {
            throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        if (a.tag !== HostRoot) {
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (a.stateNode.current === a) {
          return fiber;
        }
        return alternate;
      }
      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
      }
      function findCurrentHostFiberImpl(node2) {
        if (node2.tag === HostComponent || node2.tag === HostText) {
          return node2;
        }
        var child = node2.child;
        while (child !== null) {
          var match = findCurrentHostFiberImpl(child);
          if (match !== null) {
            return match;
          }
          child = child.sibling;
        }
        return null;
      }
      function findCurrentHostFiberWithNoPortals(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
      }
      function findCurrentHostFiberWithNoPortalsImpl(node2) {
        if (node2.tag === HostComponent || node2.tag === HostText) {
          return node2;
        }
        var child = node2.child;
        while (child !== null) {
          if (child.tag !== HostPortal) {
            var match = findCurrentHostFiberWithNoPortalsImpl(child);
            if (match !== null) {
              return match;
            }
          }
          child = child.sibling;
        }
        return null;
      }
      var scheduleCallback = Scheduler.unstable_scheduleCallback;
      var cancelCallback = Scheduler.unstable_cancelCallback;
      var shouldYield = Scheduler.unstable_shouldYield;
      var requestPaint = Scheduler.unstable_requestPaint;
      var now = Scheduler.unstable_now;
      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
      var NormalPriority = Scheduler.unstable_NormalPriority;
      var LowPriority = Scheduler.unstable_LowPriority;
      var IdlePriority = Scheduler.unstable_IdlePriority;
      var unstable_yieldValue = Scheduler.unstable_yieldValue;
      var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
      var rendererID = null;
      var injectedHook = null;
      var injectedProfilingHooks = null;
      var hasLoggedError = false;
      var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          return false;
        }
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled) {
          return true;
        }
        if (!hook.supportsFiber) {
          {
            error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
          }
          return true;
        }
        try {
          if (enableSchedulingProfiler) {
            internals = assign2({}, internals, {
              getLaneLabelMap,
              injectProfilingHooks
            });
          }
          rendererID = hook.inject(internals);
          injectedHook = hook;
        } catch (err) {
          {
            error("React instrumentation encountered an error: %s.", err);
          }
        }
        if (hook.checkDCE) {
          return true;
        } else {
          return false;
        }
      }
      function onScheduleRoot(root3, children2) {
        {
          if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
            try {
              injectedHook.onScheduleFiberRoot(rendererID, root3, children2);
            } catch (err) {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onCommitRoot(root3, eventPriority) {
        if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
          try {
            var didError = (root3.current.flags & DidCapture) === DidCapture;
            if (enableProfilerTimer) {
              var schedulerPriority;
              switch (eventPriority) {
                case DiscreteEventPriority:
                  schedulerPriority = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriority = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriority = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriority = IdlePriority;
                  break;
                default:
                  schedulerPriority = NormalPriority;
                  break;
              }
              injectedHook.onCommitFiberRoot(rendererID, root3, schedulerPriority, didError);
            }
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onPostCommitRoot(root3) {
        if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root3);
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onCommitUnmount(fiber) {
        if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
          try {
            injectedHook.onCommitFiberUnmount(rendererID, fiber);
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function setIsStrictModeForDevtools(newIsStrictMode) {
        {
          if (typeof unstable_yieldValue === "function") {
            unstable_setDisableYieldValue(newIsStrictMode);
            setSuppressWarning(newIsStrictMode);
          }
          if (injectedHook && typeof injectedHook.setStrictMode === "function") {
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
      }
      function injectProfilingHooks(profilingHooks) {
        injectedProfilingHooks = profilingHooks;
      }
      function getLaneLabelMap() {
        {
          var map2 = /* @__PURE__ */ new Map();
          var lane = 1;
          for (var index2 = 0; index2 < TotalLanes; index2++) {
            var label = getLabelForLane(lane);
            map2.set(lane, label);
            lane *= 2;
          }
          return map2;
        }
      }
      function markCommitStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
            injectedProfilingHooks.markCommitStarted(lanes);
          }
        }
      }
      function markCommitStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
            injectedProfilingHooks.markCommitStopped();
          }
        }
      }
      function markComponentRenderStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
            injectedProfilingHooks.markComponentRenderStarted(fiber);
          }
        }
      }
      function markComponentRenderStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
            injectedProfilingHooks.markComponentRenderStopped();
          }
        }
      }
      function markComponentPassiveEffectMountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
            injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
          }
        }
      }
      function markComponentPassiveEffectMountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
            injectedProfilingHooks.markComponentPassiveEffectMountStopped();
          }
        }
      }
      function markComponentPassiveEffectUnmountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
            injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
          }
        }
      }
      function markComponentPassiveEffectUnmountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
            injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
          }
        }
      }
      function markComponentLayoutEffectMountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
            injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
          }
        }
      }
      function markComponentLayoutEffectMountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
            injectedProfilingHooks.markComponentLayoutEffectMountStopped();
          }
        }
      }
      function markComponentLayoutEffectUnmountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
            injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
          }
        }
      }
      function markComponentLayoutEffectUnmountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
            injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
          }
        }
      }
      function markComponentErrored(fiber, thrownValue, lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
            injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
          }
        }
      }
      function markComponentSuspended(fiber, wakeable, lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
            injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
          }
        }
      }
      function markLayoutEffectsStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
            injectedProfilingHooks.markLayoutEffectsStarted(lanes);
          }
        }
      }
      function markLayoutEffectsStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
            injectedProfilingHooks.markLayoutEffectsStopped();
          }
        }
      }
      function markPassiveEffectsStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
            injectedProfilingHooks.markPassiveEffectsStarted(lanes);
          }
        }
      }
      function markPassiveEffectsStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
            injectedProfilingHooks.markPassiveEffectsStopped();
          }
        }
      }
      function markRenderStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
            injectedProfilingHooks.markRenderStarted(lanes);
          }
        }
      }
      function markRenderYielded() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
            injectedProfilingHooks.markRenderYielded();
          }
        }
      }
      function markRenderStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
            injectedProfilingHooks.markRenderStopped();
          }
        }
      }
      function markRenderScheduled(lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
            injectedProfilingHooks.markRenderScheduled(lane);
          }
        }
      }
      function markForceUpdateScheduled(fiber, lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
            injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
          }
        }
      }
      function markStateUpdateScheduled(fiber, lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
            injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
          }
        }
      }
      var NoMode = (
        /*                         */
        0
      );
      var ConcurrentMode = (
        /*                 */
        1
      );
      var ProfileMode = (
        /*                    */
        2
      );
      var StrictLegacyMode = (
        /*               */
        8
      );
      var StrictEffectsMode = (
        /*              */
        16
      );
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x2) {
        var asUint = x2 >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      var TotalLanes = 31;
      var NoLanes = (
        /*                        */
        0
      );
      var NoLane = (
        /*                          */
        0
      );
      var SyncLane = (
        /*                        */
        1
      );
      var InputContinuousHydrationLane = (
        /*    */
        2
      );
      var InputContinuousLane = (
        /*             */
        4
      );
      var DefaultHydrationLane = (
        /*            */
        8
      );
      var DefaultLane = (
        /*                     */
        16
      );
      var TransitionHydrationLane = (
        /*                */
        32
      );
      var TransitionLanes = (
        /*                       */
        4194240
      );
      var TransitionLane1 = (
        /*                        */
        64
      );
      var TransitionLane2 = (
        /*                        */
        128
      );
      var TransitionLane3 = (
        /*                        */
        256
      );
      var TransitionLane4 = (
        /*                        */
        512
      );
      var TransitionLane5 = (
        /*                        */
        1024
      );
      var TransitionLane6 = (
        /*                        */
        2048
      );
      var TransitionLane7 = (
        /*                        */
        4096
      );
      var TransitionLane8 = (
        /*                        */
        8192
      );
      var TransitionLane9 = (
        /*                        */
        16384
      );
      var TransitionLane10 = (
        /*                       */
        32768
      );
      var TransitionLane11 = (
        /*                       */
        65536
      );
      var TransitionLane12 = (
        /*                       */
        131072
      );
      var TransitionLane13 = (
        /*                       */
        262144
      );
      var TransitionLane14 = (
        /*                       */
        524288
      );
      var TransitionLane15 = (
        /*                       */
        1048576
      );
      var TransitionLane16 = (
        /*                       */
        2097152
      );
      var RetryLanes = (
        /*                            */
        130023424
      );
      var RetryLane1 = (
        /*                             */
        4194304
      );
      var RetryLane2 = (
        /*                             */
        8388608
      );
      var RetryLane3 = (
        /*                             */
        16777216
      );
      var RetryLane4 = (
        /*                             */
        33554432
      );
      var RetryLane5 = (
        /*                             */
        67108864
      );
      var SomeRetryLane = RetryLane1;
      var SelectiveHydrationLane = (
        /*          */
        134217728
      );
      var NonIdleLanes = (
        /*                          */
        268435455
      );
      var IdleHydrationLane = (
        /*               */
        268435456
      );
      var IdleLane = (
        /*                        */
        536870912
      );
      var OffscreenLane = (
        /*                   */
        1073741824
      );
      function getLabelForLane(lane) {
        {
          if (lane & SyncLane) {
            return "Sync";
          }
          if (lane & InputContinuousHydrationLane) {
            return "InputContinuousHydration";
          }
          if (lane & InputContinuousLane) {
            return "InputContinuous";
          }
          if (lane & DefaultHydrationLane) {
            return "DefaultHydration";
          }
          if (lane & DefaultLane) {
            return "Default";
          }
          if (lane & TransitionHydrationLane) {
            return "TransitionHydration";
          }
          if (lane & TransitionLanes) {
            return "Transition";
          }
          if (lane & RetryLanes) {
            return "Retry";
          }
          if (lane & SelectiveHydrationLane) {
            return "SelectiveHydration";
          }
          if (lane & IdleHydrationLane) {
            return "IdleHydration";
          }
          if (lane & IdleLane) {
            return "Idle";
          }
          if (lane & OffscreenLane) {
            return "Offscreen";
          }
        }
      }
      var NoTimestamp = -1;
      var nextTransitionLane = TransitionLane1;
      var nextRetryLane = RetryLane1;
      function getHighestPriorityLanes(lanes) {
        switch (getHighestPriorityLane(lanes)) {
          case SyncLane:
            return SyncLane;
          case InputContinuousHydrationLane:
            return InputContinuousHydrationLane;
          case InputContinuousLane:
            return InputContinuousLane;
          case DefaultHydrationLane:
            return DefaultHydrationLane;
          case DefaultLane:
            return DefaultLane;
          case TransitionHydrationLane:
            return TransitionHydrationLane;
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
            return lanes & TransitionLanes;
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            return lanes & RetryLanes;
          case SelectiveHydrationLane:
            return SelectiveHydrationLane;
          case IdleHydrationLane:
            return IdleHydrationLane;
          case IdleLane:
            return IdleLane;
          case OffscreenLane:
            return OffscreenLane;
          default:
            {
              error("Should have found matching lanes. This is a bug in React.");
            }
            return lanes;
        }
      }
      function getNextLanes(root3, wipLanes) {
        var pendingLanes = root3.pendingLanes;
        if (pendingLanes === NoLanes) {
          return NoLanes;
        }
        var nextLanes = NoLanes;
        var suspendedLanes = root3.suspendedLanes;
        var pingedLanes = root3.pingedLanes;
        var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
        if (nonIdlePendingLanes !== NoLanes) {
          var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
          if (nonIdleUnblockedLanes !== NoLanes) {
            nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
          } else {
            var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
            if (nonIdlePingedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
            }
          }
        } else {
          var unblockedLanes = pendingLanes & ~suspendedLanes;
          if (unblockedLanes !== NoLanes) {
            nextLanes = getHighestPriorityLanes(unblockedLanes);
          } else {
            if (pingedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(pingedLanes);
            }
          }
        }
        if (nextLanes === NoLanes) {
          return NoLanes;
        }
        if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
        // bother waiting until the root is complete.
        (wipLanes & suspendedLanes) === NoLanes) {
          var nextLane = getHighestPriorityLane(nextLanes);
          var wipLane = getHighestPriorityLane(wipLanes);
          if (
            // Tests whether the next lane is equal or lower priority than the wip
            // one. This works because the bits decrease in priority as you go left.
            nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
            // only difference between default updates and transition updates is that
            // default updates do not support refresh transitions.
            nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
          ) {
            return wipLanes;
          }
        }
        if ((nextLanes & InputContinuousLane) !== NoLanes) {
          nextLanes |= pendingLanes & DefaultLane;
        }
        var entangledLanes = root3.entangledLanes;
        if (entangledLanes !== NoLanes) {
          var entanglements = root3.entanglements;
          var lanes = nextLanes & entangledLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            nextLanes |= entanglements[index2];
            lanes &= ~lane;
          }
        }
        return nextLanes;
      }
      function getMostRecentEventTime(root3, lanes) {
        var eventTimes = root3.eventTimes;
        var mostRecentEventTime = NoTimestamp;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          var eventTime = eventTimes[index2];
          if (eventTime > mostRecentEventTime) {
            mostRecentEventTime = eventTime;
          }
          lanes &= ~lane;
        }
        return mostRecentEventTime;
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case SyncLane:
          case InputContinuousHydrationLane:
          case InputContinuousLane:
            return currentTime + 250;
          case DefaultHydrationLane:
          case DefaultLane:
          case TransitionHydrationLane:
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
            return currentTime + 5e3;
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            return NoTimestamp;
          case SelectiveHydrationLane:
          case IdleHydrationLane:
          case IdleLane:
          case OffscreenLane:
            return NoTimestamp;
          default:
            {
              error("Should have found matching lanes. This is a bug in React.");
            }
            return NoTimestamp;
        }
      }
      function markStarvedLanesAsExpired(root3, currentTime) {
        var pendingLanes = root3.pendingLanes;
        var suspendedLanes = root3.suspendedLanes;
        var pingedLanes = root3.pingedLanes;
        var expirationTimes = root3.expirationTimes;
        var lanes = pendingLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          var expirationTime = expirationTimes[index2];
          if (expirationTime === NoTimestamp) {
            if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
              expirationTimes[index2] = computeExpirationTime(lane, currentTime);
            }
          } else if (expirationTime <= currentTime) {
            root3.expiredLanes |= lane;
          }
          lanes &= ~lane;
        }
      }
      function getHighestPriorityPendingLanes(root3) {
        return getHighestPriorityLanes(root3.pendingLanes);
      }
      function getLanesToRetrySynchronouslyOnError(root3) {
        var everythingButOffscreen = root3.pendingLanes & ~OffscreenLane;
        if (everythingButOffscreen !== NoLanes) {
          return everythingButOffscreen;
        }
        if (everythingButOffscreen & OffscreenLane) {
          return OffscreenLane;
        }
        return NoLanes;
      }
      function includesSyncLane(lanes) {
        return (lanes & SyncLane) !== NoLanes;
      }
      function includesNonIdleWork(lanes) {
        return (lanes & NonIdleLanes) !== NoLanes;
      }
      function includesOnlyRetries(lanes) {
        return (lanes & RetryLanes) === lanes;
      }
      function includesOnlyNonUrgentLanes(lanes) {
        var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
        return (lanes & UrgentLanes) === NoLanes;
      }
      function includesOnlyTransitions(lanes) {
        return (lanes & TransitionLanes) === lanes;
      }
      function includesBlockingLane(root3, lanes) {
        var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
        return (lanes & SyncDefaultLanes) !== NoLanes;
      }
      function includesExpiredLane(root3, lanes) {
        return (lanes & root3.expiredLanes) !== NoLanes;
      }
      function isTransitionLane(lane) {
        return (lane & TransitionLanes) !== NoLanes;
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        if ((nextTransitionLane & TransitionLanes) === NoLanes) {
          nextTransitionLane = TransitionLane1;
        }
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        if ((nextRetryLane & RetryLanes) === NoLanes) {
          nextRetryLane = RetryLane1;
        }
        return lane;
      }
      function getHighestPriorityLane(lanes) {
        return lanes & -lanes;
      }
      function pickArbitraryLane(lanes) {
        return getHighestPriorityLane(lanes);
      }
      function pickArbitraryLaneIndex(lanes) {
        return 31 - clz32(lanes);
      }
      function laneToIndex(lane) {
        return pickArbitraryLaneIndex(lane);
      }
      function includesSomeLane(a, b) {
        return (a & b) !== NoLanes;
      }
      function isSubsetOfLanes(set3, subset) {
        return (set3 & subset) === subset;
      }
      function mergeLanes(a, b) {
        return a | b;
      }
      function removeLanes(set3, subset) {
        return set3 & ~subset;
      }
      function intersectLanes(a, b) {
        return a & b;
      }
      function laneToLanes(lane) {
        return lane;
      }
      function higherPriorityLane(a, b) {
        return a !== NoLane && a < b ? a : b;
      }
      function createLaneMap(initial) {
        var laneMap = [];
        for (var i2 = 0; i2 < TotalLanes; i2++) {
          laneMap.push(initial);
        }
        return laneMap;
      }
      function markRootUpdated(root3, updateLane, eventTime) {
        root3.pendingLanes |= updateLane;
        if (updateLane !== IdleLane) {
          root3.suspendedLanes = NoLanes;
          root3.pingedLanes = NoLanes;
        }
        var eventTimes = root3.eventTimes;
        var index2 = laneToIndex(updateLane);
        eventTimes[index2] = eventTime;
      }
      function markRootSuspended(root3, suspendedLanes) {
        root3.suspendedLanes |= suspendedLanes;
        root3.pingedLanes &= ~suspendedLanes;
        var expirationTimes = root3.expirationTimes;
        var lanes = suspendedLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          expirationTimes[index2] = NoTimestamp;
          lanes &= ~lane;
        }
      }
      function markRootPinged(root3, pingedLanes, eventTime) {
        root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
      }
      function markRootFinished(root3, remainingLanes) {
        var noLongerPendingLanes = root3.pendingLanes & ~remainingLanes;
        root3.pendingLanes = remainingLanes;
        root3.suspendedLanes = NoLanes;
        root3.pingedLanes = NoLanes;
        root3.expiredLanes &= remainingLanes;
        root3.mutableReadLanes &= remainingLanes;
        root3.entangledLanes &= remainingLanes;
        var entanglements = root3.entanglements;
        var eventTimes = root3.eventTimes;
        var expirationTimes = root3.expirationTimes;
        var lanes = noLongerPendingLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          entanglements[index2] = NoLanes;
          eventTimes[index2] = NoTimestamp;
          expirationTimes[index2] = NoTimestamp;
          lanes &= ~lane;
        }
      }
      function markRootEntangled(root3, entangledLanes) {
        var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
        var entanglements = root3.entanglements;
        var lanes = rootEntangledLanes;
        while (lanes) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          if (
            // Is this one of the newly entangled lanes?
            lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
            entanglements[index2] & entangledLanes
          ) {
            entanglements[index2] |= entangledLanes;
          }
          lanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root3, renderLanes2) {
        var renderLane = getHighestPriorityLane(renderLanes2);
        var lane;
        switch (renderLane) {
          case InputContinuousLane:
            lane = InputContinuousHydrationLane;
            break;
          case DefaultLane:
            lane = DefaultHydrationLane;
            break;
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            lane = TransitionHydrationLane;
            break;
          case IdleLane:
            lane = IdleHydrationLane;
            break;
          default:
            lane = NoLane;
            break;
        }
        if ((lane & (root3.suspendedLanes | renderLanes2)) !== NoLane) {
          return NoLane;
        }
        return lane;
      }
      function addFiberToLanesMap(root3, fiber, lanes) {
        if (!isDevToolsPresent) {
          return;
        }
        var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
        while (lanes > 0) {
          var index2 = laneToIndex(lanes);
          var lane = 1 << index2;
          var updaters = pendingUpdatersLaneMap[index2];
          updaters.add(fiber);
          lanes &= ~lane;
        }
      }
      function movePendingFibersToMemoized(root3, lanes) {
        if (!isDevToolsPresent) {
          return;
        }
        var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
        var memoizedUpdaters = root3.memoizedUpdaters;
        while (lanes > 0) {
          var index2 = laneToIndex(lanes);
          var lane = 1 << index2;
          var updaters = pendingUpdatersLaneMap[index2];
          if (updaters.size > 0) {
            updaters.forEach(function(fiber) {
              var alternate = fiber.alternate;
              if (alternate === null || !memoizedUpdaters.has(alternate)) {
                memoizedUpdaters.add(fiber);
              }
            });
            updaters.clear();
          }
          lanes &= ~lane;
        }
      }
      function getTransitionsForLanes(root3, lanes) {
        {
          return null;
        }
      }
      var DiscreteEventPriority = SyncLane;
      var ContinuousEventPriority = InputContinuousLane;
      var DefaultEventPriority = DefaultLane;
      var IdleEventPriority = IdleLane;
      var currentUpdatePriority = NoLane;
      function getCurrentUpdatePriority() {
        return currentUpdatePriority;
      }
      function setCurrentUpdatePriority(newPriority) {
        currentUpdatePriority = newPriority;
      }
      function runWithPriority(priority, fn) {
        var previousPriority = currentUpdatePriority;
        try {
          currentUpdatePriority = priority;
          return fn();
        } finally {
          currentUpdatePriority = previousPriority;
        }
      }
      function higherEventPriority(a, b) {
        return a !== 0 && a < b ? a : b;
      }
      function lowerEventPriority(a, b) {
        return a > b ? a : b;
      }
      function isHigherEventPriority(a, b) {
        return a !== 0 && a < b;
      }
      function lanesToEventPriority(lanes) {
        var lane = getHighestPriorityLane(lanes);
        if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
          return DiscreteEventPriority;
        }
        if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
          return ContinuousEventPriority;
        }
        if (includesNonIdleWork(lane)) {
          return DefaultEventPriority;
        }
        return IdleEventPriority;
      }
      function isRootDehydrated(root3) {
        var currentState = root3.current.memoizedState;
        return currentState.isDehydrated;
      }
      var _attemptSynchronousHydration;
      function setAttemptSynchronousHydration(fn) {
        _attemptSynchronousHydration = fn;
      }
      function attemptSynchronousHydration(fiber) {
        _attemptSynchronousHydration(fiber);
      }
      var attemptContinuousHydration;
      function setAttemptContinuousHydration(fn) {
        attemptContinuousHydration = fn;
      }
      var attemptHydrationAtCurrentPriority;
      function setAttemptHydrationAtCurrentPriority(fn) {
        attemptHydrationAtCurrentPriority = fn;
      }
      var getCurrentUpdatePriority$1;
      function setGetCurrentUpdatePriority(fn) {
        getCurrentUpdatePriority$1 = fn;
      }
      var attemptHydrationAtPriority;
      function setAttemptHydrationAtPriority(fn) {
        attemptHydrationAtPriority = fn;
      }
      var hasScheduledReplayAttempt = false;
      var queuedDiscreteEvents = [];
      var queuedFocus = null;
      var queuedDrag = null;
      var queuedMouse = null;
      var queuedPointers = /* @__PURE__ */ new Map();
      var queuedPointerCaptures = /* @__PURE__ */ new Map();
      var queuedExplicitHydrationTargets = [];
      var discreteReplayableEvents = [
        "mousedown",
        "mouseup",
        "touchcancel",
        "touchend",
        "touchstart",
        "auxclick",
        "dblclick",
        "pointercancel",
        "pointerdown",
        "pointerup",
        "dragend",
        "dragstart",
        "drop",
        "compositionend",
        "compositionstart",
        "keydown",
        "keypress",
        "keyup",
        "input",
        "textInput",
        // Intentionally camelCase
        "copy",
        "cut",
        "paste",
        "click",
        "change",
        "contextmenu",
        "reset",
        "submit"
      ];
      function isDiscreteEventThatRequiresHydration(eventType) {
        return discreteReplayableEvents.indexOf(eventType) > -1;
      }
      function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        };
      }
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout": {
            var pointerId = nativeEvent.pointerId;
            queuedPointers.delete(pointerId);
            break;
          }
          case "gotpointercapture":
          case "lostpointercapture": {
            var _pointerId = nativeEvent.pointerId;
            queuedPointerCaptures.delete(_pointerId);
            break;
          }
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
          var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn !== null) {
            var _fiber2 = getInstanceFromNode(blockedOn);
            if (_fiber2 !== null) {
              attemptContinuousHydration(_fiber2);
            }
          }
          return queuedEvent;
        }
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        var targetContainers = existingQueuedEvent.targetContainers;
        if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
          targetContainers.push(targetContainer);
        }
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin": {
            var focusEvent = nativeEvent;
            queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
            return true;
          }
          case "dragenter": {
            var dragEvent = nativeEvent;
            queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
            return true;
          }
          case "mouseover": {
            var mouseEvent = nativeEvent;
            queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
            return true;
          }
          case "pointerover": {
            var pointerEvent = nativeEvent;
            var pointerId = pointerEvent.pointerId;
            queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
            return true;
          }
          case "gotpointercapture": {
            var _pointerEvent = nativeEvent;
            var _pointerId2 = _pointerEvent.pointerId;
            queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
            return true;
          }
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (targetInst !== null) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (nearestMounted !== null) {
            var tag = nearestMounted.tag;
            if (tag === SuspenseComponent) {
              var instance = getSuspenseInstanceFromFiber(nearestMounted);
              if (instance !== null) {
                queuedTarget.blockedOn = instance;
                attemptHydrationAtPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (tag === HostRoot) {
              var root3 = nearestMounted.stateNode;
              if (isRootDehydrated(root3)) {
                queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                return;
              }
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function queueExplicitHydrationTarget(target2) {
        var updatePriority = getCurrentUpdatePriority$1();
        var queuedTarget = {
          blockedOn: null,
          target: target2,
          priority: updatePriority
        };
        var i2 = 0;
        for (; i2 < queuedExplicitHydrationTargets.length; i2++) {
          if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i2].priority)) {
            break;
          }
        }
        queuedExplicitHydrationTargets.splice(i2, 0, queuedTarget);
        if (i2 === 0) {
          attemptExplicitHydrationTarget(queuedTarget);
        }
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (queuedEvent.blockedOn !== null) {
          return false;
        }
        var targetContainers = queuedEvent.targetContainers;
        while (targetContainers.length > 0) {
          var targetContainer = targetContainers[0];
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
          if (nextBlockedOn === null) {
            {
              var nativeEvent = queuedEvent.nativeEvent;
              var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
              setReplayingEvent(nativeEventClone);
              nativeEvent.target.dispatchEvent(nativeEventClone);
              resetReplayingEvent();
            }
          } else {
            var _fiber3 = getInstanceFromNode(nextBlockedOn);
            if (_fiber3 !== null) {
              attemptContinuousHydration(_fiber3);
            }
            queuedEvent.blockedOn = nextBlockedOn;
            return false;
          }
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key2, map2) {
        if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
          map2.delete(key2);
        }
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
          queuedFocus = null;
        }
        if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
          queuedDrag = null;
        }
        if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
          queuedMouse = null;
        }
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        if (queuedEvent.blockedOn === unblocked) {
          queuedEvent.blockedOn = null;
          if (!hasScheduledReplayAttempt) {
            hasScheduledReplayAttempt = true;
            Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
          }
        }
      }
      function retryIfBlockedOn(unblocked) {
        if (queuedDiscreteEvents.length > 0) {
          scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
          for (var i2 = 1; i2 < queuedDiscreteEvents.length; i2++) {
            var queuedEvent = queuedDiscreteEvents[i2];
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
            }
          }
        }
        if (queuedFocus !== null) {
          scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        }
        if (queuedDrag !== null) {
          scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        }
        if (queuedMouse !== null) {
          scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        }
        var unblock = function(queuedEvent2) {
          return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
        };
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
          var queuedTarget = queuedExplicitHydrationTargets[_i];
          if (queuedTarget.blockedOn === unblocked) {
            queuedTarget.blockedOn = null;
          }
        }
        while (queuedExplicitHydrationTargets.length > 0) {
          var nextExplicitTarget = queuedExplicitHydrationTargets[0];
          if (nextExplicitTarget.blockedOn !== null) {
            break;
          } else {
            attemptExplicitHydrationTarget(nextExplicitTarget);
            if (nextExplicitTarget.blockedOn === null) {
              queuedExplicitHydrationTargets.shift();
            }
          }
        }
      }
      var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
      var _enabled = true;
      function setEnabled(enabled) {
        _enabled = !!enabled;
      }
      function isEnabled() {
        return _enabled;
      }
      function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
        var eventPriority = getEventPriority(domEventName);
        var listenerWrapper;
        switch (eventPriority) {
          case DiscreteEventPriority:
            listenerWrapper = dispatchDiscreteEvent;
            break;
          case ContinuousEventPriority:
            listenerWrapper = dispatchContinuousEvent;
            break;
          case DefaultEventPriority:
          default:
            listenerWrapper = dispatchEvent;
            break;
        }
        return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
      }
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = null;
        try {
          setCurrentUpdatePriority(DiscreteEventPriority);
          dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig.transition = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = null;
        try {
          setCurrentUpdatePriority(ContinuousEventPriority);
          dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig.transition = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (!_enabled) {
          return;
        }
        {
          dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
        }
      }
      function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
        if (blockedOn === null) {
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
          clearIfContinuousEvent(domEventName, nativeEvent);
          return;
        }
        if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
          nativeEvent.stopPropagation();
          return;
        }
        clearIfContinuousEvent(domEventName, nativeEvent);
        if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
          while (blockedOn !== null) {
            var fiber = getInstanceFromNode(blockedOn);
            if (fiber !== null) {
              attemptSynchronousHydration(fiber);
            }
            var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (nextBlockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            }
            if (nextBlockedOn === blockedOn) {
              break;
            }
            blockedOn = nextBlockedOn;
          }
          if (blockedOn !== null) {
            nativeEvent.stopPropagation();
          }
          return;
        }
        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
      }
      var return_targetInst = null;
      function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return_targetInst = null;
        var nativeEventTarget = getEventTarget(nativeEvent);
        var targetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (targetInst !== null) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (nearestMounted === null) {
            targetInst = null;
          } else {
            var tag = nearestMounted.tag;
            if (tag === SuspenseComponent) {
              var instance = getSuspenseInstanceFromFiber(nearestMounted);
              if (instance !== null) {
                return instance;
              }
              targetInst = null;
            } else if (tag === HostRoot) {
              var root3 = nearestMounted.stateNode;
              if (isRootDehydrated(root3)) {
                return getContainerFromFiber(nearestMounted);
              }
              targetInst = null;
            } else if (nearestMounted !== targetInst) {
              targetInst = null;
            }
          }
        }
        return_targetInst = targetInst;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return DiscreteEventPriority;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return ContinuousEventPriority;
          case "message": {
            var schedulerPriority = getCurrentPriorityLevel();
            switch (schedulerPriority) {
              case ImmediatePriority:
                return DiscreteEventPriority;
              case UserBlockingPriority:
                return ContinuousEventPriority;
              case NormalPriority:
              case LowPriority:
                return DefaultEventPriority;
              case IdlePriority:
                return IdleEventPriority;
              default:
                return DefaultEventPriority;
            }
          }
          default:
            return DefaultEventPriority;
        }
      }
      function addEventBubbleListener(target2, eventType, listener) {
        target2.addEventListener(eventType, listener, false);
        return listener;
      }
      function addEventCaptureListener(target2, eventType, listener) {
        target2.addEventListener(eventType, listener, true);
        return listener;
      }
      function addEventCaptureListenerWithPassiveFlag(target2, eventType, listener, passive) {
        target2.addEventListener(eventType, listener, {
          capture: true,
          passive
        });
        return listener;
      }
      function addEventBubbleListenerWithPassiveFlag(target2, eventType, listener, passive) {
        target2.addEventListener(eventType, listener, {
          passive
        });
        return listener;
      }
      var root2 = null;
      var startText = null;
      var fallbackText = null;
      function initialize(nativeEventTarget) {
        root2 = nativeEventTarget;
        startText = getText2();
        return true;
      }
      function reset() {
        root2 = null;
        startText = null;
        fallbackText = null;
      }
      function getData() {
        if (fallbackText) {
          return fallbackText;
        }
        var start;
        var startValue = startText;
        var startLength = startValue.length;
        var end;
        var endValue = getText2();
        var endLength = endValue.length;
        for (start = 0; start < startLength; start++) {
          if (startValue[start] !== endValue[start]) {
            break;
          }
        }
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd; end++) {
          if (startValue[startLength - end] !== endValue[endLength - end]) {
            break;
          }
        }
        var sliceTail = end > 1 ? 1 - end : void 0;
        fallbackText = endValue.slice(start, sliceTail);
        return fallbackText;
      }
      function getText2() {
        if ("value" in root2) {
          return root2.value;
        }
        return root2.textContent;
      }
      function getEventCharCode(nativeEvent) {
        var charCode;
        var keyCode = nativeEvent.keyCode;
        if ("charCode" in nativeEvent) {
          charCode = nativeEvent.charCode;
          if (charCode === 0 && keyCode === 13) {
            charCode = 13;
          }
        } else {
          charCode = keyCode;
        }
        if (charCode === 10) {
          charCode = 13;
        }
        if (charCode >= 32 || charCode === 13) {
          return charCode;
        }
        return 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var _propName in Interface) {
            if (!Interface.hasOwnProperty(_propName)) {
              continue;
            }
            var normalize3 = Interface[_propName];
            if (normalize3) {
              this[_propName] = normalize3(nativeEvent);
            } else {
              this[_propName] = nativeEvent[_propName];
            }
          }
          var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
          if (defaultPrevented) {
            this.isDefaultPrevented = functionThatReturnsTrue;
          } else {
            this.isDefaultPrevented = functionThatReturnsFalse;
          }
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign2(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event2 = this.nativeEvent;
            if (!event2) {
              return;
            }
            if (event2.preventDefault) {
              event2.preventDefault();
            } else if (typeof event2.returnValue !== "unknown") {
              event2.returnValue = false;
            }
            this.isDefaultPrevented = functionThatReturnsTrue;
          },
          stopPropagation: function() {
            var event2 = this.nativeEvent;
            if (!event2) {
              return;
            }
            if (event2.stopPropagation) {
              event2.stopPropagation();
            } else if (typeof event2.cancelBubble !== "unknown") {
              event2.cancelBubble = true;
            }
            this.isPropagationStopped = functionThatReturnsTrue;
          },
          /**
           * We release all dispatched `SyntheticEvent`s after each event loop, adding
           * them back into the pool. This allows a way to hold onto a reference that
           * won't be added back into the pool.
           */
          persist: function() {
          },
          /**
           * Checks if this event should be released back into the pool.
           *
           * @return {boolean} True if this should not be released, false otherwise.
           */
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event2) {
          return event2.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      };
      var SyntheticEvent = createSyntheticEvent(EventInterface);
      var UIEventInterface = assign2({}, EventInterface, {
        view: 0,
        detail: 0
      });
      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
      var lastMovementX;
      var lastMovementY;
      var lastMouseEvent;
      function updateMouseMovementPolyfillState(event2) {
        if (event2 !== lastMouseEvent) {
          if (lastMouseEvent && event2.type === "mousemove") {
            lastMovementX = event2.screenX - lastMouseEvent.screenX;
            lastMovementY = event2.screenY - lastMouseEvent.screenY;
          } else {
            lastMovementX = 0;
            lastMovementY = 0;
          }
          lastMouseEvent = event2;
        }
      }
      var MouseEventInterface = assign2({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event2) {
          if (event2.relatedTarget === void 0) return event2.fromElement === event2.srcElement ? event2.toElement : event2.fromElement;
          return event2.relatedTarget;
        },
        movementX: function(event2) {
          if ("movementX" in event2) {
            return event2.movementX;
          }
          updateMouseMovementPolyfillState(event2);
          return lastMovementX;
        },
        movementY: function(event2) {
          if ("movementY" in event2) {
            return event2.movementY;
          }
          return lastMovementY;
        }
      });
      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
      var DragEventInterface = assign2({}, MouseEventInterface, {
        dataTransfer: 0
      });
      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
      var FocusEventInterface = assign2({}, UIEventInterface, {
        relatedTarget: 0
      });
      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
      var AnimationEventInterface = assign2({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
      var ClipboardEventInterface = assign2({}, EventInterface, {
        clipboardData: function(event2) {
          return "clipboardData" in event2 ? event2.clipboardData : window.clipboardData;
        }
      });
      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
      var CompositionEventInterface = assign2({}, EventInterface, {
        data: 0
      });
      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
      var SyntheticInputEvent = SyntheticCompositionEvent;
      var normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var translateToKey = {
        "8": "Backspace",
        "9": "Tab",
        "12": "Clear",
        "13": "Enter",
        "16": "Shift",
        "17": "Control",
        "18": "Alt",
        "19": "Pause",
        "20": "CapsLock",
        "27": "Escape",
        "32": " ",
        "33": "PageUp",
        "34": "PageDown",
        "35": "End",
        "36": "Home",
        "37": "ArrowLeft",
        "38": "ArrowUp",
        "39": "ArrowRight",
        "40": "ArrowDown",
        "45": "Insert",
        "46": "Delete",
        "112": "F1",
        "113": "F2",
        "114": "F3",
        "115": "F4",
        "116": "F5",
        "117": "F6",
        "118": "F7",
        "119": "F8",
        "120": "F9",
        "121": "F10",
        "122": "F11",
        "123": "F12",
        "144": "NumLock",
        "145": "ScrollLock",
        "224": "Meta"
      };
      function getEventKey(nativeEvent) {
        if (nativeEvent.key) {
          var key2 = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if (key2 !== "Unidentified") {
            return key2;
          }
        }
        if (nativeEvent.type === "keypress") {
          var charCode = getEventCharCode(nativeEvent);
          return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
        }
        if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
          return translateToKey[nativeEvent.keyCode] || "Unidentified";
        }
        return "";
      }
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var syntheticEvent = this;
        var nativeEvent = syntheticEvent.nativeEvent;
        if (nativeEvent.getModifierState) {
          return nativeEvent.getModifierState(keyArg);
        }
        var keyProp = modifierKeyToProp[keyArg];
        return keyProp ? !!nativeEvent[keyProp] : false;
      }
      function getEventModifierState(nativeEvent) {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign2({}, UIEventInterface, {
        key: getEventKey,
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        // Legacy Interface
        charCode: function(event2) {
          if (event2.type === "keypress") {
            return getEventCharCode(event2);
          }
          return 0;
        },
        keyCode: function(event2) {
          if (event2.type === "keydown" || event2.type === "keyup") {
            return event2.keyCode;
          }
          return 0;
        },
        which: function(event2) {
          if (event2.type === "keypress") {
            return getEventCharCode(event2);
          }
          if (event2.type === "keydown" || event2.type === "keyup") {
            return event2.keyCode;
          }
          return 0;
        }
      });
      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
      var PointerEventInterface = assign2({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      });
      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
      var TouchEventInterface = assign2({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      });
      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
      var TransitionEventInterface = assign2({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
      var WheelEventInterface = assign2({}, MouseEventInterface, {
        deltaX: function(event2) {
          return "deltaX" in event2 ? event2.deltaX : (
            // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
            "wheelDeltaX" in event2 ? -event2.wheelDeltaX : 0
          );
        },
        deltaY: function(event2) {
          return "deltaY" in event2 ? event2.deltaY : (
            // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
            "wheelDeltaY" in event2 ? -event2.wheelDeltaY : (
              // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
              "wheelDelta" in event2 ? -event2.wheelDelta : 0
            )
          );
        },
        deltaZ: 0,
        // Browsers without "deltaMode" is reporting in raw wheel delta where one
        // notch on the scroll is always +/- 120, roughly equivalent to pixels.
        // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
        // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
        deltaMode: 0
      });
      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
      var END_KEYCODES = [9, 13, 27, 32];
      var START_KEYCODE = 229;
      var canUseCompositionEvent = canUseDOM2 && "CompositionEvent" in window;
      var documentMode = null;
      if (canUseDOM2 && "documentMode" in document) {
        documentMode = document.documentMode;
      }
      var canUseTextInputEvent = canUseDOM2 && "TextEvent" in window && !documentMode;
      var useFallbackCompositionData = canUseDOM2 && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
      var SPACEBAR_CODE = 32;
      var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
      function registerEvents() {
        registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
        registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
      }
      var hasSpaceKeypress = false;
      function isKeypressCommand(nativeEvent) {
        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
        !(nativeEvent.ctrlKey && nativeEvent.altKey);
      }
      function getCompositionEventType(domEventName) {
        switch (domEventName) {
          case "compositionstart":
            return "onCompositionStart";
          case "compositionend":
            return "onCompositionEnd";
          case "compositionupdate":
            return "onCompositionUpdate";
        }
      }
      function isFallbackCompositionStart(domEventName, nativeEvent) {
        return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
      }
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
          case "keydown":
            return nativeEvent.keyCode !== START_KEYCODE;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        var detail = nativeEvent.detail;
        if (typeof detail === "object" && "data" in detail) {
          return detail.data;
        }
        return null;
      }
      function isUsingKoreanIME(nativeEvent) {
        return nativeEvent.locale === "ko";
      }
      var isComposing = false;
      function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var eventType;
        var fallbackData;
        if (canUseCompositionEvent) {
          eventType = getCompositionEventType(domEventName);
        } else if (!isComposing) {
          if (isFallbackCompositionStart(domEventName, nativeEvent)) {
            eventType = "onCompositionStart";
          }
        } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
          eventType = "onCompositionEnd";
        }
        if (!eventType) {
          return null;
        }
        if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
          if (!isComposing && eventType === "onCompositionStart") {
            isComposing = initialize(nativeEventTarget);
          } else if (eventType === "onCompositionEnd") {
            if (isComposing) {
              fallbackData = getData();
            }
          }
        }
        var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
        if (listeners.length > 0) {
          var event2 = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
          dispatchQueue.push({
            event: event2,
            listeners
          });
          if (fallbackData) {
            event2.data = fallbackData;
          } else {
            var customData = getDataFromCustomEvent(nativeEvent);
            if (customData !== null) {
              event2.data = customData;
            }
          }
        }
      }
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            var which = nativeEvent.which;
            if (which !== SPACEBAR_CODE) {
              return null;
            }
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            var chars = nativeEvent.data;
            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
              return null;
            }
            return chars;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing) {
          if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
            var chars = getData();
            reset();
            isComposing = false;
            return chars;
          }
          return null;
        }
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!isKeypressCommand(nativeEvent)) {
              if (nativeEvent.char && nativeEvent.char.length > 1) {
                return nativeEvent.char;
              } else if (nativeEvent.which) {
                return String.fromCharCode(nativeEvent.which);
              }
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var chars;
        if (canUseTextInputEvent) {
          chars = getNativeBeforeInputChars(domEventName, nativeEvent);
        } else {
          chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
        }
        if (!chars) {
          return null;
        }
        var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
        if (listeners.length > 0) {
          var event2 = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
          dispatchQueue.push({
            event: event2,
            listeners
          });
          event2.data = chars;
        }
      }
      function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        if (nodeName === "input") {
          return !!supportedInputTypes[elem.type];
        }
        if (nodeName === "textarea") {
          return true;
        }
        return false;
      }
      /**
       * Checks if an event is supported in the current execution environment.
       *
       * NOTE: This will not work correctly for non-generic events such as `change`,
       * `reset`, `load`, `error`, and `select`.
       *
       * Borrows from Modernizr.
       *
       * @param {string} eventNameSuffix Event name, e.g. "click".
       * @return {boolean} True if the event is supported.
       * @internal
       * @license Modernizr 3.0.0pre (Custom Build) | MIT
       */
      function isEventSupported(eventNameSuffix) {
        if (!canUseDOM2) {
          return false;
        }
        var eventName = "on" + eventNameSuffix;
        var isSupported = eventName in document;
        if (!isSupported) {
          var element = document.createElement("div");
          element.setAttribute(eventName, "return;");
          isSupported = typeof element[eventName] === "function";
        }
        return isSupported;
      }
      function registerEvents$1() {
        registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target2) {
        enqueueStateRestore(target2);
        var listeners = accumulateTwoPhaseListeners(inst, "onChange");
        if (listeners.length > 0) {
          var event2 = new SyntheticEvent("onChange", "change", null, nativeEvent, target2);
          dispatchQueue.push({
            event: event2,
            listeners
          });
        }
      }
      var activeElement = null;
      var activeElementInst = null;
      function shouldUseChangeEvent(elem) {
        var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName === "select" || nodeName === "input" && elem.type === "file";
      }
      function manualDispatchChangeEvent(nativeEvent) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
        batchedUpdates(runEventInBatch, dispatchQueue);
      }
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) {
          return targetInst;
        }
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if (domEventName === "change") {
          return targetInst;
        }
      }
      var isInputEventSupported = false;
      if (canUseDOM2) {
        isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
      }
      function startWatchingForValueChange(target2, targetInst) {
        activeElement = target2;
        activeElementInst = targetInst;
        activeElement.attachEvent("onpropertychange", handlePropertyChange);
      }
      function stopWatchingForValueChange() {
        if (!activeElement) {
          return;
        }
        activeElement.detachEvent("onpropertychange", handlePropertyChange);
        activeElement = null;
        activeElementInst = null;
      }
      function handlePropertyChange(nativeEvent) {
        if (nativeEvent.propertyName !== "value") {
          return;
        }
        if (getInstIfValueChanged(activeElementInst)) {
          manualDispatchChangeEvent(nativeEvent);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target2, targetInst) {
        if (domEventName === "focusin") {
          stopWatchingForValueChange();
          startWatchingForValueChange(target2, targetInst);
        } else if (domEventName === "focusout") {
          stopWatchingForValueChange();
        }
      }
      function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
        if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
          return getInstIfValueChanged(activeElementInst);
        }
      }
      function shouldUseClickEvent(elem) {
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if (domEventName === "click") {
          return getInstIfValueChanged(targetInst);
        }
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if (domEventName === "input" || domEventName === "change") {
          return getInstIfValueChanged(targetInst);
        }
      }
      function handleControlledInputBlur(node2) {
        var state = node2._wrapperState;
        if (!state || !state.controlled || node2.type !== "number") {
          return;
        }
        {
          setDefaultValue(node2, "number", node2.value);
        }
      }
      function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        var getTargetInstFunc, handleEventFunc;
        if (shouldUseChangeEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForChangeEvent;
        } else if (isTextInputElement(targetNode)) {
          if (isInputEventSupported) {
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          } else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            handleEventFunc = handleEventsForInputEventPolyfill;
          }
        } else if (shouldUseClickEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForClickEvent;
        }
        if (getTargetInstFunc) {
          var inst = getTargetInstFunc(domEventName, targetInst);
          if (inst) {
            createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
            return;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(domEventName, targetNode, targetInst);
        }
        if (domEventName === "focusout") {
          handleControlledInputBlur(targetNode);
        }
      }
      function registerEvents$2() {
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      }
      function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
        var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
        if (isOverEvent && !isReplayingEvent(nativeEvent)) {
          var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
          if (related) {
            if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
              return;
            }
          }
        }
        if (!isOutEvent && !isOverEvent) {
          return;
        }
        var win;
        if (nativeEventTarget.window === nativeEventTarget) {
          win = nativeEventTarget;
        } else {
          var doc2 = nativeEventTarget.ownerDocument;
          if (doc2) {
            win = doc2.defaultView || doc2.parentWindow;
          } else {
            win = window;
          }
        }
        var from2;
        var to;
        if (isOutEvent) {
          var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
          from2 = targetInst;
          to = _related ? getClosestInstanceFromNode(_related) : null;
          if (to !== null) {
            var nearestMounted = getNearestMountedFiber(to);
            if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
              to = null;
            }
          }
        } else {
          from2 = null;
          to = targetInst;
        }
        if (from2 === to) {
          return;
        }
        var SyntheticEventCtor = SyntheticMouseEvent;
        var leaveEventType = "onMouseLeave";
        var enterEventType = "onMouseEnter";
        var eventTypePrefix = "mouse";
        if (domEventName === "pointerout" || domEventName === "pointerover") {
          SyntheticEventCtor = SyntheticPointerEvent;
          leaveEventType = "onPointerLeave";
          enterEventType = "onPointerEnter";
          eventTypePrefix = "pointer";
        }
        var fromNode = from2 == null ? win : getNodeFromInstance(from2);
        var toNode = to == null ? win : getNodeFromInstance(to);
        var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from2, nativeEvent, nativeEventTarget);
        leave.target = fromNode;
        leave.relatedTarget = toNode;
        var enter = null;
        var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (nativeTargetInst === targetInst) {
          var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
          enterEvent.target = toNode;
          enterEvent.relatedTarget = fromNode;
          enter = enterEvent;
        }
        accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from2, to);
      }
      function is(x2, y) {
        return x2 === y && (x2 !== 0 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) {
          return true;
        }
        if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
          return false;
        }
        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) {
          return false;
        }
        for (var i2 = 0; i2 < keysA.length; i2++) {
          var currentKey = keysA[i2];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
            return false;
          }
        }
        return true;
      }
      function getLeafNode(node2) {
        while (node2 && node2.firstChild) {
          node2 = node2.firstChild;
        }
        return node2;
      }
      function getSiblingNode(node2) {
        while (node2) {
          if (node2.nextSibling) {
            return node2.nextSibling;
          }
          node2 = node2.parentNode;
        }
      }
      function getNodeForCharacterOffset(root3, offset) {
        var node2 = getLeafNode(root3);
        var nodeStart = 0;
        var nodeEnd = 0;
        while (node2) {
          if (node2.nodeType === TEXT_NODE) {
            nodeEnd = nodeStart + node2.textContent.length;
            if (nodeStart <= offset && nodeEnd >= offset) {
              return {
                node: node2,
                offset: offset - nodeStart
              };
            }
            nodeStart = nodeEnd;
          }
          node2 = getLeafNode(getSiblingNode(node2));
        }
      }
      function getOffsets(outerNode) {
        var ownerDocument = outerNode.ownerDocument;
        var win = ownerDocument && ownerDocument.defaultView || window;
        var selection = win.getSelection && win.getSelection();
        if (!selection || selection.rangeCount === 0) {
          return null;
        }
        var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
        try {
          anchorNode.nodeType;
          focusNode.nodeType;
        } catch (e) {
          return null;
        }
        return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
      }
      function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
        var length2 = 0;
        var start = -1;
        var end = -1;
        var indexWithinAnchor = 0;
        var indexWithinFocus = 0;
        var node2 = outerNode;
        var parentNode = null;
        outer: while (true) {
          var next = null;
          while (true) {
            if (node2 === anchorNode && (anchorOffset === 0 || node2.nodeType === TEXT_NODE)) {
              start = length2 + anchorOffset;
            }
            if (node2 === focusNode && (focusOffset === 0 || node2.nodeType === TEXT_NODE)) {
              end = length2 + focusOffset;
            }
            if (node2.nodeType === TEXT_NODE) {
              length2 += node2.nodeValue.length;
            }
            if ((next = node2.firstChild) === null) {
              break;
            }
            parentNode = node2;
            node2 = next;
          }
          while (true) {
            if (node2 === outerNode) {
              break outer;
            }
            if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
              start = length2;
            }
            if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
              end = length2;
            }
            if ((next = node2.nextSibling) !== null) {
              break;
            }
            node2 = parentNode;
            parentNode = node2.parentNode;
          }
          node2 = next;
        }
        if (start === -1 || end === -1) {
          return null;
        }
        return {
          start,
          end
        };
      }
      function setOffsets(node2, offsets) {
        var doc2 = node2.ownerDocument || document;
        var win = doc2 && doc2.defaultView || window;
        if (!win.getSelection) {
          return;
        }
        var selection = win.getSelection();
        var length2 = node2.textContent.length;
        var start = Math.min(offsets.start, length2);
        var end = offsets.end === void 0 ? start : Math.min(offsets.end, length2);
        if (!selection.extend && start > end) {
          var temp = end;
          end = start;
          start = temp;
        }
        var startMarker = getNodeForCharacterOffset(node2, start);
        var endMarker = getNodeForCharacterOffset(node2, end);
        if (startMarker && endMarker) {
          if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
            return;
          }
          var range2 = doc2.createRange();
          range2.setStart(startMarker.node, startMarker.offset);
          selection.removeAllRanges();
          if (start > end) {
            selection.addRange(range2);
            selection.extend(endMarker.node, endMarker.offset);
          } else {
            range2.setEnd(endMarker.node, endMarker.offset);
            selection.addRange(range2);
          }
        }
      }
      function isTextNode(node2) {
        return node2 && node2.nodeType === TEXT_NODE;
      }
      function containsNode(outerNode, innerNode) {
        if (!outerNode || !innerNode) {
          return false;
        } else if (outerNode === innerNode) {
          return true;
        } else if (isTextNode(outerNode)) {
          return false;
        } else if (isTextNode(innerNode)) {
          return containsNode(outerNode, innerNode.parentNode);
        } else if ("contains" in outerNode) {
          return outerNode.contains(innerNode);
        } else if (outerNode.compareDocumentPosition) {
          return !!(outerNode.compareDocumentPosition(innerNode) & 16);
        } else {
          return false;
        }
      }
      function isInDocument(node2) {
        return node2 && node2.ownerDocument && containsNode(node2.ownerDocument.documentElement, node2);
      }
      function isSameOriginFrame(iframe) {
        try {
          return typeof iframe.contentWindow.location.href === "string";
        } catch (err) {
          return false;
        }
      }
      function getActiveElementDeep() {
        var win = window;
        var element = getActiveElement();
        while (element instanceof win.HTMLIFrameElement) {
          if (isSameOriginFrame(element)) {
            win = element.contentWindow;
          } else {
            return element;
          }
          element = getActiveElement(win.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
      }
      function getSelectionInformation() {
        var focusedElem = getActiveElementDeep();
        return {
          focusedElem,
          selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection2(focusedElem) : null
        };
      }
      function restoreSelection(priorSelectionInformation) {
        var curFocusedElem = getActiveElementDeep();
        var priorFocusedElem = priorSelectionInformation.focusedElem;
        var priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
          if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
            setSelection(priorFocusedElem, priorSelectionRange);
          }
          var ancestors = [];
          var ancestor = priorFocusedElem;
          while (ancestor = ancestor.parentNode) {
            if (ancestor.nodeType === ELEMENT_NODE) {
              ancestors.push({
                element: ancestor,
                left: ancestor.scrollLeft,
                top: ancestor.scrollTop
              });
            }
          }
          if (typeof priorFocusedElem.focus === "function") {
            priorFocusedElem.focus();
          }
          for (var i2 = 0; i2 < ancestors.length; i2++) {
            var info = ancestors[i2];
            info.element.scrollLeft = info.left;
            info.element.scrollTop = info.top;
          }
        }
      }
      function getSelection2(input2) {
        var selection;
        if ("selectionStart" in input2) {
          selection = {
            start: input2.selectionStart,
            end: input2.selectionEnd
          };
        } else {
          selection = getOffsets(input2);
        }
        return selection || {
          start: 0,
          end: 0
        };
      }
      function setSelection(input2, offsets) {
        var start = offsets.start;
        var end = offsets.end;
        if (end === void 0) {
          end = start;
        }
        if ("selectionStart" in input2) {
          input2.selectionStart = start;
          input2.selectionEnd = Math.min(end, input2.value.length);
        } else {
          setOffsets(input2, offsets);
        }
      }
      var skipSelectionChangeEvent = canUseDOM2 && "documentMode" in document && document.documentMode <= 11;
      function registerEvents$3() {
        registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
      }
      var activeElement$1 = null;
      var activeElementInst$1 = null;
      var lastSelection = null;
      var mouseDown = false;
      function getSelection$1(node2) {
        if ("selectionStart" in node2 && hasSelectionCapabilities(node2)) {
          return {
            start: node2.selectionStart,
            end: node2.selectionEnd
          };
        } else {
          var win = node2.ownerDocument && node2.ownerDocument.defaultView || window;
          var selection = win.getSelection();
          return {
            anchorNode: selection.anchorNode,
            anchorOffset: selection.anchorOffset,
            focusNode: selection.focusNode,
            focusOffset: selection.focusOffset
          };
        }
      }
      function getEventTargetDocument(eventTarget) {
        return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
      }
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc2 = getEventTargetDocument(nativeEventTarget);
        if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc2)) {
          return;
        }
        var currentSelection = getSelection$1(activeElement$1);
        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
          lastSelection = currentSelection;
          var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
          if (listeners.length > 0) {
            var event2 = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event: event2,
              listeners
            });
            event2.target = activeElement$1;
          }
        }
      }
      function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        switch (domEventName) {
          case "focusin":
            if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
              activeElement$1 = targetNode;
              activeElementInst$1 = targetInst;
              lastSelection = null;
            }
            break;
          case "focusout":
            activeElement$1 = null;
            activeElementInst$1 = null;
            lastSelection = null;
            break;
          case "mousedown":
            mouseDown = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            mouseDown = false;
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            break;
          case "selectionchange":
            if (skipSelectionChangeEvent) {
              break;
            }
          case "keydown":
          case "keyup":
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes2 = {};
        prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes2["Webkit" + styleProp] = "webkit" + eventName;
        prefixes2["Moz" + styleProp] = "moz" + eventName;
        return prefixes2;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      var prefixedEventNames = {};
      var style2 = {};
      if (canUseDOM2) {
        style2 = document.createElement("div").style;
        if (!("AnimationEvent" in window)) {
          delete vendorPrefixes.animationend.animation;
          delete vendorPrefixes.animationiteration.animation;
          delete vendorPrefixes.animationstart.animation;
        }
        if (!("TransitionEvent" in window)) {
          delete vendorPrefixes.transitionend.transition;
        }
      }
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) {
          return prefixedEventNames[eventName];
        } else if (!vendorPrefixes[eventName]) {
          return eventName;
        }
        var prefixMap = vendorPrefixes[eventName];
        for (var styleProp in prefixMap) {
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style2) {
            return prefixedEventNames[eventName] = prefixMap[styleProp];
          }
        }
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend");
      var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
      var ANIMATION_START = getVendorPrefixedEventName("animationstart");
      var TRANSITION_END = getVendorPrefixedEventName("transitionend");
      var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
      var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      function registerSimpleEvents() {
        for (var i2 = 0; i2 < simpleEventPluginEvents.length; i2++) {
          var eventName = simpleEventPluginEvents[i2];
          var domEventName = eventName.toLowerCase();
          var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
          registerSimpleEvent(domEventName, "on" + capitalizedEvent);
        }
        registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
        registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
        registerSimpleEvent(ANIMATION_START, "onAnimationStart");
        registerSimpleEvent("dblclick", "onDoubleClick");
        registerSimpleEvent("focusin", "onFocus");
        registerSimpleEvent("focusout", "onBlur");
        registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      }
      function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (reactName === void 0) {
          return;
        }
        var SyntheticEventCtor = SyntheticEvent;
        var reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (getEventCharCode(nativeEvent) === 0) {
              return;
            }
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (nativeEvent.button === 2) {
              return;
            }
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
        }
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        {
          var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          domEventName === "scroll";
          var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
          if (_listeners.length > 0) {
            var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event: _event,
              listeners: _listeners
            });
          }
        }
      }
      registerSimpleEvents();
      registerEvents$2();
      registerEvents$1();
      registerEvents$3();
      registerEvents();
      function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
        if (shouldProcessPolyfillPlugins) {
          extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
      }
      var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
      var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
      function executeDispatch(event2, listener, currentTarget) {
        var type = event2.type || "unknown-event";
        event2.currentTarget = currentTarget;
        invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event2);
        event2.currentTarget = null;
      }
      function processDispatchQueueItemsInOrder(event2, dispatchListeners, inCapturePhase) {
        var previousInstance;
        if (inCapturePhase) {
          for (var i2 = dispatchListeners.length - 1; i2 >= 0; i2--) {
            var _dispatchListeners$i = dispatchListeners[i2], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event2.isPropagationStopped()) {
              return;
            }
            executeDispatch(event2, listener, currentTarget);
            previousInstance = instance;
          }
        } else {
          for (var _i = 0; _i < dispatchListeners.length; _i++) {
            var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
            if (_instance !== previousInstance && event2.isPropagationStopped()) {
              return;
            }
            executeDispatch(event2, _listener, _currentTarget);
            previousInstance = _instance;
          }
        }
      }
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
          var _dispatchQueue$i = dispatchQueue[i2], event2 = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
          processDispatchQueueItemsInOrder(event2, listeners, inCapturePhase);
        }
        rethrowCaughtError();
      }
      function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var nativeEventTarget = getEventTarget(nativeEvent);
        var dispatchQueue = [];
        extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        {
          if (!nonDelegatedEvents.has(domEventName)) {
            error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
          }
        }
        var isCapturePhaseListener = false;
        var listenerSet = getEventListenerSet(targetElement);
        var listenerSetKey = getListenerSetKey(domEventName);
        if (!listenerSet.has(listenerSetKey)) {
          addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
          listenerSet.add(listenerSetKey);
        }
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target2) {
        {
          if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
            error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
          }
        }
        var eventSystemFlags = 0;
        if (isCapturePhaseListener) {
          eventSystemFlags |= IS_CAPTURE_PHASE;
        }
        addTrappedEventListener(target2, domEventName, eventSystemFlags, isCapturePhaseListener);
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            if (domEventName !== "selectionchange") {
              if (!nonDelegatedEvents.has(domEventName)) {
                listenToNativeEvent(domEventName, false, rootContainerElement);
              }
              listenToNativeEvent(domEventName, true, rootContainerElement);
            }
          });
          var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          if (ownerDocument !== null) {
            if (!ownerDocument[listeningMarker]) {
              ownerDocument[listeningMarker] = true;
              listenToNativeEvent("selectionchange", false, ownerDocument);
            }
          }
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
        var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
        var isPassiveListener = void 0;
        if (passiveBrowserEventsSupported) {
          if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
            isPassiveListener = true;
          }
        }
        targetContainer = targetContainer;
        if (isCapturePhaseListener) {
          if (isPassiveListener !== void 0) {
            addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
          } else {
            addEventCaptureListener(targetContainer, domEventName, listener);
          }
        } else {
          if (isPassiveListener !== void 0) {
            addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
          } else {
            addEventBubbleListener(targetContainer, domEventName, listener);
          }
        }
      }
      function isMatchingRootContainer(grandContainer, targetContainer) {
        return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var ancestorInst = targetInst;
        if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
          var targetContainerNode = targetContainer;
          if (targetInst !== null) {
            var node2 = targetInst;
            mainLoop: while (true) {
              if (node2 === null) {
                return;
              }
              var nodeTag = node2.tag;
              if (nodeTag === HostRoot || nodeTag === HostPortal) {
                var container2 = node2.stateNode.containerInfo;
                if (isMatchingRootContainer(container2, targetContainerNode)) {
                  break;
                }
                if (nodeTag === HostPortal) {
                  var grandNode = node2.return;
                  while (grandNode !== null) {
                    var grandTag = grandNode.tag;
                    if (grandTag === HostRoot || grandTag === HostPortal) {
                      var grandContainer = grandNode.stateNode.containerInfo;
                      if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                        return;
                      }
                    }
                    grandNode = grandNode.return;
                  }
                }
                while (container2 !== null) {
                  var parentNode = getClosestInstanceFromNode(container2);
                  if (parentNode === null) {
                    return;
                  }
                  var parentTag = parentNode.tag;
                  if (parentTag === HostComponent || parentTag === HostText) {
                    node2 = ancestorInst = parentNode;
                    continue mainLoop;
                  }
                  container2 = container2.parentNode;
                }
              }
              node2 = node2.return;
            }
          }
        }
        batchedUpdates(function() {
          return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
        var captureName = reactName !== null ? reactName + "Capture" : null;
        var reactEventName = inCapturePhase ? captureName : reactName;
        var listeners = [];
        var instance = targetFiber;
        var lastHostComponent = null;
        while (instance !== null) {
          var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
          if (tag === HostComponent && stateNode !== null) {
            lastHostComponent = stateNode;
            if (reactEventName !== null) {
              var listener = getListener(instance, reactEventName);
              if (listener != null) {
                listeners.push(createDispatchListener(instance, listener, lastHostComponent));
              }
            }
          }
          if (accumulateTargetOnly) {
            break;
          }
          instance = instance.return;
        }
        return listeners;
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        var captureName = reactName + "Capture";
        var listeners = [];
        var instance = targetFiber;
        while (instance !== null) {
          var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
          if (tag === HostComponent && stateNode !== null) {
            var currentTarget = stateNode;
            var captureListener = getListener(instance, captureName);
            if (captureListener != null) {
              listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
            }
            var bubbleListener = getListener(instance, reactName);
            if (bubbleListener != null) {
              listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
            }
          }
          instance = instance.return;
        }
        return listeners;
      }
      function getParent2(inst) {
        if (inst === null) {
          return null;
        }
        do {
          inst = inst.return;
        } while (inst && inst.tag !== HostComponent);
        if (inst) {
          return inst;
        }
        return null;
      }
      function getLowestCommonAncestor(instA, instB) {
        var nodeA = instA;
        var nodeB = instB;
        var depthA = 0;
        for (var tempA = nodeA; tempA; tempA = getParent2(tempA)) {
          depthA++;
        }
        var depthB = 0;
        for (var tempB = nodeB; tempB; tempB = getParent2(tempB)) {
          depthB++;
        }
        while (depthA - depthB > 0) {
          nodeA = getParent2(nodeA);
          depthA--;
        }
        while (depthB - depthA > 0) {
          nodeB = getParent2(nodeB);
          depthB--;
        }
        var depth = depthA;
        while (depth--) {
          if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
            return nodeA;
          }
          nodeA = getParent2(nodeA);
          nodeB = getParent2(nodeB);
        }
        return null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event2, target2, common, inCapturePhase) {
        var registrationName = event2._reactName;
        var listeners = [];
        var instance = target2;
        while (instance !== null) {
          if (instance === common) {
            break;
          }
          var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
          if (alternate !== null && alternate === common) {
            break;
          }
          if (tag === HostComponent && stateNode !== null) {
            var currentTarget = stateNode;
            if (inCapturePhase) {
              var captureListener = getListener(instance, registrationName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
              }
            } else if (!inCapturePhase) {
              var bubbleListener = getListener(instance, registrationName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
              }
            }
          }
          instance = instance.return;
        }
        if (listeners.length !== 0) {
          dispatchQueue.push({
            event: event2,
            listeners
          });
        }
      }
      function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from2, to) {
        var common = from2 && to ? getLowestCommonAncestor(from2, to) : null;
        if (from2 !== null) {
          accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from2, common, false);
        }
        if (to !== null && enterEvent !== null) {
          accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
        }
      }
      function getListenerSetKey(domEventName, capture) {
        return domEventName + "__bubble";
      }
      var didWarnInvalidHydration = false;
      var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
      var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
      var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
      var AUTOFOCUS = "autoFocus";
      var CHILDREN2 = "children";
      var STYLE = "style";
      var HTML$1 = "__html";
      var warnedUnknownTags;
      var validatePropertiesInDevelopment;
      var warnForPropDifference;
      var warnForExtraAttributes;
      var warnForInvalidEventListener;
      var canDiffStyleForHydrationWarning;
      var normalizeHTML;
      {
        warnedUnknownTags = {
          // There are working polyfills for <dialog>. Let people use it.
          dialog: true,
          // Electron ships a custom <webview> tag to display external web content in
          // an isolated frame and process.
          // This tag is not present in non Electron environments such as JSDom which
          // is often used for testing purposes.
          // @see https://electronjs.org/docs/api/webview-tag
          webview: true
        };
        validatePropertiesInDevelopment = function(type, props) {
          validateProperties(type, props);
          validateProperties$1(type, props);
          validateProperties$2(type, props, {
            registrationNameDependencies,
            possibleRegistrationNames
          });
        };
        canDiffStyleForHydrationWarning = canUseDOM2 && !document.documentMode;
        warnForPropDifference = function(propName, serverValue, clientValue) {
          if (didWarnInvalidHydration) {
            return;
          }
          var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
          var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
          if (normalizedServerValue === normalizedClientValue) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
        };
        warnForExtraAttributes = function(attributeNames) {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          var names = [];
          attributeNames.forEach(function(name2) {
            names.push(name2);
          });
          error("Extra attributes from the server: %s", names);
        };
        warnForInvalidEventListener = function(registrationName, listener) {
          if (listener === false) {
            error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
          } else {
            error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
          }
        };
        normalizeHTML = function(parent, html2) {
          var testElement2 = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
          testElement2.innerHTML = html2;
          return testElement2.innerHTML;
        };
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        {
          checkHtmlStringCoercion(markup);
        }
        var markupString = typeof markup === "string" ? markup : "" + markup;
        return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
        var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
        var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
        if (normalizedServerText === normalizedClientText) {
          return;
        }
        if (shouldWarnDev) {
          {
            if (!didWarnInvalidHydration) {
              didWarnInvalidHydration = true;
              error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
            }
          }
        }
        if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
          throw new Error("Text content does not match server-rendered HTML.");
        }
      }
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function noop() {
      }
      function trapClickOnNonInteractiveElement(node2) {
        node2.onclick = noop;
      }
      function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
        for (var propKey in nextProps) {
          if (!nextProps.hasOwnProperty(propKey)) {
            continue;
          }
          var nextProp = nextProps[propKey];
          if (propKey === STYLE) {
            {
              if (nextProp) {
                Object.freeze(nextProp);
              }
            }
            setValueForStyles(domElement, nextProp);
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
            if (nextHtml != null) {
              setInnerHTML(domElement, nextHtml);
            }
          } else if (propKey === CHILDREN2) {
            if (typeof nextProp === "string") {
              var canSetTextContent = tag !== "textarea" || nextProp !== "";
              if (canSetTextContent) {
                setTextContent(domElement, nextProp);
              }
            } else if (typeof nextProp === "number") {
              setTextContent(domElement, "" + nextProp);
            }
          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
          else if (propKey === AUTOFOCUS) ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
          } else if (nextProp != null) {
            setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
          }
        }
      }
      function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
        for (var i2 = 0; i2 < updatePayload.length; i2 += 2) {
          var propKey = updatePayload[i2];
          var propValue = updatePayload[i2 + 1];
          if (propKey === STYLE) {
            setValueForStyles(domElement, propValue);
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            setInnerHTML(domElement, propValue);
          } else if (propKey === CHILDREN2) {
            setTextContent(domElement, propValue);
          } else {
            setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
          }
        }
      }
      function createElement(type, props, rootContainerElement, parentNamespace) {
        var isCustomComponentTag;
        var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
        var domElement;
        var namespaceURI = parentNamespace;
        if (namespaceURI === HTML_NAMESPACE) {
          namespaceURI = getIntrinsicNamespace(type);
        }
        if (namespaceURI === HTML_NAMESPACE) {
          {
            isCustomComponentTag = isCustomComponent(type, props);
            if (!isCustomComponentTag && type !== type.toLowerCase()) {
              error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
            }
          }
          if (type === "script") {
            var div = ownerDocument.createElement("div");
            div.innerHTML = "<script><\/script>";
            var firstChild = div.firstChild;
            domElement = div.removeChild(firstChild);
          } else if (typeof props.is === "string") {
            domElement = ownerDocument.createElement(type, {
              is: props.is
            });
          } else {
            domElement = ownerDocument.createElement(type);
            if (type === "select") {
              var node2 = domElement;
              if (props.multiple) {
                node2.multiple = true;
              } else if (props.size) {
                node2.size = props.size;
              }
            }
          }
        } else {
          domElement = ownerDocument.createElementNS(namespaceURI, type);
        }
        {
          if (namespaceURI === HTML_NAMESPACE) {
            if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty.call(warnedUnknownTags, type)) {
              warnedUnknownTags[type] = true;
              error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
            }
          }
        }
        return domElement;
      }
      function createTextNode(text2, rootContainerElement) {
        return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text2);
      }
      function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
        var isCustomComponentTag = isCustomComponent(tag, rawProps);
        {
          validatePropertiesInDevelopment(tag, rawProps);
        }
        var props;
        switch (tag) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            props = rawProps;
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", domElement);
            props = rawProps;
            break;
          case "video":
          case "audio":
            for (var i2 = 0; i2 < mediaEventTypes.length; i2++) {
              listenToNonDelegatedEvent(mediaEventTypes[i2], domElement);
            }
            props = rawProps;
            break;
          case "source":
            listenToNonDelegatedEvent("error", domElement);
            props = rawProps;
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            props = rawProps;
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            props = rawProps;
            break;
          case "input":
            initWrapperState(domElement, rawProps);
            props = getHostProps(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "option":
            validateProps(domElement, rawProps);
            props = rawProps;
            break;
          case "select":
            initWrapperState$1(domElement, rawProps);
            props = getHostProps$1(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "textarea":
            initWrapperState$2(domElement, rawProps);
            props = getHostProps$2(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          default:
            props = rawProps;
        }
        assertValidProps(tag, props);
        setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
        switch (tag) {
          case "input":
            track(domElement);
            postMountWrapper(domElement, rawProps, false);
            break;
          case "textarea":
            track(domElement);
            postMountWrapper$3(domElement);
            break;
          case "option":
            postMountWrapper$1(domElement, rawProps);
            break;
          case "select":
            postMountWrapper$2(domElement, rawProps);
            break;
          default:
            if (typeof props.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
      }
      function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
        {
          validatePropertiesInDevelopment(tag, nextRawProps);
        }
        var updatePayload = null;
        var lastProps;
        var nextProps;
        switch (tag) {
          case "input":
            lastProps = getHostProps(domElement, lastRawProps);
            nextProps = getHostProps(domElement, nextRawProps);
            updatePayload = [];
            break;
          case "select":
            lastProps = getHostProps$1(domElement, lastRawProps);
            nextProps = getHostProps$1(domElement, nextRawProps);
            updatePayload = [];
            break;
          case "textarea":
            lastProps = getHostProps$2(domElement, lastRawProps);
            nextProps = getHostProps$2(domElement, nextRawProps);
            updatePayload = [];
            break;
          default:
            lastProps = lastRawProps;
            nextProps = nextRawProps;
            if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
        assertValidProps(tag, nextProps);
        var propKey;
        var styleName;
        var styleUpdates = null;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = lastProps[propKey];
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                if (!styleUpdates) {
                  styleUpdates = {};
                }
                styleUpdates[styleName] = "";
              }
            }
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN2) ;
          else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
          else if (propKey === AUTOFOCUS) ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (!updatePayload) {
              updatePayload = [];
            }
          } else {
            (updatePayload = updatePayload || []).push(propKey, null);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = lastProps != null ? lastProps[propKey] : void 0;
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
            continue;
          }
          if (propKey === STYLE) {
            {
              if (nextProp) {
                Object.freeze(nextProp);
              }
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              if (!styleUpdates) {
                if (!updatePayload) {
                  updatePayload = [];
                }
                updatePayload.push(propKey, styleUpdates);
              }
              styleUpdates = nextProp;
            }
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
            var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
            if (nextHtml != null) {
              if (lastHtml !== nextHtml) {
                (updatePayload = updatePayload || []).push(propKey, nextHtml);
              }
            }
          } else if (propKey === CHILDREN2) {
            if (typeof nextProp === "string" || typeof nextProp === "number") {
              (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
            }
          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
            if (!updatePayload && lastProp !== nextProp) {
              updatePayload = [];
            }
          } else {
            (updatePayload = updatePayload || []).push(propKey, nextProp);
          }
        }
        if (styleUpdates) {
          {
            validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
          }
          (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
        }
        return updatePayload;
      }
      function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
        if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
          updateChecked(domElement, nextRawProps);
        }
        var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
        var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
        updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
        switch (tag) {
          case "input":
            updateWrapper(domElement, nextRawProps);
            break;
          case "textarea":
            updateWrapper$1(domElement, nextRawProps);
            break;
          case "select":
            postUpdateWrapper(domElement, nextRawProps);
            break;
        }
      }
      function getPossibleStandardName(propName) {
        {
          var lowerCasedName = propName.toLowerCase();
          if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            return null;
          }
          return possibleStandardNames[lowerCasedName] || null;
        }
      }
      function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
        var isCustomComponentTag;
        var extraAttributeNames;
        {
          isCustomComponentTag = isCustomComponent(tag, rawProps);
          validatePropertiesInDevelopment(tag, rawProps);
        }
        switch (tag) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (var i2 = 0; i2 < mediaEventTypes.length; i2++) {
              listenToNonDelegatedEvent(mediaEventTypes[i2], domElement);
            }
            break;
          case "source":
            listenToNonDelegatedEvent("error", domElement);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "input":
            initWrapperState(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "option":
            validateProps(domElement, rawProps);
            break;
          case "select":
            initWrapperState$1(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "textarea":
            initWrapperState$2(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
        }
        assertValidProps(tag, rawProps);
        {
          extraAttributeNames = /* @__PURE__ */ new Set();
          var attributes = domElement.attributes;
          for (var _i = 0; _i < attributes.length; _i++) {
            var name2 = attributes[_i].name.toLowerCase();
            switch (name2) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributeNames.add(attributes[_i].name);
            }
          }
        }
        var updatePayload = null;
        for (var propKey in rawProps) {
          if (!rawProps.hasOwnProperty(propKey)) {
            continue;
          }
          var nextProp = rawProps[propKey];
          if (propKey === CHILDREN2) {
            if (typeof nextProp === "string") {
              if (domElement.textContent !== nextProp) {
                if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                }
                updatePayload = [CHILDREN2, nextProp];
              }
            } else if (typeof nextProp === "number") {
              if (domElement.textContent !== "" + nextProp) {
                if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                }
                updatePayload = [CHILDREN2, "" + nextProp];
              }
            }
          } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
          } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof isCustomComponentTag === "boolean") {
            var serverValue = void 0;
            var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
            if (rawProps[SUPPRESS_HYDRATION_WARNING] === true) ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
            // TODO: Only ignore them on controlled tags.
            propKey === "value" || propKey === "checked" || propKey === "selected") ;
            else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var serverHTML = domElement.innerHTML;
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                var expectedHTML = normalizeHTML(domElement, nextHtml);
                if (expectedHTML !== serverHTML) {
                  warnForPropDifference(propKey, serverHTML, expectedHTML);
                }
              }
            } else if (propKey === STYLE) {
              extraAttributeNames.delete(propKey);
              if (canDiffStyleForHydrationWarning) {
                var expectedStyle = createDangerousStringForStyles(nextProp);
                serverValue = domElement.getAttribute("style");
                if (expectedStyle !== serverValue) {
                  warnForPropDifference(propKey, serverValue, expectedStyle);
                }
              }
            } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
              extraAttributeNames.delete(propKey.toLowerCase());
              serverValue = getValueForAttribute(domElement, propKey, nextProp);
              if (nextProp !== serverValue) {
                warnForPropDifference(propKey, serverValue, nextProp);
              }
            } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
              var isMismatchDueToBadCasing = false;
              if (propertyInfo !== null) {
                extraAttributeNames.delete(propertyInfo.attributeName);
                serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
              } else {
                var ownNamespace = parentNamespace;
                if (ownNamespace === HTML_NAMESPACE) {
                  ownNamespace = getIntrinsicNamespace(tag);
                }
                if (ownNamespace === HTML_NAMESPACE) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                } else {
                  var standardName = getPossibleStandardName(propKey);
                  if (standardName !== null && standardName !== propKey) {
                    isMismatchDueToBadCasing = true;
                    extraAttributeNames.delete(standardName);
                  }
                  extraAttributeNames.delete(propKey);
                }
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
              }
              var dontWarnCustomElement = enableCustomElementPropertySupport;
              if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                warnForPropDifference(propKey, serverValue, nextProp);
              }
            }
          }
        }
        {
          if (shouldWarnDev) {
            if (
              // $FlowFixMe - Should be inferred as not undefined.
              extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
            ) {
              warnForExtraAttributes(extraAttributeNames);
            }
          }
        }
        switch (tag) {
          case "input":
            track(domElement);
            postMountWrapper(domElement, rawProps, true);
            break;
          case "textarea":
            track(domElement);
            postMountWrapper$3(domElement);
            break;
          case "select":
          case "option":
            break;
          default:
            if (typeof rawProps.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
        return updatePayload;
      }
      function diffHydratedText(textNode, text2, isConcurrentMode) {
        var isDifferent = textNode.nodeValue !== text2;
        return isDifferent;
      }
      function warnForDeletedHydratableElement(parentNode, child) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
        }
      }
      function warnForDeletedHydratableText(parentNode, child) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
        }
      }
      function warnForInsertedHydratedElement(parentNode, tag, props) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
        }
      }
      function warnForInsertedHydratedText(parentNode, text2) {
        {
          if (text2 === "") {
            return;
          }
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text2, parentNode.nodeName.toLowerCase());
        }
      }
      function restoreControlledState$3(domElement, tag, props) {
        switch (tag) {
          case "input":
            restoreControlledState(domElement, props);
            return;
          case "textarea":
            restoreControlledState$2(domElement, props);
            return;
          case "select":
            restoreControlledState$1(domElement, props);
            return;
        }
      }
      var validateDOMNesting = function() {
      };
      var updatedAncestorInfo = function() {
      };
      {
        var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
        var inScopeTags = [
          "applet",
          "caption",
          "html",
          "table",
          "td",
          "th",
          "marquee",
          "object",
          "template",
          // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
          // TODO: Distinguish by namespace here -- for <title>, including it here
          // errs on the side of fewer warnings
          "foreignObject",
          "desc",
          "title"
        ];
        var buttonScopeTags = inScopeTags.concat(["button"]);
        var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
        var emptyAncestorInfo = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null
        };
        updatedAncestorInfo = function(oldInfo, tag) {
          var ancestorInfo = assign2({}, oldInfo || emptyAncestorInfo);
          var info = {
            tag
          };
          if (inScopeTags.indexOf(tag) !== -1) {
            ancestorInfo.aTagInScope = null;
            ancestorInfo.buttonTagInScope = null;
            ancestorInfo.nobrTagInScope = null;
          }
          if (buttonScopeTags.indexOf(tag) !== -1) {
            ancestorInfo.pTagInButtonScope = null;
          }
          if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
            ancestorInfo.listItemTagAutoclosing = null;
            ancestorInfo.dlItemTagAutoclosing = null;
          }
          ancestorInfo.current = info;
          if (tag === "form") {
            ancestorInfo.formTag = info;
          }
          if (tag === "a") {
            ancestorInfo.aTagInScope = info;
          }
          if (tag === "button") {
            ancestorInfo.buttonTagInScope = info;
          }
          if (tag === "nobr") {
            ancestorInfo.nobrTagInScope = info;
          }
          if (tag === "p") {
            ancestorInfo.pTagInButtonScope = info;
          }
          if (tag === "li") {
            ancestorInfo.listItemTagAutoclosing = info;
          }
          if (tag === "dd" || tag === "dt") {
            ancestorInfo.dlItemTagAutoclosing = info;
          }
          return ancestorInfo;
        };
        var isTagValidWithParent = function(tag, parentTag) {
          switch (parentTag) {
            case "select":
              return tag === "option" || tag === "optgroup" || tag === "#text";
            case "optgroup":
              return tag === "option" || tag === "#text";
            case "option":
              return tag === "#text";
            case "tr":
              return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
            case "tbody":
            case "thead":
            case "tfoot":
              return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
            case "colgroup":
              return tag === "col" || tag === "template";
            case "table":
              return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
            case "head":
              return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
            case "html":
              return tag === "head" || tag === "body" || tag === "frameset";
            case "frameset":
              return tag === "frame";
            case "#document":
              return tag === "html";
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
            case "rp":
            case "rt":
              return impliedEndTags.indexOf(parentTag) === -1;
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "head":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return parentTag == null;
          }
          return true;
        };
        var findInvalidAncestorForTag = function(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        };
        var didWarn$1 = {};
        validateDOMNesting = function(childTag, childText, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfo;
          var parentInfo = ancestorInfo.current;
          var parentTag = parentInfo && parentInfo.tag;
          if (childText != null) {
            if (childTag != null) {
              error("validateDOMNesting: when childText is passed, childTag should be null");
            }
            childTag = "#text";
          }
          var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
          var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          var invalidParentOrAncestor = invalidParent || invalidAncestor;
          if (!invalidParentOrAncestor) {
            return;
          }
          var ancestorTag = invalidParentOrAncestor.tag;
          var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
          if (didWarn$1[warnKey]) {
            return;
          }
          didWarn$1[warnKey] = true;
          var tagDisplayName = childTag;
          var whitespaceInfo = "";
          if (childTag === "#text") {
            if (/\S/.test(childText)) {
              tagDisplayName = "Text nodes";
            } else {
              tagDisplayName = "Whitespace text nodes";
              whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
            }
          } else {
            tagDisplayName = "<" + childTag + ">";
          }
          if (invalidParent) {
            var info = "";
            if (ancestorTag === "table" && childTag === "tr") {
              info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
            }
            error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
          } else {
            error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
          }
        };
      }
      var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
      var SUSPENSE_START_DATA = "$";
      var SUSPENSE_END_DATA = "/$";
      var SUSPENSE_PENDING_START_DATA = "$?";
      var SUSPENSE_FALLBACK_START_DATA = "$!";
      var STYLE$1 = "style";
      var eventsEnabled = null;
      var selectionInformation = null;
      function getRootHostContext(rootContainerInstance) {
        var type;
        var namespace;
        var nodeType = rootContainerInstance.nodeType;
        switch (nodeType) {
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE: {
            type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
            var root3 = rootContainerInstance.documentElement;
            namespace = root3 ? root3.namespaceURI : getChildNamespace(null, "");
            break;
          }
          default: {
            var container2 = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
            var ownNamespace = container2.namespaceURI || null;
            type = container2.tagName;
            namespace = getChildNamespace(ownNamespace, type);
            break;
          }
        }
        {
          var validatedTag = type.toLowerCase();
          var ancestorInfo = updatedAncestorInfo(null, validatedTag);
          return {
            namespace,
            ancestorInfo
          };
        }
      }
      function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        {
          var parentHostContextDev = parentHostContext;
          var namespace = getChildNamespace(parentHostContextDev.namespace, type);
          var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
          return {
            namespace,
            ancestorInfo
          };
        }
      }
      function getPublicInstance(instance) {
        return instance;
      }
      function prepareForCommit(containerInfo) {
        eventsEnabled = isEnabled();
        selectionInformation = getSelectionInformation();
        var activeInstance = null;
        setEnabled(false);
        return activeInstance;
      }
      function resetAfterCommit(containerInfo) {
        restoreSelection(selectionInformation);
        setEnabled(eventsEnabled);
        eventsEnabled = null;
        selectionInformation = null;
      }
      function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var parentNamespace;
        {
          var hostContextDev = hostContext;
          validateDOMNesting(type, null, hostContextDev.ancestorInfo);
          if (typeof props.children === "string" || typeof props.children === "number") {
            var string = "" + props.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
          parentNamespace = hostContextDev.namespace;
        }
        var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
        precacheFiberNode(internalInstanceHandle, domElement);
        updateFiberProps(domElement, props);
        return domElement;
      }
      function appendInitialChild(parentInstance, child) {
        parentInstance.appendChild(child);
      }
      function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
        setInitialProperties(domElement, type, props, rootContainerInstance);
        switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            return !!props.autoFocus;
          case "img":
            return true;
          default:
            return false;
        }
      }
      function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
        {
          var hostContextDev = hostContext;
          if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
            var string = "" + newProps.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
        }
        return diffProperties(domElement, type, oldProps, newProps);
      }
      function shouldSetTextContent(type, props) {
        return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
      }
      function createTextInstance(text2, rootContainerInstance, hostContext, internalInstanceHandle) {
        {
          var hostContextDev = hostContext;
          validateDOMNesting(null, text2, hostContextDev.ancestorInfo);
        }
        var textNode = createTextNode(text2, rootContainerInstance);
        precacheFiberNode(internalInstanceHandle, textNode);
        return textNode;
      }
      function getCurrentEventPriority() {
        var currentEvent = window.event;
        if (currentEvent === void 0) {
          return DefaultEventPriority;
        }
        return getEventPriority(currentEvent.type);
      }
      var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
      var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
      var noTimeout = -1;
      var localPromise = typeof Promise === "function" ? Promise : void 0;
      var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error2) {
        setTimeout(function() {
          throw error2;
        });
      }
      function commitMount(domElement, type, newProps, internalInstanceHandle) {
        switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            if (newProps.autoFocus) {
              domElement.focus();
            }
            return;
          case "img": {
            if (newProps.src) {
              domElement.src = newProps.src;
            }
            return;
          }
        }
      }
      function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
        updateProperties(domElement, updatePayload, type, oldProps, newProps);
        updateFiberProps(domElement, newProps);
      }
      function resetTextContent(domElement) {
        setTextContent(domElement, "");
      }
      function commitTextUpdate(textInstance, oldText, newText) {
        textInstance.nodeValue = newText;
      }
      function appendChild2(parentInstance, child) {
        parentInstance.appendChild(child);
      }
      function appendChildToContainer(container2, child) {
        var parentNode;
        if (container2.nodeType === COMMENT_NODE) {
          parentNode = container2.parentNode;
          parentNode.insertBefore(child, container2);
        } else {
          parentNode = container2;
          parentNode.appendChild(child);
        }
        var reactRootContainer = container2._reactRootContainer;
        if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
          trapClickOnNonInteractiveElement(parentNode);
        }
      }
      function insertBefore(parentInstance, child, beforeChild) {
        parentInstance.insertBefore(child, beforeChild);
      }
      function insertInContainerBefore(container2, child, beforeChild) {
        if (container2.nodeType === COMMENT_NODE) {
          container2.parentNode.insertBefore(child, beforeChild);
        } else {
          container2.insertBefore(child, beforeChild);
        }
      }
      function removeChild(parentInstance, child) {
        parentInstance.removeChild(child);
      }
      function removeChildFromContainer(container2, child) {
        if (container2.nodeType === COMMENT_NODE) {
          container2.parentNode.removeChild(child);
        } else {
          container2.removeChild(child);
        }
      }
      function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node2 = suspenseInstance;
        var depth = 0;
        do {
          var nextNode = node2.nextSibling;
          parentInstance.removeChild(node2);
          if (nextNode && nextNode.nodeType === COMMENT_NODE) {
            var data = nextNode.data;
            if (data === SUSPENSE_END_DATA) {
              if (depth === 0) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(suspenseInstance);
                return;
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
              depth++;
            }
          }
          node2 = nextNode;
        } while (node2);
        retryIfBlockedOn(suspenseInstance);
      }
      function clearSuspenseBoundaryFromContainer(container2, suspenseInstance) {
        if (container2.nodeType === COMMENT_NODE) {
          clearSuspenseBoundary(container2.parentNode, suspenseInstance);
        } else if (container2.nodeType === ELEMENT_NODE) {
          clearSuspenseBoundary(container2, suspenseInstance);
        }
        retryIfBlockedOn(container2);
      }
      function hideInstance(instance) {
        instance = instance;
        var style3 = instance.style;
        if (typeof style3.setProperty === "function") {
          style3.setProperty("display", "none", "important");
        } else {
          style3.display = "none";
        }
      }
      function hideTextInstance(textInstance) {
        textInstance.nodeValue = "";
      }
      function unhideInstance(instance, props) {
        instance = instance;
        var styleProp = props[STYLE$1];
        var display2 = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
        instance.style.display = dangerousStyleValue("display", display2);
      }
      function unhideTextInstance(textInstance, text2) {
        textInstance.nodeValue = text2;
      }
      function clearContainer(container2) {
        if (container2.nodeType === ELEMENT_NODE) {
          container2.textContent = "";
        } else if (container2.nodeType === DOCUMENT_NODE) {
          if (container2.documentElement) {
            container2.removeChild(container2.documentElement);
          }
        }
      }
      function canHydrateInstance(instance, type, props) {
        if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
          return null;
        }
        return instance;
      }
      function canHydrateTextInstance(instance, text2) {
        if (text2 === "" || instance.nodeType !== TEXT_NODE) {
          return null;
        }
        return instance;
      }
      function canHydrateSuspenseInstance(instance) {
        if (instance.nodeType !== COMMENT_NODE) {
          return null;
        }
        return instance;
      }
      function isSuspenseInstancePending(instance) {
        return instance.data === SUSPENSE_PENDING_START_DATA;
      }
      function isSuspenseInstanceFallback(instance) {
        return instance.data === SUSPENSE_FALLBACK_START_DATA;
      }
      function getSuspenseInstanceFallbackErrorDetails(instance) {
        var dataset = instance.nextSibling && instance.nextSibling.dataset;
        var digest, message, stack;
        if (dataset) {
          digest = dataset.dgst;
          {
            message = dataset.msg;
            stack = dataset.stck;
          }
        }
        {
          return {
            message,
            digest,
            stack
          };
        }
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        instance._reactRetry = callback;
      }
      function getNextHydratable(node2) {
        for (; node2 != null; node2 = node2.nextSibling) {
          var nodeType = node2.nodeType;
          if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
            break;
          }
          if (nodeType === COMMENT_NODE) {
            var nodeData = node2.data;
            if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
              break;
            }
            if (nodeData === SUSPENSE_END_DATA) {
              return null;
            }
          }
        }
        return node2;
      }
      function getNextHydratableSibling(instance) {
        return getNextHydratable(instance.nextSibling);
      }
      function getFirstHydratableChild(parentInstance) {
        return getNextHydratable(parentInstance.firstChild);
      }
      function getFirstHydratableChildWithinContainer(parentContainer) {
        return getNextHydratable(parentContainer.firstChild);
      }
      function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
        return getNextHydratable(parentInstance.nextSibling);
      }
      function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
        precacheFiberNode(internalInstanceHandle, instance);
        updateFiberProps(instance, props);
        var parentNamespace;
        {
          var hostContextDev = hostContext;
          parentNamespace = hostContextDev.namespace;
        }
        var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
        return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
      }
      function hydrateTextInstance(textInstance, text2, internalInstanceHandle, shouldWarnDev) {
        precacheFiberNode(internalInstanceHandle, textInstance);
        (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
        return diffHydratedText(textInstance, text2);
      }
      function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, suspenseInstance);
      }
      function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
        var node2 = suspenseInstance.nextSibling;
        var depth = 0;
        while (node2) {
          if (node2.nodeType === COMMENT_NODE) {
            var data = node2.data;
            if (data === SUSPENSE_END_DATA) {
              if (depth === 0) {
                return getNextHydratableSibling(node2);
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
              depth++;
            }
          }
          node2 = node2.nextSibling;
        }
        return null;
      }
      function getParentSuspenseInstance(targetInstance) {
        var node2 = targetInstance.previousSibling;
        var depth = 0;
        while (node2) {
          if (node2.nodeType === COMMENT_NODE) {
            var data = node2.data;
            if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
              if (depth === 0) {
                return node2;
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_END_DATA) {
              depth++;
            }
          }
          node2 = node2.previousSibling;
        }
        return null;
      }
      function commitHydratedContainer(container2) {
        retryIfBlockedOn(container2);
      }
      function commitHydratedSuspenseInstance(suspenseInstance) {
        retryIfBlockedOn(suspenseInstance);
      }
      function shouldDeleteUnhydratedTailInstances(parentType) {
        return parentType !== "head" && parentType !== "body";
      }
      function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text2, isConcurrentMode) {
        var shouldWarnDev = true;
        checkForUnmatchedText(textInstance.nodeValue, text2, isConcurrentMode, shouldWarnDev);
      }
      function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text2, isConcurrentMode) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text2, isConcurrentMode, shouldWarnDev);
        }
      }
      function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
        {
          if (instance.nodeType === ELEMENT_NODE) {
            warnForDeletedHydratableElement(parentContainer, instance);
          } else if (instance.nodeType === COMMENT_NODE) ;
          else {
            warnForDeletedHydratableText(parentContainer, instance);
          }
        }
      }
      function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null) {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentNode, instance);
            } else if (instance.nodeType === COMMENT_NODE) ;
            else {
              warnForDeletedHydratableText(parentNode, instance);
            }
          }
        }
      }
      function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentInstance, instance);
            } else if (instance.nodeType === COMMENT_NODE) ;
            else {
              warnForDeletedHydratableText(parentInstance, instance);
            }
          }
        }
      }
      function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
        {
          warnForInsertedHydratedElement(parentContainer, type);
        }
      }
      function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text2) {
        {
          warnForInsertedHydratedText(parentContainer, text2);
        }
      }
      function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type);
        }
      }
      function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text2) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null) warnForInsertedHydratedText(parentNode, text2);
        }
      }
      function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForInsertedHydratedElement(parentInstance, type);
          }
        }
      }
      function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text2, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForInsertedHydratedText(parentInstance, text2);
          }
        }
      }
      function errorHydratingContainer(parentContainer) {
        {
          error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
        }
      }
      function preparePortalMount(portalInstance) {
        listenToAllSupportedEvents(portalInstance);
      }
      var randomKey = Math.random().toString(36).slice(2);
      var internalInstanceKey = "__reactFiber$" + randomKey;
      var internalPropsKey = "__reactProps$" + randomKey;
      var internalContainerInstanceKey = "__reactContainer$" + randomKey;
      var internalEventHandlersKey = "__reactEvents$" + randomKey;
      var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
      var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
      function detachDeletedInstance(node2) {
        delete node2[internalInstanceKey];
        delete node2[internalPropsKey];
        delete node2[internalEventHandlersKey];
        delete node2[internalEventHandlerListenersKey];
        delete node2[internalEventHandlesSetKey];
      }
      function precacheFiberNode(hostInst, node2) {
        node2[internalInstanceKey] = hostInst;
      }
      function markContainerAsRoot(hostRoot, node2) {
        node2[internalContainerInstanceKey] = hostRoot;
      }
      function unmarkContainerAsRoot(node2) {
        node2[internalContainerInstanceKey] = null;
      }
      function isContainerMarkedAsRoot(node2) {
        return !!node2[internalContainerInstanceKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) {
          return targetInst;
        }
        var parentNode = targetNode.parentNode;
        while (parentNode) {
          targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
          if (targetInst) {
            var alternate = targetInst.alternate;
            if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
              var suspenseInstance = getParentSuspenseInstance(targetNode);
              while (suspenseInstance !== null) {
                var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                if (targetSuspenseInst) {
                  return targetSuspenseInst;
                }
                suspenseInstance = getParentSuspenseInstance(suspenseInstance);
              }
            }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node2) {
        var inst = node2[internalInstanceKey] || node2[internalContainerInstanceKey];
        if (inst) {
          if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
            return inst;
          } else {
            return null;
          }
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        if (inst.tag === HostComponent || inst.tag === HostText) {
          return inst.stateNode;
        }
        throw new Error("getNodeFromInstance: Invalid argument.");
      }
      function getFiberCurrentPropsFromNode(node2) {
        return node2[internalPropsKey] || null;
      }
      function updateFiberProps(node2, props) {
        node2[internalPropsKey] = props;
      }
      function getEventListenerSet(node2) {
        var elementListenerSet = node2[internalEventHandlersKey];
        if (elementListenerSet === void 0) {
          elementListenerSet = node2[internalEventHandlersKey] = /* @__PURE__ */ new Set();
        }
        return elementListenerSet;
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has3 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has3(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var valueStack = [];
      var fiberStack;
      {
        fiberStack = [];
      }
      var index = -1;
      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }
      function pop(cursor, fiber) {
        if (index < 0) {
          {
            error("Unexpected pop.");
          }
          return;
        }
        {
          if (fiber !== fiberStack[index]) {
            error("Unexpected Fiber popped.");
          }
        }
        cursor.current = valueStack[index];
        valueStack[index] = null;
        {
          fiberStack[index] = null;
        }
        index--;
      }
      function push(cursor, value, fiber) {
        index++;
        valueStack[index] = cursor.current;
        {
          fiberStack[index] = fiber;
        }
        cursor.current = value;
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      var contextStackCursor = createCursor(emptyContextObject);
      var didPerformWorkStackCursor = createCursor(false);
      var previousContext = emptyContextObject;
      function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
        {
          if (didPushOwnContextIfProvider && isContextProvider(Component)) {
            return previousContext;
          }
          return contextStackCursor.current;
        }
      }
      function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
        {
          var instance = workInProgress2.stateNode;
          instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
          instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
        }
      }
      function getMaskedContext(workInProgress2, unmaskedContext) {
        {
          var type = workInProgress2.type;
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var instance = workInProgress2.stateNode;
          if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
            return instance.__reactInternalMemoizedMaskedChildContext;
          }
          var context = {};
          for (var key2 in contextTypes) {
            context[key2] = unmaskedContext[key2];
          }
          {
            var name2 = getComponentNameFromFiber(workInProgress2) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name2);
          }
          if (instance) {
            cacheContext(workInProgress2, unmaskedContext, context);
          }
          return context;
        }
      }
      function hasContextChanged() {
        {
          return didPerformWorkStackCursor.current;
        }
      }
      function isContextProvider(type) {
        {
          var childContextTypes = type.childContextTypes;
          return childContextTypes !== null && childContextTypes !== void 0;
        }
      }
      function popContext(fiber) {
        {
          pop(didPerformWorkStackCursor, fiber);
          pop(contextStackCursor, fiber);
        }
      }
      function popTopLevelContextObject(fiber) {
        {
          pop(didPerformWorkStackCursor, fiber);
          pop(contextStackCursor, fiber);
        }
      }
      function pushTopLevelContextObject(fiber, context, didChange) {
        {
          if (contextStackCursor.current !== emptyContextObject) {
            throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
          }
          push(contextStackCursor, context, fiber);
          push(didPerformWorkStackCursor, didChange, fiber);
        }
      }
      function processChildContext(fiber, type, parentContext) {
        {
          var instance = fiber.stateNode;
          var childContextTypes = type.childContextTypes;
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromFiber(fiber) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
            }
          }
          {
            var name2 = getComponentNameFromFiber(fiber) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name2);
          }
          return assign2({}, parentContext, childContext);
        }
      }
      function pushContextProvider(workInProgress2) {
        {
          var instance = workInProgress2.stateNode;
          var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
          previousContext = contextStackCursor.current;
          push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
          push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
          return true;
        }
      }
      function invalidateContextProvider(workInProgress2, type, didChange) {
        {
          var instance = workInProgress2.stateNode;
          if (!instance) {
            throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
          }
          if (didChange) {
            var mergedContext = processChildContext(workInProgress2, type, previousContext);
            instance.__reactInternalMemoizedMergedChildContext = mergedContext;
            pop(didPerformWorkStackCursor, workInProgress2);
            pop(contextStackCursor, workInProgress2);
            push(contextStackCursor, mergedContext, workInProgress2);
            push(didPerformWorkStackCursor, didChange, workInProgress2);
          } else {
            pop(didPerformWorkStackCursor, workInProgress2);
            push(didPerformWorkStackCursor, didChange, workInProgress2);
          }
        }
      }
      function findCurrentUnmaskedContext(fiber) {
        {
          if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
            throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
          }
          var node2 = fiber;
          do {
            switch (node2.tag) {
              case HostRoot:
                return node2.stateNode.context;
              case ClassComponent: {
                var Component = node2.type;
                if (isContextProvider(Component)) {
                  return node2.stateNode.__reactInternalMemoizedMergedChildContext;
                }
                break;
              }
            }
            node2 = node2.return;
          } while (node2 !== null);
          throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      var LegacyRoot = 0;
      var ConcurrentRoot = 1;
      var syncQueue = null;
      var includesLegacySyncCallbacks = false;
      var isFlushingSyncQueue = false;
      function scheduleSyncCallback(callback) {
        if (syncQueue === null) {
          syncQueue = [callback];
        } else {
          syncQueue.push(callback);
        }
      }
      function scheduleLegacySyncCallback(callback) {
        includesLegacySyncCallbacks = true;
        scheduleSyncCallback(callback);
      }
      function flushSyncCallbacksOnlyInLegacyMode() {
        if (includesLegacySyncCallbacks) {
          flushSyncCallbacks();
        }
      }
      function flushSyncCallbacks() {
        if (!isFlushingSyncQueue && syncQueue !== null) {
          isFlushingSyncQueue = true;
          var i2 = 0;
          var previousUpdatePriority = getCurrentUpdatePriority();
          try {
            var isSync = true;
            var queue = syncQueue;
            setCurrentUpdatePriority(DiscreteEventPriority);
            for (; i2 < queue.length; i2++) {
              var callback = queue[i2];
              do {
                callback = callback(isSync);
              } while (callback !== null);
            }
            syncQueue = null;
            includesLegacySyncCallbacks = false;
          } catch (error2) {
            if (syncQueue !== null) {
              syncQueue = syncQueue.slice(i2 + 1);
            }
            scheduleCallback(ImmediatePriority, flushSyncCallbacks);
            throw error2;
          } finally {
            setCurrentUpdatePriority(previousUpdatePriority);
            isFlushingSyncQueue = false;
          }
        }
        return null;
      }
      var forkStack = [];
      var forkStackIndex = 0;
      var treeForkProvider = null;
      var treeForkCount = 0;
      var idStack = [];
      var idStackIndex = 0;
      var treeContextProvider = null;
      var treeContextId = 1;
      var treeContextOverflow = "";
      function isForkedChild(workInProgress2) {
        warnIfNotHydrating();
        return (workInProgress2.flags & Forked) !== NoFlags;
      }
      function getForksAtLevel(workInProgress2) {
        warnIfNotHydrating();
        return treeForkCount;
      }
      function getTreeId() {
        var overflow = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeFork(workInProgress2, totalChildren) {
        warnIfNotHydrating();
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        var baseOverflow = treeContextOverflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index2 + 1;
        var length2 = getBitLength(totalChildren) + baseLength;
        if (length2 > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          treeContextId = 1 << restOfLength | id;
          treeContextOverflow = overflow;
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          treeContextId = 1 << length2 | _id;
          treeContextOverflow = _overflow;
        }
      }
      function pushMaterializedTreeId(workInProgress2) {
        warnIfNotHydrating();
        var returnFiber = workInProgress2.return;
        if (returnFiber !== null) {
          var numberOfForks = 1;
          var slotIndex = 0;
          pushTreeFork(workInProgress2, numberOfForks);
          pushTreeId(workInProgress2, numberOfForks, slotIndex);
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      function popTreeContext(workInProgress2) {
        while (workInProgress2 === treeForkProvider) {
          treeForkProvider = forkStack[--forkStackIndex];
          forkStack[forkStackIndex] = null;
          treeForkCount = forkStack[--forkStackIndex];
          forkStack[forkStackIndex] = null;
        }
        while (workInProgress2 === treeContextProvider) {
          treeContextProvider = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
          treeContextOverflow = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
          treeContextId = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
        }
      }
      function getSuspendedTreeContext() {
        warnIfNotHydrating();
        if (treeContextProvider !== null) {
          return {
            id: treeContextId,
            overflow: treeContextOverflow
          };
        } else {
          return null;
        }
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextId = suspendedContext.id;
        treeContextOverflow = suspendedContext.overflow;
        treeContextProvider = workInProgress2;
      }
      function warnIfNotHydrating() {
        {
          if (!getIsHydrating()) {
            error("Expected to be hydrating. This is a bug in React. Please file an issue.");
          }
        }
      }
      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;
      var didSuspendOrErrorDEV = false;
      var hydrationErrors = null;
      function warnIfHydrating() {
        {
          if (isHydrating) {
            error("We should not be hydrating here. This is a bug in React. Please file a bug.");
          }
        }
      }
      function markDidThrowWhileHydratingDEV() {
        {
          didSuspendOrErrorDEV = true;
        }
      }
      function didSuspendOrErrorWhileHydratingDEV() {
        {
          return didSuspendOrErrorDEV;
        }
      }
      function enterHydrationState(fiber) {
        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        hydrationErrors = null;
        didSuspendOrErrorDEV = false;
        return true;
      }
      function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
        nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        hydrationErrors = null;
        didSuspendOrErrorDEV = false;
        if (treeContext !== null) {
          restoreSuspendedTreeContext(fiber, treeContext);
        }
        return true;
      }
      function warnUnhydratedInstance(returnFiber, instance) {
        {
          switch (returnFiber.tag) {
            case HostRoot: {
              didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
              break;
            }
            case HostComponent: {
              var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
              didNotHydrateInstance(
                returnFiber.type,
                returnFiber.memoizedProps,
                returnFiber.stateNode,
                instance,
                // TODO: Delete this argument when we remove the legacy root API.
                isConcurrentMode
              );
              break;
            }
            case SuspenseComponent: {
              var suspenseState = returnFiber.memoizedState;
              if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
              break;
            }
          }
        }
      }
      function deleteHydratableInstance(returnFiber, instance) {
        warnUnhydratedInstance(returnFiber, instance);
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance;
        childToDelete.return = returnFiber;
        var deletions = returnFiber.deletions;
        if (deletions === null) {
          returnFiber.deletions = [childToDelete];
          returnFiber.flags |= ChildDeletion;
        } else {
          deletions.push(childToDelete);
        }
      }
      function warnNonhydratedInstance(returnFiber, fiber) {
        {
          if (didSuspendOrErrorDEV) {
            return;
          }
          switch (returnFiber.tag) {
            case HostRoot: {
              var parentContainer = returnFiber.stateNode.containerInfo;
              switch (fiber.tag) {
                case HostComponent:
                  var type = fiber.type;
                  fiber.pendingProps;
                  didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                  break;
                case HostText:
                  var text2 = fiber.pendingProps;
                  didNotFindHydratableTextInstanceWithinContainer(parentContainer, text2);
                  break;
              }
              break;
            }
            case HostComponent: {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              switch (fiber.tag) {
                case HostComponent: {
                  var _type = fiber.type;
                  var _props = fiber.pendingProps;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotFindHydratableInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    _type,
                    _props,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case HostText: {
                  var _text = fiber.pendingProps;
                  var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotFindHydratableTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    _text,
                    // TODO: Delete this argument when we remove the legacy root API.
                    _isConcurrentMode
                  );
                  break;
                }
              }
              break;
            }
            case SuspenseComponent: {
              var suspenseState = returnFiber.memoizedState;
              var _parentInstance = suspenseState.dehydrated;
              if (_parentInstance !== null) switch (fiber.tag) {
                case HostComponent:
                  var _type2 = fiber.type;
                  fiber.pendingProps;
                  didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                  break;
                case HostText:
                  var _text2 = fiber.pendingProps;
                  didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                  break;
              }
              break;
            }
            default:
              return;
          }
        }
      }
      function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.flags = fiber.flags & ~Hydrating | Placement;
        warnNonhydratedInstance(returnFiber, fiber);
      }
      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent: {
            var type = fiber.type;
            fiber.pendingProps;
            var instance = canHydrateInstance(nextInstance, type);
            if (instance !== null) {
              fiber.stateNode = instance;
              hydrationParentFiber = fiber;
              nextHydratableInstance = getFirstHydratableChild(instance);
              return true;
            }
            return false;
          }
          case HostText: {
            var text2 = fiber.pendingProps;
            var textInstance = canHydrateTextInstance(nextInstance, text2);
            if (textInstance !== null) {
              fiber.stateNode = textInstance;
              hydrationParentFiber = fiber;
              nextHydratableInstance = null;
              return true;
            }
            return false;
          }
          case SuspenseComponent: {
            var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
            if (suspenseInstance !== null) {
              var suspenseState = {
                dehydrated: suspenseInstance,
                treeContext: getSuspendedTreeContext(),
                retryLane: OffscreenLane
              };
              fiber.memoizedState = suspenseState;
              var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
              dehydratedFragment.return = fiber;
              fiber.child = dehydratedFragment;
              hydrationParentFiber = fiber;
              nextHydratableInstance = null;
              return true;
            }
            return false;
          }
          default:
            return false;
        }
      }
      function shouldClientRenderOnMismatch(fiber) {
        return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
      }
      function throwOnHydrationMismatch(fiber) {
        throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
      }
      function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating) {
          return;
        }
        var nextInstance = nextHydratableInstance;
        if (!nextInstance) {
          if (shouldClientRenderOnMismatch(fiber)) {
            warnNonhydratedInstance(hydrationParentFiber, fiber);
            throwOnHydrationMismatch();
          }
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }
        var firstAttemptedInstance = nextInstance;
        if (!tryHydrate(fiber, nextInstance)) {
          if (shouldClientRenderOnMismatch(fiber)) {
            warnNonhydratedInstance(hydrationParentFiber, fiber);
            throwOnHydrationMismatch();
          }
          nextInstance = getNextHydratableSibling(firstAttemptedInstance);
          var prevHydrationParentFiber = hydrationParentFiber;
          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
        }
      }
      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        var instance = fiber.stateNode;
        var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
        fiber.updateQueue = updatePayload;
        if (updatePayload !== null) {
          return true;
        }
        return false;
      }
      function prepareToHydrateHostTextInstance(fiber) {
        var textInstance = fiber.stateNode;
        var textContent2 = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent2, fiber);
        if (shouldUpdate) {
          var returnFiber = hydrationParentFiber;
          if (returnFiber !== null) {
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotMatchHydratedContainerTextInstance(
                  parentContainer,
                  textInstance,
                  textContent2,
                  // TODO: Delete this argument when we remove the legacy root API.
                  isConcurrentMode
                );
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotMatchHydratedTextInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  textInstance,
                  textContent2,
                  // TODO: Delete this argument when we remove the legacy root API.
                  _isConcurrentMode2
                );
                break;
              }
            }
          }
        }
        return shouldUpdate;
      }
      function prepareToHydrateHostSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState;
        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance) {
          throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        }
        hydrateSuspenseInstance(suspenseInstance, fiber);
      }
      function skipPastDehydratedSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState;
        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance) {
          throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        }
        return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
      }
      function popToNextHostParent(fiber) {
        var parent = fiber.return;
        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
          parent = parent.return;
        }
        hydrationParentFiber = parent;
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) {
          return false;
        }
        if (!isHydrating) {
          popToNextHostParent(fiber);
          isHydrating = true;
          return false;
        }
        if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
          var nextInstance = nextHydratableInstance;
          if (nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnIfUnhydratedTailNodes(fiber);
              throwOnHydrationMismatch();
            } else {
              while (nextInstance) {
                deleteHydratableInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
              }
            }
          }
        }
        popToNextHostParent(fiber);
        if (fiber.tag === SuspenseComponent) {
          nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
        } else {
          nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        }
        return true;
      }
      function hasUnhydratedTailNodes() {
        return isHydrating && nextHydratableInstance !== null;
      }
      function warnIfUnhydratedTailNodes(fiber) {
        var nextInstance = nextHydratableInstance;
        while (nextInstance) {
          warnUnhydratedInstance(fiber, nextInstance);
          nextInstance = getNextHydratableSibling(nextInstance);
        }
      }
      function resetHydrationState() {
        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating = false;
        didSuspendOrErrorDEV = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        if (hydrationErrors !== null) {
          queueRecoverableErrors(hydrationErrors);
          hydrationErrors = null;
        }
      }
      function getIsHydrating() {
        return isHydrating;
      }
      function queueHydrationError(error2) {
        if (hydrationErrors === null) {
          hydrationErrors = [error2];
        } else {
          hydrationErrors.push(error2);
        }
      }
      var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
      var NoTransition = null;
      function requestCurrentTransition() {
        return ReactCurrentBatchConfig$1.transition;
      }
      var ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function(fiber, instance) {
        },
        flushPendingUnsafeLifecycleWarnings: function() {
        },
        recordLegacyContextWarning: function(fiber, instance) {
        },
        flushLegacyContextWarning: function() {
        },
        discardPendingWarnings: function() {
        }
      };
      {
        var findStrictRoot = function(fiber) {
          var maybeStrictRoot = null;
          var node2 = fiber;
          while (node2 !== null) {
            if (node2.mode & StrictLegacyMode) {
              maybeStrictRoot = node2;
            }
            node2 = node2.return;
          }
          return maybeStrictRoot;
        };
        var setToSortedString = function(set3) {
          var array = [];
          set3.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        };
        var pendingComponentWillMountWarnings = [];
        var pendingUNSAFE_ComponentWillMountWarnings = [];
        var pendingComponentWillReceivePropsWarnings = [];
        var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        var pendingComponentWillUpdateWarnings = [];
        var pendingUNSAFE_ComponentWillUpdateWarnings = [];
        var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
            return;
          }
          if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
          instance.componentWillMount.__suppressDeprecationWarning !== true) {
            pendingComponentWillMountWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
            pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
          }
          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
            pendingComponentWillReceivePropsWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
          }
          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
            pendingComponentWillUpdateWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
            pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
          }
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          if (pendingComponentWillMountWarnings.length > 0) {
            pendingComponentWillMountWarnings.forEach(function(fiber) {
              componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillMountWarnings = [];
          }
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
            pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
              UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillMountWarnings = [];
          }
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          if (pendingComponentWillReceivePropsWarnings.length > 0) {
            pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
              componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillReceivePropsWarnings = [];
          }
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
            pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          }
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          if (pendingComponentWillUpdateWarnings.length > 0) {
            pendingComponentWillUpdateWarnings.forEach(function(fiber) {
              componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillUpdateWarnings = [];
          }
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
            pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
              UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
          }
          if (UNSAFE_componentWillMountUniqueNames.size > 0) {
            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
            error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
          }
          if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
            error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
          }
          if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
            error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
          }
          if (componentWillMountUniqueNames.size > 0) {
            var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
            warn2("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
          }
          if (componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
            warn2("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
          }
          if (componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
            warn2("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
          }
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = findStrictRoot(fiber);
          if (strictRoot === null) {
            error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
            return;
          }
          if (didWarnAboutLegacyContext.has(fiber.type)) {
            return;
          }
          var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
          if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
            if (warningsForRoot === void 0) {
              warningsForRoot = [];
              pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
            }
            warningsForRoot.push(fiber);
          }
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
            if (fiberArray.length === 0) {
              return;
            }
            var firstFiber = fiberArray[0];
            var uniqueNames = /* @__PURE__ */ new Set();
            fiberArray.forEach(function(fiber) {
              uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            try {
              setCurrentFiber(firstFiber);
              error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
            } finally {
              resetCurrentFiber();
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
      }
      var didWarnAboutMaps;
      var didWarnAboutGenerators;
      var didWarnAboutStringRefs;
      var ownerHasKeyUseWarning;
      var ownerHasFunctionTypeWarning;
      var warnForMissingKey = function(child, returnFiber) {
      };
      {
        didWarnAboutMaps = false;
        didWarnAboutGenerators = false;
        didWarnAboutStringRefs = {};
        ownerHasKeyUseWarning = {};
        ownerHasFunctionTypeWarning = {};
        warnForMissingKey = function(child, returnFiber) {
          if (child === null || typeof child !== "object") {
            return;
          }
          if (!child._store || child._store.validated || child.key != null) {
            return;
          }
          if (typeof child._store !== "object") {
            throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
          }
          child._store.validated = true;
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          if (ownerHasKeyUseWarning[componentName]) {
            return;
          }
          ownerHasKeyUseWarning[componentName] = true;
          error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
        };
      }
      function isReactClass(type) {
        return type.prototype && type.prototype.isReactComponent;
      }
      function coerceRef(returnFiber, current2, element) {
        var mixedRef = element.ref;
        if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
          {
            if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
            // because these cannot be automatically converted to an arrow function
            // using a codemod. Therefore, we don't have to warn about string refs again.
            !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
            !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
            !(typeof element.type === "function" && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
            element._owner) {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (!didWarnAboutStringRefs[componentName]) {
                {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);
                }
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
          if (element._owner) {
            var owner = element._owner;
            var inst;
            if (owner) {
              var ownerFiber = owner;
              if (ownerFiber.tag !== ClassComponent) {
                throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
              }
              inst = ownerFiber.stateNode;
            }
            if (!inst) {
              throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
            }
            var resolvedInst = inst;
            {
              checkPropStringCoercion(mixedRef, "ref");
            }
            var stringRef = "" + mixedRef;
            if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
              return current2.ref;
            }
            var ref2 = function(value) {
              var refs = resolvedInst.refs;
              if (value === null) {
                delete refs[stringRef];
              } else {
                refs[stringRef] = value;
              }
            };
            ref2._stringRef = stringRef;
            return ref2;
          } else {
            if (typeof mixedRef !== "string") {
              throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
            }
            if (!element._owner) {
              throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
            }
          }
        }
        return mixedRef;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        var childString = Object.prototype.toString.call(newChild);
        throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
      }
      function warnOnFunctionType(returnFiber) {
        {
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          if (ownerHasFunctionTypeWarning[componentName]) {
            return;
          }
          ownerHasFunctionTypeWarning[componentName] = true;
          error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
        }
      }
      function resolveLazy(lazyType) {
        var payload = lazyType._payload;
        var init = lazyType._init;
        return init(payload);
      }
      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
            return;
          }
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) {
            return null;
          }
          var childToDelete = currentFirstChild;
          while (childToDelete !== null) {
            deleteChild(returnFiber, childToDelete);
            childToDelete = childToDelete.sibling;
          }
          return null;
        }
        function mapRemainingChildren(returnFiber, currentFirstChild) {
          var existingChildren = /* @__PURE__ */ new Map();
          var existingChild = currentFirstChild;
          while (existingChild !== null) {
            if (existingChild.key !== null) {
              existingChildren.set(existingChild.key, existingChild);
            } else {
              existingChildren.set(existingChild.index, existingChild);
            }
            existingChild = existingChild.sibling;
          }
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          var clone = createWorkInProgress(fiber, pendingProps);
          clone.index = 0;
          clone.sibling = null;
          return clone;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects) {
            newFiber.flags |= Forked;
            return lastPlacedIndex;
          }
          var current2 = newFiber.alternate;
          if (current2 !== null) {
            var oldIndex = current2.index;
            if (oldIndex < lastPlacedIndex) {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            } else {
              return oldIndex;
            }
          } else {
            newFiber.flags |= Placement;
            return lastPlacedIndex;
          }
        }
        function placeSingleChild(newFiber) {
          if (shouldTrackSideEffects && newFiber.alternate === null) {
            newFiber.flags |= Placement;
          }
          return newFiber;
        }
        function updateTextNode(returnFiber, current2, textContent2, lanes) {
          if (current2 === null || current2.tag !== HostText) {
            var created = createFiberFromText(textContent2, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current2, textContent2);
            existing.return = returnFiber;
            return existing;
          }
        }
        function updateElement(returnFiber, current2, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE) {
            return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
          }
          if (current2 !== null) {
            if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
            isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
              var existing = useFiber(current2, element.props);
              existing.ref = coerceRef(returnFiber, current2, element);
              existing.return = returnFiber;
              {
                existing._debugSource = element._source;
                existing._debugOwner = element._owner;
              }
              return existing;
            }
          }
          var created = createFiberFromElement(element, returnFiber.mode, lanes);
          created.ref = coerceRef(returnFiber, current2, element);
          created.return = returnFiber;
          return created;
        }
        function updatePortal(returnFiber, current2, portal, lanes) {
          if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current2, portal.children || []);
            existing.return = returnFiber;
            return existing;
          }
        }
        function updateFragment2(returnFiber, current2, fragment, lanes, key2) {
          if (current2 === null || current2.tag !== Fragment) {
            var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key2);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current2, fragment);
            existing.return = returnFiber;
            return existing;
          }
        }
        function createChild(returnFiber, newChild, lanes) {
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE2: {
                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                _created.ref = coerceRef(returnFiber, null, newChild);
                _created.return = returnFiber;
                return _created;
              }
              case REACT_PORTAL_TYPE: {
                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                _created2.return = returnFiber;
                return _created2;
              }
              case REACT_LAZY_TYPE: {
                var payload = newChild._payload;
                var init = newChild._init;
                return createChild(returnFiber, init(payload), lanes);
              }
            }
            if (isArray2(newChild) || getIteratorFn(newChild)) {
              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
              _created3.return = returnFiber;
              return _created3;
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key2 = oldFiber !== null ? oldFiber.key : null;
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            if (key2 !== null) {
              return null;
            }
            return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE2: {
                if (newChild.key === key2) {
                  return updateElement(returnFiber, oldFiber, newChild, lanes);
                } else {
                  return null;
                }
              }
              case REACT_PORTAL_TYPE: {
                if (newChild.key === key2) {
                  return updatePortal(returnFiber, oldFiber, newChild, lanes);
                } else {
                  return null;
                }
              }
              case REACT_LAZY_TYPE: {
                var payload = newChild._payload;
                var init = newChild._init;
                return updateSlot(returnFiber, oldFiber, init(payload), lanes);
              }
            }
            if (isArray2(newChild) || getIteratorFn(newChild)) {
              if (key2 !== null) {
                return null;
              }
              return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE2: {
                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updateElement(returnFiber, _matchedFiber, newChild, lanes);
              }
              case REACT_PORTAL_TYPE: {
                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
              }
              case REACT_LAZY_TYPE:
                var payload = newChild._payload;
                var init = newChild._init;
                return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
            }
            if (isArray2(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber3 = existingChildren.get(newIdx) || null;
              return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function warnOnInvalidKey(child, knownKeys, returnFiber) {
          {
            if (typeof child !== "object" || child === null) {
              return knownKeys;
            }
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE2:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child, returnFiber);
                var key2 = child.key;
                if (typeof key2 !== "string") {
                  break;
                }
                if (knownKeys === null) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key2);
                  break;
                }
                if (!knownKeys.has(key2)) {
                  knownKeys.add(key2);
                  break;
                }
                error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", key2);
                break;
              case REACT_LAZY_TYPE:
                var payload = child._payload;
                var init = child._init;
                warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                break;
            }
          }
          return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          {
            var knownKeys = null;
            for (var i2 = 0; i2 < newChildren.length; i2++) {
              var child = newChildren[i2];
              knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
            }
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }
            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }
              break;
            }
            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }
            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length) {
            deleteRemainingChildren(returnFiber, oldFiber);
            if (getIsHydrating()) {
              var numberOfForks = newIdx;
              pushTreeFork(returnFiber, numberOfForks);
            }
            return resultingFirstChild;
          }
          if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
              if (_newFiber === null) {
                continue;
              }
              lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber;
              } else {
                previousNewFiber.sibling = _newFiber;
              }
              previousNewFiber = _newFiber;
            }
            if (getIsHydrating()) {
              var _numberOfForks = newIdx;
              pushTreeFork(returnFiber, _numberOfForks);
            }
            return resultingFirstChild;
          }
          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
            if (_newFiber2 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber2.alternate !== null) {
                  existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                }
              }
              lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber2;
              } else {
                previousNewFiber.sibling = _newFiber2;
              }
              previousNewFiber = _newFiber2;
            }
          }
          if (shouldTrackSideEffects) {
            existingChildren.forEach(function(child2) {
              return deleteChild(returnFiber, child2);
            });
          }
          if (getIsHydrating()) {
            var _numberOfForks2 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks2);
          }
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          if (typeof iteratorFn !== "function") {
            throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
          }
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            newChildrenIterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (newChildrenIterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
            var _newChildren = iteratorFn.call(newChildrenIterable);
            if (_newChildren) {
              var knownKeys = null;
              var _step = _newChildren.next();
              for (; !_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          if (newChildren == null) {
            throw new Error("An iterable object provided no iterator.");
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          var step = newChildren.next();
          for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }
              break;
            }
            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }
            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done) {
            deleteRemainingChildren(returnFiber, oldFiber);
            if (getIsHydrating()) {
              var numberOfForks = newIdx;
              pushTreeFork(returnFiber, numberOfForks);
            }
            return resultingFirstChild;
          }
          if (oldFiber === null) {
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, lanes);
              if (_newFiber3 === null) {
                continue;
              }
              lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber3;
              } else {
                previousNewFiber.sibling = _newFiber3;
              }
              previousNewFiber = _newFiber3;
            }
            if (getIsHydrating()) {
              var _numberOfForks3 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks3);
            }
            return resultingFirstChild;
          }
          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
            if (_newFiber4 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber4.alternate !== null) {
                  existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                }
              }
              lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber4;
              } else {
                previousNewFiber.sibling = _newFiber4;
              }
              previousNewFiber = _newFiber4;
            }
          }
          if (shouldTrackSideEffects) {
            existingChildren.forEach(function(child2) {
              return deleteChild(returnFiber, child2);
            });
          }
          if (getIsHydrating()) {
            var _numberOfForks4 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks4);
          }
          return resultingFirstChild;
        }
        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent2, lanes) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent2);
            existing.return = returnFiber;
            return existing;
          }
          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created = createFiberFromText(textContent2, returnFiber.mode, lanes);
          created.return = returnFiber;
          return created;
        }
        function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
          var key2 = element.key;
          var child = currentFirstChild;
          while (child !== null) {
            if (child.key === key2) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                if (child.tag === Fragment) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, element.props.children);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              } else {
                if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                // We need to do this after the Hot Reloading check above,
                // because hot reloading has different semantics than prod because
                // it doesn't resuspend. So we can't let the call below suspend.
                typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var _existing = useFiber(child, element.props);
                  _existing.ref = coerceRef(returnFiber, child, element);
                  _existing.return = returnFiber;
                  {
                    _existing._debugSource = element._source;
                    _existing._debugOwner = element._owner;
                  }
                  return _existing;
                }
              }
              deleteRemainingChildren(returnFiber, child);
              break;
            } else {
              deleteChild(returnFiber, child);
            }
            child = child.sibling;
          }
          if (element.type === REACT_FRAGMENT_TYPE) {
            var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
            created.return = returnFiber;
            return created;
          } else {
            var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
            _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
            _created4.return = returnFiber;
            return _created4;
          }
        }
        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
          var key2 = portal.key;
          var child = currentFirstChild;
          while (child !== null) {
            if (child.key === key2) {
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || []);
                existing.return = returnFiber;
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }
            child = child.sibling;
          }
          var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
          created.return = returnFiber;
          return created;
        }
        function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
          var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
          if (isUnkeyedTopLevelFragment) {
            newChild = newChild.props.children;
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE2:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_LAZY_TYPE:
                var payload = newChild._payload;
                var init = newChild._init;
                return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
            }
            if (isArray2(newChild)) {
              return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
            }
            if (getIteratorFn(newChild)) {
              return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return reconcileChildFibers2;
      }
      var reconcileChildFibers = ChildReconciler(true);
      var mountChildFibers = ChildReconciler(false);
      function cloneChildFibers(current2, workInProgress2) {
        if (current2 !== null && workInProgress2.child !== current2.child) {
          throw new Error("Resuming work not yet implemented.");
        }
        if (workInProgress2.child === null) {
          return;
        }
        var currentChild = workInProgress2.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
        workInProgress2.child = newChild;
        newChild.return = workInProgress2;
        while (currentChild.sibling !== null) {
          currentChild = currentChild.sibling;
          newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
          newChild.return = workInProgress2;
        }
        newChild.sibling = null;
      }
      function resetChildFibers(workInProgress2, lanes) {
        var child = workInProgress2.child;
        while (child !== null) {
          resetWorkInProgress(child, lanes);
          child = child.sibling;
        }
      }
      var valueCursor = createCursor(null);
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var currentlyRenderingFiber = null;
      var lastContextDependency = null;
      var lastFullyObservedContext = null;
      var isDisallowedContextReadInDEV = false;
      function resetContextDependencies() {
        currentlyRenderingFiber = null;
        lastContextDependency = null;
        lastFullyObservedContext = null;
        {
          isDisallowedContextReadInDEV = false;
        }
      }
      function enterDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = true;
        }
      }
      function exitDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = false;
        }
      }
      function pushProvider(providerFiber, context, nextValue) {
        {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          {
            if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
      }
      function popProvider(context, providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        {
          {
            context._currentValue = currentValue;
          }
        }
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        var node2 = parent;
        while (node2 !== null) {
          var alternate = node2.alternate;
          if (!isSubsetOfLanes(node2.childLanes, renderLanes2)) {
            node2.childLanes = mergeLanes(node2.childLanes, renderLanes2);
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
          } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
            alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
          }
          if (node2 === propagationRoot) {
            break;
          }
          node2 = node2.return;
        }
        {
          if (node2 !== propagationRoot) {
            error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
      }
      function propagateContextChange(workInProgress2, context, renderLanes2) {
        {
          propagateContextChange_eager(workInProgress2, context, renderLanes2);
        }
      }
      function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
        var fiber = workInProgress2.child;
        if (fiber !== null) {
          fiber.return = workInProgress2;
        }
        while (fiber !== null) {
          var nextFiber = void 0;
          var list2 = fiber.dependencies;
          if (list2 !== null) {
            nextFiber = fiber.child;
            var dependency = list2.firstContext;
            while (dependency !== null) {
              if (dependency.context === context) {
                if (fiber.tag === ClassComponent) {
                  var lane = pickArbitraryLane(renderLanes2);
                  var update = createUpdate(NoTimestamp, lane);
                  update.tag = ForceUpdate;
                  var updateQueue2 = fiber.updateQueue;
                  if (updateQueue2 === null) ;
                  else {
                    var sharedQueue = updateQueue2.shared;
                    var pending = sharedQueue.pending;
                    if (pending === null) {
                      update.next = update;
                    } else {
                      update.next = pending.next;
                      pending.next = update;
                    }
                    sharedQueue.pending = update;
                  }
                }
                fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                var alternate = fiber.alternate;
                if (alternate !== null) {
                  alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                list2.lanes = mergeLanes(list2.lanes, renderLanes2);
                break;
              }
              dependency = dependency.next;
            }
          } else if (fiber.tag === ContextProvider) {
            nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
          } else if (fiber.tag === DehydratedFragment) {
            var parentSuspense = fiber.return;
            if (parentSuspense === null) {
              throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
            }
            parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
            var _alternate = parentSuspense.alternate;
            if (_alternate !== null) {
              _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
            nextFiber = fiber.sibling;
          } else {
            nextFiber = fiber.child;
          }
          if (nextFiber !== null) {
            nextFiber.return = fiber;
          } else {
            nextFiber = fiber;
            while (nextFiber !== null) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              var sibling = nextFiber.sibling;
              if (sibling !== null) {
                sibling.return = nextFiber.return;
                nextFiber = sibling;
                break;
              }
              nextFiber = nextFiber.return;
            }
          }
          fiber = nextFiber;
        }
      }
      function prepareToReadContext(workInProgress2, renderLanes2) {
        currentlyRenderingFiber = workInProgress2;
        lastContextDependency = null;
        lastFullyObservedContext = null;
        var dependencies = workInProgress2.dependencies;
        if (dependencies !== null) {
          {
            var firstContext = dependencies.firstContext;
            if (firstContext !== null) {
              if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                markWorkInProgressReceivedUpdate();
              }
              dependencies.firstContext = null;
            }
          }
        }
      }
      function readContext(context) {
        {
          if (isDisallowedContextReadInDEV) {
            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          }
        }
        var value = context._currentValue;
        if (lastFullyObservedContext === context) ;
        else {
          var contextItem = {
            context,
            memoizedValue: value,
            next: null
          };
          if (lastContextDependency === null) {
            if (currentlyRenderingFiber === null) {
              throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
            lastContextDependency = contextItem;
            currentlyRenderingFiber.dependencies = {
              lanes: NoLanes,
              firstContext: contextItem
            };
          } else {
            lastContextDependency = lastContextDependency.next = contextItem;
          }
        }
        return value;
      }
      var concurrentQueues = null;
      function pushConcurrentUpdateQueue(queue) {
        if (concurrentQueues === null) {
          concurrentQueues = [queue];
        } else {
          concurrentQueues.push(queue);
        }
      }
      function finishQueueingConcurrentUpdates() {
        if (concurrentQueues !== null) {
          for (var i2 = 0; i2 < concurrentQueues.length; i2++) {
            var queue = concurrentQueues[i2];
            var lastInterleavedUpdate = queue.interleaved;
            if (lastInterleavedUpdate !== null) {
              queue.interleaved = null;
              var firstInterleavedUpdate = lastInterleavedUpdate.next;
              var lastPendingUpdate = queue.pending;
              if (lastPendingUpdate !== null) {
                var firstPendingUpdate = lastPendingUpdate.next;
                lastPendingUpdate.next = firstInterleavedUpdate;
                lastInterleavedUpdate.next = firstPendingUpdate;
              }
              queue.pending = lastInterleavedUpdate;
            }
          }
          concurrentQueues = null;
        }
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue.interleaved = update;
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue.interleaved = update;
      }
      function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue.interleaved = update;
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
      function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
        var alternate = sourceFiber.alternate;
        if (alternate !== null) {
          alternate.lanes = mergeLanes(alternate.lanes, lane);
        }
        {
          if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          }
        }
        var node2 = sourceFiber;
        var parent = sourceFiber.return;
        while (parent !== null) {
          parent.childLanes = mergeLanes(parent.childLanes, lane);
          alternate = parent.alternate;
          if (alternate !== null) {
            alternate.childLanes = mergeLanes(alternate.childLanes, lane);
          } else {
            {
              if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
          }
          node2 = parent;
          parent = parent.return;
        }
        if (node2.tag === HostRoot) {
          var root3 = node2.stateNode;
          return root3;
        } else {
          return null;
        }
      }
      var UpdateState = 0;
      var ReplaceState = 1;
      var ForceUpdate = 2;
      var CaptureUpdate = 3;
      var hasForceUpdate = false;
      var didWarnUpdateInsideUpdate;
      var currentlyProcessingQueue;
      {
        didWarnUpdateInsideUpdate = false;
        currentlyProcessingQueue = null;
      }
      function initializeUpdateQueue(fiber) {
        var queue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: {
            pending: null,
            interleaved: null,
            lanes: NoLanes
          },
          effects: null
        };
        fiber.updateQueue = queue;
      }
      function cloneUpdateQueue(current2, workInProgress2) {
        var queue = workInProgress2.updateQueue;
        var currentQueue = current2.updateQueue;
        if (queue === currentQueue) {
          var clone = {
            baseState: currentQueue.baseState,
            firstBaseUpdate: currentQueue.firstBaseUpdate,
            lastBaseUpdate: currentQueue.lastBaseUpdate,
            shared: currentQueue.shared,
            effects: currentQueue.effects
          };
          workInProgress2.updateQueue = clone;
        }
      }
      function createUpdate(eventTime, lane) {
        var update = {
          eventTime,
          lane,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null
        };
        return update;
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue2 = fiber.updateQueue;
        if (updateQueue2 === null) {
          return null;
        }
        var sharedQueue = updateQueue2.shared;
        {
          if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
            error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
            didWarnUpdateInsideUpdate = true;
          }
        }
        if (isUnsafeClassRenderPhaseUpdate()) {
          var pending = sharedQueue.pending;
          if (pending === null) {
            update.next = update;
          } else {
            update.next = pending.next;
            pending.next = update;
          }
          sharedQueue.pending = update;
          return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
        } else {
          return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
        }
      }
      function entangleTransitions(root3, fiber, lane) {
        var updateQueue2 = fiber.updateQueue;
        if (updateQueue2 === null) {
          return;
        }
        var sharedQueue = updateQueue2.shared;
        if (isTransitionLane(lane)) {
          var queueLanes = sharedQueue.lanes;
          queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
          var newQueueLanes = mergeLanes(queueLanes, lane);
          sharedQueue.lanes = newQueueLanes;
          markRootEntangled(root3, newQueueLanes);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue;
        var current2 = workInProgress2.alternate;
        if (current2 !== null) {
          var currentQueue = current2.updateQueue;
          if (queue === currentQueue) {
            var newFirst = null;
            var newLast = null;
            var firstBaseUpdate = queue.firstBaseUpdate;
            if (firstBaseUpdate !== null) {
              var update = firstBaseUpdate;
              do {
                var clone = {
                  eventTime: update.eventTime,
                  lane: update.lane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                if (newLast === null) {
                  newFirst = newLast = clone;
                } else {
                  newLast.next = clone;
                  newLast = clone;
                }
                update = update.next;
              } while (update !== null);
              if (newLast === null) {
                newFirst = newLast = capturedUpdate;
              } else {
                newLast.next = capturedUpdate;
                newLast = capturedUpdate;
              }
            } else {
              newFirst = newLast = capturedUpdate;
            }
            queue = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = queue;
            return;
          }
        }
        var lastBaseUpdate = queue.lastBaseUpdate;
        if (lastBaseUpdate === null) {
          queue.firstBaseUpdate = capturedUpdate;
        } else {
          lastBaseUpdate.next = capturedUpdate;
        }
        queue.lastBaseUpdate = capturedUpdate;
      }
      function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
        switch (update.tag) {
          case ReplaceState: {
            var payload = update.payload;
            if (typeof payload === "function") {
              {
                enterDisallowedContextReadInDEV();
              }
              var nextState = payload.call(instance, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    payload.call(instance, prevState, nextProps);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                exitDisallowedContextReadInDEV();
              }
              return nextState;
            }
            return payload;
          }
          case CaptureUpdate: {
            workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
          }
          case UpdateState: {
            var _payload = update.payload;
            var partialState;
            if (typeof _payload === "function") {
              {
                enterDisallowedContextReadInDEV();
              }
              partialState = _payload.call(instance, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    _payload.call(instance, prevState, nextProps);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                exitDisallowedContextReadInDEV();
              }
            } else {
              partialState = _payload;
            }
            if (partialState === null || partialState === void 0) {
              return prevState;
            }
            return assign2({}, prevState, partialState);
          }
          case ForceUpdate: {
            hasForceUpdate = true;
            return prevState;
          }
        }
        return prevState;
      }
      function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
        var queue = workInProgress2.updateQueue;
        hasForceUpdate = false;
        {
          currentlyProcessingQueue = queue.shared;
        }
        var firstBaseUpdate = queue.firstBaseUpdate;
        var lastBaseUpdate = queue.lastBaseUpdate;
        var pendingQueue = queue.shared.pending;
        if (pendingQueue !== null) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue;
          var firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          if (lastBaseUpdate === null) {
            firstBaseUpdate = firstPendingUpdate;
          } else {
            lastBaseUpdate.next = firstPendingUpdate;
          }
          lastBaseUpdate = lastPendingUpdate;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue = current2.updateQueue;
            var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
            if (currentLastBaseUpdate !== lastBaseUpdate) {
              if (currentLastBaseUpdate === null) {
                currentQueue.firstBaseUpdate = firstPendingUpdate;
              } else {
                currentLastBaseUpdate.next = firstPendingUpdate;
              }
              currentQueue.lastBaseUpdate = lastPendingUpdate;
            }
          }
        }
        if (firstBaseUpdate !== null) {
          var newState = queue.baseState;
          var newLanes = NoLanes;
          var newBaseState = null;
          var newFirstBaseUpdate = null;
          var newLastBaseUpdate = null;
          var update = firstBaseUpdate;
          do {
            var updateLane = update.lane;
            var updateEventTime = update.eventTime;
            if (!isSubsetOfLanes(renderLanes2, updateLane)) {
              var clone = {
                eventTime: updateEventTime,
                lane: updateLane,
                tag: update.tag,
                payload: update.payload,
                callback: update.callback,
                next: null
              };
              if (newLastBaseUpdate === null) {
                newFirstBaseUpdate = newLastBaseUpdate = clone;
                newBaseState = newState;
              } else {
                newLastBaseUpdate = newLastBaseUpdate.next = clone;
              }
              newLanes = mergeLanes(newLanes, updateLane);
            } else {
              if (newLastBaseUpdate !== null) {
                var _clone = {
                  eventTime: updateEventTime,
                  // This update is going to be committed so we never want uncommit
                  // it. Using NoLane works because 0 is a subset of all bitmasks, so
                  // this will never be skipped by the check above.
                  lane: NoLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                newLastBaseUpdate = newLastBaseUpdate.next = _clone;
              }
              newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
              var callback = update.callback;
              if (callback !== null && // If the update was already committed, we should not queue its
              // callback again.
              update.lane !== NoLane) {
                workInProgress2.flags |= Callback;
                var effects = queue.effects;
                if (effects === null) {
                  queue.effects = [update];
                } else {
                  effects.push(update);
                }
              }
            }
            update = update.next;
            if (update === null) {
              pendingQueue = queue.shared.pending;
              if (pendingQueue === null) {
                break;
              } else {
                var _lastPendingUpdate = pendingQueue;
                var _firstPendingUpdate = _lastPendingUpdate.next;
                _lastPendingUpdate.next = null;
                update = _firstPendingUpdate;
                queue.lastBaseUpdate = _lastPendingUpdate;
                queue.shared.pending = null;
              }
            }
          } while (true);
          if (newLastBaseUpdate === null) {
            newBaseState = newState;
          }
          queue.baseState = newBaseState;
          queue.firstBaseUpdate = newFirstBaseUpdate;
          queue.lastBaseUpdate = newLastBaseUpdate;
          var lastInterleaved = queue.shared.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              newLanes = mergeLanes(newLanes, interleaved.lane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (firstBaseUpdate === null) {
            queue.shared.lanes = NoLanes;
          }
          markSkippedUpdateLanes(newLanes);
          workInProgress2.lanes = newLanes;
          workInProgress2.memoizedState = newState;
        }
        {
          currentlyProcessingQueue = null;
        }
      }
      function callCallback(callback, context) {
        if (typeof callback !== "function") {
          throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
        }
        callback.call(context);
      }
      function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = false;
      }
      function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
      }
      function commitUpdateQueue(finishedWork, finishedQueue, instance) {
        var effects = finishedQueue.effects;
        finishedQueue.effects = null;
        if (effects !== null) {
          for (var i2 = 0; i2 < effects.length; i2++) {
            var effect = effects[i2];
            var callback = effect.callback;
            if (callback !== null) {
              effect.callback = null;
              callCallback(callback, instance);
            }
          }
        }
      }
      var NO_CONTEXT = {};
      var contextStackCursor$1 = createCursor(NO_CONTEXT);
      var contextFiberStackCursor = createCursor(NO_CONTEXT);
      var rootInstanceStackCursor = createCursor(NO_CONTEXT);
      function requiredContext(c) {
        if (c === NO_CONTEXT) {
          throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
        }
        return c;
      }
      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance);
        pop(contextStackCursor$1, fiber);
        push(contextStackCursor$1, nextRootContext, fiber);
      }
      function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }
      function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
      }
      function pushHostContext(fiber) {
        requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor$1.current);
        var nextContext = getChildHostContext(context, fiber.type);
        if (context === nextContext) {
          return;
        }
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, nextContext, fiber);
      }
      function popHostContext(fiber) {
        if (contextFiberStackCursor.current !== fiber) {
          return;
        }
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
      }
      var DefaultSuspenseContext = 0;
      var SubtreeSuspenseContextMask = 1;
      var InvisibleParentSuspenseContext = 1;
      var ForceSuspenseFallback = 2;
      var suspenseStackCursor = createCursor(DefaultSuspenseContext);
      function hasSuspenseContext(parentContext, flag) {
        return (parentContext & flag) !== 0;
      }
      function setDefaultShallowSuspenseContext(parentContext) {
        return parentContext & SubtreeSuspenseContextMask;
      }
      function setShallowSuspenseContext(parentContext, shallowContext) {
        return parentContext & SubtreeSuspenseContextMask | shallowContext;
      }
      function addSubtreeSuspenseContext(parentContext, subtreeContext) {
        return parentContext | subtreeContext;
      }
      function pushSuspenseContext(fiber, newContext) {
        push(suspenseStackCursor, newContext, fiber);
      }
      function popSuspenseContext(fiber) {
        pop(suspenseStackCursor, fiber);
      }
      function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
        var nextState = workInProgress2.memoizedState;
        if (nextState !== null) {
          if (nextState.dehydrated !== null) {
            return true;
          }
          return false;
        }
        workInProgress2.memoizedProps;
        {
          return true;
        }
      }
      function findFirstSuspended(row) {
        var node2 = row;
        while (node2 !== null) {
          if (node2.tag === SuspenseComponent) {
            var state = node2.memoizedState;
            if (state !== null) {
              var dehydrated = state.dehydrated;
              if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                return node2;
              }
            }
          } else if (node2.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
          // keep track of whether it suspended or not.
          node2.memoizedProps.revealOrder !== void 0) {
            var didSuspend = (node2.flags & DidCapture) !== NoFlags;
            if (didSuspend) {
              return node2;
            }
          } else if (node2.child !== null) {
            node2.child.return = node2;
            node2 = node2.child;
            continue;
          }
          if (node2 === row) {
            return null;
          }
          while (node2.sibling === null) {
            if (node2.return === null || node2.return === row) {
              return null;
            }
            node2 = node2.return;
          }
          node2.sibling.return = node2.return;
          node2 = node2.sibling;
        }
        return null;
      }
      var NoFlags$1 = (
        /*   */
        0
      );
      var HasEffect = (
        /* */
        1
      );
      var Insertion = (
        /*  */
        2
      );
      var Layout2 = (
        /*    */
        4
      );
      var Passive$1 = (
        /*   */
        8
      );
      var workInProgressSources = [];
      function resetWorkInProgressVersions() {
        for (var i2 = 0; i2 < workInProgressSources.length; i2++) {
          var mutableSource = workInProgressSources[i2];
          {
            mutableSource._workInProgressVersionPrimary = null;
          }
        }
        workInProgressSources.length = 0;
      }
      function registerMutableSourceForHydration(root3, mutableSource) {
        var getVersion = mutableSource._getVersion;
        var version = getVersion(mutableSource._source);
        if (root3.mutableSourceEagerHydrationData == null) {
          root3.mutableSourceEagerHydrationData = [mutableSource, version];
        } else {
          root3.mutableSourceEagerHydrationData.push(mutableSource, version);
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
      var didWarnAboutMismatchedHooksForComponent;
      var didWarnUncachedGetSnapshot;
      {
        didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
      }
      var renderLanes = NoLanes;
      var currentlyRenderingFiber$1 = null;
      var currentHook = null;
      var workInProgressHook = null;
      var didScheduleRenderPhaseUpdate = false;
      var didScheduleRenderPhaseUpdateDuringThisPass = false;
      var localIdCounter = 0;
      var globalClientIdCounter = 0;
      var RE_RENDER_LIMIT = 25;
      var currentHookNameInDev = null;
      var hookTypesDev = null;
      var hookTypesUpdateIndexDev = -1;
      var ignorePreviousDependencies = false;
      function mountHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          if (hookTypesDev === null) {
            hookTypesDev = [hookName];
          } else {
            hookTypesDev.push(hookName);
          }
        }
      }
      function updateHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          if (hookTypesDev !== null) {
            hookTypesUpdateIndexDev++;
            if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
              warnOnHookMismatchInDev(hookName);
            }
          }
        }
      }
      function checkDepsAreArrayDev(deps) {
        {
          if (deps !== void 0 && deps !== null && !isArray2(deps)) {
            error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
          }
        }
      }
      function warnOnHookMismatchInDev(currentHookName) {
        {
          var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
          if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
            didWarnAboutMismatchedHooksForComponent.add(componentName);
            if (hookTypesDev !== null) {
              var table = "";
              var secondColumnStart = 30;
              for (var i2 = 0; i2 <= hookTypesUpdateIndexDev; i2++) {
                var oldHookName = hookTypesDev[i2];
                var newHookName = i2 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                var row = i2 + 1 + ". " + oldHookName;
                while (row.length < secondColumnStart) {
                  row += " ";
                }
                row += newHookName + "\n";
                table += row;
              }
              error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
            }
          }
        }
      }
      function throwInvalidHookError() {
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        {
          if (ignorePreviousDependencies) {
            return false;
          }
        }
        if (prevDeps === null) {
          {
            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
          }
        }
        for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
          if (objectIs(nextDeps[i2], prevDeps[i2])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber$1 = workInProgress2;
        {
          hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
        }
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = NoLanes;
        {
          if (current2 !== null && current2.memoizedState !== null) {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
          } else if (hookTypesDev !== null) {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
          } else {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
          }
        }
        var children2 = Component(props, secondArg);
        if (didScheduleRenderPhaseUpdateDuringThisPass) {
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
            if (numberOfReRenders >= RE_RENDER_LIMIT) {
              throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
            numberOfReRenders += 1;
            {
              ignorePreviousDependencies = false;
            }
            currentHook = null;
            workInProgressHook = null;
            workInProgress2.updateQueue = null;
            {
              hookTypesUpdateIndexDev = -1;
            }
            ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
            children2 = Component(props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
        }
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        {
          workInProgress2._debugHookTypes = hookTypesDev;
        }
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        renderLanes = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook = null;
        workInProgressHook = null;
        {
          currentHookNameInDev = null;
          hookTypesDev = null;
          hookTypesUpdateIndexDev = -1;
          if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
          // and creates false positives. To make this work in legacy mode, we'd
          // need to mark fibers that commit in an incomplete state, somehow. For
          // now I'll disable the warning that most of the bugs that would trigger
          // it are either exclusive to concurrent mode or exist in both.
          (current2.mode & ConcurrentMode) !== NoMode) {
            error("Internal React error: Expected static flag was missing. Please notify the React team.");
          }
        }
        didScheduleRenderPhaseUpdate = false;
        if (didRenderTooFewHooks) {
          throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
        }
        return children2;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current2, workInProgress2, lanes) {
        workInProgress2.updateQueue = current2.updateQueue;
        if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
          workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
        } else {
          workInProgress2.flags &= ~(Passive | Update);
        }
        current2.lanes = removeLanes(current2.lanes, lanes);
      }
      function resetHooksAfterThrow() {
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        if (didScheduleRenderPhaseUpdate) {
          var hook = currentlyRenderingFiber$1.memoizedState;
          while (hook !== null) {
            var queue = hook.queue;
            if (queue !== null) {
              queue.pending = null;
            }
            hook = hook.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook = null;
        workInProgressHook = null;
        {
          hookTypesDev = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          isUpdatingOpaqueValueInRenderPhase = false;
        }
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        localIdCounter = 0;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        if (workInProgressHook === null) {
          currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
        } else {
          workInProgressHook = workInProgressHook.next = hook;
        }
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        var nextCurrentHook;
        if (currentHook === null) {
          var current2 = currentlyRenderingFiber$1.alternate;
          if (current2 !== null) {
            nextCurrentHook = current2.memoizedState;
          } else {
            nextCurrentHook = null;
          }
        } else {
          nextCurrentHook = currentHook.next;
        }
        var nextWorkInProgressHook;
        if (workInProgressHook === null) {
          nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
        } else {
          nextWorkInProgressHook = workInProgressHook.next;
        }
        if (nextWorkInProgressHook !== null) {
          workInProgressHook = nextWorkInProgressHook;
          nextWorkInProgressHook = workInProgressHook.next;
          currentHook = nextCurrentHook;
        } else {
          if (nextCurrentHook === null) {
            throw new Error("Rendered more hooks than during the previous render.");
          }
          currentHook = nextCurrentHook;
          var newHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
          } else {
            workInProgressHook = workInProgressHook.next = newHook;
          }
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return {
          lastEffect: null,
          stores: null
        };
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        var initialState;
        if (init !== void 0) {
          initialState = init(initialArg);
        } else {
          initialState = initialArg;
        }
        hook.memoizedState = hook.baseState = initialState;
        var queue = {
          pending: null,
          interleaved: null,
          lanes: NoLanes,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = queue;
        var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }
      function updateReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        if (queue === null) {
          throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        }
        queue.lastRenderedReducer = reducer;
        var current2 = currentHook;
        var baseQueue = current2.baseQueue;
        var pendingQueue = queue.pending;
        if (pendingQueue !== null) {
          if (baseQueue !== null) {
            var baseFirst = baseQueue.next;
            var pendingFirst = pendingQueue.next;
            baseQueue.next = pendingFirst;
            pendingQueue.next = baseFirst;
          }
          {
            if (current2.baseQueue !== baseQueue) {
              error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
            }
          }
          current2.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        if (baseQueue !== null) {
          var first = baseQueue.next;
          var newState = current2.baseState;
          var newBaseState = null;
          var newBaseQueueFirst = null;
          var newBaseQueueLast = null;
          var update = first;
          do {
            var updateLane = update.lane;
            if (!isSubsetOfLanes(renderLanes, updateLane)) {
              var clone = {
                lane: updateLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              };
              if (newBaseQueueLast === null) {
                newBaseQueueFirst = newBaseQueueLast = clone;
                newBaseState = newState;
              } else {
                newBaseQueueLast = newBaseQueueLast.next = clone;
              }
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
              markSkippedUpdateLanes(updateLane);
            } else {
              if (newBaseQueueLast !== null) {
                var _clone = {
                  // This update is going to be committed so we never want uncommit
                  // it. Using NoLane works because 0 is a subset of all bitmasks, so
                  // this will never be skipped by the check above.
                  lane: NoLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                };
                newBaseQueueLast = newBaseQueueLast.next = _clone;
              }
              if (update.hasEagerState) {
                newState = update.eagerState;
              } else {
                var action = update.action;
                newState = reducer(newState, action);
              }
            }
            update = update.next;
          } while (update !== null && update !== first);
          if (newBaseQueueLast === null) {
            newBaseState = newState;
          } else {
            newBaseQueueLast.next = newBaseQueueFirst;
          }
          if (!objectIs(newState, hook.memoizedState)) {
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = newState;
          hook.baseState = newBaseState;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = newState;
        }
        var lastInterleaved = queue.interleaved;
        if (lastInterleaved !== null) {
          var interleaved = lastInterleaved;
          do {
            var interleavedLane = interleaved.lane;
            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
            markSkippedUpdateLanes(interleavedLane);
            interleaved = interleaved.next;
          } while (interleaved !== lastInterleaved);
        } else if (baseQueue === null) {
          queue.lanes = NoLanes;
        }
        var dispatch = queue.dispatch;
        return [hook.memoizedState, dispatch];
      }
      function rerenderReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        if (queue === null) {
          throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        }
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch;
        var lastRenderPhaseUpdate = queue.pending;
        var newState = hook.memoizedState;
        if (lastRenderPhaseUpdate !== null) {
          queue.pending = null;
          var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          var update = firstRenderPhaseUpdate;
          do {
            var action = update.action;
            newState = reducer(newState, action);
            update = update.next;
          } while (update !== firstRenderPhaseUpdate);
          if (!objectIs(newState, hook.memoizedState)) {
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = newState;
          if (hook.baseQueue === null) {
            hook.baseState = newState;
          }
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function mountMutableSource(source, getSnapshot, subscribe) {
        {
          return void 0;
        }
      }
      function updateMutableSource(source, getSnapshot, subscribe) {
        {
          return void 0;
        }
      }
      function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1;
        var hook = mountWorkInProgressHook();
        var nextSnapshot;
        var isHydrating2 = getIsHydrating();
        if (isHydrating2) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          nextSnapshot = getServerSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              if (nextSnapshot !== getServerSnapshot()) {
                error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
        } else {
          nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var root3 = getWorkInProgressRoot();
          if (root3 === null) {
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          }
          if (!includesBlockingLane(root3, renderLanes)) {
            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
        }
        hook.memoizedState = nextSnapshot;
        var inst = {
          value: nextSnapshot,
          getSnapshot
        };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
        fiber.flags |= Passive;
        pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
        return nextSnapshot;
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1;
        var hook = updateWorkInProgressHook();
        var nextSnapshot = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            if (!objectIs(nextSnapshot, cachedSnapshot)) {
              error("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var prevSnapshot = hook.memoizedState;
        var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
        if (snapshotChanged) {
          hook.memoizedState = nextSnapshot;
          markWorkInProgressReceivedUpdate();
        }
        var inst = hook.queue;
        updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
        if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
        // checking whether we scheduled a subscription effect above.
        workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          var root3 = getWorkInProgressRoot();
          if (root3 === null) {
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          }
          if (!includesBlockingLane(root3, renderLanes)) {
            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
        }
        return nextSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= StoreConsistency;
        var check = {
          getSnapshot,
          value: renderedSnapshot
        };
        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
          componentUpdateQueue.stores = [check];
        } else {
          var stores = componentUpdateQueue.stores;
          if (stores === null) {
            componentUpdateQueue.stores = [check];
          } else {
            stores.push(check);
          }
        }
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        if (checkIfSnapshotChanged(inst)) {
          forceStoreRerender(fiber);
        }
      }
      function subscribeToStore(fiber, inst, subscribe) {
        var handleStoreChange = function() {
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        };
        return subscribe(handleStoreChange);
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
        if (root3 !== null) {
          scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
        }
      }
      function mountState(initialState) {
        var hook = mountWorkInProgressHook();
        if (typeof initialState === "function") {
          initialState = initialState();
        }
        hook.memoizedState = hook.baseState = initialState;
        var queue = {
          pending: null,
          interleaved: null,
          lanes: NoLanes,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        hook.queue = queue;
        var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }
      function updateState(initialState) {
        return updateReducer(basicStateReducer);
      }
      function rerenderState(initialState) {
        return rerenderReducer(basicStateReducer);
      }
      function pushEffect(tag, create2, destroy, deps) {
        var effect = {
          tag,
          create: create2,
          destroy,
          deps,
          // Circular
          next: null
        };
        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
          componentUpdateQueue.lastEffect = effect.next = effect;
        } else {
          var lastEffect = componentUpdateQueue.lastEffect;
          if (lastEffect === null) {
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var firstEffect = lastEffect.next;
            lastEffect.next = effect;
            effect.next = firstEffect;
            componentUpdateQueue.lastEffect = effect;
          }
        }
        return effect;
      }
      function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        {
          var _ref2 = {
            current: initialValue
          };
          hook.memoizedState = _ref2;
          return _ref2;
        }
      }
      function updateRef(initialValue) {
        var hook = updateWorkInProgressHook();
        return hook.memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, void 0, nextDeps);
      }
      function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var destroy = void 0;
        if (currentHook !== null) {
          var prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;
          if (nextDeps !== null) {
            var prevDeps = prevEffect.deps;
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              hook.memoizedState = pushEffect(hookFlags, create2, destroy, nextDeps);
              return;
            }
          }
        }
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, destroy, nextDeps);
      }
      function mountEffect(create2, deps) {
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create2, deps);
        } else {
          return mountEffectImpl(Passive | PassiveStatic, Passive$1, create2, deps);
        }
      }
      function updateEffect(create2, deps) {
        return updateEffectImpl(Passive, Passive$1, create2, deps);
      }
      function mountInsertionEffect(create2, deps) {
        return mountEffectImpl(Update, Insertion, create2, deps);
      }
      function updateInsertionEffect(create2, deps) {
        return updateEffectImpl(Update, Insertion, create2, deps);
      }
      function mountLayoutEffect(create2, deps) {
        var fiberFlags = Update;
        {
          fiberFlags |= LayoutStatic;
        }
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          fiberFlags |= MountLayoutDev;
        }
        return mountEffectImpl(fiberFlags, Layout2, create2, deps);
      }
      function updateLayoutEffect(create2, deps) {
        return updateEffectImpl(Update, Layout2, create2, deps);
      }
      function imperativeHandleEffect(create2, ref2) {
        if (typeof ref2 === "function") {
          var refCallback = ref2;
          var _inst = create2();
          refCallback(_inst);
          return function() {
            refCallback(null);
          };
        } else if (ref2 !== null && ref2 !== void 0) {
          var refObject = ref2;
          {
            if (!refObject.hasOwnProperty("current")) {
              error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
            }
          }
          var _inst2 = create2();
          refObject.current = _inst2;
          return function() {
            refObject.current = null;
          };
        }
      }
      function mountImperativeHandle(ref2, create2, deps) {
        {
          if (typeof create2 !== "function") {
            error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
          }
        }
        var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref2]) : null;
        var fiberFlags = Update;
        {
          fiberFlags |= LayoutStatic;
        }
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          fiberFlags |= MountLayoutDev;
        }
        return mountEffectImpl(fiberFlags, Layout2, imperativeHandleEffect.bind(null, create2, ref2), effectDeps);
      }
      function updateImperativeHandle(ref2, create2, deps) {
        {
          if (typeof create2 !== "function") {
            error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
          }
        }
        var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref2]) : null;
        return updateEffectImpl(Update, Layout2, imperativeHandleEffect.bind(null, create2, ref2), effectDeps);
      }
      function mountDebugValue(value, formatterFn) {
      }
      var updateDebugValue = mountDebugValue;
      function mountCallback(callback, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        hook.memoizedState = [callback, nextDeps];
        return callback;
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }
        hook.memoizedState = [callback, nextDeps];
        return callback;
      }
      function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }
        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function mountDeferredValue(value) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = value;
        return value;
      }
      function updateDeferredValue(value) {
        var hook = updateWorkInProgressHook();
        var resolvedCurrentHook = currentHook;
        var prevValue = resolvedCurrentHook.memoizedState;
        return updateDeferredValueImpl(hook, prevValue, value);
      }
      function rerenderDeferredValue(value) {
        var hook = updateWorkInProgressHook();
        if (currentHook === null) {
          hook.memoizedState = value;
          return value;
        } else {
          var prevValue = currentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value);
        }
      }
      function updateDeferredValueImpl(hook, prevValue, value) {
        var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
        if (shouldDeferValue) {
          if (!objectIs(value, prevValue)) {
            var deferredLane = claimNextTransitionLane();
            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
            markSkippedUpdateLanes(deferredLane);
            hook.baseState = true;
          }
          return prevValue;
        } else {
          if (hook.baseState) {
            hook.baseState = false;
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = value;
          return value;
        }
      }
      function startTransition(setPending, callback, options2) {
        var previousPriority = getCurrentUpdatePriority();
        setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
        setPending(true);
        var prevTransition = ReactCurrentBatchConfig$2.transition;
        ReactCurrentBatchConfig$2.transition = {};
        var currentTransition = ReactCurrentBatchConfig$2.transition;
        {
          ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
        }
        try {
          setPending(false);
          callback();
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$2.transition = prevTransition;
          {
            if (prevTransition === null && currentTransition._updatedFibers) {
              var updatedFibersCount = currentTransition._updatedFibers.size;
              if (updatedFibersCount > 10) {
                warn2("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
              }
              currentTransition._updatedFibers.clear();
            }
          }
        }
      }
      function mountTransition() {
        var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
        var start = startTransition.bind(null, setPending);
        var hook = mountWorkInProgressHook();
        hook.memoizedState = start;
        return [isPending, start];
      }
      function updateTransition() {
        var _updateState = updateState(), isPending = _updateState[0];
        var hook = updateWorkInProgressHook();
        var start = hook.memoizedState;
        return [isPending, start];
      }
      function rerenderTransition() {
        var _rerenderState = rerenderState(), isPending = _rerenderState[0];
        var hook = updateWorkInProgressHook();
        var start = hook.memoizedState;
        return [isPending, start];
      }
      var isUpdatingOpaqueValueInRenderPhase = false;
      function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
        {
          return isUpdatingOpaqueValueInRenderPhase;
        }
      }
      function mountId() {
        var hook = mountWorkInProgressHook();
        var root3 = getWorkInProgressRoot();
        var identifierPrefix = root3.identifierPrefix;
        var id;
        if (getIsHydrating()) {
          var treeId = getTreeId();
          id = ":" + identifierPrefix + "R" + treeId;
          var localId = localIdCounter++;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          id += ":";
        } else {
          var globalClientId = globalClientIdCounter++;
          id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
        }
        hook.memoizedState = id;
        return id;
      }
      function updateId() {
        var hook = updateWorkInProgressHook();
        var id = hook.memoizedState;
        return id;
      }
      function dispatchReducerAction(fiber, queue, action) {
        {
          if (typeof arguments[3] === "function") {
            error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
          }
        }
        var lane = requestUpdateLane(fiber);
        var update = {
          lane,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          enqueueRenderPhaseUpdate(queue, update);
        } else {
          var root3 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (root3 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            entangleTransitionUpdate(root3, queue, lane);
          }
        }
        markUpdateInDevTools(fiber, lane);
      }
      function dispatchSetState(fiber, queue, action) {
        {
          if (typeof arguments[3] === "function") {
            error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
          }
        }
        var lane = requestUpdateLane(fiber);
        var update = {
          lane,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          enqueueRenderPhaseUpdate(queue, update);
        } else {
          var alternate = fiber.alternate;
          if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
            var lastRenderedReducer = queue.lastRenderedReducer;
            if (lastRenderedReducer !== null) {
              var prevDispatcher;
              {
                prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              }
              try {
                var currentState = queue.lastRenderedState;
                var eagerState = lastRenderedReducer(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState)) {
                  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                  return;
                }
              } catch (error2) {
              } finally {
                {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              }
            }
          }
          var root3 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (root3 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            entangleTransitionUpdate(root3, queue, lane);
          }
        }
        markUpdateInDevTools(fiber, lane);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        if (pending === null) {
          update.next = update;
        } else {
          update.next = pending.next;
          pending.next = update;
        }
        queue.pending = update;
      }
      function entangleTransitionUpdate(root3, queue, lane) {
        if (isTransitionLane(lane)) {
          var queueLanes = queue.lanes;
          queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
          var newQueueLanes = mergeLanes(queueLanes, lane);
          queue.lanes = newQueueLanes;
          markRootEntangled(root3, newQueueLanes);
        }
      }
      function markUpdateInDevTools(fiber, lane, action) {
        {
          markStateUpdateScheduled(fiber, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useMutableSource: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        unstable_isNewReconciler: enableNewReconciler
      };
      var HooksDispatcherOnMountInDEV = null;
      var HooksDispatcherOnMountWithHookTypesInDEV = null;
      var HooksDispatcherOnUpdateInDEV = null;
      var HooksDispatcherOnRerenderInDEV = null;
      var InvalidNestedHooksDispatcherOnMountInDEV = null;
      var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
      var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
      {
        var warnInvalidContextAccess = function() {
          error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        };
        var warnInvalidHookAccess = function() {
          error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
        };
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref2, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref2, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            mountHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref2, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref2, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return mountInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return updateEffect(create2, deps);
          },
          useImperativeHandle: function(ref2, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref2, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return updateEffect(create2, deps);
          },
          useImperativeHandle: function(ref2, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref2, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref2, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref2, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create2, deps);
          },
          useImperativeHandle: function(ref2, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref2, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create2, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create2, deps);
          },
          useImperativeHandle: function(ref2, create2, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref2, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
      }
      var now$1 = Scheduler.unstable_now;
      var commitTime = 0;
      var layoutEffectStartTime = -1;
      var profilerStartTime = -1;
      var passiveEffectStartTime = -1;
      var currentUpdateIsNested = false;
      var nestedUpdateScheduled = false;
      function isCurrentUpdateNested() {
        return currentUpdateIsNested;
      }
      function markNestedUpdateScheduled() {
        {
          nestedUpdateScheduled = true;
        }
      }
      function resetNestedUpdateFlag() {
        {
          currentUpdateIsNested = false;
          nestedUpdateScheduled = false;
        }
      }
      function syncNestedUpdateFlag() {
        {
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
        }
      }
      function getCommitTime() {
        return commitTime;
      }
      function recordCommitTime() {
        commitTime = now$1();
      }
      function startProfilerTimer(fiber) {
        profilerStartTime = now$1();
        if (fiber.actualStartTime < 0) {
          fiber.actualStartTime = now$1();
        }
      }
      function stopProfilerTimerIfRunning(fiber) {
        profilerStartTime = -1;
      }
      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (profilerStartTime >= 0) {
          var elapsedTime = now$1() - profilerStartTime;
          fiber.actualDuration += elapsedTime;
          if (overrideBaseTime) {
            fiber.selfBaseDuration = elapsedTime;
          }
          profilerStartTime = -1;
        }
      }
      function recordLayoutEffectDuration(fiber) {
        if (layoutEffectStartTime >= 0) {
          var elapsedTime = now$1() - layoutEffectStartTime;
          layoutEffectStartTime = -1;
          var parentFiber = fiber.return;
          while (parentFiber !== null) {
            switch (parentFiber.tag) {
              case HostRoot:
                var root3 = parentFiber.stateNode;
                root3.effectDuration += elapsedTime;
                return;
              case Profiler:
                var parentStateNode = parentFiber.stateNode;
                parentStateNode.effectDuration += elapsedTime;
                return;
            }
            parentFiber = parentFiber.return;
          }
        }
      }
      function recordPassiveEffectDuration(fiber) {
        if (passiveEffectStartTime >= 0) {
          var elapsedTime = now$1() - passiveEffectStartTime;
          passiveEffectStartTime = -1;
          var parentFiber = fiber.return;
          while (parentFiber !== null) {
            switch (parentFiber.tag) {
              case HostRoot:
                var root3 = parentFiber.stateNode;
                if (root3 !== null) {
                  root3.passiveEffectDuration += elapsedTime;
                }
                return;
              case Profiler:
                var parentStateNode = parentFiber.stateNode;
                if (parentStateNode !== null) {
                  parentStateNode.passiveEffectDuration += elapsedTime;
                }
                return;
            }
            parentFiber = parentFiber.return;
          }
        }
      }
      function startLayoutEffectTimer() {
        layoutEffectStartTime = now$1();
      }
      function startPassiveEffectTimer() {
        passiveEffectStartTime = now$1();
      }
      function transferActualDuration(fiber) {
        var child = fiber.child;
        while (child) {
          fiber.actualDuration += child.actualDuration;
          child = child.sibling;
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign2({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === void 0) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      var fakeInternalInstance = {};
      var didWarnAboutStateAssignmentForComponent;
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      var didWarnAboutLegacyContext$1;
      {
        didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
        didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key2 = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key2)) {
            didWarnOnInvalidCallback.add(key2);
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
          }
        };
        Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: false,
          value: function() {
            throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
          }
        });
        Object.freeze(fakeInternalInstance);
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress2.memoizedState;
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var memoizedState = partialState === null || partialState === void 0 ? prevState : assign2({}, prevState, partialState);
        workInProgress2.memoizedState = memoizedState;
        if (workInProgress2.lanes === NoLanes) {
          var updateQueue2 = workInProgress2.updateQueue;
          updateQueue2.baseState = memoizedState;
        }
      }
      var classComponentUpdater = {
        isMounted,
        enqueueSetState: function(inst, payload, callback) {
          var fiber = get(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.payload = payload;
          if (callback !== void 0 && callback !== null) {
            {
              warnOnInvalidCallback(callback, "setState");
            }
            update.callback = callback;
          }
          var root3 = enqueueUpdate(fiber, update, lane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            entangleTransitions(root3, fiber, lane);
          }
          {
            markStateUpdateScheduled(fiber, lane);
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var fiber = get(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.tag = ReplaceState;
          update.payload = payload;
          if (callback !== void 0 && callback !== null) {
            {
              warnOnInvalidCallback(callback, "replaceState");
            }
            update.callback = callback;
          }
          var root3 = enqueueUpdate(fiber, update, lane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            entangleTransitions(root3, fiber, lane);
          }
          {
            markStateUpdateScheduled(fiber, lane);
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var fiber = get(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.tag = ForceUpdate;
          if (callback !== void 0 && callback !== null) {
            {
              warnOnInvalidCallback(callback, "forceUpdate");
            }
            update.callback = callback;
          }
          var root3 = enqueueUpdate(fiber, update, lane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            entangleTransitions(root3, fiber, lane);
          }
          {
            markForceUpdateScheduled(fiber, lane);
          }
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress2.stateNode;
        if (typeof instance.shouldComponentUpdate === "function") {
          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            if (shouldUpdate === void 0) {
              error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
            }
          }
          return shouldUpdate;
        }
        if (ctor.prototype && ctor.prototype.isPureReactComponent) {
          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        }
        return true;
      }
      function checkClassInstance(workInProgress2, ctor, newProps) {
        var instance = workInProgress2.stateNode;
        {
          var name2 = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name2);
            } else {
              error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name2);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
          }
          if (instance.propTypes) {
            error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name2);
          }
          if (instance.contextType) {
            error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
          }
          {
            if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
            // this one.
            (workInProgress2.mode & StrictLegacyMode) === NoMode) {
              didWarnAboutLegacyContext$1.add(ctor);
              error("%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead\n\n.Learn more about this warning here: https://reactjs.org/link/legacy-context", name2);
            }
            if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
            // this one.
            (workInProgress2.mode & StrictLegacyMode) === NoMode) {
              didWarnAboutLegacyContext$1.add(ctor);
              error("%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", name2);
            }
            if (instance.contextTypes) {
              error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name2);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name2);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== void 0 && hasMutatedProps) {
            error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2, name2);
          }
          if (instance.defaultProps) {
            error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray2(_state))) {
            error("%s.state: must be set to an object or null", name2);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
          }
        }
      }
      function adoptClassInstance(workInProgress2, instance) {
        instance.updater = classComponentUpdater;
        workInProgress2.stateNode = instance;
        set2(instance, workInProgress2);
        {
          instance._reactInternalInstance = fakeInternalInstance;
        }
      }
      function constructClassInstance(workInProgress2, ctor, props) {
        var isLegacyContextConsumer = false;
        var unmaskedContext = emptyContextObject;
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid = (
              // Allow null for conditional declaration
              contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
            );
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === void 0) {
                addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== void 0) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          var contextTypes = ctor.contextTypes;
          isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
          context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
        }
        var instance = new ctor(props, context);
        {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              instance = new ctor(props, context);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
        adoptClassInstance(workInProgress2, instance);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        if (isLegacyContextConsumer) {
          cacheContext(workInProgress2, unmaskedContext, context);
        }
        return instance;
      }
      function callComponentWillMount(workInProgress2, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        var oldState = instance.state;
        if (typeof instance.componentWillReceiveProps === "function") {
          instance.componentWillReceiveProps(newProps, nextContext);
        }
        if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
          instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        }
        if (instance.state !== oldState) {
          {
            var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
              didWarnAboutStateAssignmentForComponent.add(componentName);
              error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
            }
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        {
          checkClassInstance(workInProgress2, ctor, newProps);
        }
        var instance = workInProgress2.stateNode;
        instance.props = newProps;
        instance.state = workInProgress2.memoizedState;
        instance.refs = {};
        initializeUpdateQueue(workInProgress2);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          instance.context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
          }
          if (workInProgress2.mode & StrictLegacyMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
          }
          {
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
          }
        }
        instance.state = workInProgress2.memoizedState;
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          instance.state = workInProgress2.memoizedState;
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(workInProgress2, instance);
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          instance.state = workInProgress2.memoizedState;
        }
        if (typeof instance.componentDidMount === "function") {
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          workInProgress2.flags |= fiberFlags;
        }
      }
      function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        var instance = workInProgress2.stateNode;
        var oldProps = workInProgress2.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext(contextType);
        } else {
          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
          }
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState;
        var newState = instance.state = oldState;
        processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
        newState = workInProgress2.memoizedState;
        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidMount === "function") {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
          return false;
        }
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress2.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
          }
          if (typeof instance.componentDidMount === "function") {
            var _fiberFlags = Update;
            {
              _fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              _fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= _fiberFlags;
          }
        } else {
          if (typeof instance.componentDidMount === "function") {
            var _fiberFlags2 = Update;
            {
              _fiberFlags2 |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              _fiberFlags2 |= MountLayoutDev;
            }
            workInProgress2.flags |= _fiberFlags2;
          }
          workInProgress2.memoizedProps = newProps;
          workInProgress2.memoizedState = newState;
        }
        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }
      function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
        var instance = workInProgress2.stateNode;
        cloneUpdateQueue(current2, workInProgress2);
        var unresolvedOldProps = workInProgress2.memoizedProps;
        var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
        instance.props = oldProps;
        var unresolvedNewProps = workInProgress2.pendingProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext(contextType);
        } else {
          var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
          }
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState;
        var newState = instance.state = oldState;
        processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
        newState = workInProgress2.memoizedState;
        if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
          if (typeof instance.componentDidUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Update;
            }
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Snapshot;
            }
          }
          return false;
        }
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress2.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
        // both before and after `shouldComponentUpdate` has been called. Not ideal,
        // but I'm loath to refactor this function. This only happens for memoized
        // components so it's not that common.
        enableLazyContextPropagation;
        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
            if (typeof instance.componentWillUpdate === "function") {
              instance.componentWillUpdate(newProps, newState, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
            }
          }
          if (typeof instance.componentDidUpdate === "function") {
            workInProgress2.flags |= Update;
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            workInProgress2.flags |= Snapshot;
          }
        } else {
          if (typeof instance.componentDidUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Update;
            }
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Snapshot;
            }
          }
          workInProgress2.memoizedProps = newProps;
          workInProgress2.memoizedState = newState;
        }
        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }
      function createCapturedValueAtFiber(value, source) {
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source),
          digest: null
        };
      }
      function createCapturedValue(value, digest, stack) {
        return {
          value,
          source: null,
          stack: stack != null ? stack : null,
          digest: digest != null ? digest : null
        };
      }
      function showErrorDialog(boundary, errorInfo) {
        return true;
      }
      function logCapturedError(boundary, errorInfo) {
        try {
          var logError = showErrorDialog(boundary, errorInfo);
          if (logError === false) {
            return;
          }
          var error2 = errorInfo.value;
          if (true) {
            var source = errorInfo.source;
            var stack = errorInfo.stack;
            var componentStack = stack !== null ? stack : "";
            if (error2 != null && error2._suppressLogging) {
              if (boundary.tag === ClassComponent) {
                return;
              }
              console["error"](error2);
            }
            var componentName = source ? getComponentNameFromFiber(source) : null;
            var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
            var errorBoundaryMessage;
            if (boundary.tag === HostRoot) {
              errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
            } else {
              var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
              errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            }
            var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
            console["error"](combinedMessage);
          }
        } catch (e) {
          setTimeout(function() {
            throw e;
          });
        }
      }
      var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
      function createRootErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        update.payload = {
          element: null
        };
        var error2 = errorInfo.value;
        update.callback = function() {
          onUncaughtError(error2);
          logCapturedError(fiber, errorInfo);
        };
        return update;
      }
      function createClassErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if (typeof getDerivedStateFromError === "function") {
          var error$1 = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error$1);
          };
          update.callback = function() {
            {
              markFailedErrorBoundaryForHotReloading(fiber);
            }
            logCapturedError(fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        if (inst !== null && typeof inst.componentDidCatch === "function") {
          update.callback = function callback() {
            {
              markFailedErrorBoundaryForHotReloading(fiber);
            }
            logCapturedError(fiber, errorInfo);
            if (typeof getDerivedStateFromError !== "function") {
              markLegacyErrorBoundaryAsFailed(this);
            }
            var error$12 = errorInfo.value;
            var stack = errorInfo.stack;
            this.componentDidCatch(error$12, {
              componentStack: stack !== null ? stack : ""
            });
            {
              if (typeof getDerivedStateFromError !== "function") {
                if (!includesSomeLane(fiber.lanes, SyncLane)) {
                  error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                }
              }
            }
          };
        }
        return update;
      }
      function attachPingListener(root3, wakeable, lanes) {
        var pingCache = root3.pingCache;
        var threadIDs;
        if (pingCache === null) {
          pingCache = root3.pingCache = new PossiblyWeakMap$1();
          threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else {
          threadIDs = pingCache.get(wakeable);
          if (threadIDs === void 0) {
            threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          }
        }
        if (!threadIDs.has(lanes)) {
          threadIDs.add(lanes);
          var ping = pingSuspendedRoot.bind(null, root3, wakeable, lanes);
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root3, lanes);
            }
          }
          wakeable.then(ping, ping);
        }
      }
      function attachRetryListener(suspenseBoundary, root3, wakeable, lanes) {
        var wakeables = suspenseBoundary.updateQueue;
        if (wakeables === null) {
          var updateQueue2 = /* @__PURE__ */ new Set();
          updateQueue2.add(wakeable);
          suspenseBoundary.updateQueue = updateQueue2;
        } else {
          wakeables.add(wakeable);
        }
      }
      function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
        var tag = sourceFiber.tag;
        if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
          var currentSource = sourceFiber.alternate;
          if (currentSource) {
            sourceFiber.updateQueue = currentSource.updateQueue;
            sourceFiber.memoizedState = currentSource.memoizedState;
            sourceFiber.lanes = currentSource.lanes;
          } else {
            sourceFiber.updateQueue = null;
            sourceFiber.memoizedState = null;
          }
        }
      }
      function getNearestSuspenseBoundaryToCapture(returnFiber) {
        var node2 = returnFiber;
        do {
          if (node2.tag === SuspenseComponent && shouldCaptureSuspense(node2)) {
            return node2;
          }
          node2 = node2.return;
        } while (node2 !== null);
        return null;
      }
      function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes) {
        if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
          if (suspenseBoundary === returnFiber) {
            suspenseBoundary.flags |= ShouldCapture;
          } else {
            suspenseBoundary.flags |= DidCapture;
            sourceFiber.flags |= ForceUpdateForLegacySuspense;
            sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
            if (sourceFiber.tag === ClassComponent) {
              var currentSourceFiber = sourceFiber.alternate;
              if (currentSourceFiber === null) {
                sourceFiber.tag = IncompleteClassComponent;
              } else {
                var update = createUpdate(NoTimestamp, SyncLane);
                update.tag = ForceUpdate;
                enqueueUpdate(sourceFiber, update, SyncLane);
              }
            }
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
          }
          return suspenseBoundary;
        }
        suspenseBoundary.flags |= ShouldCapture;
        suspenseBoundary.lanes = rootRenderLanes;
        return suspenseBoundary;
      }
      function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= Incomplete;
        {
          if (isDevToolsPresent) {
            restorePendingUpdaters(root3, rootRenderLanes);
          }
        }
        if (value !== null && typeof value === "object" && typeof value.then === "function") {
          var wakeable = value;
          resetSuspendedComponent(sourceFiber);
          {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
            }
          }
          var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
          if (suspenseBoundary !== null) {
            suspenseBoundary.flags &= ~ForceClientRender;
            markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
            if (suspenseBoundary.mode & ConcurrentMode) {
              attachPingListener(root3, wakeable, rootRenderLanes);
            }
            attachRetryListener(suspenseBoundary, root3, wakeable);
            return;
          } else {
            if (!includesSyncLane(rootRenderLanes)) {
              attachPingListener(root3, wakeable, rootRenderLanes);
              renderDidSuspendDelayIfPossible();
              return;
            }
            var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
            value = uncaughtSuspenseError;
          }
        } else {
          if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
            markDidThrowWhileHydratingDEV();
            var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (_suspenseBoundary !== null) {
              if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                _suspenseBoundary.flags |= ForceClientRender;
              }
              markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
              queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
              return;
            }
          }
        }
        value = createCapturedValueAtFiber(value, sourceFiber);
        renderDidError(value);
        var workInProgress2 = returnFiber;
        do {
          switch (workInProgress2.tag) {
            case HostRoot: {
              var _errorInfo = value;
              workInProgress2.flags |= ShouldCapture;
              var lane = pickArbitraryLane(rootRenderLanes);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
              enqueueCapturedUpdate(workInProgress2, update);
              return;
            }
            case ClassComponent:
              var errorInfo = value;
              var ctor = workInProgress2.type;
              var instance = workInProgress2.stateNode;
              if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                workInProgress2.flags |= ShouldCapture;
                var _lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                enqueueCapturedUpdate(workInProgress2, _update);
                return;
              }
              break;
          }
          workInProgress2 = workInProgress2.return;
        } while (workInProgress2 !== null);
      }
      function getSuspendedCache() {
        {
          return null;
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var didReceiveUpdate = false;
      var didWarnAboutBadClass;
      var didWarnAboutModulePatternComponent;
      var didWarnAboutContextTypeOnFunctionComponent;
      var didWarnAboutGetDerivedStateOnFunctionComponent;
      var didWarnAboutFunctionRefs;
      var didWarnAboutReassigningProps;
      var didWarnAboutRevealOrder;
      var didWarnAboutTailOptions;
      var didWarnAboutDefaultPropsOnFunctionComponent;
      {
        didWarnAboutBadClass = {};
        didWarnAboutModulePatternComponent = {};
        didWarnAboutContextTypeOnFunctionComponent = {};
        didWarnAboutGetDerivedStateOnFunctionComponent = {};
        didWarnAboutFunctionRefs = {};
        didWarnAboutReassigningProps = false;
        didWarnAboutRevealOrder = {};
        didWarnAboutTailOptions = {};
        didWarnAboutDefaultPropsOnFunctionComponent = {};
      }
      function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
        if (current2 === null) {
          workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        } else {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
        }
      }
      function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
      }
      function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(Component)
              );
            }
          }
        }
        var render3 = Component.render;
        var ref2 = workInProgress2.ref;
        var nextChildren;
        var hasId;
        prepareToReadContext(workInProgress2, renderLanes2);
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          nextChildren = renderWithHooks(current2, workInProgress2, render3, nextProps, ref2, renderLanes2);
          hasId = checkDidRenderIdHook();
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              nextChildren = renderWithHooks(current2, workInProgress2, render3, nextProps, ref2, renderLanes2);
              hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        if (current2 !== null && !didReceiveUpdate) {
          bailoutHooks(current2, workInProgress2, renderLanes2);
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        if (getIsHydrating() && hasId) {
          pushMaterializedTreeId(workInProgress2);
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (current2 === null) {
          var type = Component.type;
          if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
          Component.defaultProps === void 0) {
            var resolvedType = type;
            {
              resolvedType = resolveFunctionForHotReloading(type);
            }
            workInProgress2.tag = SimpleMemoComponent;
            workInProgress2.type = resolvedType;
            {
              validateFunctionComponentInDev(workInProgress2, type);
            }
            return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
          }
          {
            var innerPropTypes = type.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(type)
              );
            }
            if (Component.defaultProps !== void 0) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
              }
            }
          }
          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
          child.ref = workInProgress2.ref;
          child.return = workInProgress2;
          workInProgress2.child = child;
          return child;
        }
        {
          var _type = Component.type;
          var _innerPropTypes = _type.propTypes;
          if (_innerPropTypes) {
            checkPropTypes(
              _innerPropTypes,
              nextProps,
              // Resolved props
              "prop",
              getComponentNameFromType(_type)
            );
          }
        }
        var currentChild = current2.child;
        var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
        if (!hasScheduledUpdateOrContext) {
          var prevProps = currentChild.memoizedProps;
          var compare2 = Component.compare;
          compare2 = compare2 !== null ? compare2 : shallowEqual;
          if (compare2(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
        }
        workInProgress2.flags |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps);
        newChild.ref = workInProgress2.ref;
        newChild.return = workInProgress2;
        workInProgress2.child = newChild;
        return newChild;
      }
      function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var outerMemoType = workInProgress2.elementType;
            if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
              var lazyComponent = outerMemoType;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                outerMemoType = init(payload);
              } catch (x2) {
                outerMemoType = null;
              }
              var outerPropTypes = outerMemoType && outerMemoType.propTypes;
              if (outerPropTypes) {
                checkPropTypes(
                  outerPropTypes,
                  nextProps,
                  // Resolved (SimpleMemoComponent has no defaultProps)
                  "prop",
                  getComponentNameFromType(outerMemoType)
                );
              }
            }
          }
        }
        if (current2 !== null) {
          var prevProps = current2.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
          workInProgress2.type === current2.type) {
            didReceiveUpdate = false;
            workInProgress2.pendingProps = nextProps = prevProps;
            if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
              workInProgress2.lanes = current2.lanes;
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
              didReceiveUpdate = true;
            }
          }
        }
        return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
      }
      function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        var nextChildren = nextProps.children;
        var prevState = current2 !== null ? current2.memoizedState : null;
        if (nextProps.mode === "hidden" || enableLegacyHidden) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            var nextState = {
              baseLanes: NoLanes,
              cachePool: null,
              transitions: null
            };
            workInProgress2.memoizedState = nextState;
            pushRenderLanes(workInProgress2, renderLanes2);
          } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
            var spawnedCachePool = null;
            var nextBaseLanes;
            if (prevState !== null) {
              var prevBaseLanes = prevState.baseLanes;
              nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
            } else {
              nextBaseLanes = renderLanes2;
            }
            workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
            var _nextState = {
              baseLanes: nextBaseLanes,
              cachePool: spawnedCachePool,
              transitions: null
            };
            workInProgress2.memoizedState = _nextState;
            workInProgress2.updateQueue = null;
            pushRenderLanes(workInProgress2, nextBaseLanes);
            return null;
          } else {
            var _nextState2 = {
              baseLanes: NoLanes,
              cachePool: null,
              transitions: null
            };
            workInProgress2.memoizedState = _nextState2;
            var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
            pushRenderLanes(workInProgress2, subtreeRenderLanes2);
          }
        } else {
          var _subtreeRenderLanes;
          if (prevState !== null) {
            _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
            workInProgress2.memoizedState = null;
          } else {
            _subtreeRenderLanes = renderLanes2;
          }
          pushRenderLanes(workInProgress2, _subtreeRenderLanes);
        }
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateFragment(current2, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateMode(current2, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps.children;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateProfiler(current2, workInProgress2, renderLanes2) {
        {
          workInProgress2.flags |= Update;
          {
            var stateNode = workInProgress2.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
        }
        var nextProps = workInProgress2.pendingProps;
        var nextChildren = nextProps.children;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function markRef(current2, workInProgress2) {
        var ref2 = workInProgress2.ref;
        if (current2 === null && ref2 !== null || current2 !== null && current2.ref !== ref2) {
          workInProgress2.flags |= Ref;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
      }
      function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(Component)
              );
            }
          }
        }
        var context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        var nextChildren;
        var hasId;
        prepareToReadContext(workInProgress2, renderLanes2);
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
          hasId = checkDidRenderIdHook();
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        if (current2 !== null && !didReceiveUpdate) {
          bailoutHooks(current2, workInProgress2, renderLanes2);
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        if (getIsHydrating() && hasId) {
          pushMaterializedTreeId(workInProgress2);
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          switch (shouldError(workInProgress2)) {
            case false: {
              var _instance = workInProgress2.stateNode;
              var ctor = workInProgress2.type;
              var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
              var state = tempInstance.state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            }
            case true: {
              workInProgress2.flags |= DidCapture;
              workInProgress2.flags |= ShouldCapture;
              var error$1 = new Error("Simulated error coming from DevTools");
              var lane = pickArbitraryLane(renderLanes2);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
              enqueueCapturedUpdate(workInProgress2, update);
              break;
            }
          }
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(
                innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(Component)
              );
            }
          }
        }
        var hasContext;
        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress2);
        } else {
          hasContext = false;
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var instance = workInProgress2.stateNode;
        var shouldUpdate;
        if (instance === null) {
          resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
          constructClassInstance(workInProgress2, Component, nextProps);
          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          shouldUpdate = true;
        } else if (current2 === null) {
          shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
        } else {
          shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
        }
        var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
        {
          var inst = workInProgress2.stateNode;
          if (shouldUpdate && inst.props !== nextProps) {
            if (!didWarnAboutReassigningProps) {
              error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        return nextUnitOfWork;
      }
      function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
        markRef(current2, workInProgress2);
        var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (!shouldUpdate && !didCaptureError) {
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component, false);
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        var instance = workInProgress2.stateNode;
        ReactCurrentOwner$1.current = workInProgress2;
        var nextChildren;
        if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
          nextChildren = null;
          {
            stopProfilerTimerIfRunning();
          }
        } else {
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            setIsRendering(true);
            nextChildren = instance.render();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance.render();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
        }
        workInProgress2.flags |= PerformedWork;
        if (current2 !== null && didCaptureError) {
          forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
        } else {
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        }
        workInProgress2.memoizedState = instance.state;
        if (hasContext) {
          invalidateContextProvider(workInProgress2, Component, true);
        }
        return workInProgress2.child;
      }
      function pushHostRootContext(workInProgress2) {
        var root3 = workInProgress2.stateNode;
        if (root3.pendingContext) {
          pushTopLevelContextObject(workInProgress2, root3.pendingContext, root3.pendingContext !== root3.context);
        } else if (root3.context) {
          pushTopLevelContextObject(workInProgress2, root3.context, false);
        }
        pushHostContainer(workInProgress2, root3.containerInfo);
      }
      function updateHostRoot(current2, workInProgress2, renderLanes2) {
        pushHostRootContext(workInProgress2);
        if (current2 === null) {
          throw new Error("Should have a current fiber. This is a bug in React.");
        }
        var nextProps = workInProgress2.pendingProps;
        var prevState = workInProgress2.memoizedState;
        var prevChildren = prevState.element;
        cloneUpdateQueue(current2, workInProgress2);
        processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
        var nextState = workInProgress2.memoizedState;
        workInProgress2.stateNode;
        var nextChildren = nextState.element;
        if (prevState.isDehydrated) {
          var overrideState = {
            element: nextChildren,
            isDehydrated: false,
            cache: nextState.cache,
            pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
            transitions: nextState.transitions
          };
          var updateQueue2 = workInProgress2.updateQueue;
          updateQueue2.baseState = overrideState;
          workInProgress2.memoizedState = overrideState;
          if (workInProgress2.flags & ForceClientRender) {
            var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
          } else if (nextChildren !== prevChildren) {
            var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
          } else {
            enterHydrationState(workInProgress2);
            var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            workInProgress2.child = child;
            var node2 = child;
            while (node2) {
              node2.flags = node2.flags & ~Placement | Hydrating;
              node2 = node2.sibling;
            }
          }
        } else {
          resetHydrationState();
          if (nextChildren === prevChildren) {
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        }
        return workInProgress2.child;
      }
      function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
        resetHydrationState();
        queueHydrationError(recoverableError);
        workInProgress2.flags |= ForceClientRender;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateHostComponent(current2, workInProgress2, renderLanes2) {
        pushHostContext(workInProgress2);
        if (current2 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
        }
        var type = workInProgress2.type;
        var nextProps = workInProgress2.pendingProps;
        var prevProps = current2 !== null ? current2.memoizedProps : null;
        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);
        if (isDirectTextChild) {
          nextChildren = null;
        } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
          workInProgress2.flags |= ContentReset;
        }
        markRef(current2, workInProgress2);
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateHostText(current2, workInProgress2) {
        if (current2 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
        }
        return null;
      }
      function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        var props = workInProgress2.pendingProps;
        var lazyComponent = elementType;
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload);
        workInProgress2.type = Component;
        var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child;
        switch (resolvedTag) {
          case FunctionComponent: {
            {
              validateFunctionComponentInDev(workInProgress2, Component);
              workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
            }
            child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case ClassComponent: {
            {
              workInProgress2.type = Component = resolveClassForHotReloading(Component);
            }
            child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case ForwardRef: {
            {
              workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
            }
            child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case MemoComponent: {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerPropTypes = Component.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    resolvedProps,
                    // Resolved for outer only
                    "prop",
                    getComponentNameFromType(Component)
                  );
                }
              }
            }
            child = updateMemoComponent(
              null,
              workInProgress2,
              Component,
              resolveDefaultProps(Component.type, resolvedProps),
              // The inner type can have defaults too
              renderLanes2
            );
            return child;
          }
        }
        var hint = "";
        {
          if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
            hint = " Did you wrap a component in React.lazy() more than once?";
          }
        }
        throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
      }
      function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        workInProgress2.tag = ClassComponent;
        var hasContext;
        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress2);
        } else {
          hasContext = false;
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        constructClassInstance(workInProgress2, Component, nextProps);
        mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
        return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
      }
      function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        var props = workInProgress2.pendingProps;
        var context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var value;
        var hasId;
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
          if (workInProgress2.mode & StrictLegacyMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
          }
          setIsRendering(true);
          ReactCurrentOwner$1.current = workInProgress2;
          value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
          hasId = checkDidRenderIdHook();
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        workInProgress2.flags |= PerformedWork;
        {
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (
          // Run these checks in production only if the flag is off.
          // Eventually we'll delete this branch altogether.
          typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
        ) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          workInProgress2.tag = ClassComponent;
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          var hasContext = false;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
          initializeUpdateQueue(workInProgress2);
          adoptClassInstance(workInProgress2, value);
          mountClassInstance(workInProgress2, Component, props, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
        } else {
          workInProgress2.tag = FunctionComponent;
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          reconcileChildren(null, workInProgress2, value, renderLanes2);
          {
            validateFunctionComponentInDev(workInProgress2, Component);
          }
          return workInProgress2.child;
        }
      }
      function validateFunctionComponentInDev(workInProgress2, Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (workInProgress2.ref !== null) {
            var info = "";
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              info += "\n\nCheck the render method of `" + ownerName + "`.";
            }
            var warningKey = ownerName || "";
            var debugSource = workInProgress2._debugSource;
            if (debugSource) {
              warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
            }
            if (!didWarnAboutFunctionRefs[warningKey]) {
              didWarnAboutFunctionRefs[warningKey] = true;
              error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
            }
          }
          if (Component.defaultProps !== void 0) {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
              error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
              didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: NoLane
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return {
          baseLanes: renderLanes2,
          cachePool: getSuspendedCache(),
          transitions: null
        };
      }
      function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
        var cachePool = null;
        return {
          baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
          cachePool,
          transitions: prevOffscreenState.transitions
        };
      }
      function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
        if (current2 !== null) {
          var suspenseState = current2.memoizedState;
          if (suspenseState === null) {
            return false;
          }
        }
        return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
      }
      function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
        return removeLanes(current2.childLanes, renderLanes2);
      }
      function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        {
          if (shouldSuspend(workInProgress2)) {
            workInProgress2.flags |= DidCapture;
          }
        }
        var suspenseContext = suspenseStackCursor.current;
        var showFallback = false;
        var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
          showFallback = true;
          workInProgress2.flags &= ~DidCapture;
        } else {
          if (current2 === null || current2.memoizedState !== null) {
            {
              suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
            }
          }
        }
        suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        pushSuspenseContext(workInProgress2, suspenseContext);
        if (current2 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
          var suspenseState = workInProgress2.memoizedState;
          if (suspenseState !== null) {
            var dehydrated = suspenseState.dehydrated;
            if (dehydrated !== null) {
              return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
            }
          }
          var nextPrimaryChildren = nextProps.children;
          var nextFallbackChildren = nextProps.fallback;
          if (showFallback) {
            var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
            var primaryChildFragment = workInProgress2.child;
            primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackFragment;
          } else {
            return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
          }
        } else {
          var prevState = current2.memoizedState;
          if (prevState !== null) {
            var _dehydrated = prevState.dehydrated;
            if (_dehydrated !== null) {
              return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
            }
          }
          if (showFallback) {
            var _nextFallbackChildren = nextProps.fallback;
            var _nextPrimaryChildren = nextProps.children;
            var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
            var _primaryChildFragment2 = workInProgress2.child;
            var prevOffscreenState = current2.child.memoizedState;
            _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
            _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackChildFragment;
          } else {
            var _nextPrimaryChildren2 = nextProps.children;
            var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
            workInProgress2.memoizedState = null;
            return _primaryChildFragment3;
          }
        }
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        };
        var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
        primaryChildFragment.return = workInProgress2;
        workInProgress2.child = primaryChildFragment;
        return primaryChildFragment;
      }
      function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var progressedPrimaryFragment = workInProgress2.child;
        var primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        };
        var primaryChildFragment;
        var fallbackChildFragment;
        if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
          primaryChildFragment = progressedPrimaryFragment;
          primaryChildFragment.childLanes = NoLanes;
          primaryChildFragment.pendingProps = primaryChildProps;
          if (workInProgress2.mode & ProfileMode) {
            primaryChildFragment.actualDuration = 0;
            primaryChildFragment.actualStartTime = -1;
            primaryChildFragment.selfBaseDuration = 0;
            primaryChildFragment.treeBaseDuration = 0;
          }
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
        } else {
          primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
        }
        primaryChildFragment.return = workInProgress2;
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        return fallbackChildFragment;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
        return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
      }
      function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
        return createWorkInProgress(current2, offscreenProps);
      }
      function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
        var currentPrimaryChildFragment = current2.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
          mode: "visible",
          children: primaryChildren
        });
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          primaryChildFragment.lanes = renderLanes2;
        }
        primaryChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = null;
        if (currentFallbackChildFragment !== null) {
          var deletions = workInProgress2.deletions;
          if (deletions === null) {
            workInProgress2.deletions = [currentFallbackChildFragment];
            workInProgress2.flags |= ChildDeletion;
          } else {
            deletions.push(currentFallbackChildFragment);
          }
        }
        workInProgress2.child = primaryChildFragment;
        return primaryChildFragment;
      }
      function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var currentPrimaryChildFragment = current2.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        };
        var primaryChildFragment;
        if (
          // In legacy mode, we commit the primary tree as if it successfully
          // completed, even though it's in an inconsistent state.
          (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
          // already cloned. In legacy mode, the only case where this isn't true is
          // when DevTools forces us to display a fallback; we skip the first render
          // pass entirely and go straight to rendering the fallback. (In Concurrent
          // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
          // only codepath.)
          workInProgress2.child !== currentPrimaryChildFragment
        ) {
          var progressedPrimaryFragment = workInProgress2.child;
          primaryChildFragment = progressedPrimaryFragment;
          primaryChildFragment.childLanes = NoLanes;
          primaryChildFragment.pendingProps = primaryChildProps;
          if (workInProgress2.mode & ProfileMode) {
            primaryChildFragment.actualDuration = 0;
            primaryChildFragment.actualStartTime = -1;
            primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
            primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
          }
          workInProgress2.deletions = null;
        } else {
          primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
          primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
        }
        var fallbackChildFragment;
        if (currentFallbackChildFragment !== null) {
          fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
        } else {
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
        }
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        return fallbackChildFragment;
      }
      function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
        if (recoverableError !== null) {
          queueHydrationError(recoverableError);
        }
        reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        var nextProps = workInProgress2.pendingProps;
        var primaryChildren = nextProps.children;
        var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
        primaryChildFragment.flags |= Placement;
        workInProgress2.memoizedState = null;
        return primaryChildFragment;
      }
      function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var fiberMode = workInProgress2.mode;
        var primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        };
        var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
        var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
        fallbackChildFragment.flags |= Placement;
        primaryChildFragment.return = workInProgress2;
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        }
        return fallbackChildFragment;
      }
      function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          {
            error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
          }
          workInProgress2.lanes = laneToLanes(SyncLane);
        } else if (isSuspenseInstanceFallback(suspenseInstance)) {
          workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
        } else {
          workInProgress2.lanes = laneToLanes(OffscreenLane);
        }
        return null;
      }
      function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
        if (!didSuspend) {
          warnIfHydrating();
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            return retrySuspenseComponentWithoutHydrating(
              current2,
              workInProgress2,
              renderLanes2,
              // TODO: When we delete legacy mode, we should make this error argument
              // required  every concurrent mode path that causes hydration to
              // de-opt to client rendering should have an error message.
              null
            );
          }
          if (isSuspenseInstanceFallback(suspenseInstance)) {
            var digest, message, stack;
            {
              var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
              digest = _getSuspenseInstanceF.digest;
              message = _getSuspenseInstanceF.message;
              stack = _getSuspenseInstanceF.stack;
            }
            var error2;
            if (message) {
              error2 = new Error(message);
            } else {
              error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
            }
            var capturedValue = createCapturedValue(error2, digest, stack);
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
          }
          var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
          if (didReceiveUpdate || hasContextChanged2) {
            var root3 = getWorkInProgressRoot();
            if (root3 !== null) {
              var attemptHydrationAtLane = getBumpedLaneForHydration(root3, renderLanes2);
              if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                suspenseState.retryLane = attemptHydrationAtLane;
                var eventTime = NoTimestamp;
                enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                scheduleUpdateOnFiber(root3, current2, attemptHydrationAtLane, eventTime);
              }
            }
            renderDidSuspendDelayIfPossible();
            var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
          } else if (isSuspenseInstancePending(suspenseInstance)) {
            workInProgress2.flags |= DidCapture;
            workInProgress2.child = current2.child;
            var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
            registerSuspenseInstanceRetry(suspenseInstance, retry);
            return null;
          } else {
            reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Hydrating;
            return primaryChildFragment;
          }
        } else {
          if (workInProgress2.flags & ForceClientRender) {
            workInProgress2.flags &= ~ForceClientRender;
            var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
          } else if (workInProgress2.memoizedState !== null) {
            workInProgress2.child = current2.child;
            workInProgress2.flags |= DidCapture;
            return null;
          } else {
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
            var _primaryChildFragment4 = workInProgress2.child;
            _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackChildFragment;
          }
        }
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
        var alternate = fiber.alternate;
        if (alternate !== null) {
          alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
        }
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
        var node2 = firstChild;
        while (node2 !== null) {
          if (node2.tag === SuspenseComponent) {
            var state = node2.memoizedState;
            if (state !== null) {
              scheduleSuspenseWorkOnFiber(node2, renderLanes2, workInProgress2);
            }
          } else if (node2.tag === SuspenseListComponent) {
            scheduleSuspenseWorkOnFiber(node2, renderLanes2, workInProgress2);
          } else if (node2.child !== null) {
            node2.child.return = node2;
            node2 = node2.child;
            continue;
          }
          if (node2 === workInProgress2) {
            return;
          }
          while (node2.sibling === null) {
            if (node2.return === null || node2.return === workInProgress2) {
              return;
            }
            node2 = node2.return;
          }
          node2.sibling.return = node2.return;
          node2 = node2.sibling;
        }
      }
      function findLastContentRow(firstChild) {
        var row = firstChild;
        var lastContentRow = null;
        while (row !== null) {
          var currentRow = row.alternate;
          if (currentRow !== null && findFirstSuspended(currentRow) === null) {
            lastContentRow = row;
          }
          row = row.sibling;
        }
        return lastContentRow;
      }
      function validateRevealOrder(revealOrder) {
        {
          if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
            didWarnAboutRevealOrder[revealOrder] = true;
            if (typeof revealOrder === "string") {
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards": {
                  error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                  break;
                }
                case "forward":
                case "backward": {
                  error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                  break;
                }
                default:
                  error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                  break;
              }
            } else {
              error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
            }
          }
        }
      }
      function validateTailOptions(tailMode, revealOrder) {
        {
          if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
            if (tailMode !== "collapsed" && tailMode !== "hidden") {
              didWarnAboutTailOptions[tailMode] = true;
              error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
            } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
              didWarnAboutTailOptions[tailMode] = true;
              error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
            }
          }
        }
      }
      function validateSuspenseListNestedChild(childSlot, index2) {
        {
          var isAnArray = isArray2(childSlot);
          var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
          if (isAnArray || isIterable) {
            var type = isAnArray ? "array" : "iterable";
            error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
            return false;
          }
        }
        return true;
      }
      function validateSuspenseListChildren(children2, revealOrder) {
        {
          if ((revealOrder === "forwards" || revealOrder === "backwards") && children2 !== void 0 && children2 !== null && children2 !== false) {
            if (isArray2(children2)) {
              for (var i2 = 0; i2 < children2.length; i2++) {
                if (!validateSuspenseListNestedChild(children2[i2], i2)) {
                  return;
                }
              }
            } else {
              var iteratorFn = getIteratorFn(children2);
              if (typeof iteratorFn === "function") {
                var childrenIterator = iteratorFn.call(children2);
                if (childrenIterator) {
                  var step = childrenIterator.next();
                  var _i = 0;
                  for (; !step.done; step = childrenIterator.next()) {
                    if (!validateSuspenseListNestedChild(step.value, _i)) {
                      return;
                    }
                    _i++;
                  }
                }
              } else {
                error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
              }
            }
          }
        }
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        if (renderState === null) {
          workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode
          };
        } else {
          renderState.isBackwards = isBackwards;
          renderState.rendering = null;
          renderState.renderingStartTime = 0;
          renderState.last = lastContentRow;
          renderState.tail = tail;
          renderState.tailMode = tailMode;
        }
      }
      function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        var revealOrder = nextProps.revealOrder;
        var tailMode = nextProps.tail;
        var newChildren = nextProps.children;
        validateRevealOrder(revealOrder);
        validateTailOptions(tailMode, revealOrder);
        validateSuspenseListChildren(newChildren, revealOrder);
        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        var suspenseContext = suspenseStackCursor.current;
        var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        if (shouldForceFallback) {
          suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
          workInProgress2.flags |= DidCapture;
        } else {
          var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
          if (didSuspendBefore) {
            propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        }
        pushSuspenseContext(workInProgress2, suspenseContext);
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          workInProgress2.memoizedState = null;
        } else {
          switch (revealOrder) {
            case "forwards": {
              var lastContentRow = findLastContentRow(workInProgress2.child);
              var tail;
              if (lastContentRow === null) {
                tail = workInProgress2.child;
                workInProgress2.child = null;
              } else {
                tail = lastContentRow.sibling;
                lastContentRow.sibling = null;
              }
              initSuspenseListRenderState(
                workInProgress2,
                false,
                // isBackwards
                tail,
                lastContentRow,
                tailMode
              );
              break;
            }
            case "backwards": {
              var _tail = null;
              var row = workInProgress2.child;
              workInProgress2.child = null;
              while (row !== null) {
                var currentRow = row.alternate;
                if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                  workInProgress2.child = row;
                  break;
                }
                var nextRow = row.sibling;
                row.sibling = _tail;
                _tail = row;
                row = nextRow;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                // isBackwards
                _tail,
                null,
                // last
                tailMode
              );
              break;
            }
            case "together": {
              initSuspenseListRenderState(
                workInProgress2,
                false,
                // isBackwards
                null,
                // tail
                null,
                // last
                void 0
              );
              break;
            }
            default: {
              workInProgress2.memoizedState = null;
            }
          }
        }
        return workInProgress2.child;
      }
      function updatePortalComponent(current2, workInProgress2, renderLanes2) {
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        var nextChildren = workInProgress2.pendingProps;
        if (current2 === null) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        } else {
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        }
        return workInProgress2.child;
      }
      var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
      function updateContextProvider(current2, workInProgress2, renderLanes2) {
        var providerType = workInProgress2.type;
        var context = providerType._context;
        var newProps = workInProgress2.pendingProps;
        var oldProps = workInProgress2.memoizedProps;
        var newValue = newProps.value;
        {
          if (!("value" in newProps)) {
            if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
              hasWarnedAboutUsingNoValuePropOnContextProvider = true;
              error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
            }
          }
          var providerPropTypes = workInProgress2.type.propTypes;
          if (providerPropTypes) {
            checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
          }
        }
        pushProvider(workInProgress2, context, newValue);
        {
          if (oldProps !== null) {
            var oldValue = oldProps.value;
            if (objectIs(oldValue, newValue)) {
              if (oldProps.children === newProps.children && !hasContextChanged()) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            } else {
              propagateContextChange(workInProgress2, context, renderLanes2);
            }
          }
        }
        var newChildren = newProps.children;
        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        return workInProgress2.child;
      }
      var hasWarnedAboutUsingContextAsConsumer = false;
      function updateContextConsumer(current2, workInProgress2, renderLanes2) {
        var context = workInProgress2.type;
        {
          if (context._context === void 0) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var newProps = workInProgress2.pendingProps;
        var render3 = newProps.children;
        {
          if (typeof render3 !== "function") {
            error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          }
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var newValue = readContext(context);
        {
          markComponentRenderStarted(workInProgress2);
        }
        var newChildren;
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          newChildren = render3(newValue);
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        return workInProgress2.child;
      }
      function markWorkInProgressReceivedUpdate() {
        didReceiveUpdate = true;
      }
      function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          if (current2 !== null) {
            current2.alternate = null;
            workInProgress2.alternate = null;
            workInProgress2.flags |= Placement;
          }
        }
      }
      function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
        if (current2 !== null) {
          workInProgress2.dependencies = current2.dependencies;
        }
        {
          stopProfilerTimerIfRunning();
        }
        markSkippedUpdateLanes(workInProgress2.lanes);
        if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
          {
            return null;
          }
        }
        cloneChildFibers(current2, workInProgress2);
        return workInProgress2.child;
      }
      function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
        {
          var returnFiber = oldWorkInProgress.return;
          if (returnFiber === null) {
            throw new Error("Cannot swap the root fiber.");
          }
          current2.alternate = null;
          oldWorkInProgress.alternate = null;
          newWorkInProgress.index = oldWorkInProgress.index;
          newWorkInProgress.sibling = oldWorkInProgress.sibling;
          newWorkInProgress.return = oldWorkInProgress.return;
          newWorkInProgress.ref = oldWorkInProgress.ref;
          if (oldWorkInProgress === returnFiber.child) {
            returnFiber.child = newWorkInProgress;
          } else {
            var prevSibling = returnFiber.child;
            if (prevSibling === null) {
              throw new Error("Expected parent to have a child.");
            }
            while (prevSibling.sibling !== oldWorkInProgress) {
              prevSibling = prevSibling.sibling;
              if (prevSibling === null) {
                throw new Error("Expected to find the previous sibling.");
              }
            }
            prevSibling.sibling = newWorkInProgress;
          }
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [current2];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(current2);
          }
          newWorkInProgress.flags |= Placement;
          return newWorkInProgress;
        }
      }
      function checkScheduledUpdateOrContext(current2, renderLanes2) {
        var updateLanes = current2.lanes;
        if (includesSomeLane(updateLanes, renderLanes2)) {
          return true;
        }
        return false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case HostRoot:
            pushHostRootContext(workInProgress2);
            workInProgress2.stateNode;
            resetHydrationState();
            break;
          case HostComponent:
            pushHostContext(workInProgress2);
            break;
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              pushContextProvider(workInProgress2);
            }
            break;
          }
          case HostPortal:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case ContextProvider: {
            var newValue = workInProgress2.memoizedProps.value;
            var context = workInProgress2.type._context;
            pushProvider(workInProgress2, context, newValue);
            break;
          }
          case Profiler:
            {
              var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (hasChildWork) {
                workInProgress2.flags |= Update;
              }
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            break;
          case SuspenseComponent: {
            var state = workInProgress2.memoizedState;
            if (state !== null) {
              if (state.dehydrated !== null) {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                workInProgress2.flags |= DidCapture;
                return null;
              }
              var primaryChildFragment = workInProgress2.child;
              var primaryChildLanes = primaryChildFragment.childLanes;
              if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                if (child !== null) {
                  return child.sibling;
                } else {
                  return null;
                }
              }
            } else {
              pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
            }
            break;
          }
          case SuspenseListComponent: {
            var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
            var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
            if (didSuspendBefore) {
              if (_hasChildWork) {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              workInProgress2.flags |= DidCapture;
            }
            var renderState = workInProgress2.memoizedState;
            if (renderState !== null) {
              renderState.rendering = null;
              renderState.tail = null;
              renderState.lastEffect = null;
            }
            pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
            if (_hasChildWork) {
              break;
            } else {
              return null;
            }
          }
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            workInProgress2.lanes = NoLanes;
            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
          }
        }
        return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      function beginWork(current2, workInProgress2, renderLanes2) {
        {
          if (workInProgress2._debugNeedsRemount && current2 !== null) {
            return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
          }
        }
        if (current2 !== null) {
          var oldProps = current2.memoizedProps;
          var newProps = workInProgress2.pendingProps;
          if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
          workInProgress2.type !== current2.type) {
            didReceiveUpdate = true;
          } else {
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
            // may not be work scheduled on `current`, so we check for this flag.
            (workInProgress2.flags & DidCapture) === NoFlags) {
              didReceiveUpdate = false;
              return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
            }
            if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
              didReceiveUpdate = true;
            } else {
              didReceiveUpdate = false;
            }
          }
        } else {
          didReceiveUpdate = false;
          if (getIsHydrating() && isForkedChild(workInProgress2)) {
            var slotIndex = workInProgress2.index;
            var numberOfForks = getForksAtLevel();
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        workInProgress2.lanes = NoLanes;
        switch (workInProgress2.tag) {
          case IndeterminateComponent: {
            return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
          }
          case LazyComponent: {
            var elementType = workInProgress2.elementType;
            return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
          }
          case FunctionComponent: {
            var Component = workInProgress2.type;
            var unresolvedProps = workInProgress2.pendingProps;
            var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
            return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
          }
          case ClassComponent: {
            var _Component = workInProgress2.type;
            var _unresolvedProps = workInProgress2.pendingProps;
            var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
            return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
          }
          case HostRoot:
            return updateHostRoot(current2, workInProgress2, renderLanes2);
          case HostComponent:
            return updateHostComponent(current2, workInProgress2, renderLanes2);
          case HostText:
            return updateHostText(current2, workInProgress2);
          case SuspenseComponent:
            return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
          case HostPortal:
            return updatePortalComponent(current2, workInProgress2, renderLanes2);
          case ForwardRef: {
            var type = workInProgress2.type;
            var _unresolvedProps2 = workInProgress2.pendingProps;
            var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
            return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
          }
          case Fragment:
            return updateFragment(current2, workInProgress2, renderLanes2);
          case Mode:
            return updateMode(current2, workInProgress2, renderLanes2);
          case Profiler:
            return updateProfiler(current2, workInProgress2, renderLanes2);
          case ContextProvider:
            return updateContextProvider(current2, workInProgress2, renderLanes2);
          case ContextConsumer:
            return updateContextConsumer(current2, workInProgress2, renderLanes2);
          case MemoComponent: {
            var _type2 = workInProgress2.type;
            var _unresolvedProps3 = workInProgress2.pendingProps;
            var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerPropTypes = _type2.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    _resolvedProps3,
                    // Resolved for outer only
                    "prop",
                    getComponentNameFromType(_type2)
                  );
                }
              }
            }
            _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
            return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
          }
          case SimpleMemoComponent: {
            return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
          }
          case IncompleteClassComponent: {
            var _Component2 = workInProgress2.type;
            var _unresolvedProps4 = workInProgress2.pendingProps;
            var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
            return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
          }
          case SuspenseListComponent: {
            return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
          }
          case ScopeComponent: {
            break;
          }
          case OffscreenComponent: {
            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
          }
        }
        throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= Update;
      }
      function markRef$1(workInProgress2) {
        workInProgress2.flags |= Ref;
        {
          workInProgress2.flags |= RefStatic;
        }
      }
      var appendAllChildren;
      var updateHostContainer;
      var updateHostComponent$1;
      var updateHostText$1;
      {
        appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden3) {
          var node2 = workInProgress2.child;
          while (node2 !== null) {
            if (node2.tag === HostComponent || node2.tag === HostText) {
              appendInitialChild(parent, node2.stateNode);
            } else if (node2.tag === HostPortal) ;
            else if (node2.child !== null) {
              node2.child.return = node2;
              node2 = node2.child;
              continue;
            }
            if (node2 === workInProgress2) {
              return;
            }
            while (node2.sibling === null) {
              if (node2.return === null || node2.return === workInProgress2) {
                return;
              }
              node2 = node2.return;
            }
            node2.sibling.return = node2.return;
            node2 = node2.sibling;
          }
        };
        updateHostContainer = function(current2, workInProgress2) {
        };
        updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
          var oldProps = current2.memoizedProps;
          if (oldProps === newProps) {
            return;
          }
          var instance = workInProgress2.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          workInProgress2.updateQueue = updatePayload;
          if (updatePayload) {
            markUpdate(workInProgress2);
          }
        };
        updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
          if (oldText !== newText) {
            markUpdate(workInProgress2);
          }
        };
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (getIsHydrating()) {
          return;
        }
        switch (renderState.tailMode) {
          case "hidden": {
            var tailNode = renderState.tail;
            var lastTailNode = null;
            while (tailNode !== null) {
              if (tailNode.alternate !== null) {
                lastTailNode = tailNode;
              }
              tailNode = tailNode.sibling;
            }
            if (lastTailNode === null) {
              renderState.tail = null;
            } else {
              lastTailNode.sibling = null;
            }
            break;
          }
          case "collapsed": {
            var _tailNode = renderState.tail;
            var _lastTailNode = null;
            while (_tailNode !== null) {
              if (_tailNode.alternate !== null) {
                _lastTailNode = _tailNode;
              }
              _tailNode = _tailNode.sibling;
            }
            if (_lastTailNode === null) {
              if (!hasRenderedATailFallback && renderState.tail !== null) {
                renderState.tail.sibling = null;
              } else {
                renderState.tail = null;
              }
            } else {
              _lastTailNode.sibling = null;
            }
            break;
          }
        }
      }
      function bubbleProperties(completedWork) {
        var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
        var newChildLanes = NoLanes;
        var subtreeFlags = NoFlags;
        if (!didBailout) {
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            var actualDuration = completedWork.actualDuration;
            var treeBaseDuration = completedWork.selfBaseDuration;
            var child = completedWork.child;
            while (child !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
              subtreeFlags |= child.subtreeFlags;
              subtreeFlags |= child.flags;
              actualDuration += child.actualDuration;
              treeBaseDuration += child.treeBaseDuration;
              child = child.sibling;
            }
            completedWork.actualDuration = actualDuration;
            completedWork.treeBaseDuration = treeBaseDuration;
          } else {
            var _child = completedWork.child;
            while (_child !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
              subtreeFlags |= _child.subtreeFlags;
              subtreeFlags |= _child.flags;
              _child.return = completedWork;
              _child = _child.sibling;
            }
          }
          completedWork.subtreeFlags |= subtreeFlags;
        } else {
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            var _treeBaseDuration = completedWork.selfBaseDuration;
            var _child2 = completedWork.child;
            while (_child2 !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
              subtreeFlags |= _child2.subtreeFlags & StaticMask;
              subtreeFlags |= _child2.flags & StaticMask;
              _treeBaseDuration += _child2.treeBaseDuration;
              _child2 = _child2.sibling;
            }
            completedWork.treeBaseDuration = _treeBaseDuration;
          } else {
            var _child3 = completedWork.child;
            while (_child3 !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
              subtreeFlags |= _child3.subtreeFlags & StaticMask;
              subtreeFlags |= _child3.flags & StaticMask;
              _child3.return = completedWork;
              _child3 = _child3.sibling;
            }
          }
          completedWork.subtreeFlags |= subtreeFlags;
        }
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
        if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
          warnIfUnhydratedTailNodes(workInProgress2);
          resetHydrationState();
          workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
          return false;
        }
        var wasHydrated = popHydrationState(workInProgress2);
        if (nextState !== null && nextState.dehydrated !== null) {
          if (current2 === null) {
            if (!wasHydrated) {
              throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
            }
            prepareToHydrateHostSuspenseInstance(workInProgress2);
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                var isTimedOutSuspense = nextState !== null;
                if (isTimedOutSuspense) {
                  var primaryChildFragment = workInProgress2.child;
                  if (primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return false;
          } else {
            resetHydrationState();
            if ((workInProgress2.flags & DidCapture) === NoFlags) {
              workInProgress2.memoizedState = null;
            }
            workInProgress2.flags |= Update;
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                var _isTimedOutSuspense = nextState !== null;
                if (_isTimedOutSuspense) {
                  var _primaryChildFragment = workInProgress2.child;
                  if (_primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return false;
          }
        } else {
          upgradeHydrationErrorsToRecoverable();
          return true;
        }
      }
      function completeWork(current2, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case IndeterminateComponent:
          case LazyComponent:
          case SimpleMemoComponent:
          case FunctionComponent:
          case ForwardRef:
          case Fragment:
          case Mode:
          case Profiler:
          case ContextConsumer:
          case MemoComponent:
            bubbleProperties(workInProgress2);
            return null;
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress2);
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostRoot: {
            var fiberRoot = workInProgress2.stateNode;
            popHostContainer(workInProgress2);
            popTopLevelContextObject(workInProgress2);
            resetWorkInProgressVersions();
            if (fiberRoot.pendingContext) {
              fiberRoot.context = fiberRoot.pendingContext;
              fiberRoot.pendingContext = null;
            }
            if (current2 === null || current2.child === null) {
              var wasHydrated = popHydrationState(workInProgress2);
              if (wasHydrated) {
                markUpdate(workInProgress2);
              } else {
                if (current2 !== null) {
                  var prevState = current2.memoizedState;
                  if (
                    // Check if this is a client root
                    !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                    (workInProgress2.flags & ForceClientRender) !== NoFlags
                  ) {
                    workInProgress2.flags |= Snapshot;
                    upgradeHydrationErrorsToRecoverable();
                  }
                }
              }
            }
            updateHostContainer(current2, workInProgress2);
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostComponent: {
            popHostContext(workInProgress2);
            var rootContainerInstance = getRootHostContainer();
            var type = workInProgress2.type;
            if (current2 !== null && workInProgress2.stateNode != null) {
              updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
              if (current2.ref !== workInProgress2.ref) {
                markRef$1(workInProgress2);
              }
            } else {
              if (!newProps) {
                if (workInProgress2.stateNode === null) {
                  throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              var currentHostContext = getHostContext();
              var _wasHydrated = popHydrationState(workInProgress2);
              if (_wasHydrated) {
                if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                  markUpdate(workInProgress2);
                }
              } else {
                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                appendAllChildren(instance, workInProgress2, false, false);
                workInProgress2.stateNode = instance;
                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                  markUpdate(workInProgress2);
                }
              }
              if (workInProgress2.ref !== null) {
                markRef$1(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostText: {
            var newText = newProps;
            if (current2 && workInProgress2.stateNode != null) {
              var oldText = current2.memoizedProps;
              updateHostText$1(current2, workInProgress2, oldText, newText);
            } else {
              if (typeof newText !== "string") {
                if (workInProgress2.stateNode === null) {
                  throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              var _rootContainerInstance = getRootHostContainer();
              var _currentHostContext = getHostContext();
              var _wasHydrated2 = popHydrationState(workInProgress2);
              if (_wasHydrated2) {
                if (prepareToHydrateHostTextInstance(workInProgress2)) {
                  markUpdate(workInProgress2);
                }
              } else {
                workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var nextState = workInProgress2.memoizedState;
            if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
              var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
              if (!fallthroughToNormalSuspensePath) {
                if (workInProgress2.flags & ShouldCapture) {
                  return workInProgress2;
                } else {
                  return null;
                }
              }
            }
            if ((workInProgress2.flags & DidCapture) !== NoFlags) {
              workInProgress2.lanes = renderLanes2;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            var nextDidTimeout = nextState !== null;
            var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
            if (nextDidTimeout !== prevDidTimeout) {
              if (nextDidTimeout) {
                var _offscreenFiber2 = workInProgress2.child;
                _offscreenFiber2.flags |= Visibility;
                if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                  var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                  if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                    renderDidSuspend();
                  } else {
                    renderDidSuspendDelayIfPossible();
                  }
                }
              }
            }
            var wakeables = workInProgress2.updateQueue;
            if (wakeables !== null) {
              workInProgress2.flags |= Update;
            }
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                if (nextDidTimeout) {
                  var primaryChildFragment = workInProgress2.child;
                  if (primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return null;
          }
          case HostPortal:
            popHostContainer(workInProgress2);
            updateHostContainer(current2, workInProgress2);
            if (current2 === null) {
              preparePortalMount(workInProgress2.stateNode.containerInfo);
            }
            bubbleProperties(workInProgress2);
            return null;
          case ContextProvider:
            var context = workInProgress2.type._context;
            popProvider(context, workInProgress2);
            bubbleProperties(workInProgress2);
            return null;
          case IncompleteClassComponent: {
            var _Component = workInProgress2.type;
            if (isContextProvider(_Component)) {
              popContext(workInProgress2);
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case SuspenseListComponent: {
            popSuspenseContext(workInProgress2);
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              bubbleProperties(workInProgress2);
              return null;
            }
            var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
            var renderedTail = renderState.rendering;
            if (renderedTail === null) {
              if (!didSuspendAlready) {
                var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                if (!cannotBeSuspended) {
                  var row = workInProgress2.child;
                  while (row !== null) {
                    var suspended = findFirstSuspended(row);
                    if (suspended !== null) {
                      didSuspendAlready = true;
                      workInProgress2.flags |= DidCapture;
                      cutOffTailIfNeeded(renderState, false);
                      var newThenables = suspended.updateQueue;
                      if (newThenables !== null) {
                        workInProgress2.updateQueue = newThenables;
                        workInProgress2.flags |= Update;
                      }
                      workInProgress2.subtreeFlags = NoFlags;
                      resetChildFibers(workInProgress2, renderLanes2);
                      pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                      return workInProgress2.child;
                    }
                    row = row.sibling;
                  }
                }
                if (renderState.tail !== null && now() > getRenderTargetTime()) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  cutOffTailIfNeeded(renderState, false);
                  workInProgress2.lanes = SomeRetryLane;
                }
              } else {
                cutOffTailIfNeeded(renderState, false);
              }
            } else {
              if (!didSuspendAlready) {
                var _suspended = findFirstSuspended(renderedTail);
                if (_suspended !== null) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  var _newThenables = _suspended.updateQueue;
                  if (_newThenables !== null) {
                    workInProgress2.updateQueue = _newThenables;
                    workInProgress2.flags |= Update;
                  }
                  cutOffTailIfNeeded(renderState, true);
                  if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                } else if (
                  // The time it took to render last row is greater than the remaining
                  // time we have to render. So rendering one more row would likely
                  // exceed it.
                  now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                ) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  cutOffTailIfNeeded(renderState, false);
                  workInProgress2.lanes = SomeRetryLane;
                }
              }
              if (renderState.isBackwards) {
                renderedTail.sibling = workInProgress2.child;
                workInProgress2.child = renderedTail;
              } else {
                var previousSibling = renderState.last;
                if (previousSibling !== null) {
                  previousSibling.sibling = renderedTail;
                } else {
                  workInProgress2.child = renderedTail;
                }
                renderState.last = renderedTail;
              }
            }
            if (renderState.tail !== null) {
              var next = renderState.tail;
              renderState.rendering = next;
              renderState.tail = next.sibling;
              renderState.renderingStartTime = now();
              next.sibling = null;
              var suspenseContext = suspenseStackCursor.current;
              if (didSuspendAlready) {
                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              } else {
                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
              }
              pushSuspenseContext(workInProgress2, suspenseContext);
              return next;
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case ScopeComponent: {
            break;
          }
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            popRenderLanes(workInProgress2);
            var _nextState = workInProgress2.memoizedState;
            var nextIsHidden = _nextState !== null;
            if (current2 !== null) {
              var _prevState = current2.memoizedState;
              var prevIsHidden = _prevState !== null;
              if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.
              !enableLegacyHidden) {
                workInProgress2.flags |= Visibility;
              }
            }
            if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
              bubbleProperties(workInProgress2);
            } else {
              if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                bubbleProperties(workInProgress2);
                {
                  if (workInProgress2.subtreeFlags & (Placement | Update)) {
                    workInProgress2.flags |= Visibility;
                  }
                }
              }
            }
            return null;
          }
          case CacheComponent: {
            return null;
          }
          case TracingMarkerComponent: {
            return null;
          }
        }
        throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
      }
      function unwindWork(current2, workInProgress2, renderLanes2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress2);
            }
            var flags = workInProgress2.flags;
            if (flags & ShouldCapture) {
              workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            return null;
          }
          case HostRoot: {
            workInProgress2.stateNode;
            popHostContainer(workInProgress2);
            popTopLevelContextObject(workInProgress2);
            resetWorkInProgressVersions();
            var _flags = workInProgress2.flags;
            if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
              workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
              return workInProgress2;
            }
            return null;
          }
          case HostComponent: {
            popHostContext(workInProgress2);
            return null;
          }
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              if (workInProgress2.alternate === null) {
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              }
              resetHydrationState();
            }
            var _flags2 = workInProgress2.flags;
            if (_flags2 & ShouldCapture) {
              workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            return null;
          }
          case SuspenseListComponent: {
            popSuspenseContext(workInProgress2);
            return null;
          }
          case HostPortal:
            popHostContainer(workInProgress2);
            return null;
          case ContextProvider:
            var context = workInProgress2.type._context;
            popProvider(context, workInProgress2);
            return null;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            popRenderLanes(workInProgress2);
            return null;
          case CacheComponent:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case ClassComponent: {
            var childContextTypes = interruptedWork.type.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              popContext(interruptedWork);
            }
            break;
          }
          case HostRoot: {
            interruptedWork.stateNode;
            popHostContainer(interruptedWork);
            popTopLevelContextObject(interruptedWork);
            resetWorkInProgressVersions();
            break;
          }
          case HostComponent: {
            popHostContext(interruptedWork);
            break;
          }
          case HostPortal:
            popHostContainer(interruptedWork);
            break;
          case SuspenseComponent:
            popSuspenseContext(interruptedWork);
            break;
          case SuspenseListComponent:
            popSuspenseContext(interruptedWork);
            break;
          case ContextProvider:
            var context = interruptedWork.type._context;
            popProvider(context, interruptedWork);
            break;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            popRenderLanes(interruptedWork);
            break;
        }
      }
      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      {
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
      }
      var offscreenSubtreeIsHidden = false;
      var offscreenSubtreeWasHidden = false;
      var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
      var nextEffect = null;
      var inProgressLanes = null;
      var inProgressRoot = null;
      function reportUncaughtErrorInDEV(error2) {
        {
          invokeGuardedCallback(null, function() {
            throw error2;
          });
          clearCaughtError();
        }
      }
      var callComponentWillUnmountWithTimer = function(current2, instance) {
        instance.props = current2.memoizedProps;
        instance.state = current2.memoizedState;
        if (current2.mode & ProfileMode) {
          try {
            startLayoutEffectTimer();
            instance.componentWillUnmount();
          } finally {
            recordLayoutEffectDuration(current2);
          }
        } else {
          instance.componentWillUnmount();
        }
      };
      function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
        try {
          commitHookEffectListMount(Layout2, current2);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
        try {
          callComponentWillUnmountWithTimer(current2, instance);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
        try {
          instance.componentDidMount();
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyAttachRef(current2, nearestMountedAncestor) {
        try {
          commitAttachRef(current2);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyDetachRef(current2, nearestMountedAncestor) {
        var ref2 = current2.ref;
        if (ref2 !== null) {
          if (typeof ref2 === "function") {
            var retVal;
            try {
              if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref2(null);
                } finally {
                  recordLayoutEffectDuration(current2);
                }
              } else {
                retVal = ref2(null);
              }
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
            {
              if (typeof retVal === "function") {
                error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
              }
            }
          } else {
            ref2.current = null;
          }
        }
      }
      function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
        try {
          destroy();
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      var shouldFireAfterActiveInstanceBlur = false;
      function commitBeforeMutationEffects(root3, firstChild) {
        prepareForCommit(root3.containerInfo);
        nextEffect = firstChild;
        commitBeforeMutationEffects_begin();
        var shouldFire = shouldFireAfterActiveInstanceBlur;
        shouldFireAfterActiveInstanceBlur = false;
        return shouldFire;
      }
      function commitBeforeMutationEffects_begin() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var child = fiber.child;
          if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitBeforeMutationEffects_complete();
          }
        }
      }
      function commitBeforeMutationEffects_complete() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          try {
            commitBeforeMutationEffectsOnFiber(fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitBeforeMutationEffectsOnFiber(finishedWork) {
        var current2 = finishedWork.alternate;
        var flags = finishedWork.flags;
        if ((flags & Snapshot) !== NoFlags) {
          setCurrentFiber(finishedWork);
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              break;
            }
            case ClassComponent: {
              if (current2 !== null) {
                var prevProps = current2.memoizedProps;
                var prevState = current2.memoizedState;
                var instance = finishedWork.stateNode;
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    if (instance.props !== finishedWork.memoizedProps) {
                      error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                    if (instance.state !== finishedWork.memoizedState) {
                      error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                  }
                }
                var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                {
                  var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                  if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                    didWarnSet.add(finishedWork.type);
                    error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                  }
                }
                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
              }
              break;
            }
            case HostRoot: {
              {
                var root3 = finishedWork.stateNode;
                clearContainer(root3.containerInfo);
              }
              break;
            }
            case HostComponent:
            case HostText:
            case HostPortal:
            case IncompleteClassComponent:
              break;
            default: {
              throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          resetCurrentFiber();
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
        var updateQueue2 = finishedWork.updateQueue;
        var lastEffect = updateQueue2 !== null ? updateQueue2.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;
          do {
            if ((effect.tag & flags) === flags) {
              var destroy = effect.destroy;
              effect.destroy = void 0;
              if (destroy !== void 0) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectUnmountStarted(finishedWork);
                  } else if ((flags & Layout2) !== NoFlags$1) {
                    markComponentLayoutEffectUnmountStarted(finishedWork);
                  }
                }
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectUnmountStopped();
                  } else if ((flags & Layout2) !== NoFlags$1) {
                    markComponentLayoutEffectUnmountStopped();
                  }
                }
              }
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        var updateQueue2 = finishedWork.updateQueue;
        var lastEffect = updateQueue2 !== null ? updateQueue2.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;
          do {
            if ((effect.tag & flags) === flags) {
              {
                if ((flags & Passive$1) !== NoFlags$1) {
                  markComponentPassiveEffectMountStarted(finishedWork);
                } else if ((flags & Layout2) !== NoFlags$1) {
                  markComponentLayoutEffectMountStarted(finishedWork);
                }
              }
              var create2 = effect.create;
              {
                if ((flags & Insertion) !== NoFlags$1) {
                  setIsRunningInsertionEffect(true);
                }
              }
              effect.destroy = create2();
              {
                if ((flags & Insertion) !== NoFlags$1) {
                  setIsRunningInsertionEffect(false);
                }
              }
              {
                if ((flags & Passive$1) !== NoFlags$1) {
                  markComponentPassiveEffectMountStopped();
                } else if ((flags & Layout2) !== NoFlags$1) {
                  markComponentLayoutEffectMountStopped();
                }
              }
              {
                var destroy = effect.destroy;
                if (destroy !== void 0 && typeof destroy !== "function") {
                  var hookName = void 0;
                  if ((effect.tag & Layout2) !== NoFlags) {
                    hookName = "useLayoutEffect";
                  } else if ((effect.tag & Insertion) !== NoFlags) {
                    hookName = "useInsertionEffect";
                  } else {
                    hookName = "useEffect";
                  }
                  var addendum = void 0;
                  if (destroy === null) {
                    addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                  } else if (typeof destroy.then === "function") {
                    addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                  } else {
                    addendum = " You returned: " + destroy;
                  }
                  error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                }
              }
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitPassiveEffectDurations(finishedRoot, finishedWork) {
        {
          if ((finishedWork.flags & Update) !== NoFlags) {
            switch (finishedWork.tag) {
              case Profiler: {
                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                var commitTime2 = getCommitTime();
                var phase = finishedWork.alternate === null ? "mount" : "update";
                {
                  if (isCurrentUpdateNested()) {
                    phase = "nested-update";
                  }
                }
                if (typeof onPostCommit === "function") {
                  onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                }
                var parentFiber = finishedWork.return;
                outer: while (parentFiber !== null) {
                  switch (parentFiber.tag) {
                    case HostRoot:
                      var root3 = parentFiber.stateNode;
                      root3.passiveEffectDuration += passiveEffectDuration;
                      break outer;
                    case Profiler:
                      var parentStateNode = parentFiber.stateNode;
                      parentStateNode.passiveEffectDuration += passiveEffectDuration;
                      break outer;
                  }
                  parentFiber = parentFiber.return;
                }
                break;
              }
            }
          }
        }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
        if ((finishedWork.flags & LayoutMask) !== NoFlags) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListMount(Layout2 | HasEffect, finishedWork);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Layout2 | HasEffect, finishedWork);
                }
              }
              break;
            }
            case ClassComponent: {
              var instance = finishedWork.stateNode;
              if (finishedWork.flags & Update) {
                if (!offscreenSubtreeWasHidden) {
                  if (current2 === null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        instance.componentDidMount();
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      instance.componentDidMount();
                    }
                  } else {
                    var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                    var prevState = current2.memoizedState;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                    }
                  }
                }
              }
              var updateQueue2 = finishedWork.updateQueue;
              if (updateQueue2 !== null) {
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    if (instance.props !== finishedWork.memoizedProps) {
                      error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                    if (instance.state !== finishedWork.memoizedState) {
                      error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                  }
                }
                commitUpdateQueue(finishedWork, updateQueue2, instance);
              }
              break;
            }
            case HostRoot: {
              var _updateQueue = finishedWork.updateQueue;
              if (_updateQueue !== null) {
                var _instance = null;
                if (finishedWork.child !== null) {
                  switch (finishedWork.child.tag) {
                    case HostComponent:
                      _instance = getPublicInstance(finishedWork.child.stateNode);
                      break;
                    case ClassComponent:
                      _instance = finishedWork.child.stateNode;
                      break;
                  }
                }
                commitUpdateQueue(finishedWork, _updateQueue, _instance);
              }
              break;
            }
            case HostComponent: {
              var _instance2 = finishedWork.stateNode;
              if (current2 === null && finishedWork.flags & Update) {
                var type = finishedWork.type;
                var props = finishedWork.memoizedProps;
                commitMount(_instance2, type, props);
              }
              break;
            }
            case HostText: {
              break;
            }
            case HostPortal: {
              break;
            }
            case Profiler: {
              {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                var effectDuration = finishedWork.stateNode.effectDuration;
                var commitTime2 = getCommitTime();
                var phase = current2 === null ? "mount" : "update";
                {
                  if (isCurrentUpdateNested()) {
                    phase = "nested-update";
                  }
                }
                if (typeof onRender === "function") {
                  onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                }
                {
                  if (typeof onCommit === "function") {
                    onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                  }
                  enqueuePendingPassiveProfilerEffect(finishedWork);
                  var parentFiber = finishedWork.return;
                  outer: while (parentFiber !== null) {
                    switch (parentFiber.tag) {
                      case HostRoot:
                        var root3 = parentFiber.stateNode;
                        root3.effectDuration += effectDuration;
                        break outer;
                      case Profiler:
                        var parentStateNode = parentFiber.stateNode;
                        parentStateNode.effectDuration += effectDuration;
                        break outer;
                    }
                    parentFiber = parentFiber.return;
                  }
                }
              }
              break;
            }
            case SuspenseComponent: {
              commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            }
            case SuspenseListComponent:
            case IncompleteClassComponent:
            case ScopeComponent:
            case OffscreenComponent:
            case LegacyHiddenComponent:
            case TracingMarkerComponent: {
              break;
            }
            default:
              throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        if (!offscreenSubtreeWasHidden) {
          {
            if (finishedWork.flags & Ref) {
              commitAttachRef(finishedWork);
            }
          }
        }
      }
      function reappearLayoutEffectsOnFiber(node2) {
        switch (node2.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (node2.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                safelyCallCommitHookLayoutEffectListMount(node2, node2.return);
              } finally {
                recordLayoutEffectDuration(node2);
              }
            } else {
              safelyCallCommitHookLayoutEffectListMount(node2, node2.return);
            }
            break;
          }
          case ClassComponent: {
            var instance = node2.stateNode;
            if (typeof instance.componentDidMount === "function") {
              safelyCallComponentDidMount(node2, node2.return, instance);
            }
            safelyAttachRef(node2, node2.return);
            break;
          }
          case HostComponent: {
            safelyAttachRef(node2, node2.return);
            break;
          }
        }
      }
      function hideOrUnhideAllChildren(finishedWork, isHidden3) {
        var hostSubtreeRoot = null;
        {
          var node2 = finishedWork;
          while (true) {
            if (node2.tag === HostComponent) {
              if (hostSubtreeRoot === null) {
                hostSubtreeRoot = node2;
                try {
                  var instance = node2.stateNode;
                  if (isHidden3) {
                    hideInstance(instance);
                  } else {
                    unhideInstance(node2.stateNode, node2.memoizedProps);
                  }
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            } else if (node2.tag === HostText) {
              if (hostSubtreeRoot === null) {
                try {
                  var _instance3 = node2.stateNode;
                  if (isHidden3) {
                    hideTextInstance(_instance3);
                  } else {
                    unhideTextInstance(_instance3, node2.memoizedProps);
                  }
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            } else if ((node2.tag === OffscreenComponent || node2.tag === LegacyHiddenComponent) && node2.memoizedState !== null && node2 !== finishedWork) ;
            else if (node2.child !== null) {
              node2.child.return = node2;
              node2 = node2.child;
              continue;
            }
            if (node2 === finishedWork) {
              return;
            }
            while (node2.sibling === null) {
              if (node2.return === null || node2.return === finishedWork) {
                return;
              }
              if (hostSubtreeRoot === node2) {
                hostSubtreeRoot = null;
              }
              node2 = node2.return;
            }
            if (hostSubtreeRoot === node2) {
              hostSubtreeRoot = null;
            }
            node2.sibling.return = node2.return;
            node2 = node2.sibling;
          }
        }
      }
      function commitAttachRef(finishedWork) {
        var ref2 = finishedWork.ref;
        if (ref2 !== null) {
          var instance = finishedWork.stateNode;
          var instanceToUse;
          switch (finishedWork.tag) {
            case HostComponent:
              instanceToUse = getPublicInstance(instance);
              break;
            default:
              instanceToUse = instance;
          }
          if (typeof ref2 === "function") {
            var retVal;
            if (finishedWork.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                retVal = ref2(instanceToUse);
              } finally {
                recordLayoutEffectDuration(finishedWork);
              }
            } else {
              retVal = ref2(instanceToUse);
            }
            {
              if (typeof retVal === "function") {
                error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
              }
            }
          } else {
            {
              if (!ref2.hasOwnProperty("current")) {
                error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
              }
            }
            ref2.current = instanceToUse;
          }
        }
      }
      function detachFiberMutation(fiber) {
        var alternate = fiber.alternate;
        if (alternate !== null) {
          alternate.return = null;
        }
        fiber.return = null;
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        if (alternate !== null) {
          fiber.alternate = null;
          detachFiberAfterEffects(alternate);
        }
        {
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          if (fiber.tag === HostComponent) {
            var hostInstance = fiber.stateNode;
            if (hostInstance !== null) {
              detachDeletedInstance(hostInstance);
            }
          }
          fiber.stateNode = null;
          {
            fiber._debugOwner = null;
          }
          {
            fiber.return = null;
            fiber.dependencies = null;
            fiber.memoizedProps = null;
            fiber.memoizedState = null;
            fiber.pendingProps = null;
            fiber.stateNode = null;
            fiber.updateQueue = null;
          }
        }
      }
      function getHostParentFiber(fiber) {
        var parent = fiber.return;
        while (parent !== null) {
          if (isHostParent(parent)) {
            return parent;
          }
          parent = parent.return;
        }
        throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      }
      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }
      function getHostSibling(fiber) {
        var node2 = fiber;
        siblings: while (true) {
          while (node2.sibling === null) {
            if (node2.return === null || isHostParent(node2.return)) {
              return null;
            }
            node2 = node2.return;
          }
          node2.sibling.return = node2.return;
          node2 = node2.sibling;
          while (node2.tag !== HostComponent && node2.tag !== HostText && node2.tag !== DehydratedFragment) {
            if (node2.flags & Placement) {
              continue siblings;
            }
            if (node2.child === null || node2.tag === HostPortal) {
              continue siblings;
            } else {
              node2.child.return = node2;
              node2 = node2.child;
            }
          }
          if (!(node2.flags & Placement)) {
            return node2.stateNode;
          }
        }
      }
      function commitPlacement(finishedWork) {
        var parentFiber = getHostParentFiber(finishedWork);
        switch (parentFiber.tag) {
          case HostComponent: {
            var parent = parentFiber.stateNode;
            if (parentFiber.flags & ContentReset) {
              resetTextContent(parent);
              parentFiber.flags &= ~ContentReset;
            }
            var before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent);
            break;
          }
          case HostRoot:
          case HostPortal: {
            var _parent = parentFiber.stateNode.containerInfo;
            var _before = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node2, before, parent) {
        var tag = node2.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost) {
          var stateNode = node2.stateNode;
          if (before) {
            insertInContainerBefore(parent, stateNode, before);
          } else {
            appendChildToContainer(parent, stateNode);
          }
        } else if (tag === HostPortal) ;
        else {
          var child = node2.child;
          if (child !== null) {
            insertOrAppendPlacementNodeIntoContainer(child, before, parent);
            var sibling = child.sibling;
            while (sibling !== null) {
              insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
              sibling = sibling.sibling;
            }
          }
        }
      }
      function insertOrAppendPlacementNode(node2, before, parent) {
        var tag = node2.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost) {
          var stateNode = node2.stateNode;
          if (before) {
            insertBefore(parent, stateNode, before);
          } else {
            appendChild2(parent, stateNode);
          }
        } else if (tag === HostPortal) ;
        else {
          var child = node2.child;
          if (child !== null) {
            insertOrAppendPlacementNode(child, before, parent);
            var sibling = child.sibling;
            while (sibling !== null) {
              insertOrAppendPlacementNode(sibling, before, parent);
              sibling = sibling.sibling;
            }
          }
        }
      }
      var hostParent = null;
      var hostParentIsContainer = false;
      function commitDeletionEffects(root3, returnFiber, deletedFiber) {
        {
          var parent = returnFiber;
          findParent: while (parent !== null) {
            switch (parent.tag) {
              case HostComponent: {
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break findParent;
              }
              case HostRoot: {
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break findParent;
              }
              case HostPortal: {
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break findParent;
              }
            }
            parent = parent.return;
          }
          if (hostParent === null) {
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber);
          hostParent = null;
          hostParentIsContainer = false;
        }
        detachFiberMutation(deletedFiber);
      }
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        var child = parent.child;
        while (child !== null) {
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
          child = child.sibling;
        }
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        onCommitUnmount(deletedFiber);
        switch (deletedFiber.tag) {
          case HostComponent: {
            if (!offscreenSubtreeWasHidden) {
              safelyDetachRef(deletedFiber, nearestMountedAncestor);
            }
          }
          case HostText: {
            {
              var prevHostParent = hostParent;
              var prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (hostParent !== null) {
                if (hostParentIsContainer) {
                  removeChildFromContainer(hostParent, deletedFiber.stateNode);
                } else {
                  removeChild(hostParent, deletedFiber.stateNode);
                }
              }
            }
            return;
          }
          case DehydratedFragment: {
            {
              if (hostParent !== null) {
                if (hostParentIsContainer) {
                  clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                } else {
                  clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                }
              }
            }
            return;
          }
          case HostPortal: {
            {
              var _prevHostParent = hostParent;
              var _prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              hostParent = _prevHostParent;
              hostParentIsContainer = _prevHostParentIsContainer;
            }
            return;
          }
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            if (!offscreenSubtreeWasHidden) {
              var updateQueue2 = deletedFiber.updateQueue;
              if (updateQueue2 !== null) {
                var lastEffect = updateQueue2.lastEffect;
                if (lastEffect !== null) {
                  var firstEffect = lastEffect.next;
                  var effect = firstEffect;
                  do {
                    var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                    if (destroy !== void 0) {
                      if ((tag & Insertion) !== NoFlags$1) {
                        safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                      } else if ((tag & Layout2) !== NoFlags$1) {
                        {
                          markComponentLayoutEffectUnmountStarted(deletedFiber);
                        }
                        if (deletedFiber.mode & ProfileMode) {
                          startLayoutEffectTimer();
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          recordLayoutEffectDuration(deletedFiber);
                        } else {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        }
                        {
                          markComponentLayoutEffectUnmountStopped();
                        }
                      }
                    }
                    effect = effect.next;
                  } while (effect !== firstEffect);
                }
              }
            }
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case ClassComponent: {
            if (!offscreenSubtreeWasHidden) {
              safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var instance = deletedFiber.stateNode;
              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
              }
            }
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case ScopeComponent: {
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case OffscreenComponent: {
            if (
              // TODO: Remove this dead flag
              deletedFiber.mode & ConcurrentMode
            ) {
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            } else {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            }
            break;
          }
          default: {
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
        }
      }
      function commitSuspenseCallback(finishedWork) {
        finishedWork.memoizedState;
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        var newState = finishedWork.memoizedState;
        if (newState === null) {
          var current2 = finishedWork.alternate;
          if (current2 !== null) {
            var prevState = current2.memoizedState;
            if (prevState !== null) {
              var suspenseInstance = prevState.dehydrated;
              if (suspenseInstance !== null) {
                commitHydratedSuspenseInstance(suspenseInstance);
              }
            }
          }
        }
      }
      function attachSuspenseRetryListeners(finishedWork) {
        var wakeables = finishedWork.updateQueue;
        if (wakeables !== null) {
          finishedWork.updateQueue = null;
          var retryCache = finishedWork.stateNode;
          if (retryCache === null) {
            retryCache = finishedWork.stateNode = new PossiblyWeakSet();
          }
          wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              {
                if (isDevToolsPresent) {
                  if (inProgressLanes !== null && inProgressRoot !== null) {
                    restorePendingUpdaters(inProgressRoot, inProgressLanes);
                  } else {
                    throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                  }
                }
              }
              wakeable.then(retry, retry);
            }
          });
        }
      }
      function commitMutationEffects(root3, finishedWork, committedLanes) {
        inProgressLanes = committedLanes;
        inProgressRoot = root3;
        setCurrentFiber(finishedWork);
        commitMutationEffectsOnFiber(finishedWork, root3);
        setCurrentFiber(finishedWork);
        inProgressLanes = null;
        inProgressRoot = null;
      }
      function recursivelyTraverseMutationEffects(root3, parentFiber, lanes) {
        var deletions = parentFiber.deletions;
        if (deletions !== null) {
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2];
            try {
              commitDeletionEffects(root3, parentFiber, childToDelete);
            } catch (error2) {
              captureCommitPhaseError(childToDelete, parentFiber, error2);
            }
          }
        }
        var prevDebugFiber = getCurrentFiber();
        if (parentFiber.subtreeFlags & MutationMask) {
          var child = parentFiber.child;
          while (child !== null) {
            setCurrentFiber(child);
            commitMutationEffectsOnFiber(child, root3);
            child = child.sibling;
          }
        }
        setCurrentFiber(prevDebugFiber);
      }
      function commitMutationEffectsOnFiber(finishedWork, root3, lanes) {
        var current2 = finishedWork.alternate;
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              try {
                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                commitHookEffectListMount(Insertion | HasEffect, finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  commitHookEffectListUnmount(Layout2 | HasEffect, finishedWork, finishedWork.return);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
                recordLayoutEffectDuration(finishedWork);
              } else {
                try {
                  commitHookEffectListUnmount(Layout2 | HasEffect, finishedWork, finishedWork.return);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            }
            return;
          }
          case ClassComponent: {
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Ref) {
              if (current2 !== null) {
                safelyDetachRef(current2, current2.return);
              }
            }
            return;
          }
          case HostComponent: {
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Ref) {
              if (current2 !== null) {
                safelyDetachRef(current2, current2.return);
              }
            }
            {
              if (finishedWork.flags & ContentReset) {
                var instance = finishedWork.stateNode;
                try {
                  resetTextContent(instance);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
              if (flags & Update) {
                var _instance4 = finishedWork.stateNode;
                if (_instance4 != null) {
                  var newProps = finishedWork.memoizedProps;
                  var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                  var type = finishedWork.type;
                  var updatePayload = finishedWork.updateQueue;
                  finishedWork.updateQueue = null;
                  if (updatePayload !== null) {
                    try {
                      commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
              }
            }
            return;
          }
          case HostText: {
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              {
                if (finishedWork.stateNode === null) {
                  throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                }
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps;
                var oldText = current2 !== null ? current2.memoizedProps : newText;
                try {
                  commitTextUpdate(textInstance, oldText, newText);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            }
            return;
          }
          case HostRoot: {
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              {
                if (current2 !== null) {
                  var prevRootState = current2.memoizedState;
                  if (prevRootState.isDehydrated) {
                    try {
                      commitHydratedContainer(root3.containerInfo);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
              }
            }
            return;
          }
          case HostPortal: {
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            return;
          }
          case SuspenseComponent: {
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            var offscreenFiber = finishedWork.child;
            if (offscreenFiber.flags & Visibility) {
              var offscreenInstance = offscreenFiber.stateNode;
              var newState = offscreenFiber.memoizedState;
              var isHidden3 = newState !== null;
              offscreenInstance.isHidden = isHidden3;
              if (isHidden3) {
                var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                if (!wasHidden) {
                  markCommitTimeOfFallback();
                }
              }
            }
            if (flags & Update) {
              try {
                commitSuspenseCallback(finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              attachSuspenseRetryListeners(finishedWork);
            }
            return;
          }
          case OffscreenComponent: {
            var _wasHidden = current2 !== null && current2.memoizedState !== null;
            if (
              // TODO: Remove this dead flag
              finishedWork.mode & ConcurrentMode
            ) {
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
              recursivelyTraverseMutationEffects(root3, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            } else {
              recursivelyTraverseMutationEffects(root3, finishedWork);
            }
            commitReconciliationEffects(finishedWork);
            if (flags & Visibility) {
              var _offscreenInstance = finishedWork.stateNode;
              var _newState = finishedWork.memoizedState;
              var _isHidden = _newState !== null;
              var offscreenBoundary = finishedWork;
              _offscreenInstance.isHidden = _isHidden;
              {
                if (_isHidden) {
                  if (!_wasHidden) {
                    if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                      nextEffect = offscreenBoundary;
                      var offscreenChild = offscreenBoundary.child;
                      while (offscreenChild !== null) {
                        nextEffect = offscreenChild;
                        disappearLayoutEffects_begin(offscreenChild);
                        offscreenChild = offscreenChild.sibling;
                      }
                    }
                  }
                }
              }
              {
                hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
              }
            }
            return;
          }
          case SuspenseListComponent: {
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              attachSuspenseRetryListeners(finishedWork);
            }
            return;
          }
          case ScopeComponent: {
            return;
          }
          default: {
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            return;
          }
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & Placement) {
          try {
            commitPlacement(finishedWork);
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
          finishedWork.flags &= ~Placement;
        }
        if (flags & Hydrating) {
          finishedWork.flags &= ~Hydrating;
        }
      }
      function commitLayoutEffects(finishedWork, root3, committedLanes) {
        inProgressLanes = committedLanes;
        inProgressRoot = root3;
        nextEffect = finishedWork;
        commitLayoutEffects_begin(finishedWork, root3, committedLanes);
        inProgressLanes = null;
        inProgressRoot = null;
      }
      function commitLayoutEffects_begin(subtreeRoot, root3, committedLanes) {
        var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if (fiber.tag === OffscreenComponent && isModernRoot) {
            var isHidden3 = fiber.memoizedState !== null;
            var newOffscreenSubtreeIsHidden = isHidden3 || offscreenSubtreeIsHidden;
            if (newOffscreenSubtreeIsHidden) {
              commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
              continue;
            } else {
              var current2 = fiber.alternate;
              var wasHidden = current2 !== null && current2.memoizedState !== null;
              var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
              var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
              offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
              if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                nextEffect = fiber;
                reappearLayoutEffects_begin(fiber);
              }
              var child = firstChild;
              while (child !== null) {
                nextEffect = child;
                commitLayoutEffects_begin(
                  child,
                  // New root; bubble back up to here and stop.
                  root3,
                  committedLanes
                );
                child = child.sibling;
              }
              nextEffect = fiber;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
              continue;
            }
          }
          if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
          }
        }
      }
      function commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & LayoutMask) !== NoFlags) {
            var current2 = fiber.alternate;
            setCurrentFiber(fiber);
            try {
              commitLayoutEffectOnFiber(root3, current2, fiber, committedLanes);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
          }
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function disappearLayoutEffects_begin(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (fiber.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  commitHookEffectListUnmount(Layout2, fiber, fiber.return);
                } finally {
                  recordLayoutEffectDuration(fiber);
                }
              } else {
                commitHookEffectListUnmount(Layout2, fiber, fiber.return);
              }
              break;
            }
            case ClassComponent: {
              safelyDetachRef(fiber, fiber.return);
              var instance = fiber.stateNode;
              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(fiber, fiber.return, instance);
              }
              break;
            }
            case HostComponent: {
              safelyDetachRef(fiber, fiber.return);
              break;
            }
            case OffscreenComponent: {
              var isHidden3 = fiber.memoizedState !== null;
              if (isHidden3) {
                disappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
              break;
            }
          }
          if (firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            disappearLayoutEffects_complete(subtreeRoot);
          }
        }
      }
      function disappearLayoutEffects_complete(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function reappearLayoutEffects_begin(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if (fiber.tag === OffscreenComponent) {
            var isHidden3 = fiber.memoizedState !== null;
            if (isHidden3) {
              reappearLayoutEffects_complete(subtreeRoot);
              continue;
            }
          }
          if (firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            reappearLayoutEffects_complete(subtreeRoot);
          }
        }
      }
      function reappearLayoutEffects_complete(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          try {
            reappearLayoutEffectsOnFiber(fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveMountEffects(root3, finishedWork, committedLanes, committedTransitions) {
        nextEffect = finishedWork;
        commitPassiveMountEffects_begin(finishedWork, root3, committedLanes, committedTransitions);
      }
      function commitPassiveMountEffects_begin(subtreeRoot, root3, committedLanes, committedTransitions) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions);
          }
        }
      }
      function commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & Passive) !== NoFlags) {
            setCurrentFiber(fiber);
            try {
              commitPassiveMountOnFiber(root3, fiber, committedLanes, committedTransitions);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
          }
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (finishedWork.mode & ProfileMode) {
              startPassiveEffectTimer();
              try {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              } finally {
                recordPassiveEffectDuration(finishedWork);
              }
            } else {
              commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
            }
            break;
          }
        }
      }
      function commitPassiveUnmountEffects(firstChild) {
        nextEffect = firstChild;
        commitPassiveUnmountEffects_begin();
      }
      function commitPassiveUnmountEffects_begin() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var child = fiber.child;
          if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
            var deletions = fiber.deletions;
            if (deletions !== null) {
              for (var i2 = 0; i2 < deletions.length; i2++) {
                var fiberToDelete = deletions[i2];
                nextEffect = fiberToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
              }
              {
                var previousFiber = fiber.alternate;
                if (previousFiber !== null) {
                  var detachedChild = previousFiber.child;
                  if (detachedChild !== null) {
                    previousFiber.child = null;
                    do {
                      var detachedSibling = detachedChild.sibling;
                      detachedChild.sibling = null;
                      detachedChild = detachedSibling;
                    } while (detachedChild !== null);
                  }
                }
              }
              nextEffect = fiber;
            }
          }
          if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitPassiveUnmountEffects_complete();
          }
        }
      }
      function commitPassiveUnmountEffects_complete() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & Passive) !== NoFlags) {
            setCurrentFiber(fiber);
            commitPassiveUnmountOnFiber(fiber);
            resetCurrentFiber();
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (finishedWork.mode & ProfileMode) {
              startPassiveEffectTimer();
              commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              recordPassiveEffectDuration(finishedWork);
            } else {
              commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
            }
            break;
          }
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
          resetCurrentFiber();
          var child = fiber.child;
          if (child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
          }
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var sibling = fiber.sibling;
          var returnFiber = fiber.return;
          {
            detachFiberAfterEffects(fiber);
            if (fiber === deletedSubtreeRoot) {
              nextEffect = null;
              return;
            }
          }
          if (sibling !== null) {
            sibling.return = returnFiber;
            nextEffect = sibling;
            return;
          }
          nextEffect = returnFiber;
        }
      }
      function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
        switch (current2.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (current2.mode & ProfileMode) {
              startPassiveEffectTimer();
              commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
              recordPassiveEffectDuration(current2);
            } else {
              commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
            }
            break;
          }
        }
      }
      function invokeLayoutEffectMountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListMount(Layout2 | HasEffect, fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
            case ClassComponent: {
              var instance = fiber.stateNode;
              try {
                instance.componentDidMount();
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
          }
        }
      }
      function invokePassiveEffectMountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListMount(Passive$1 | HasEffect, fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
          }
        }
      }
      function invokeLayoutEffectUnmountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListUnmount(Layout2 | HasEffect, fiber, fiber.return);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
            case ClassComponent: {
              var instance = fiber.stateNode;
              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(fiber, fiber.return, instance);
              }
              break;
            }
          }
        }
      }
      function invokePassiveEffectUnmountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
            }
          }
        }
      }
      if (typeof Symbol === "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        symbolFor("selector.component");
        symbolFor("selector.has_pseudo_class");
        symbolFor("selector.role");
        symbolFor("selector.test_id");
        symbolFor("selector.text");
      }
      var commitHooks = [];
      function onCommitRoot$1() {
        {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
      }
      var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
      function isLegacyActEnvironment(fiber) {
        {
          var isReactActEnvironmentGlobal = (
            // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
            typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
          );
          var jestIsDefined = typeof jest !== "undefined";
          return jestIsDefined && isReactActEnvironmentGlobal !== false;
        }
      }
      function isConcurrentActEnvironment() {
        {
          var isReactActEnvironmentGlobal = (
            // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
            typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
          );
          if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
            error("The current testing environment is not configured to support act(...)");
          }
          return isReactActEnvironmentGlobal;
        }
      }
      var ceil = Math.ceil;
      var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
      var NoContext = (
        /*             */
        0
      );
      var BatchedContext = (
        /*               */
        1
      );
      var RenderContext = (
        /*                */
        2
      );
      var CommitContext = (
        /*                */
        4
      );
      var RootInProgress = 0;
      var RootFatalErrored = 1;
      var RootErrored = 2;
      var RootSuspended = 3;
      var RootSuspendedWithDelay = 4;
      var RootCompleted = 5;
      var RootDidNotComplete = 6;
      var executionContext = NoContext;
      var workInProgressRoot = null;
      var workInProgress = null;
      var workInProgressRootRenderLanes = NoLanes;
      var subtreeRenderLanes = NoLanes;
      var subtreeRenderLanesCursor = createCursor(NoLanes);
      var workInProgressRootExitStatus = RootInProgress;
      var workInProgressRootFatalError = null;
      var workInProgressRootSkippedLanes = NoLanes;
      var workInProgressRootInterleavedUpdatedLanes = NoLanes;
      var workInProgressRootPingedLanes = NoLanes;
      var workInProgressRootConcurrentErrors = null;
      var workInProgressRootRecoverableErrors = null;
      var globalMostRecentFallbackTime = 0;
      var FALLBACK_THROTTLE_MS = 500;
      var workInProgressRootRenderTargetTime = Infinity;
      var RENDER_TIMEOUT_MS = 500;
      var workInProgressTransitions = null;
      function resetRenderTimer() {
        workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
      }
      function getRenderTargetTime() {
        return workInProgressRootRenderTargetTime;
      }
      var hasUncaughtError = false;
      var firstUncaughtError = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var rootDoesHavePassiveEffects = false;
      var rootWithPendingPassiveEffects = null;
      var pendingPassiveEffectsLanes = NoLanes;
      var pendingPassiveProfilerEffects = [];
      var pendingPassiveTransitions = null;
      var NESTED_UPDATE_LIMIT = 50;
      var nestedUpdateCount = 0;
      var rootWithNestedUpdates = null;
      var isFlushingPassiveEffects = false;
      var didScheduleUpdateDuringPassiveEffects = false;
      var NESTED_PASSIVE_UPDATE_LIMIT = 50;
      var nestedPassiveUpdateCount = 0;
      var rootWithPassiveNestedUpdates = null;
      var currentEventTime = NoTimestamp;
      var currentEventTransitionLane = NoLanes;
      var isRunningInsertionEffect = false;
      function getWorkInProgressRoot() {
        return workInProgressRoot;
      }
      function requestEventTime() {
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          return now();
        }
        if (currentEventTime !== NoTimestamp) {
          return currentEventTime;
        }
        currentEventTime = now();
        return currentEventTime;
      }
      function requestUpdateLane(fiber) {
        var mode = fiber.mode;
        if ((mode & ConcurrentMode) === NoMode) {
          return SyncLane;
        } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
          return pickArbitraryLane(workInProgressRootRenderLanes);
        }
        var isTransition = requestCurrentTransition() !== NoTransition;
        if (isTransition) {
          if (ReactCurrentBatchConfig$3.transition !== null) {
            var transition = ReactCurrentBatchConfig$3.transition;
            if (!transition._updatedFibers) {
              transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            transition._updatedFibers.add(fiber);
          }
          if (currentEventTransitionLane === NoLane) {
            currentEventTransitionLane = claimNextTransitionLane();
          }
          return currentEventTransitionLane;
        }
        var updateLane = getCurrentUpdatePriority();
        if (updateLane !== NoLane) {
          return updateLane;
        }
        var eventLane = getCurrentEventPriority();
        return eventLane;
      }
      function requestRetryLane(fiber) {
        var mode = fiber.mode;
        if ((mode & ConcurrentMode) === NoMode) {
          return SyncLane;
        }
        return claimNextRetryLane();
      }
      function scheduleUpdateOnFiber(root3, fiber, lane, eventTime) {
        checkForNestedUpdates();
        {
          if (isRunningInsertionEffect) {
            error("useInsertionEffect must not schedule updates.");
          }
        }
        {
          if (isFlushingPassiveEffects) {
            didScheduleUpdateDuringPassiveEffects = true;
          }
        }
        markRootUpdated(root3, lane, eventTime);
        if ((executionContext & RenderContext) !== NoLanes && root3 === workInProgressRoot) {
          warnAboutRenderPhaseUpdatesInDEV(fiber);
        } else {
          {
            if (isDevToolsPresent) {
              addFiberToLanesMap(root3, fiber, lane);
            }
          }
          warnIfUpdatesNotWrappedWithActDEV(fiber);
          if (root3 === workInProgressRoot) {
            if ((executionContext & RenderContext) === NoContext) {
              workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
            }
            if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
              markRootSuspended$1(root3, workInProgressRootRenderLanes);
            }
          }
          ensureRootIsScheduled(root3, eventTime);
          if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
          !ReactCurrentActQueue$1.isBatchingLegacy) {
            resetRenderTimer();
            flushSyncCallbacksOnlyInLegacyMode();
          }
        }
      }
      function scheduleInitialHydrationOnRoot(root3, lane, eventTime) {
        var current2 = root3.current;
        current2.lanes = lane;
        markRootUpdated(root3, lane, eventTime);
        ensureRootIsScheduled(root3, eventTime);
      }
      function isUnsafeClassRenderPhaseUpdate(fiber) {
        return (
          // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
          // decided not to enable it.
          (executionContext & RenderContext) !== NoContext
        );
      }
      function ensureRootIsScheduled(root3, currentTime) {
        var existingCallbackNode = root3.callbackNode;
        markStarvedLanesAsExpired(root3, currentTime);
        var nextLanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (nextLanes === NoLanes) {
          if (existingCallbackNode !== null) {
            cancelCallback$1(existingCallbackNode);
          }
          root3.callbackNode = null;
          root3.callbackPriority = NoLane;
          return;
        }
        var newCallbackPriority = getHighestPriorityLane(nextLanes);
        var existingCallbackPriority = root3.callbackPriority;
        if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
        // Scheduler task, rather than an `act` task, cancel it and re-scheduled
        // on the `act` queue.
        !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
          {
            if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
              error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          return;
        }
        if (existingCallbackNode != null) {
          cancelCallback$1(existingCallbackNode);
        }
        var newCallbackNode;
        if (newCallbackPriority === SyncLane) {
          if (root3.tag === LegacyRoot) {
            if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
              ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
            }
            scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root3));
          } else {
            scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3));
          }
          {
            if (ReactCurrentActQueue$1.current !== null) {
              ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
            } else {
              scheduleMicrotask(function() {
                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                  flushSyncCallbacks();
                }
              });
            }
          }
          newCallbackNode = null;
        } else {
          var schedulerPriorityLevel;
          switch (lanesToEventPriority(nextLanes)) {
            case DiscreteEventPriority:
              schedulerPriorityLevel = ImmediatePriority;
              break;
            case ContinuousEventPriority:
              schedulerPriorityLevel = UserBlockingPriority;
              break;
            case DefaultEventPriority:
              schedulerPriorityLevel = NormalPriority;
              break;
            case IdleEventPriority:
              schedulerPriorityLevel = IdlePriority;
              break;
            default:
              schedulerPriorityLevel = NormalPriority;
              break;
          }
          newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root3));
        }
        root3.callbackPriority = newCallbackPriority;
        root3.callbackNode = newCallbackNode;
      }
      function performConcurrentWorkOnRoot(root3, didTimeout) {
        {
          resetNestedUpdateFlag();
        }
        currentEventTime = NoTimestamp;
        currentEventTransitionLane = NoLanes;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        var originalCallbackNode = root3.callbackNode;
        var didFlushPassiveEffects = flushPassiveEffects();
        if (didFlushPassiveEffects) {
          if (root3.callbackNode !== originalCallbackNode) {
            return null;
          }
        }
        var lanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (lanes === NoLanes) {
          return null;
        }
        var shouldTimeSlice = !includesBlockingLane(root3, lanes) && !includesExpiredLane(root3, lanes) && !didTimeout;
        var exitStatus = shouldTimeSlice ? renderRootConcurrent(root3, lanes) : renderRootSync(root3, lanes);
        if (exitStatus !== RootInProgress) {
          if (exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root3, NoLanes);
            markRootSuspended$1(root3, lanes);
            ensureRootIsScheduled(root3, now());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            markRootSuspended$1(root3, lanes);
          } else {
            var renderWasConcurrent = !includesBlockingLane(root3, lanes);
            var finishedWork = root3.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
              exitStatus = renderRootSync(root3, lanes);
              if (exitStatus === RootErrored) {
                var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                if (_errorRetryLanes !== NoLanes) {
                  lanes = _errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root3, _errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var _fatalError = workInProgressRootFatalError;
                prepareFreshStack(root3, NoLanes);
                markRootSuspended$1(root3, lanes);
                ensureRootIsScheduled(root3, now());
                throw _fatalError;
              }
            }
            root3.finishedWork = finishedWork;
            root3.finishedLanes = lanes;
            finishConcurrentRender(root3, exitStatus, lanes);
          }
        }
        ensureRootIsScheduled(root3, now());
        if (root3.callbackNode === originalCallbackNode) {
          return performConcurrentWorkOnRoot.bind(null, root3);
        }
        return null;
      }
      function recoverFromConcurrentError(root3, errorRetryLanes) {
        var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
        if (isRootDehydrated(root3)) {
          var rootWorkInProgress = prepareFreshStack(root3, errorRetryLanes);
          rootWorkInProgress.flags |= ForceClientRender;
          {
            errorHydratingContainer(root3.containerInfo);
          }
        }
        var exitStatus = renderRootSync(root3, errorRetryLanes);
        if (exitStatus !== RootErrored) {
          var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
          workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
          if (errorsFromSecondAttempt !== null) {
            queueRecoverableErrors(errorsFromSecondAttempt);
          }
        }
        return exitStatus;
      }
      function queueRecoverableErrors(errors) {
        if (workInProgressRootRecoverableErrors === null) {
          workInProgressRootRecoverableErrors = errors;
        } else {
          workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
        }
      }
      function finishConcurrentRender(root3, exitStatus, lanes) {
        switch (exitStatus) {
          case RootInProgress:
          case RootFatalErrored: {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          case RootErrored: {
            commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootSuspended: {
            markRootSuspended$1(root3, lanes);
            if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
            !shouldForceFlushFallbacksInDEV()) {
              var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
              if (msUntilTimeout > 10) {
                var nextLanes = getNextLanes(root3, NoLanes);
                if (nextLanes !== NoLanes) {
                  break;
                }
                var suspendedLanes = root3.suspendedLanes;
                if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                  requestEventTime();
                  markRootPinged(root3, suspendedLanes);
                  break;
                }
                root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                break;
              }
            }
            commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootSuspendedWithDelay: {
            markRootSuspended$1(root3, lanes);
            if (includesOnlyTransitions(lanes)) {
              break;
            }
            if (!shouldForceFlushFallbacksInDEV()) {
              var mostRecentEventTime = getMostRecentEventTime(root3, lanes);
              var eventTimeMs = mostRecentEventTime;
              var timeElapsedMs = now() - eventTimeMs;
              var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
              if (_msUntilTimeout > 10) {
                root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                break;
              }
            }
            commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootCompleted: {
            commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          default: {
            throw new Error("Unknown root exit status.");
          }
        }
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        var node2 = finishedWork;
        while (true) {
          if (node2.flags & StoreConsistency) {
            var updateQueue2 = node2.updateQueue;
            if (updateQueue2 !== null) {
              var checks = updateQueue2.stores;
              if (checks !== null) {
                for (var i2 = 0; i2 < checks.length; i2++) {
                  var check = checks[i2];
                  var getSnapshot = check.getSnapshot;
                  var renderedValue = check.value;
                  try {
                    if (!objectIs(getSnapshot(), renderedValue)) {
                      return false;
                    }
                  } catch (error2) {
                    return false;
                  }
                }
              }
            }
          }
          var child = node2.child;
          if (node2.subtreeFlags & StoreConsistency && child !== null) {
            child.return = node2;
            node2 = child;
            continue;
          }
          if (node2 === finishedWork) {
            return true;
          }
          while (node2.sibling === null) {
            if (node2.return === null || node2.return === finishedWork) {
              return true;
            }
            node2 = node2.return;
          }
          node2.sibling.return = node2.return;
          node2 = node2.sibling;
        }
        return true;
      }
      function markRootSuspended$1(root3, suspendedLanes) {
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
        markRootSuspended(root3, suspendedLanes);
      }
      function performSyncWorkOnRoot(root3) {
        {
          syncNestedUpdateFlag();
        }
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        flushPassiveEffects();
        var lanes = getNextLanes(root3, NoLanes);
        if (!includesSomeLane(lanes, SyncLane)) {
          ensureRootIsScheduled(root3, now());
          return null;
        }
        var exitStatus = renderRootSync(root3, lanes);
        if (root3.tag !== LegacyRoot && exitStatus === RootErrored) {
          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
          if (errorRetryLanes !== NoLanes) {
            lanes = errorRetryLanes;
            exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
          }
        }
        if (exitStatus === RootFatalErrored) {
          var fatalError = workInProgressRootFatalError;
          prepareFreshStack(root3, NoLanes);
          markRootSuspended$1(root3, lanes);
          ensureRootIsScheduled(root3, now());
          throw fatalError;
        }
        if (exitStatus === RootDidNotComplete) {
          throw new Error("Root did not complete. This is a bug in React.");
        }
        var finishedWork = root3.current.alternate;
        root3.finishedWork = finishedWork;
        root3.finishedLanes = lanes;
        commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
        ensureRootIsScheduled(root3, now());
        return null;
      }
      function flushRoot(root3, lanes) {
        if (lanes !== NoLanes) {
          markRootEntangled(root3, mergeLanes(lanes, SyncLane));
          ensureRootIsScheduled(root3, now());
          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
            resetRenderTimer();
            flushSyncCallbacks();
          }
        }
      }
      function batchedUpdates$1(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        try {
          return fn(a);
        } finally {
          executionContext = prevExecutionContext;
          if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
          !ReactCurrentActQueue$1.isBatchingLegacy) {
            resetRenderTimer();
            flushSyncCallbacksOnlyInLegacyMode();
          }
        }
      }
      function discreteUpdates(fn, a, b, c, d) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          return fn(a, b, c, d);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
          if (executionContext === NoContext) {
            resetRenderTimer();
          }
        }
      }
      function flushSync(fn) {
        if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
          flushPassiveEffects();
        }
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        var previousPriority = getCurrentUpdatePriority();
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          if (fn) {
            return fn();
          } else {
            return void 0;
          }
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
          executionContext = prevExecutionContext;
          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushSyncCallbacks();
          }
        }
      }
      function isAlreadyRendering() {
        return (executionContext & (RenderContext | CommitContext)) !== NoContext;
      }
      function pushRenderLanes(fiber, lanes) {
        push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
        subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
      }
      function popRenderLanes(fiber) {
        subtreeRenderLanes = subtreeRenderLanesCursor.current;
        pop(subtreeRenderLanesCursor, fiber);
      }
      function prepareFreshStack(root3, lanes) {
        root3.finishedWork = null;
        root3.finishedLanes = NoLanes;
        var timeoutHandle = root3.timeoutHandle;
        if (timeoutHandle !== noTimeout) {
          root3.timeoutHandle = noTimeout;
          cancelTimeout(timeoutHandle);
        }
        if (workInProgress !== null) {
          var interruptedWork = workInProgress.return;
          while (interruptedWork !== null) {
            var current2 = interruptedWork.alternate;
            unwindInterruptedWork(current2, interruptedWork);
            interruptedWork = interruptedWork.return;
          }
        }
        workInProgressRoot = root3;
        var rootWorkInProgress = createWorkInProgress(root3.current, null);
        workInProgress = rootWorkInProgress;
        workInProgressRootRenderLanes = subtreeRenderLanes = lanes;
        workInProgressRootExitStatus = RootInProgress;
        workInProgressRootFatalError = null;
        workInProgressRootSkippedLanes = NoLanes;
        workInProgressRootInterleavedUpdatedLanes = NoLanes;
        workInProgressRootPingedLanes = NoLanes;
        workInProgressRootConcurrentErrors = null;
        workInProgressRootRecoverableErrors = null;
        finishQueueingConcurrentUpdates();
        {
          ReactStrictModeWarnings.discardPendingWarnings();
        }
        return rootWorkInProgress;
      }
      function handleError(root3, thrownValue) {
        do {
          var erroredWork = workInProgress;
          try {
            resetContextDependencies();
            resetHooksAfterThrow();
            resetCurrentFiber();
            ReactCurrentOwner$2.current = null;
            if (erroredWork === null || erroredWork.return === null) {
              workInProgressRootExitStatus = RootFatalErrored;
              workInProgressRootFatalError = thrownValue;
              workInProgress = null;
              return;
            }
            if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
              stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
            }
            if (enableSchedulingProfiler) {
              markComponentRenderStopped();
              if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                var wakeable = thrownValue;
                markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
              } else {
                markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
              }
            }
            throwException(root3, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
            completeUnitOfWork(erroredWork);
          } catch (yetAnotherThrownValue) {
            thrownValue = yetAnotherThrownValue;
            if (workInProgress === erroredWork && erroredWork !== null) {
              erroredWork = erroredWork.return;
              workInProgress = erroredWork;
            } else {
              erroredWork = workInProgress;
            }
            continue;
          }
          return;
        } while (true);
      }
      function pushDispatcher() {
        var prevDispatcher = ReactCurrentDispatcher$2.current;
        ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
        if (prevDispatcher === null) {
          return ContextOnlyDispatcher;
        } else {
          return prevDispatcher;
        }
      }
      function popDispatcher(prevDispatcher) {
        ReactCurrentDispatcher$2.current = prevDispatcher;
      }
      function markCommitTimeOfFallback() {
        globalMostRecentFallbackTime = now();
      }
      function markSkippedUpdateLanes(lane) {
        workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
      }
      function renderDidSuspend() {
        if (workInProgressRootExitStatus === RootInProgress) {
          workInProgressRootExitStatus = RootSuspended;
        }
      }
      function renderDidSuspendDelayIfPossible() {
        if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
        }
        if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
          markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
        }
      }
      function renderDidError(error2) {
        if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
          workInProgressRootExitStatus = RootErrored;
        }
        if (workInProgressRootConcurrentErrors === null) {
          workInProgressRootConcurrentErrors = [error2];
        } else {
          workInProgressRootConcurrentErrors.push(error2);
        }
      }
      function renderHasNotSuspendedYet() {
        return workInProgressRootExitStatus === RootInProgress;
      }
      function renderRootSync(root3, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root3.memoizedUpdaters;
              if (memoizedUpdaters.size > 0) {
                restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                memoizedUpdaters.clear();
              }
              movePendingFibersToMemoized(root3, lanes);
            }
          }
          workInProgressTransitions = getTransitionsForLanes();
          prepareFreshStack(root3, lanes);
        }
        {
          markRenderStarted(lanes);
        }
        do {
          try {
            workLoopSync();
            break;
          } catch (thrownValue) {
            handleError(root3, thrownValue);
          }
        } while (true);
        resetContextDependencies();
        executionContext = prevExecutionContext;
        popDispatcher(prevDispatcher);
        if (workInProgress !== null) {
          throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
        }
        {
          markRenderStopped();
        }
        workInProgressRoot = null;
        workInProgressRootRenderLanes = NoLanes;
        return workInProgressRootExitStatus;
      }
      function workLoopSync() {
        while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
        }
      }
      function renderRootConcurrent(root3, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root3.memoizedUpdaters;
              if (memoizedUpdaters.size > 0) {
                restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                memoizedUpdaters.clear();
              }
              movePendingFibersToMemoized(root3, lanes);
            }
          }
          workInProgressTransitions = getTransitionsForLanes();
          resetRenderTimer();
          prepareFreshStack(root3, lanes);
        }
        {
          markRenderStarted(lanes);
        }
        do {
          try {
            workLoopConcurrent();
            break;
          } catch (thrownValue) {
            handleError(root3, thrownValue);
          }
        } while (true);
        resetContextDependencies();
        popDispatcher(prevDispatcher);
        executionContext = prevExecutionContext;
        if (workInProgress !== null) {
          {
            markRenderYielded();
          }
          return RootInProgress;
        } else {
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
      }
      function workLoopConcurrent() {
        while (workInProgress !== null && !shouldYield()) {
          performUnitOfWork(workInProgress);
        }
      }
      function performUnitOfWork(unitOfWork) {
        var current2 = unitOfWork.alternate;
        setCurrentFiber(unitOfWork);
        var next;
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          startProfilerTimer(unitOfWork);
          next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
          stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
        } else {
          next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
        }
        resetCurrentFiber();
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        if (next === null) {
          completeUnitOfWork(unitOfWork);
        } else {
          workInProgress = next;
        }
        ReactCurrentOwner$2.current = null;
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          var current2 = completedWork.alternate;
          var returnFiber = completedWork.return;
          if ((completedWork.flags & Incomplete) === NoFlags) {
            setCurrentFiber(completedWork);
            var next = void 0;
            if ((completedWork.mode & ProfileMode) === NoMode) {
              next = completeWork(current2, completedWork, subtreeRenderLanes);
            } else {
              startProfilerTimer(completedWork);
              next = completeWork(current2, completedWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
            }
            resetCurrentFiber();
            if (next !== null) {
              workInProgress = next;
              return;
            }
          } else {
            var _next = unwindWork(current2, completedWork);
            if (_next !== null) {
              _next.flags &= HostEffectMask;
              workInProgress = _next;
              return;
            }
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              var actualDuration = completedWork.actualDuration;
              var child = completedWork.child;
              while (child !== null) {
                actualDuration += child.actualDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
            }
            if (returnFiber !== null) {
              returnFiber.flags |= Incomplete;
              returnFiber.subtreeFlags = NoFlags;
              returnFiber.deletions = null;
            } else {
              workInProgressRootExitStatus = RootDidNotComplete;
              workInProgress = null;
              return;
            }
          }
          var siblingFiber = completedWork.sibling;
          if (siblingFiber !== null) {
            workInProgress = siblingFiber;
            return;
          }
          completedWork = returnFiber;
          workInProgress = completedWork;
        } while (completedWork !== null);
        if (workInProgressRootExitStatus === RootInProgress) {
          workInProgressRootExitStatus = RootCompleted;
        }
      }
      function commitRoot(root3, recoverableErrors, transitions) {
        var previousUpdateLanePriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          commitRootImpl(root3, recoverableErrors, transitions, previousUpdateLanePriority);
        } finally {
          ReactCurrentBatchConfig$3.transition = prevTransition;
          setCurrentUpdatePriority(previousUpdateLanePriority);
        }
        return null;
      }
      function commitRootImpl(root3, recoverableErrors, transitions, renderPriorityLevel) {
        do {
          flushPassiveEffects();
        } while (rootWithPendingPassiveEffects !== null);
        flushRenderPhaseStrictModeWarningsInDEV();
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        var finishedWork = root3.finishedWork;
        var lanes = root3.finishedLanes;
        {
          markCommitStarted(lanes);
        }
        if (finishedWork === null) {
          {
            markCommitStopped();
          }
          return null;
        } else {
          {
            if (lanes === NoLanes) {
              error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
            }
          }
        }
        root3.finishedWork = null;
        root3.finishedLanes = NoLanes;
        if (finishedWork === root3.current) {
          throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        }
        root3.callbackNode = null;
        root3.callbackPriority = NoLane;
        var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
        markRootFinished(root3, remainingLanes);
        if (root3 === workInProgressRoot) {
          workInProgressRoot = null;
          workInProgress = null;
          workInProgressRootRenderLanes = NoLanes;
        }
        if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
          if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            pendingPassiveTransitions = transitions;
            scheduleCallback$1(NormalPriority, function() {
              flushPassiveEffects();
              return null;
            });
          }
        }
        var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
        var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
        if (subtreeHasEffects || rootHasEffect) {
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          ReactCurrentBatchConfig$3.transition = null;
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(DiscreteEventPriority);
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          ReactCurrentOwner$2.current = null;
          commitBeforeMutationEffects(root3, finishedWork);
          {
            recordCommitTime();
          }
          commitMutationEffects(root3, finishedWork, lanes);
          resetAfterCommit(root3.containerInfo);
          root3.current = finishedWork;
          {
            markLayoutEffectsStarted(lanes);
          }
          commitLayoutEffects(finishedWork, root3, lanes);
          {
            markLayoutEffectsStopped();
          }
          requestPaint();
          executionContext = prevExecutionContext;
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
        } else {
          root3.current = finishedWork;
          {
            recordCommitTime();
          }
        }
        var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
        if (rootDoesHavePassiveEffects) {
          rootDoesHavePassiveEffects = false;
          rootWithPendingPassiveEffects = root3;
          pendingPassiveEffectsLanes = lanes;
        } else {
          {
            nestedPassiveUpdateCount = 0;
            rootWithPassiveNestedUpdates = null;
          }
        }
        remainingLanes = root3.pendingLanes;
        if (remainingLanes === NoLanes) {
          legacyErrorBoundariesThatAlreadyFailed = null;
        }
        {
          if (!rootDidHavePassiveEffects) {
            commitDoubleInvokeEffectsInDEV(root3.current, false);
          }
        }
        onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
        {
          if (isDevToolsPresent) {
            root3.memoizedUpdaters.clear();
          }
        }
        {
          onCommitRoot$1();
        }
        ensureRootIsScheduled(root3, now());
        if (recoverableErrors !== null) {
          var onRecoverableError = root3.onRecoverableError;
          for (var i2 = 0; i2 < recoverableErrors.length; i2++) {
            var recoverableError = recoverableErrors[i2];
            var componentStack = recoverableError.stack;
            var digest = recoverableError.digest;
            onRecoverableError(recoverableError.value, {
              componentStack,
              digest
            });
          }
        }
        if (hasUncaughtError) {
          hasUncaughtError = false;
          var error$1 = firstUncaughtError;
          firstUncaughtError = null;
          throw error$1;
        }
        if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root3.tag !== LegacyRoot) {
          flushPassiveEffects();
        }
        remainingLanes = root3.pendingLanes;
        if (includesSomeLane(remainingLanes, SyncLane)) {
          {
            markNestedUpdateScheduled();
          }
          if (root3 === rootWithNestedUpdates) {
            nestedUpdateCount++;
          } else {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = root3;
          }
        } else {
          nestedUpdateCount = 0;
        }
        flushSyncCallbacks();
        {
          markCommitStopped();
        }
        return null;
      }
      function flushPassiveEffects() {
        if (rootWithPendingPassiveEffects !== null) {
          var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
          var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(priority);
            return flushPassiveEffectsImpl();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          }
        }
        return false;
      }
      function enqueuePendingPassiveProfilerEffect(fiber) {
        {
          pendingPassiveProfilerEffects.push(fiber);
          if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback$1(NormalPriority, function() {
              flushPassiveEffects();
              return null;
            });
          }
        }
      }
      function flushPassiveEffectsImpl() {
        if (rootWithPendingPassiveEffects === null) {
          return false;
        }
        var transitions = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root3 = rootWithPendingPassiveEffects;
        var lanes = pendingPassiveEffectsLanes;
        rootWithPendingPassiveEffects = null;
        pendingPassiveEffectsLanes = NoLanes;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Cannot flush passive effects while already rendering.");
        }
        {
          isFlushingPassiveEffects = true;
          didScheduleUpdateDuringPassiveEffects = false;
        }
        {
          markPassiveEffectsStarted(lanes);
        }
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        commitPassiveUnmountEffects(root3.current);
        commitPassiveMountEffects(root3, root3.current, lanes, transitions);
        {
          var profilerEffects = pendingPassiveProfilerEffects;
          pendingPassiveProfilerEffects = [];
          for (var i2 = 0; i2 < profilerEffects.length; i2++) {
            var _fiber = profilerEffects[i2];
            commitPassiveEffectDurations(root3, _fiber);
          }
        }
        {
          markPassiveEffectsStopped();
        }
        {
          commitDoubleInvokeEffectsInDEV(root3.current, true);
        }
        executionContext = prevExecutionContext;
        flushSyncCallbacks();
        {
          if (didScheduleUpdateDuringPassiveEffects) {
            if (root3 === rootWithPassiveNestedUpdates) {
              nestedPassiveUpdateCount++;
            } else {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = root3;
            }
          } else {
            nestedPassiveUpdateCount = 0;
          }
          isFlushingPassiveEffects = false;
          didScheduleUpdateDuringPassiveEffects = false;
        }
        onPostCommitRoot(root3);
        {
          var stateNode = root3.current.stateNode;
          stateNode.effectDuration = 0;
          stateNode.passiveEffectDuration = 0;
        }
        return true;
      }
      function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
      }
      function markLegacyErrorBoundaryAsFailed(instance) {
        if (legacyErrorBoundariesThatAlreadyFailed === null) {
          legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
        } else {
          legacyErrorBoundariesThatAlreadyFailed.add(instance);
        }
      }
      function prepareToThrowUncaughtError(error2) {
        if (!hasUncaughtError) {
          hasUncaughtError = true;
          firstUncaughtError = error2;
        }
      }
      var onUncaughtError = prepareToThrowUncaughtError;
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
        var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
        var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
        var root3 = enqueueUpdate(rootFiber, update, SyncLane);
        var eventTime = requestEventTime();
        if (root3 !== null) {
          markRootUpdated(root3, SyncLane, eventTime);
          ensureRootIsScheduled(root3, eventTime);
        }
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
        {
          reportUncaughtErrorInDEV(error$1);
          setIsRunningInsertionEffect(false);
        }
        if (sourceFiber.tag === HostRoot) {
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
          return;
        }
        var fiber = null;
        {
          fiber = nearestMountedAncestor;
        }
        while (fiber !== null) {
          if (fiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
            return;
          } else if (fiber.tag === ClassComponent) {
            var ctor = fiber.type;
            var instance = fiber.stateNode;
            if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
              var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
              var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
              var root3 = enqueueUpdate(fiber, update, SyncLane);
              var eventTime = requestEventTime();
              if (root3 !== null) {
                markRootUpdated(root3, SyncLane, eventTime);
                ensureRootIsScheduled(root3, eventTime);
              }
              return;
            }
          }
          fiber = fiber.return;
        }
        {
          error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
        }
      }
      function pingSuspendedRoot(root3, wakeable, pingedLanes) {
        var pingCache = root3.pingCache;
        if (pingCache !== null) {
          pingCache.delete(wakeable);
        }
        var eventTime = requestEventTime();
        markRootPinged(root3, pingedLanes);
        warnIfSuspenseResolutionNotWrappedWithActDEV(root3);
        if (workInProgressRoot === root3 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
          if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
            prepareFreshStack(root3, NoLanes);
          } else {
            workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
          }
        }
        ensureRootIsScheduled(root3, eventTime);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        if (retryLane === NoLane) {
          retryLane = requestRetryLane(boundaryFiber);
        }
        var eventTime = requestEventTime();
        var root3 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        if (root3 !== null) {
          markRootUpdated(root3, retryLane, eventTime);
          ensureRootIsScheduled(root3, eventTime);
        }
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState;
        var retryLane = NoLane;
        if (suspenseState !== null) {
          retryLane = suspenseState.retryLane;
        }
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = NoLane;
        var retryCache;
        switch (boundaryFiber.tag) {
          case SuspenseComponent:
            retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            break;
          case SuspenseListComponent:
            retryCache = boundaryFiber.stateNode;
            break;
          default:
            throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
        }
        if (retryCache !== null) {
          retryCache.delete(wakeable);
        }
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function jnd(timeElapsed) {
        return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
      }
      function checkForNestedUpdates() {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
          nestedUpdateCount = 0;
          rootWithNestedUpdates = null;
          throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
        }
        {
          if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
            nestedPassiveUpdateCount = 0;
            rootWithPassiveNestedUpdates = null;
            error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
          }
        }
      }
      function flushRenderPhaseStrictModeWarningsInDEV() {
        {
          ReactStrictModeWarnings.flushLegacyContextWarning();
          {
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          }
        }
      }
      function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
        {
          setCurrentFiber(fiber);
          invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
          if (hasPassiveEffects) {
            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
          }
          invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
          if (hasPassiveEffects) {
            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
          }
          resetCurrentFiber();
        }
      }
      function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
        {
          var current2 = firstChild;
          var subtreeRoot = null;
          while (current2 !== null) {
            var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
            if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
              current2 = current2.child;
            } else {
              if ((current2.flags & fiberFlags) !== NoFlags) {
                invokeEffectFn(current2);
              }
              if (current2.sibling !== null) {
                current2 = current2.sibling;
              } else {
                current2 = subtreeRoot = current2.return;
              }
            }
          }
        }
      }
      var didWarnStateUpdateForNotYetMountedComponent = null;
      function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        {
          if ((executionContext & RenderContext) !== NoContext) {
            return;
          }
          if (!(fiber.mode & ConcurrentMode)) {
            return;
          }
          var tag = fiber.tag;
          if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
            return;
          }
          var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
              return;
            }
            didWarnStateUpdateForNotYetMountedComponent.add(componentName);
          } else {
            didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
          }
          var previousFiber = current;
          try {
            setCurrentFiber(fiber);
            error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          } finally {
            if (previousFiber) {
              setCurrentFiber(fiber);
            } else {
              resetCurrentFiber();
            }
          }
        }
      }
      var beginWork$1;
      {
        var dummyFiber = null;
        beginWork$1 = function(current2, unitOfWork, lanes) {
          var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
          try {
            return beginWork(current2, unitOfWork, lanes);
          } catch (originalError) {
            if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
              throw originalError;
            }
            resetContextDependencies();
            resetHooksAfterThrow();
            unwindInterruptedWork(current2, unitOfWork);
            assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
            if (unitOfWork.mode & ProfileMode) {
              startProfilerTimer(unitOfWork);
            }
            invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
            if (hasCaughtError()) {
              var replayError = clearCaughtError();
              if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                originalError._suppressLogging = true;
              }
            }
            throw originalError;
          }
        };
      }
      var didWarnAboutUpdateInRender = false;
      var didWarnAboutUpdateInRenderForAnotherComponent;
      {
        didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
      }
      function warnAboutRenderPhaseUpdatesInDEV(fiber) {
        {
          if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                var dedupeKey = renderingComponentName;
                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                  didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                  var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                  error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                }
                break;
              }
              case ClassComponent: {
                if (!didWarnAboutUpdateInRender) {
                  error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                  didWarnAboutUpdateInRender = true;
                }
                break;
              }
            }
          }
        }
      }
      function restorePendingUpdaters(root3, lanes) {
        {
          if (isDevToolsPresent) {
            var memoizedUpdaters = root3.memoizedUpdaters;
            memoizedUpdaters.forEach(function(schedulingFiber) {
              addFiberToLanesMap(root3, schedulingFiber, lanes);
            });
          }
        }
      }
      var fakeActCallbackNode = {};
      function scheduleCallback$1(priorityLevel, callback) {
        {
          var actQueue = ReactCurrentActQueue$1.current;
          if (actQueue !== null) {
            actQueue.push(callback);
            return fakeActCallbackNode;
          } else {
            return scheduleCallback(priorityLevel, callback);
          }
        }
      }
      function cancelCallback$1(callbackNode) {
        if (callbackNode === fakeActCallbackNode) {
          return;
        }
        return cancelCallback(callbackNode);
      }
      function shouldForceFlushFallbacksInDEV() {
        return ReactCurrentActQueue$1.current !== null;
      }
      function warnIfUpdatesNotWrappedWithActDEV(fiber) {
        {
          if (fiber.mode & ConcurrentMode) {
            if (!isConcurrentActEnvironment()) {
              return;
            }
          } else {
            if (!isLegacyActEnvironment()) {
              return;
            }
            if (executionContext !== NoContext) {
              return;
            }
            if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
              return;
            }
          }
          if (ReactCurrentActQueue$1.current === null) {
            var previousFiber = current;
            try {
              setCurrentFiber(fiber);
              error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
      }
      function warnIfSuspenseResolutionNotWrappedWithActDEV(root3) {
        {
          if (root3.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
            error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
          }
        }
      }
      function setIsRunningInsertionEffect(isRunning) {
        {
          isRunningInsertionEffect = isRunning;
        }
      }
      var resolveFamily = null;
      var failedBoundaries = null;
      var setRefreshHandler = function(handler) {
        {
          resolveFamily = handler;
        }
      };
      function resolveFunctionForHotReloading(type) {
        {
          if (resolveFamily === null) {
            return type;
          }
          var family = resolveFamily(type);
          if (family === void 0) {
            return type;
          }
          return family.current;
        }
      }
      function resolveClassForHotReloading(type) {
        return resolveFunctionForHotReloading(type);
      }
      function resolveForwardRefForHotReloading(type) {
        {
          if (resolveFamily === null) {
            return type;
          }
          var family = resolveFamily(type);
          if (family === void 0) {
            if (type !== null && type !== void 0 && typeof type.render === "function") {
              var currentRender = resolveFunctionForHotReloading(type.render);
              if (type.render !== currentRender) {
                var syntheticType = {
                  $$typeof: REACT_FORWARD_REF_TYPE,
                  render: currentRender
                };
                if (type.displayName !== void 0) {
                  syntheticType.displayName = type.displayName;
                }
                return syntheticType;
              }
            }
            return type;
          }
          return family.current;
        }
      }
      function isCompatibleFamilyForHotReloading(fiber, element) {
        {
          if (resolveFamily === null) {
            return false;
          }
          var prevType = fiber.elementType;
          var nextType = element.type;
          var needsCompareFamilies = false;
          var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
          switch (fiber.tag) {
            case ClassComponent: {
              if (typeof nextType === "function") {
                needsCompareFamilies = true;
              }
              break;
            }
            case FunctionComponent: {
              if (typeof nextType === "function") {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            case ForwardRef: {
              if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            case MemoComponent:
            case SimpleMemoComponent: {
              if ($$typeofNextType === REACT_MEMO_TYPE) {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            default:
              return false;
          }
          if (needsCompareFamilies) {
            var prevFamily = resolveFamily(prevType);
            if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
              return true;
            }
          }
          return false;
        }
      }
      function markFailedErrorBoundaryForHotReloading(fiber) {
        {
          if (resolveFamily === null) {
            return;
          }
          if (typeof WeakSet !== "function") {
            return;
          }
          if (failedBoundaries === null) {
            failedBoundaries = /* @__PURE__ */ new WeakSet();
          }
          failedBoundaries.add(fiber);
        }
      }
      var scheduleRefresh = function(root3, update) {
        {
          if (resolveFamily === null) {
            return;
          }
          var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
          flushPassiveEffects();
          flushSync(function() {
            scheduleFibersWithFamiliesRecursively(root3.current, updatedFamilies, staleFamilies);
          });
        }
      };
      var scheduleRoot = function(root3, element) {
        {
          if (root3.context !== emptyContextObject) {
            return;
          }
          flushPassiveEffects();
          flushSync(function() {
            updateContainer(element, root3, null, null);
          });
        }
      };
      function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        {
          var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
          var candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef:
              candidateType = type.render;
              break;
          }
          if (resolveFamily === null) {
            throw new Error("Expected resolveFamily to be set during hot reload.");
          }
          var needsRender = false;
          var needsRemount = false;
          if (candidateType !== null) {
            var family = resolveFamily(candidateType);
            if (family !== void 0) {
              if (staleFamilies.has(family)) {
                needsRemount = true;
              } else if (updatedFamilies.has(family)) {
                if (tag === ClassComponent) {
                  needsRemount = true;
                } else {
                  needsRender = true;
                }
              }
            }
          }
          if (failedBoundaries !== null) {
            if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
              needsRemount = true;
            }
          }
          if (needsRemount) {
            fiber._debugNeedsRemount = true;
          }
          if (needsRemount || needsRender) {
            var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (_root !== null) {
              scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
            }
          }
          if (child !== null && !needsRemount) {
            scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
          }
          if (sibling !== null) {
            scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
          }
        }
      }
      var findHostInstancesForRefresh = function(root3, families) {
        {
          var hostInstances = /* @__PURE__ */ new Set();
          var types2 = new Set(families.map(function(family) {
            return family.current;
          }));
          findHostInstancesForMatchingFibersRecursively(root3.current, types2, hostInstances);
          return hostInstances;
        }
      };
      function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
        {
          var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
          var candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef:
              candidateType = type.render;
              break;
          }
          var didMatch = false;
          if (candidateType !== null) {
            if (types2.has(candidateType)) {
              didMatch = true;
            }
          }
          if (didMatch) {
            findHostInstancesForFiberShallowly(fiber, hostInstances);
          } else {
            if (child !== null) {
              findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances);
            }
          }
          if (sibling !== null) {
            findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
          }
        }
      }
      function findHostInstancesForFiberShallowly(fiber, hostInstances) {
        {
          var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
          if (foundHostInstances) {
            return;
          }
          var node2 = fiber;
          while (true) {
            switch (node2.tag) {
              case HostComponent:
                hostInstances.add(node2.stateNode);
                return;
              case HostPortal:
                hostInstances.add(node2.stateNode.containerInfo);
                return;
              case HostRoot:
                hostInstances.add(node2.stateNode.containerInfo);
                return;
            }
            if (node2.return === null) {
              throw new Error("Expected to reach root first.");
            }
            node2 = node2.return;
          }
        }
      }
      function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
        {
          var node2 = fiber;
          var foundHostInstances = false;
          while (true) {
            if (node2.tag === HostComponent) {
              foundHostInstances = true;
              hostInstances.add(node2.stateNode);
            } else if (node2.child !== null) {
              node2.child.return = node2;
              node2 = node2.child;
              continue;
            }
            if (node2 === fiber) {
              return foundHostInstances;
            }
            while (node2.sibling === null) {
              if (node2.return === null || node2.return === fiber) {
                return foundHostInstances;
              }
              node2 = node2.return;
            }
            node2.sibling.return = node2.return;
            node2 = node2.sibling;
          }
        }
        return false;
      }
      var hasBadMapPolyfill;
      {
        hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e) {
          hasBadMapPolyfill = true;
        }
      }
      function FiberNode(tag, pendingProps, key2, mode) {
        this.tag = tag;
        this.key = key2;
        this.elementType = null;
        this.type = null;
        this.stateNode = null;
        this.return = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.dependencies = null;
        this.mode = mode;
        this.flags = NoFlags;
        this.subtreeFlags = NoFlags;
        this.deletions = null;
        this.lanes = NoLanes;
        this.childLanes = NoLanes;
        this.alternate = null;
        {
          this.actualDuration = Number.NaN;
          this.actualStartTime = Number.NaN;
          this.selfBaseDuration = Number.NaN;
          this.treeBaseDuration = Number.NaN;
          this.actualDuration = 0;
          this.actualStartTime = -1;
          this.selfBaseDuration = 0;
          this.treeBaseDuration = 0;
        }
        {
          this._debugSource = null;
          this._debugOwner = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
            Object.preventExtensions(this);
          }
        }
      }
      var createFiber = function(tag, pendingProps, key2, mode) {
        return new FiberNode(tag, pendingProps, key2, mode);
      };
      function shouldConstruct$1(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function isSimpleFunctionComponent(type) {
        return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
      }
      function resolveLazyComponentTag(Component) {
        if (typeof Component === "function") {
          return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
        } else if (Component !== void 0 && Component !== null) {
          var $$typeof = Component.$$typeof;
          if ($$typeof === REACT_FORWARD_REF_TYPE) {
            return ForwardRef;
          }
          if ($$typeof === REACT_MEMO_TYPE) {
            return MemoComponent;
          }
        }
        return IndeterminateComponent;
      }
      function createWorkInProgress(current2, pendingProps) {
        var workInProgress2 = current2.alternate;
        if (workInProgress2 === null) {
          workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
          workInProgress2.elementType = current2.elementType;
          workInProgress2.type = current2.type;
          workInProgress2.stateNode = current2.stateNode;
          {
            workInProgress2._debugSource = current2._debugSource;
            workInProgress2._debugOwner = current2._debugOwner;
            workInProgress2._debugHookTypes = current2._debugHookTypes;
          }
          workInProgress2.alternate = current2;
          current2.alternate = workInProgress2;
        } else {
          workInProgress2.pendingProps = pendingProps;
          workInProgress2.type = current2.type;
          workInProgress2.flags = NoFlags;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.deletions = null;
          {
            workInProgress2.actualDuration = 0;
            workInProgress2.actualStartTime = -1;
          }
        }
        workInProgress2.flags = current2.flags & StaticMask;
        workInProgress2.childLanes = current2.childLanes;
        workInProgress2.lanes = current2.lanes;
        workInProgress2.child = current2.child;
        workInProgress2.memoizedProps = current2.memoizedProps;
        workInProgress2.memoizedState = current2.memoizedState;
        workInProgress2.updateQueue = current2.updateQueue;
        var currentDependencies = current2.dependencies;
        workInProgress2.dependencies = currentDependencies === null ? null : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext
        };
        workInProgress2.sibling = current2.sibling;
        workInProgress2.index = current2.index;
        workInProgress2.ref = current2.ref;
        {
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
        }
        {
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case FunctionComponent:
            case SimpleMemoComponent:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case ClassComponent:
              workInProgress2.type = resolveClassForHotReloading(current2.type);
              break;
            case ForwardRef:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
              break;
          }
        }
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= StaticMask | Placement;
        var current2 = workInProgress2.alternate;
        if (current2 === null) {
          workInProgress2.childLanes = NoLanes;
          workInProgress2.lanes = renderLanes2;
          workInProgress2.child = null;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.memoizedProps = null;
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.dependencies = null;
          workInProgress2.stateNode = null;
          {
            workInProgress2.selfBaseDuration = 0;
            workInProgress2.treeBaseDuration = 0;
          }
        } else {
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.deletions = null;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.type = current2.type;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          {
            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          }
        }
        return workInProgress2;
      }
      function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
        var mode;
        if (tag === ConcurrentRoot) {
          mode = ConcurrentMode;
          if (isStrictMode === true) {
            mode |= StrictLegacyMode;
            {
              mode |= StrictEffectsMode;
            }
          }
        } else {
          mode = NoMode;
        }
        if (isDevToolsPresent) {
          mode |= ProfileMode;
        }
        return createFiber(HostRoot, null, null, mode);
      }
      function createFiberFromTypeAndProps(type, key2, pendingProps, owner, mode, lanes) {
        var fiberTag = IndeterminateComponent;
        var resolvedType = type;
        if (typeof type === "function") {
          if (shouldConstruct$1(type)) {
            fiberTag = ClassComponent;
            {
              resolvedType = resolveClassForHotReloading(resolvedType);
            }
          } else {
            {
              resolvedType = resolveFunctionForHotReloading(resolvedType);
            }
          }
        } else if (typeof type === "string") {
          fiberTag = HostComponent;
        } else {
          getTag: switch (type) {
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key2);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = Mode;
              mode |= StrictLegacyMode;
              if ((mode & ConcurrentMode) !== NoMode) {
                mode |= StrictEffectsMode;
              }
              break;
            case REACT_PROFILER_TYPE:
              return createFiberFromProfiler(pendingProps, mode, lanes, key2);
            case REACT_SUSPENSE_TYPE:
              return createFiberFromSuspense(pendingProps, mode, lanes, key2);
            case REACT_SUSPENSE_LIST_TYPE:
              return createFiberFromSuspenseList(pendingProps, mode, lanes, key2);
            case REACT_OFFSCREEN_TYPE:
              return createFiberFromOffscreen(pendingProps, mode, lanes, key2);
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_SCOPE_TYPE:
            case REACT_CACHE_TYPE:
            case REACT_TRACING_MARKER_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            default: {
              if (typeof type === "object" && type !== null) {
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                    fiberTag = ContextProvider;
                    break getTag;
                  case REACT_CONTEXT_TYPE:
                    fiberTag = ContextConsumer;
                    break getTag;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = ForwardRef;
                    {
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                    }
                    break getTag;
                  case REACT_MEMO_TYPE:
                    fiberTag = MemoComponent;
                    break getTag;
                  case REACT_LAZY_TYPE:
                    fiberTag = LazyComponent;
                    resolvedType = null;
                    break getTag;
                }
              }
              var info = "";
              {
                if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
            }
          }
        }
        var fiber = createFiber(fiberTag, pendingProps, key2, mode);
        fiber.elementType = type;
        fiber.type = resolvedType;
        fiber.lanes = lanes;
        {
          fiber._debugOwner = owner;
        }
        return fiber;
      }
      function createFiberFromElement(element, mode, lanes) {
        var owner = null;
        {
          owner = element._owner;
        }
        var type = element.type;
        var key2 = element.key;
        var pendingProps = element.props;
        var fiber = createFiberFromTypeAndProps(type, key2, pendingProps, owner, mode, lanes);
        {
          fiber._debugSource = element._source;
          fiber._debugOwner = element._owner;
        }
        return fiber;
      }
      function createFiberFromFragment(elements2, mode, lanes, key2) {
        var fiber = createFiber(Fragment, elements2, key2, mode);
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromProfiler(pendingProps, mode, lanes, key2) {
        {
          if (typeof pendingProps.id !== "string") {
            error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
          }
        }
        var fiber = createFiber(Profiler, pendingProps, key2, mode | ProfileMode);
        fiber.elementType = REACT_PROFILER_TYPE;
        fiber.lanes = lanes;
        {
          fiber.stateNode = {
            effectDuration: 0,
            passiveEffectDuration: 0
          };
        }
        return fiber;
      }
      function createFiberFromSuspense(pendingProps, mode, lanes, key2) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key2, mode);
        fiber.elementType = REACT_SUSPENSE_TYPE;
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromSuspenseList(pendingProps, mode, lanes, key2) {
        var fiber = createFiber(SuspenseListComponent, pendingProps, key2, mode);
        fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromOffscreen(pendingProps, mode, lanes, key2) {
        var fiber = createFiber(OffscreenComponent, pendingProps, key2, mode);
        fiber.elementType = REACT_OFFSCREEN_TYPE;
        fiber.lanes = lanes;
        var primaryChildInstance = {
          isHidden: false
        };
        fiber.stateNode = primaryChildInstance;
        return fiber;
      }
      function createFiberFromText(content, mode, lanes) {
        var fiber = createFiber(HostText, content, null, mode);
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoMode);
        fiber.elementType = "DELETED";
        return fiber;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiber(DehydratedFragment, null, null, NoMode);
        fiber.stateNode = dehydratedNode;
        return fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        fiber.lanes = lanes;
        fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          // Used by persistent updates
          implementation: portal.implementation
        };
        return fiber;
      }
      function assignFiberPropertiesInDEV(target2, source) {
        if (target2 === null) {
          target2 = createFiber(IndeterminateComponent, null, null, NoMode);
        }
        target2.tag = source.tag;
        target2.key = source.key;
        target2.elementType = source.elementType;
        target2.type = source.type;
        target2.stateNode = source.stateNode;
        target2.return = source.return;
        target2.child = source.child;
        target2.sibling = source.sibling;
        target2.index = source.index;
        target2.ref = source.ref;
        target2.pendingProps = source.pendingProps;
        target2.memoizedProps = source.memoizedProps;
        target2.updateQueue = source.updateQueue;
        target2.memoizedState = source.memoizedState;
        target2.dependencies = source.dependencies;
        target2.mode = source.mode;
        target2.flags = source.flags;
        target2.subtreeFlags = source.subtreeFlags;
        target2.deletions = source.deletions;
        target2.lanes = source.lanes;
        target2.childLanes = source.childLanes;
        target2.alternate = source.alternate;
        {
          target2.actualDuration = source.actualDuration;
          target2.actualStartTime = source.actualStartTime;
          target2.selfBaseDuration = source.selfBaseDuration;
          target2.treeBaseDuration = source.treeBaseDuration;
        }
        target2._debugSource = source._debugSource;
        target2._debugOwner = source._debugOwner;
        target2._debugNeedsRemount = source._debugNeedsRemount;
        target2._debugHookTypes = source._debugHookTypes;
        return target2;
      }
      function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
        this.tag = tag;
        this.containerInfo = containerInfo;
        this.pendingChildren = null;
        this.current = null;
        this.pingCache = null;
        this.finishedWork = null;
        this.timeoutHandle = noTimeout;
        this.context = null;
        this.pendingContext = null;
        this.callbackNode = null;
        this.callbackPriority = NoLane;
        this.eventTimes = createLaneMap(NoLanes);
        this.expirationTimes = createLaneMap(NoTimestamp);
        this.pendingLanes = NoLanes;
        this.suspendedLanes = NoLanes;
        this.pingedLanes = NoLanes;
        this.expiredLanes = NoLanes;
        this.mutableReadLanes = NoLanes;
        this.finishedLanes = NoLanes;
        this.entangledLanes = NoLanes;
        this.entanglements = createLaneMap(NoLanes);
        this.identifierPrefix = identifierPrefix;
        this.onRecoverableError = onRecoverableError;
        {
          this.mutableSourceEagerHydrationData = null;
        }
        {
          this.effectDuration = 0;
          this.passiveEffectDuration = 0;
        }
        {
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
          for (var _i = 0; _i < TotalLanes; _i++) {
            pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
          }
        }
        {
          switch (tag) {
            case ConcurrentRoot:
              this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
              break;
            case LegacyRoot:
              this._debugRootType = hydrate2 ? "hydrate()" : "render()";
              break;
          }
        }
      }
      function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var root3 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
        var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
        root3.current = uninitializedFiber;
        uninitializedFiber.stateNode = root3;
        {
          var _initialState = {
            element: initialChildren,
            isDehydrated: hydrate2,
            cache: null,
            // not enabled yet
            transitions: null,
            pendingSuspenseBoundaries: null
          };
          uninitializedFiber.memoizedState = _initialState;
        }
        initializeUpdateQueue(uninitializedFiber);
        return root3;
      }
      var ReactVersion = "18.3.1";
      function createPortal(children2, containerInfo, implementation) {
        var key2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        {
          checkKeyStringCoercion(key2);
        }
        return {
          // This tag allow us to uniquely identify this as a React Portal
          $$typeof: REACT_PORTAL_TYPE,
          key: key2 == null ? null : "" + key2,
          children: children2,
          containerInfo,
          implementation
        };
      }
      var didWarnAboutNestedUpdates;
      var didWarnAboutFindNodeInStrictMode;
      {
        didWarnAboutNestedUpdates = false;
        didWarnAboutFindNodeInStrictMode = {};
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) {
          return emptyContextObject;
        }
        var fiber = get(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);
        if (fiber.tag === ClassComponent) {
          var Component = fiber.type;
          if (isContextProvider(Component)) {
            return processChildContext(fiber, Component, parentContext);
          }
        }
        return parentContext;
      }
      function findHostInstanceWithWarning(component, methodName) {
        {
          var fiber = get(component);
          if (fiber === void 0) {
            if (typeof component.render === "function") {
              throw new Error("Unable to find node on an unmounted component.");
            } else {
              var keys2 = Object.keys(component).join(",");
              throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys2);
            }
          }
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          if (hostFiber.mode & StrictLegacyMode) {
            var componentName = getComponentNameFromFiber(fiber) || "Component";
            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
              didWarnAboutFindNodeInStrictMode[componentName] = true;
              var previousFiber = current;
              try {
                setCurrentFiber(hostFiber);
                if (fiber.mode & StrictLegacyMode) {
                  error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                } else {
                  error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                }
              } finally {
                if (previousFiber) {
                  setCurrentFiber(previousFiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          return hostFiber.stateNode;
        }
      }
      function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var hydrate2 = false;
        var initialChildren = null;
        return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
      }
      function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var hydrate2 = true;
        var root3 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        root3.context = getContextForSubtree(null);
        var current2 = root3.current;
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(current2);
        var update = createUpdate(eventTime, lane);
        update.callback = callback !== void 0 && callback !== null ? callback : null;
        enqueueUpdate(current2, update, lane);
        scheduleInitialHydrationOnRoot(root3, lane, eventTime);
        return root3;
      }
      function updateContainer(element, container2, parentComponent, callback) {
        {
          onScheduleRoot(container2, element);
        }
        var current$1 = container2.current;
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(current$1);
        {
          markRenderScheduled(lane);
        }
        var context = getContextForSubtree(parentComponent);
        if (container2.context === null) {
          container2.context = context;
        } else {
          container2.pendingContext = context;
        }
        {
          if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
          }
        }
        var update = createUpdate(eventTime, lane);
        update.payload = {
          element
        };
        callback = callback === void 0 ? null : callback;
        if (callback !== null) {
          {
            if (typeof callback !== "function") {
              error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
            }
          }
          update.callback = callback;
        }
        var root3 = enqueueUpdate(current$1, update, lane);
        if (root3 !== null) {
          scheduleUpdateOnFiber(root3, current$1, lane, eventTime);
          entangleTransitions(root3, current$1, lane);
        }
        return lane;
      }
      function getPublicRootInstance(container2) {
        var containerFiber = container2.current;
        if (!containerFiber.child) {
          return null;
        }
        switch (containerFiber.child.tag) {
          case HostComponent:
            return getPublicInstance(containerFiber.child.stateNode);
          default:
            return containerFiber.child.stateNode;
        }
      }
      function attemptSynchronousHydration$1(fiber) {
        switch (fiber.tag) {
          case HostRoot: {
            var root3 = fiber.stateNode;
            if (isRootDehydrated(root3)) {
              var lanes = getHighestPriorityPendingLanes(root3);
              flushRoot(root3, lanes);
            }
            break;
          }
          case SuspenseComponent: {
            flushSync(function() {
              var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root4 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root4, fiber, SyncLane, eventTime);
              }
            });
            var retryLane = SyncLane;
            markRetryLaneIfNotHydrated(fiber, retryLane);
            break;
          }
        }
      }
      function markRetryLaneImpl(fiber, retryLane) {
        var suspenseState = fiber.memoizedState;
        if (suspenseState !== null && suspenseState.dehydrated !== null) {
          suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        var alternate = fiber.alternate;
        if (alternate) {
          markRetryLaneImpl(alternate, retryLane);
        }
      }
      function attemptContinuousHydration$1(fiber) {
        if (fiber.tag !== SuspenseComponent) {
          return;
        }
        var lane = SelectiveHydrationLane;
        var root3 = enqueueConcurrentRenderForLane(fiber, lane);
        if (root3 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
        }
        markRetryLaneIfNotHydrated(fiber, lane);
      }
      function attemptHydrationAtCurrentPriority$1(fiber) {
        if (fiber.tag !== SuspenseComponent) {
          return;
        }
        var lane = requestUpdateLane(fiber);
        var root3 = enqueueConcurrentRenderForLane(fiber, lane);
        if (root3 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
        }
        markRetryLaneIfNotHydrated(fiber, lane);
      }
      function findHostInstanceWithNoPortals(fiber) {
        var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
        if (hostFiber === null) {
          return null;
        }
        return hostFiber.stateNode;
      }
      var shouldErrorImpl = function(fiber) {
        return null;
      };
      function shouldError(fiber) {
        return shouldErrorImpl(fiber);
      }
      var shouldSuspendImpl = function(fiber) {
        return false;
      };
      function shouldSuspend(fiber) {
        return shouldSuspendImpl(fiber);
      }
      var overrideHookState = null;
      var overrideHookStateDeletePath = null;
      var overrideHookStateRenamePath = null;
      var overrideProps = null;
      var overridePropsDeletePath = null;
      var overridePropsRenamePath = null;
      var scheduleUpdate = null;
      var setErrorHandler = null;
      var setSuspenseHandler = null;
      {
        var copyWithDeleteImpl = function(obj, path2, index2) {
          var key2 = path2[index2];
          var updated = isArray2(obj) ? obj.slice() : assign2({}, obj);
          if (index2 + 1 === path2.length) {
            if (isArray2(updated)) {
              updated.splice(key2, 1);
            } else {
              delete updated[key2];
            }
            return updated;
          }
          updated[key2] = copyWithDeleteImpl(obj[key2], path2, index2 + 1);
          return updated;
        };
        var copyWithDelete = function(obj, path2) {
          return copyWithDeleteImpl(obj, path2, 0);
        };
        var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
          var oldKey = oldPath[index2];
          var updated = isArray2(obj) ? obj.slice() : assign2({}, obj);
          if (index2 + 1 === oldPath.length) {
            var newKey = newPath[index2];
            updated[newKey] = updated[oldKey];
            if (isArray2(updated)) {
              updated.splice(oldKey, 1);
            } else {
              delete updated[oldKey];
            }
          } else {
            updated[oldKey] = copyWithRenameImpl(
              // $FlowFixMe number or string is fine here
              obj[oldKey],
              oldPath,
              newPath,
              index2 + 1
            );
          }
          return updated;
        };
        var copyWithRename = function(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length) {
            warn2("copyWithRename() expects paths of the same length");
            return;
          } else {
            for (var i2 = 0; i2 < newPath.length - 1; i2++) {
              if (oldPath[i2] !== newPath[i2]) {
                warn2("copyWithRename() expects paths to be the same except for the deepest key");
                return;
              }
            }
          }
          return copyWithRenameImpl(obj, oldPath, newPath, 0);
        };
        var copyWithSetImpl = function(obj, path2, index2, value) {
          if (index2 >= path2.length) {
            return value;
          }
          var key2 = path2[index2];
          var updated = isArray2(obj) ? obj.slice() : assign2({}, obj);
          updated[key2] = copyWithSetImpl(obj[key2], path2, index2 + 1, value);
          return updated;
        };
        var copyWithSet = function(obj, path2, value) {
          return copyWithSetImpl(obj, path2, 0, value);
        };
        var findHook = function(fiber, id) {
          var currentHook2 = fiber.memoizedState;
          while (currentHook2 !== null && id > 0) {
            currentHook2 = currentHook2.next;
            id--;
          }
          return currentHook2;
        };
        overrideHookState = function(fiber, id, path2, value) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithSet(hook.memoizedState, path2, value);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign2({}, fiber.memoizedProps);
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideHookStateDeletePath = function(fiber, id, path2) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithDelete(hook.memoizedState, path2);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign2({}, fiber.memoizedProps);
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign2({}, fiber.memoizedProps);
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideProps = function(fiber, path2, value) {
          fiber.pendingProps = copyWithSet(fiber.memoizedProps, path2, value);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
          }
        };
        overridePropsDeletePath = function(fiber, path2) {
          fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path2);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
          }
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
          }
        };
        scheduleUpdate = function(fiber) {
          var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root3 !== null) {
            scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
          }
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
      }
      function findHostInstanceByFiber(fiber) {
        var hostFiber = findCurrentHostFiber(fiber);
        if (hostFiber === null) {
          return null;
        }
        return hostFiber.stateNode;
      }
      function emptyFindFiberByHostInstance(instance) {
        return null;
      }
      function getCurrentFiberForDevTools() {
        return current;
      }
      function injectIntoDevTools(devToolsConfig) {
        var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
        return injectInternals({
          bundleType: devToolsConfig.bundleType,
          version: devToolsConfig.version,
          rendererPackageName: devToolsConfig.rendererPackageName,
          rendererConfig: devToolsConfig.rendererConfig,
          overrideHookState,
          overrideHookStateDeletePath,
          overrideHookStateRenamePath,
          overrideProps,
          overridePropsDeletePath,
          overridePropsRenamePath,
          setErrorHandler,
          setSuspenseHandler,
          scheduleUpdate,
          currentDispatcherRef: ReactCurrentDispatcher2,
          findHostInstanceByFiber,
          findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
          // React Refresh
          findHostInstancesForRefresh,
          scheduleRefresh,
          scheduleRoot,
          setRefreshHandler,
          // Enables DevTools to append owner stacks to error messages in DEV mode.
          getCurrentFiber: getCurrentFiberForDevTools,
          // Enables DevTools to detect reconciler version rather than renderer version
          // which may not match for third party renderers.
          reconcilerVersion: ReactVersion
        });
      }
      var defaultOnRecoverableError = typeof reportError === "function" ? (
        // In modern browsers, reportError will dispatch an error event,
        // emulating an uncaught JavaScript error.
        reportError
      ) : function(error2) {
        console["error"](error2);
      };
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children2) {
        var root3 = this._internalRoot;
        if (root3 === null) {
          throw new Error("Cannot update an unmounted root.");
        }
        {
          if (typeof arguments[1] === "function") {
            error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
          } else if (isValidContainer(arguments[1])) {
            error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
          } else if (typeof arguments[1] !== "undefined") {
            error("You passed a second argument to root.render(...) but it only accepts one argument.");
          }
          var container2 = root3.containerInfo;
          if (container2.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(root3.current);
            if (hostInstance) {
              if (hostInstance.parentNode !== container2) {
                error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
              }
            }
          }
        }
        updateContainer(children2, root3, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        {
          if (typeof arguments[0] === "function") {
            error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
          }
        }
        var root3 = this._internalRoot;
        if (root3 !== null) {
          this._internalRoot = null;
          var container2 = root3.containerInfo;
          {
            if (isAlreadyRendering()) {
              error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
            }
          }
          flushSync(function() {
            updateContainer(null, root3, null, null);
          });
          unmarkContainerAsRoot(container2);
        }
      };
      function createRoot2(container2, options2) {
        if (!isValidContainer(container2)) {
          throw new Error("createRoot(...): Target container is not a DOM element.");
        }
        warnIfReactDOMContainerInDEV(container2);
        var isStrictMode = false;
        var concurrentUpdatesByDefaultOverride = false;
        var identifierPrefix = "";
        var onRecoverableError = defaultOnRecoverableError;
        if (options2 !== null && options2 !== void 0) {
          {
            if (options2.hydrate) {
              warn2("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
            } else {
              if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE2) {
                error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
              }
            }
          }
          if (options2.unstable_strictMode === true) {
            isStrictMode = true;
          }
          if (options2.identifierPrefix !== void 0) {
            identifierPrefix = options2.identifierPrefix;
          }
          if (options2.onRecoverableError !== void 0) {
            onRecoverableError = options2.onRecoverableError;
          }
          if (options2.transitionCallbacks !== void 0) {
            options2.transitionCallbacks;
          }
        }
        var root3 = createContainer(container2, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        markContainerAsRoot(root3.current, container2);
        var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
        listenToAllSupportedEvents(rootContainerElement);
        return new ReactDOMRoot(root3);
      }
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      function scheduleHydration(target2) {
        if (target2) {
          queueExplicitHydrationTarget(target2);
        }
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
      function hydrateRoot(container2, initialChildren, options2) {
        if (!isValidContainer(container2)) {
          throw new Error("hydrateRoot(...): Target container is not a DOM element.");
        }
        warnIfReactDOMContainerInDEV(container2);
        {
          if (initialChildren === void 0) {
            error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
          }
        }
        var hydrationCallbacks = options2 != null ? options2 : null;
        var mutableSources = options2 != null && options2.hydratedSources || null;
        var isStrictMode = false;
        var concurrentUpdatesByDefaultOverride = false;
        var identifierPrefix = "";
        var onRecoverableError = defaultOnRecoverableError;
        if (options2 !== null && options2 !== void 0) {
          if (options2.unstable_strictMode === true) {
            isStrictMode = true;
          }
          if (options2.identifierPrefix !== void 0) {
            identifierPrefix = options2.identifierPrefix;
          }
          if (options2.onRecoverableError !== void 0) {
            onRecoverableError = options2.onRecoverableError;
          }
        }
        var root3 = createHydrationContainer(initialChildren, null, container2, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        markContainerAsRoot(root3.current, container2);
        listenToAllSupportedEvents(container2);
        if (mutableSources) {
          for (var i2 = 0; i2 < mutableSources.length; i2++) {
            var mutableSource = mutableSources[i2];
            registerMutableSourceForHydration(root3, mutableSource);
          }
        }
        return new ReactDOMHydrationRoot(root3);
      }
      function isValidContainer(node2) {
        return !!(node2 && (node2.nodeType === ELEMENT_NODE || node2.nodeType === DOCUMENT_NODE || node2.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
      }
      function isValidContainerLegacy(node2) {
        return !!(node2 && (node2.nodeType === ELEMENT_NODE || node2.nodeType === DOCUMENT_NODE || node2.nodeType === DOCUMENT_FRAGMENT_NODE || node2.nodeType === COMMENT_NODE && node2.nodeValue === " react-mount-point-unstable "));
      }
      function warnIfReactDOMContainerInDEV(container2) {
        {
          if (container2.nodeType === ELEMENT_NODE && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
            error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
          }
          if (isContainerMarkedAsRoot(container2)) {
            if (container2._reactRootContainer) {
              error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
            } else {
              error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
            }
          }
        }
      }
      var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
      var topLevelUpdateWarnings;
      {
        topLevelUpdateWarnings = function(container2) {
          if (container2._reactRootContainer && container2.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(container2._reactRootContainer.current);
            if (hostInstance) {
              if (hostInstance.parentNode !== container2) {
                error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
              }
            }
          }
          var isRootRenderedBySomeReact = !!container2._reactRootContainer;
          var rootEl = getReactRootElementInContainer(container2);
          var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
          if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
            error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
          }
          if (container2.nodeType === ELEMENT_NODE && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
            error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
          }
        };
      }
      function getReactRootElementInContainer(container2) {
        if (!container2) {
          return null;
        }
        if (container2.nodeType === DOCUMENT_NODE) {
          return container2.documentElement;
        } else {
          return container2.firstChild;
        }
      }
      function noopOnRecoverableError() {
      }
      function legacyCreateRootFromDOMContainer(container2, initialChildren, parentComponent, callback, isHydrationContainer) {
        if (isHydrationContainer) {
          if (typeof callback === "function") {
            var originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(root3);
              originalCallback.call(instance);
            };
          }
          var root3 = createHydrationContainer(
            initialChildren,
            callback,
            container2,
            LegacyRoot,
            null,
            // hydrationCallbacks
            false,
            // isStrictMode
            false,
            // concurrentUpdatesByDefaultOverride,
            "",
            // identifierPrefix
            noopOnRecoverableError
          );
          container2._reactRootContainer = root3;
          markContainerAsRoot(root3.current, container2);
          var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
          listenToAllSupportedEvents(rootContainerElement);
          flushSync();
          return root3;
        } else {
          var rootSibling;
          while (rootSibling = container2.lastChild) {
            container2.removeChild(rootSibling);
          }
          if (typeof callback === "function") {
            var _originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(_root);
              _originalCallback.call(instance);
            };
          }
          var _root = createContainer(
            container2,
            LegacyRoot,
            null,
            // hydrationCallbacks
            false,
            // isStrictMode
            false,
            // concurrentUpdatesByDefaultOverride,
            "",
            // identifierPrefix
            noopOnRecoverableError
          );
          container2._reactRootContainer = _root;
          markContainerAsRoot(_root.current, container2);
          var _rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
          listenToAllSupportedEvents(_rootContainerElement);
          flushSync(function() {
            updateContainer(initialChildren, _root, parentComponent, callback);
          });
          return _root;
        }
      }
      function warnOnInvalidCallback$1(callback, callerName) {
        {
          if (callback !== null && typeof callback !== "function") {
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        }
      }
      function legacyRenderSubtreeIntoContainer(parentComponent, children2, container2, forceHydrate, callback) {
        {
          topLevelUpdateWarnings(container2);
          warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
        }
        var maybeRoot = container2._reactRootContainer;
        var root3;
        if (!maybeRoot) {
          root3 = legacyCreateRootFromDOMContainer(container2, children2, parentComponent, callback, forceHydrate);
        } else {
          root3 = maybeRoot;
          if (typeof callback === "function") {
            var originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(root3);
              originalCallback.call(instance);
            };
          }
          updateContainer(children2, root3, parentComponent, callback);
        }
        return getPublicRootInstance(root3);
      }
      var didWarnAboutFindDOMNode = false;
      function findDOMNode(componentOrElement) {
        {
          if (!didWarnAboutFindDOMNode) {
            didWarnAboutFindDOMNode = true;
            error("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node");
          }
          var owner = ReactCurrentOwner$3.current;
          if (owner !== null && owner.stateNode !== null) {
            var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
            if (!warnedAboutRefsInRender) {
              error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
            }
            owner.stateNode._warnedAboutRefsInRender = true;
          }
        }
        if (componentOrElement == null) {
          return null;
        }
        if (componentOrElement.nodeType === ELEMENT_NODE) {
          return componentOrElement;
        }
        {
          return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
        }
      }
      function hydrate(element, container2, callback) {
        {
          error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(container2)) {
          throw new Error("Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
          if (isModernRoot) {
            error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
          }
        }
        return legacyRenderSubtreeIntoContainer(null, element, container2, true, callback);
      }
      function render2(element, container2, callback) {
        {
          error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(container2)) {
          throw new Error("Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
          if (isModernRoot) {
            error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
          }
        }
        return legacyRenderSubtreeIntoContainer(null, element, container2, false, callback);
      }
      function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        {
          error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(containerNode)) {
          throw new Error("Target container is not a DOM element.");
        }
        if (parentComponent == null || !has2(parentComponent)) {
          throw new Error("parentComponent must be a valid React Component");
        }
        return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
      }
      var didWarnAboutUnmountComponentAtNode = false;
      function unmountComponentAtNode(container2) {
        {
          if (!didWarnAboutUnmountComponentAtNode) {
            didWarnAboutUnmountComponentAtNode = true;
            error("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
        }
        if (!isValidContainerLegacy(container2)) {
          throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
          if (isModernRoot) {
            error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
          }
        }
        if (container2._reactRootContainer) {
          {
            var rootEl = getReactRootElementInContainer(container2);
            var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
            if (renderedByDifferentReact) {
              error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
            }
          }
          flushSync(function() {
            legacyRenderSubtreeIntoContainer(null, null, container2, false, function() {
              container2._reactRootContainer = null;
              unmarkContainerAsRoot(container2);
            });
          });
          return true;
        } else {
          {
            var _rootEl = getReactRootElementInContainer(container2);
            var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
            var isContainerReactRoot = container2.nodeType === ELEMENT_NODE && isValidContainerLegacy(container2.parentNode) && !!container2.parentNode._reactRootContainer;
            if (hasNonRootReactChild) {
              error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
            }
          }
          return false;
        }
      }
      setAttemptSynchronousHydration(attemptSynchronousHydration$1);
      setAttemptContinuousHydration(attemptContinuousHydration$1);
      setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
      setGetCurrentUpdatePriority(getCurrentUpdatePriority);
      setAttemptHydrationAtPriority(runWithPriority);
      {
        if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
        Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
        Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
          error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
      }
      setRestoreImplementation(restoreControlledState$3);
      setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
      function createPortal$1(children2, container2) {
        var key2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (!isValidContainer(container2)) {
          throw new Error("Target container is not a DOM element.");
        }
        return createPortal(children2, container2, null, key2);
      }
      function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
      }
      var Internals = {
        usingClientEntryPoint: false,
        // Keep in sync with ReactTestUtils.js.
        // This is an array for better minification.
        Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
      };
      function createRoot$1(container2, options2) {
        {
          if (!Internals.usingClientEntryPoint && true) {
            error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
          }
        }
        return createRoot2(container2, options2);
      }
      function hydrateRoot$1(container2, initialChildren, options2) {
        {
          if (!Internals.usingClientEntryPoint && true) {
            error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
          }
        }
        return hydrateRoot(container2, initialChildren, options2);
      }
      function flushSync$1(fn) {
        {
          if (isAlreadyRendering()) {
            error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
          }
        }
        return flushSync(fn);
      }
      var foundDevTools = injectIntoDevTools({
        findFiberByHostInstance: getClosestInstanceFromNode,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: "react-dom"
      });
      {
        if (!foundDevTools && canUseDOM2 && window.top === window.self) {
          if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
            var protocol = window.location.protocol;
            if (/^(https?|file):$/.test(protocol)) {
              console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
            }
          }
        }
      }
      reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
      reactDom_development.createPortal = createPortal$1;
      reactDom_development.createRoot = createRoot$1;
      reactDom_development.findDOMNode = findDOMNode;
      reactDom_development.flushSync = flushSync$1;
      reactDom_development.hydrate = hydrate;
      reactDom_development.hydrateRoot = hydrateRoot$1;
      reactDom_development.render = render2;
      reactDom_development.unmountComponentAtNode = unmountComponentAtNode;
      reactDom_development.unstable_batchedUpdates = batchedUpdates$1;
      reactDom_development.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
      reactDom_development.version = ReactVersion;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return reactDom_development;
}
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  if (process.env.NODE_ENV !== "production") {
    throw new Error("^_^");
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
if (process.env.NODE_ENV === "production") {
  checkDCE();
  reactDom.exports = requireReactDom_production_min();
} else {
  reactDom.exports = requireReactDom_development();
}
var reactDomExports = reactDom.exports;
var createRoot;
var m = reactDomExports;
if (process.env.NODE_ENV === "production") {
  createRoot = m.createRoot;
  m.hydrateRoot;
} else {
  var i$1 = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  createRoot = function(c, o) {
    i$1.usingClientEntryPoint = true;
    try {
      return m.createRoot(c, o);
    } finally {
      i$1.usingClientEntryPoint = false;
    }
  };
}
const badSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20class='jp-icon0'%20fill='%23000'%20d='M24%2020.188l-8.315-8.209%208.2-8.282-3.697-3.697-8.212%208.318-8.31-8.203-3.666%203.666%208.321%208.24-8.206%208.313%203.666%203.666%208.237-8.318%208.285%208.203z'%20/%3e%3c/svg%3e";
const blankSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23000'%20fill-opacity='0.0'%20d='M24%2020.188l-8.315-8.209%208.2-8.282-3.697-3.697-8.212%208.318-8.31-8.203-3.666%203.666%208.321%208.24-8.206%208.313%203.666%203.666%208.237-8.318%208.285%208.203z'%20/%3e%3c/svg%3e";
const refreshSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2018%2018'%3e%3cpath%20fill='%23616161'%20d='M9%2013.5c-2.49%200-4.5-2.01-4.5-4.5S6.51%204.5%209%204.5c1.24%200%202.36.52%203.17%201.33L10%208h5V3l-1.76%201.76A6%206%200%200%200%209%203C5.69%203%203.01%205.69%203.01%209S5.69%2015%209%2015a5.98%205.98%200%200%200%205.9-5h-1.52c-.46%202-2.24%203.5-4.38%203.5'%20class='jp-icon3'/%3e%3c/svg%3e";
var lib$8 = {};
var typestyle = {};
let uniqueId = 0;
const CSS_NUMBER = /* @__PURE__ */ Object.create(null);
const CSS_NUMBER_KEYS = [
  "animation-iteration-count",
  "border-image-outset",
  "border-image-slice",
  "border-image-width",
  "box-flex",
  "box-flex-group",
  "box-ordinal-group",
  "column-count",
  "columns",
  "counter-increment",
  "counter-reset",
  "flex",
  "flex-grow",
  "flex-positive",
  "flex-shrink",
  "flex-negative",
  "flex-order",
  "font-weight",
  "grid-area",
  "grid-column",
  "grid-column-end",
  "grid-column-span",
  "grid-column-start",
  "grid-row",
  "grid-row-end",
  "grid-row-span",
  "grid-row-start",
  "line-clamp",
  "line-height",
  "opacity",
  "order",
  "orphans",
  "tab-size",
  "widows",
  "z-index",
  "zoom",
  // SVG properties.
  "fill-opacity",
  "flood-opacity",
  "stop-opacity",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width"
];
for (const property of CSS_NUMBER_KEYS) {
  for (const prefix of ["-webkit-", "-ms-", "-moz-", "-o-", ""]) {
    CSS_NUMBER[prefix + property] = true;
  }
}
function escape$2(str) {
  return str.replace(/[ !#$%&()*+,./;<=>?@[\]^`{|}~"'\\]/g, "\\$&");
}
function hyphenate(propertyName) {
  return propertyName.replace(/[A-Z]/g, (m2) => `-${m2.toLowerCase()}`).replace(/^ms-/, "-ms-");
}
function stringHash(str) {
  let value = 5381;
  let len = str.length;
  while (len--)
    value = value * 33 ^ str.charCodeAt(len);
  return (value >>> 0).toString(36);
}
function styleToString(key2, value) {
  if (value && typeof value === "number" && !CSS_NUMBER[key2]) {
    return `${key2}:${value}px`;
  }
  return `${key2}:${value}`;
}
function sortTuples(value) {
  return value.sort((a, b) => a[0] > b[0] ? 1 : -1);
}
function parseStyles(styles, hasNestedStyles) {
  const properties = [];
  const nestedStyles = [];
  for (const key2 of Object.keys(styles)) {
    const name2 = key2.trim();
    const value = styles[key2];
    if (name2.charCodeAt(0) !== 36 && value != null) {
      if (typeof value === "object" && !Array.isArray(value)) {
        nestedStyles.push([name2, value]);
      } else {
        properties.push([hyphenate(name2), value]);
      }
    }
  }
  return {
    style: stringifyProperties(sortTuples(properties)),
    nested: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),
    isUnique: !!styles.$unique
  };
}
function stringifyProperties(properties) {
  return properties.map(([name2, value]) => {
    if (!Array.isArray(value))
      return styleToString(name2, value);
    return value.map((x2) => styleToString(name2, x2)).join(";");
  }).join(";");
}
function interpolate(selector, parent) {
  if (selector.indexOf("&") === -1)
    return `${parent} ${selector}`;
  return selector.replace(/&/g, parent);
}
function stylize(selector, styles, rulesList, stylesList, parent) {
  const { style: style2, nested, isUnique } = parseStyles(styles, selector !== "");
  let pid = style2;
  if (selector.charCodeAt(0) === 64) {
    const child = {
      selector,
      styles: [],
      rules: [],
      style: parent ? "" : style2
    };
    rulesList.push(child);
    if (style2 && parent) {
      child.styles.push({ selector: parent, style: style2, isUnique });
    }
    for (const [name2, value] of nested) {
      pid += name2 + stylize(name2, value, child.rules, child.styles, parent);
    }
  } else {
    const key2 = parent ? interpolate(selector, parent) : selector;
    if (style2)
      stylesList.push({ selector: key2, style: style2, isUnique });
    for (const [name2, value] of nested) {
      pid += name2 + stylize(name2, value, rulesList, stylesList, key2);
    }
  }
  return pid;
}
function composeStylize(cache2, pid, rulesList, stylesList, className, isStyle) {
  for (const { selector, style: style2, isUnique } of stylesList) {
    const key2 = isStyle ? interpolate(selector, className) : selector;
    const id = isUnique ? `u\0${(++uniqueId).toString(36)}` : `s\0${pid}\0${style2}`;
    const item = new Style(style2, id);
    item.add(new Selector(key2, `k\0${pid}\0${key2}`));
    cache2.add(item);
  }
  for (const { selector, style: style2, rules: rules2, styles } of rulesList) {
    const item = new Rule$5(selector, style2, `r\0${pid}\0${selector}\0${style2}`);
    composeStylize(item, pid, rules2, styles, className, isStyle);
    cache2.add(item);
  }
}
function join$1(arr) {
  let res = "";
  for (let i2 = 0; i2 < arr.length; i2++)
    res += arr[i2];
  return res;
}
const noopChanges = {
  add: () => void 0,
  change: () => void 0,
  remove: () => void 0
};
class Cache {
  constructor(changes = noopChanges) {
    this.changes = changes;
    this.sheet = [];
    this.changeId = 0;
    this._keys = [];
    this._children = /* @__PURE__ */ Object.create(null);
    this._counters = /* @__PURE__ */ Object.create(null);
  }
  add(style2) {
    const count = this._counters[style2.id] || 0;
    const item = this._children[style2.id] || style2.clone();
    this._counters[style2.id] = count + 1;
    if (count === 0) {
      this._children[item.id] = item;
      this._keys.push(item.id);
      this.sheet.push(item.getStyles());
      this.changeId++;
      this.changes.add(item, this._keys.length - 1);
    } else if (item instanceof Cache && style2 instanceof Cache) {
      const curIndex = this._keys.indexOf(style2.id);
      const prevItemChangeId = item.changeId;
      item.merge(style2);
      if (item.changeId !== prevItemChangeId) {
        this.sheet.splice(curIndex, 1, item.getStyles());
        this.changeId++;
        this.changes.change(item, curIndex, curIndex);
      }
    }
  }
  remove(style2) {
    const count = this._counters[style2.id];
    if (count) {
      this._counters[style2.id] = count - 1;
      const item = this._children[style2.id];
      const index = this._keys.indexOf(item.id);
      if (count === 1) {
        delete this._counters[style2.id];
        delete this._children[style2.id];
        this._keys.splice(index, 1);
        this.sheet.splice(index, 1);
        this.changeId++;
        this.changes.remove(item, index);
      } else if (item instanceof Cache && style2 instanceof Cache) {
        const prevChangeId = item.changeId;
        item.unmerge(style2);
        if (item.changeId !== prevChangeId) {
          this.sheet.splice(index, 1, item.getStyles());
          this.changeId++;
          this.changes.change(item, index, index);
        }
      }
    }
  }
  values() {
    return this._keys.map((key2) => this._children[key2]);
  }
  merge(cache2) {
    for (const item of cache2.values())
      this.add(item);
    return this;
  }
  unmerge(cache2) {
    for (const item of cache2.values())
      this.remove(item);
    return this;
  }
  clone() {
    return new Cache().merge(this);
  }
}
class Selector {
  constructor(selector, id) {
    this.selector = selector;
    this.id = id;
  }
  getStyles() {
    return this.selector;
  }
  clone() {
    return this;
  }
}
class Style extends Cache {
  constructor(style2, id) {
    super();
    this.style = style2;
    this.id = id;
  }
  getStyles() {
    return `${this.sheet.join(",")}{${this.style}}`;
  }
  clone() {
    return new Style(this.style, this.id).merge(this);
  }
}
let Rule$5 = class Rule2 extends Cache {
  constructor(rule2, style2, id) {
    super();
    this.rule = rule2;
    this.style = style2;
    this.id = id;
  }
  getStyles() {
    return `${this.rule}{${this.style}${join$1(this.sheet)}}`;
  }
  clone() {
    return new Rule2(this.rule, this.style, this.id).merge(this);
  }
};
function key(pid, styles) {
  const key2 = `f${stringHash(pid)}`;
  if (process.env.NODE_ENV === "production" || !styles.$displayName)
    return key2;
  return `${styles.$displayName}_${key2}`;
}
let FreeStyle$1 = class FreeStyle2 extends Cache {
  constructor(id, changes) {
    super(changes);
    this.id = id;
  }
  registerStyle(styles) {
    const rulesList = [];
    const stylesList = [];
    const pid = stylize("&", styles, rulesList, stylesList);
    const id = key(pid, styles);
    const selector = `.${process.env.NODE_ENV === "production" ? id : escape$2(id)}`;
    composeStylize(this, pid, rulesList, stylesList, selector, true);
    return id;
  }
  registerKeyframes(keyframes) {
    return this.registerHashRule("@keyframes", keyframes);
  }
  registerHashRule(prefix, styles) {
    const rulesList = [];
    const stylesList = [];
    const pid = stylize("", styles, rulesList, stylesList);
    const id = key(pid, styles);
    const selector = `${prefix} ${process.env.NODE_ENV === "production" ? id : escape$2(id)}`;
    const rule2 = new Rule$5(selector, "", `h\0${pid}\0${prefix}`);
    composeStylize(rule2, pid, rulesList, stylesList, "", false);
    this.add(rule2);
    return id;
  }
  registerRule(rule2, styles) {
    const rulesList = [];
    const stylesList = [];
    const pid = stylize(rule2, styles, rulesList, stylesList);
    composeStylize(this, pid, rulesList, stylesList, "", false);
  }
  registerCss(styles) {
    return this.registerRule("", styles);
  }
  getStyles() {
    return join$1(this.sheet);
  }
  clone() {
    return new FreeStyle2(this.id, this.changes).merge(this);
  }
};
function create$a(changes) {
  return new FreeStyle$1(`f${(++uniqueId).toString(36)}`, changes);
}
const dist_es2015 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Cache,
  FreeStyle: FreeStyle$1,
  Rule: Rule$5,
  Selector,
  Style,
  create: create$a
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015);
var formatting = {};
Object.defineProperty(formatting, "__esModule", { value: true });
function convertToStyles(object) {
  var styles = {};
  for (var key2 in object) {
    var val = object[key2];
    if (key2 === "$nest") {
      var nested = val;
      for (var selector in nested) {
        var subproperties = nested[selector];
        styles[selector] = convertToStyles(subproperties);
      }
    } else if (key2 === "$debugName") {
      styles.$displayName = val;
    } else {
      styles[key2] = val;
    }
  }
  return styles;
}
formatting.convertToStyles = convertToStyles;
function convertToKeyframes(frames) {
  var result2 = {};
  for (var offset in frames) {
    if (offset !== "$debugName") {
      result2[offset] = frames[offset];
    }
  }
  if (frames.$debugName) {
    result2.$displayName = frames.$debugName;
  }
  return result2;
}
formatting.convertToKeyframes = convertToKeyframes;
var utilities = {};
Object.defineProperty(utilities, "__esModule", { value: true });
utilities.raf = typeof requestAnimationFrame === "undefined" ? function(cb) {
  return setTimeout(cb);
} : typeof window === "undefined" ? requestAnimationFrame : requestAnimationFrame.bind(window);
function classes() {
  var classes2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    classes2[_i] = arguments[_i];
  }
  return classes2.map(function(c) {
    return c && typeof c === "object" ? Object.keys(c).map(function(key2) {
      return !!c[key2] && key2;
    }) : [c];
  }).reduce(function(flattened, c) {
    return flattened.concat(c);
  }, []).filter(function(c) {
    return !!c;
  }).join(" ");
}
utilities.classes = classes;
function extend$1() {
  var objects = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    objects[_i] = arguments[_i];
  }
  var result2 = {};
  for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {
    var object = objects_1[_a];
    if (object == null || object === false) {
      continue;
    }
    for (var key2 in object) {
      var val = object[key2];
      if (!val && val !== 0) {
        continue;
      }
      if (key2 === "$nest" && val) {
        result2[key2] = result2["$nest"] ? extend$1(result2["$nest"], val) : val;
      } else if (key2.indexOf("&") !== -1 || key2.indexOf("@media") === 0) {
        result2[key2] = result2[key2] ? extend$1(result2[key2], val) : val;
      } else {
        result2[key2] = val;
      }
    }
  }
  return result2;
}
utilities.extend = extend$1;
utilities.media = function(mediaQuery) {
  var _a;
  var objects = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    objects[_i - 1] = arguments[_i];
  }
  var mediaQuerySections = [];
  if (mediaQuery.type)
    mediaQuerySections.push(mediaQuery.type);
  if (mediaQuery.orientation)
    mediaQuerySections.push("(orientation: " + mediaQuery.orientation + ")");
  if (mediaQuery.minWidth)
    mediaQuerySections.push("(min-width: " + mediaLength(mediaQuery.minWidth) + ")");
  if (mediaQuery.maxWidth)
    mediaQuerySections.push("(max-width: " + mediaLength(mediaQuery.maxWidth) + ")");
  if (mediaQuery.minHeight)
    mediaQuerySections.push("(min-height: " + mediaLength(mediaQuery.minHeight) + ")");
  if (mediaQuery.maxHeight)
    mediaQuerySections.push("(max-height: " + mediaLength(mediaQuery.maxHeight) + ")");
  if (mediaQuery.prefersColorScheme)
    mediaQuerySections.push("(prefers-color-scheme: " + mediaQuery.prefersColorScheme + ")");
  var stringMediaQuery = "@media " + mediaQuerySections.join(" and ");
  var object = {
    $nest: (_a = {}, _a[stringMediaQuery] = extend$1.apply(void 0, objects), _a)
  };
  return object;
};
var mediaLength = function(value) {
  return typeof value === "string" ? value : value + "px";
};
Object.defineProperty(typestyle, "__esModule", { value: true });
var FreeStyle = require$$0;
var formatting_1 = formatting;
var utilities_1$1 = utilities;
var createFreeStyle = function() {
  return FreeStyle.create();
};
var TypeStyle = (
  /** @class */
  function() {
    function TypeStyle2(_a) {
      var _this = this;
      var autoGenerateTag = _a.autoGenerateTag;
      this.cssRaw = function(mustBeValidCSS) {
        if (!mustBeValidCSS) {
          return;
        }
        _this._raw += mustBeValidCSS || "";
        _this._pendingRawChange = true;
        _this._styleUpdated();
      };
      this.cssRule = function(selector) {
        var objects = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          objects[_i - 1] = arguments[_i];
        }
        var styles = formatting_1.convertToStyles(utilities_1$1.extend.apply(void 0, objects));
        _this._freeStyle.registerRule(selector, styles);
        _this._styleUpdated();
        return;
      };
      this.forceRenderStyles = function() {
        var target2 = _this._getTag();
        if (!target2) {
          return;
        }
        target2.textContent = _this.getStyles();
      };
      this.fontFace = function() {
        var fontFace = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fontFace[_i] = arguments[_i];
        }
        var freeStyle2 = _this._freeStyle;
        for (var _a2 = 0, _b = fontFace; _a2 < _b.length; _a2++) {
          var face = _b[_a2];
          freeStyle2.registerRule("@font-face", face);
        }
        _this._styleUpdated();
        return;
      };
      this.getStyles = function() {
        return (_this._raw || "") + _this._freeStyle.getStyles();
      };
      this.keyframes = function(frames) {
        var keyframes = formatting_1.convertToKeyframes(frames);
        var animationName = _this._freeStyle.registerKeyframes(keyframes);
        _this._styleUpdated();
        return animationName;
      };
      this.reinit = function() {
        var freeStyle2 = createFreeStyle();
        _this._freeStyle = freeStyle2;
        _this._lastFreeStyleChangeId = freeStyle2.changeId;
        _this._raw = "";
        _this._pendingRawChange = false;
        var target2 = _this._getTag();
        if (target2) {
          target2.textContent = "";
        }
      };
      this.setStylesTarget = function(tag) {
        if (_this._tag) {
          _this._tag.textContent = "";
        }
        _this._tag = tag;
        _this.forceRenderStyles();
      };
      this.stylesheet = function(classes2) {
        var classNames = Object.getOwnPropertyNames(classes2);
        var result2 = {};
        for (var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++) {
          var className = classNames_1[_i];
          var classDef = classes2[className];
          if (classDef) {
            classDef.$debugName = className;
            result2[className] = _this.style(classDef);
          }
        }
        return result2;
      };
      var freeStyle = createFreeStyle();
      this._autoGenerateTag = autoGenerateTag;
      this._freeStyle = freeStyle;
      this._lastFreeStyleChangeId = freeStyle.changeId;
      this._pending = 0;
      this._pendingRawChange = false;
      this._raw = "";
      this._tag = void 0;
      this.style = this.style.bind(this);
    }
    TypeStyle2.prototype._afterAllSync = function(cb) {
      var _this = this;
      this._pending++;
      var pending = this._pending;
      utilities_1$1.raf(function() {
        if (pending !== _this._pending) {
          return;
        }
        cb();
      });
    };
    TypeStyle2.prototype._getTag = function() {
      if (this._tag) {
        return this._tag;
      }
      if (this._autoGenerateTag) {
        var tag = typeof window === "undefined" ? { textContent: "" } : document.createElement("style");
        if (typeof document !== "undefined") {
          document.head.appendChild(tag);
        }
        this._tag = tag;
        return tag;
      }
      return void 0;
    };
    TypeStyle2.prototype._styleUpdated = function() {
      var _this = this;
      var changeId = this._freeStyle.changeId;
      var lastChangeId = this._lastFreeStyleChangeId;
      if (!this._pendingRawChange && changeId === lastChangeId) {
        return;
      }
      this._lastFreeStyleChangeId = changeId;
      this._pendingRawChange = false;
      this._afterAllSync(function() {
        return _this.forceRenderStyles();
      });
    };
    TypeStyle2.prototype.style = function() {
      var className = this._freeStyle.registerStyle(formatting_1.convertToStyles(utilities_1$1.extend.apply(void 0, arguments)));
      this._styleUpdated();
      return className;
    };
    return TypeStyle2;
  }()
);
typestyle.TypeStyle = TypeStyle;
var types$2 = {};
Object.defineProperty(types$2, "__esModule", { value: true });
Object.defineProperty(lib$8, "__esModule", { value: true });
var typestyle_1 = typestyle;
lib$8.TypeStyle = typestyle_1.TypeStyle;
var types$1 = types$2;
lib$8.types = types$1;
var utilities_1 = utilities;
lib$8.extend = utilities_1.extend;
lib$8.classes = utilities_1.classes;
lib$8.media = utilities_1.media;
var ts = new typestyle_1.TypeStyle({ autoGenerateTag: true });
lib$8.setStylesTarget = ts.setStylesTarget;
lib$8.cssRaw = ts.cssRaw;
lib$8.cssRule = ts.cssRule;
lib$8.forceRenderStyles = ts.forceRenderStyles;
lib$8.fontFace = ts.fontFace;
lib$8.getStyles = ts.getStyles;
lib$8.keyframes = ts.keyframes;
lib$8.reinit = ts.reinit;
var style = lib$8.style = ts.style;
lib$8.stylesheet = ts.stylesheet;
function createTypeStyle(target2) {
  var instance = new typestyle_1.TypeStyle({ autoGenerateTag: false });
  if (target2) {
    instance.setStylesTarget(target2);
  }
  return instance;
}
lib$8.createTypeStyle = createTypeStyle;
var LabIconStyle;
(function(LabIconStyle2) {
  const builtinSheets = {
    breadCrumb: {
      container: {
        $nest: {
          // `&` will be substituted for the generated classname (interpolation)
          "&:first-child svg": {
            bottom: "1px",
            marginLeft: "0px",
            position: "relative"
          },
          "&:hover": {
            backgroundColor: "var(--jp-layout-color2)"
          },
          [".jp-mod-dropTarget&"]: {
            backgroundColor: "var(--jp-brand-color2)",
            opacity: 0.7
          }
        }
      },
      element: {
        borderRadius: "var(--jp-border-radius)",
        cursor: "pointer",
        margin: "0px 2px",
        padding: "0px 2px",
        height: "16px",
        width: "16px",
        verticalAlign: "middle"
      }
    },
    commandPaletteHeader: {
      container: {
        height: "14px",
        margin: "0 14px 0 auto"
      },
      element: {
        height: "14px",
        width: "14px"
      },
      options: {
        elementPosition: "center"
      }
    },
    commandPaletteItem: {
      element: {
        height: "16px",
        width: "16px"
      },
      options: {
        elementPosition: "center"
      }
    },
    launcherCard: {
      container: {
        height: "52px",
        width: "52px"
      },
      element: {
        height: "52px",
        width: "52px"
      },
      options: {
        elementPosition: "center"
      }
    },
    launcherSection: {
      container: {
        boxSizing: "border-box",
        marginRight: "12px",
        height: "32px",
        width: "32px"
      },
      element: {
        height: "32px",
        width: "32px"
      },
      options: {
        elementPosition: "center"
      }
    },
    listing: {
      container: {
        flex: "0 0 20px",
        marginRight: "4px",
        position: "relative"
      },
      element: {
        height: "16px",
        width: "16px"
      },
      options: {
        elementPosition: "center"
      }
    },
    listingHeaderItem: {
      container: {
        display: "inline",
        height: "16px",
        width: "16px"
      },
      element: {
        height: "auto",
        margin: "-2px 0 0 0",
        width: "20px"
      },
      options: {
        elementPosition: "center"
      }
    },
    mainAreaTab: {
      container: {
        $nest: {
          ".lm-DockPanel-tabBar &": {
            marginRight: "4px"
          }
        }
      },
      element: {
        $nest: {
          ".lm-DockPanel-tabBar &": {
            height: "14px",
            width: "14px"
          }
        }
      },
      options: {
        elementPosition: "center"
      }
    },
    menuItem: {
      container: {
        display: "inline-block",
        verticalAlign: "middle"
      },
      element: {
        height: "16px",
        width: "16px"
      },
      options: {
        elementPosition: "center"
      }
    },
    runningItem: {
      container: {
        margin: "0px 4px 0px 4px"
      },
      element: {
        height: "16px",
        width: "16px"
      },
      options: {
        elementPosition: "center"
      }
    },
    select: {
      container: {
        pointerEvents: "none"
      },
      element: {
        position: "absolute",
        height: "auto",
        width: "16px"
      }
    },
    settingsEditor: {
      container: {
        display: "flex",
        flex: "0 0 20px",
        margin: "0 3px 0 0",
        position: "relative",
        height: "20px",
        width: "20px"
      },
      element: {
        height: "16px",
        width: "16px"
      },
      options: {
        elementPosition: "center"
      }
    },
    sideBar: {
      element: {
        height: "auto",
        width: "20px"
      },
      options: {
        elementPosition: "center"
      }
    },
    splash: {
      container: {
        animation: "0.3s fade-in linear forwards",
        height: "100%",
        width: "100%",
        zIndex: 1
      },
      element: {
        // width no height
        width: "100px"
      },
      options: {
        elementPosition: "center"
      }
    },
    statusBar: {
      element: {
        left: "0px",
        top: "0px",
        height: "18px",
        width: "20px",
        position: "relative"
      }
    },
    toolbarButton: {
      container: {
        display: "inline-block",
        verticalAlign: "middle"
      },
      element: {
        height: "16px",
        width: "16px"
      },
      options: {
        elementPosition: "center"
      }
    }
  };
  function _elementPositionFactory(extra) {
    return {
      container: {
        alignItems: "center",
        display: "flex"
      },
      element: {
        display: "block",
        ...extra
      }
    };
  }
  const positionSheets = {
    center: _elementPositionFactory({ margin: "0 auto", width: "100%" }),
    top: _elementPositionFactory({ margin: "0 0 auto 0" }),
    right: _elementPositionFactory({ margin: "0 0 0 auto" }),
    bottom: _elementPositionFactory({ margin: "auto 0 0 0" }),
    left: _elementPositionFactory({ margin: "0 auto 0 0" }),
    "top right": _elementPositionFactory({ margin: "0 0 auto auto" }),
    "bottom right": _elementPositionFactory({ margin: "auto 0 0 auto" }),
    "bottom left": _elementPositionFactory({ margin: "auto auto 0 0" }),
    "top left": _elementPositionFactory({ margin: "0 auto 0 auto" })
  };
  function _elementSizeFactory(size2) {
    return {
      element: {
        height: size2,
        width: size2
      }
    };
  }
  const sizeSheets = {
    small: _elementSizeFactory("14px"),
    normal: _elementSizeFactory("16px"),
    large: _elementSizeFactory("20px"),
    xlarge: _elementSizeFactory("24px")
  };
  function mergeSheets(sheets) {
    return {
      container: Object.assign({}, ...sheets.map((s) => s.container)),
      element: Object.assign({}, ...sheets.map((s) => s.element))
    };
  }
  function resolveSheet(stylesheet) {
    if (!stylesheet) {
      return [];
    }
    if (!Array.isArray(stylesheet)) {
      stylesheet = [stylesheet];
    }
    return stylesheet.map((k) => typeof k === "string" ? builtinSheets[k] : k);
  }
  function applySheetOptions(sheets) {
    const options = Object.assign({}, ...sheets.map((s) => s.options));
    if (options.elementPosition) {
      sheets.unshift(positionSheets[options.elementPosition]);
    }
    if (options.elementSize) {
      sheets.unshift(sizeSheets[options.elementSize]);
    }
    return mergeSheets(sheets);
  }
  function resolveStyleClass(stylesheet) {
    var _a;
    return style({
      ...stylesheet.container,
      $nest: {
        ...(_a = stylesheet.container) === null || _a === void 0 ? void 0 : _a.$nest,
        ["svg"]: stylesheet.element
      }
    });
  }
  const _styleClassCache = /* @__PURE__ */ new Map();
  function styleClass(props) {
    if (!props || Object.keys(props).length === 0) {
      return "";
    }
    let { elementPosition, elementSize, stylesheet, ...elementCSS } = props;
    const options = {
      ...elementPosition && { elementPosition },
      ...elementSize && { elementSize }
    };
    const cacheable = typeof stylesheet === "string" && Object.keys(elementCSS).length === 0;
    const cacheKey = cacheable ? [stylesheet, elementPosition, elementSize].join(",") : "";
    if (cacheable && _styleClassCache.has(cacheKey)) {
      return _styleClassCache.get(cacheKey);
    }
    const sheets = resolveSheet(stylesheet);
    sheets.push({ element: elementCSS, options });
    const cls = resolveStyleClass(applySheetOptions(sheets));
    if (cacheable) {
      _styleClassCache.set(cacheKey, cls);
    }
    return cls;
  }
  LabIconStyle2.styleClass = styleClass;
})(LabIconStyle || (LabIconStyle = {}));
class LabIcon {
  /** *********
   * statics *
   ***********/
  /**
   * Remove any rendered icon from the element that contains it
   *
   * @param container - a DOM node into which an icon was
   * previously rendered
   *
   * @returns the cleaned container
   */
  static remove(container2) {
    while (container2.firstChild) {
      container2.firstChild.remove();
    }
    container2.className = "";
    return container2;
  }
  /**
   * Resolve an icon name or a \{name, svgstr\} pair into an
   * actual LabIcon.
   *
   * @param options - icon: either a string with the name of an existing icon
   * or an object with \{name: string, svgstr: string\} fields.
   *
   * @returns a LabIcon instance
   */
  static resolve({ icon }) {
    if (icon instanceof LabIcon) {
      return icon;
    }
    if (typeof icon === "string") {
      const resolved = LabIcon._instances.get(icon);
      if (resolved) {
        return resolved;
      }
      if (LabIcon._debug) {
        console.warn(`Lookup failed for icon, creating loading icon. icon: ${icon}`);
      }
      return new LabIcon({ name: icon, svgstr: refreshSvgstr, _loading: true });
    }
    return new LabIcon(icon);
  }
  /**
   * Resolve an icon name or a \{name, svgstr\} pair into a DOM element.
   * If icon arg is undefined, the function will fall back to trying to render
   * the icon as a CSS background image, via the iconClass arg.
   * If both icon and iconClass are undefined, this function will return
   * an empty div.
   *
   * @param icon - optional, either a string with the name of an existing icon
   * or an object with \{name: string, svgstr: string\} fields
   *
   * @param iconClass - optional, if the icon arg is not set, the iconClass arg
   * should be a CSS class associated with an existing CSS background-image
   *
   * @param fallback - DEPRECATED, optional, a LabIcon instance that will
   * be used if neither icon nor iconClass are defined
   *
   * @param props - any additional args are passed though to the element method
   * of the resolved icon on render
   *
   * @returns a DOM node with the resolved icon rendered into it
   */
  static resolveElement({ icon, iconClass, fallback, ...props }) {
    if (!Private$q.isResolvable(icon)) {
      if (!iconClass && fallback) {
        return fallback.element(props);
      }
      props.className = classes$1(iconClass, props.className);
      return Private$q.blankElement(props);
    }
    return LabIcon.resolve({ icon }).element(props);
  }
  /**
   * Resolve an icon name or a \{name, svgstr\} pair into a React component.
   * If icon arg is undefined, the function will fall back to trying to render
   * the icon as a CSS background image, via the iconClass arg.
   * If both icon and iconClass are undefined, the returned component
   * will simply render an empty div.
   *
   * @param icon - optional, either a string with the name of an existing icon
   * or an object with \{name: string, svgstr: string\} fields
   *
   * @param iconClass - optional, if the icon arg is not set, the iconClass arg
   * should be a CSS class associated with an existing CSS background-image
   *
   * @param fallback - DEPRECATED, optional, a LabIcon instance that will
   * be used if neither icon nor iconClass are defined
   *
   * @param props - any additional args are passed though to the React component
   * of the resolved icon on render
   *
   * @returns a React component that will render the resolved icon
   */
  static resolveReact({ icon, iconClass, fallback, ...props }) {
    if (!Private$q.isResolvable(icon)) {
      if (!iconClass && fallback) {
        return React.createElement(fallback.react, { ...props });
      }
      props.className = classes$1(iconClass, props.className);
      return React.createElement(Private$q.blankReact, { ...props });
    }
    const resolved = LabIcon.resolve({ icon });
    return React.createElement(resolved.react, { ...props });
  }
  /**
   * Resolve a \{name, svgstr\} pair into an actual svg node.
   */
  static resolveSvg({ name: name2, svgstr }) {
    const svgDoc = new DOMParser().parseFromString(Private$q.svgstrShim(svgstr), "image/svg+xml");
    const svgError = svgDoc.querySelector("parsererror");
    if (svgError) {
      const errmsg = `SVG HTML was malformed for LabIcon instance.
name: ${name2}, svgstr: ${svgstr}`;
      if (LabIcon._debug) {
        console.error(errmsg);
        return svgError;
      } else {
        console.warn(errmsg);
        return null;
      }
    } else {
      return svgDoc.documentElement;
    }
  }
  /**
   * Toggle icon debug from off-to-on, or vice-versa.
   *
   * @param debug - optional boolean to force debug on or off
   */
  static toggleDebug(debug) {
    LabIcon._debug = debug !== null && debug !== void 0 ? debug : !LabIcon._debug;
  }
  /** *********
   * members *
   ***********/
  constructor({ name: name2, svgstr, render: render2, unrender, _loading = false }) {
    this._props = {};
    this._svgReplaced = new Signal(this);
    this._svgElement = void 0;
    this._svgInnerHTML = void 0;
    this._svgReactAttrs = void 0;
    if (!(name2 && svgstr)) {
      console.error(`When defining a new LabIcon, name and svgstr must both be non-empty strings. name: ${name2}, svgstr: ${svgstr}`);
      return badIcon;
    }
    this._loading = _loading;
    if (LabIcon._instances.has(name2)) {
      const icon = LabIcon._instances.get(name2);
      if (this._loading) {
        icon.svgstr = svgstr;
        this._loading = false;
        return icon;
      } else {
        if (LabIcon._debug) {
          console.warn(`Redefining previously loaded icon svgstr. name: ${name2}, svgstrOld: ${icon.svgstr}, svgstr: ${svgstr}`);
        }
        icon.svgstr = svgstr;
        return icon;
      }
    }
    this.name = name2;
    this.react = this._initReact(name2);
    this.svgstr = svgstr;
    this._initRender({ render: render2, unrender });
    LabIcon._instances.set(this.name, this);
  }
  /**
   * Get a view of this icon that is bound to the specified icon/style props
   *
   * @param optional icon/style props (same as args for .element
   * and .react methods). These will be bound to the resulting view
   *
   * @returns a view of this LabIcon instance
   */
  bindprops(props) {
    const view = Object.create(this);
    view._props = props;
    view.react = view._initReact(view.name + "_bind");
    return view;
  }
  /**
   * Create an icon as a DOM element
   *
   * @param className - a string that will be used as the class
   * of the container element. Overrides any existing class
   *
   * @param container - a preexisting DOM element that
   * will be used as the container for the svg element
   *
   * @param label - text that will be displayed adjacent
   * to the icon
   *
   * @param title - a tooltip for the icon
   *
   * @param tag - if container is not explicitly
   * provided, this tag will be used when creating the container
   *
   * @param stylesheet - optional string naming a builtin icon
   * stylesheet, for example 'menuItem' or `statusBar`. Can also be an
   * object defining a custom icon stylesheet, or a list of builtin
   * stylesheet names and/or custom stylesheet objects. If array,
   * the given stylesheets will be merged.
   *
   *   See @jupyterlab/ui-components/src/style/icon.ts for details
   *
   * @param elementPosition - optional position for the inner svg element
   *
   * @param elementSize - optional size for the inner svg element.
   * Set to 'normal' to get a standard 16px x 16px icon
   *
   * @param ...elementCSS - all additional args are treated as
   * overrides for the CSS props applied to the inner svg element
   *
   * @returns A DOM element that contains an (inline) svg element
   * that displays an icon
   */
  element(props = {}) {
    var _a;
    let { className, container: container2, label, title, tag = "div", ...styleProps } = { ...this._props, ...props };
    const maybeSvgElement = container2 === null || container2 === void 0 ? void 0 : container2.firstChild;
    if (((_a = maybeSvgElement === null || maybeSvgElement === void 0 ? void 0 : maybeSvgElement.dataset) === null || _a === void 0 ? void 0 : _a.iconId) === this._uuid) {
      return maybeSvgElement;
    }
    if (!this.svgElement) {
      return document.createElement("div");
    }
    if (container2) {
      while (container2.firstChild) {
        container2.firstChild.remove();
      }
    } else if (tag) {
      container2 = document.createElement(tag);
    }
    const svgElement = this.svgElement.cloneNode(true);
    if (!container2) {
      if (label) {
        console.warn();
      }
      return svgElement;
    }
    if (label != null) {
      container2.textContent = label;
    }
    Private$q.initContainer({
      container: container2,
      className,
      styleProps,
      title
    });
    container2.appendChild(svgElement);
    return container2;
  }
  render(container2, options) {
    var _a;
    let label = (_a = options === null || options === void 0 ? void 0 : options.children) === null || _a === void 0 ? void 0 : _a[0];
    if (typeof label !== "string") {
      label = void 0;
    }
    this.element({
      container: container2,
      label,
      ...options === null || options === void 0 ? void 0 : options.props
    });
  }
  get svgElement() {
    if (this._svgElement === void 0) {
      this._svgElement = this._initSvg({ uuid: this._uuid });
    }
    return this._svgElement;
  }
  get svgInnerHTML() {
    if (this._svgInnerHTML === void 0) {
      if (this.svgElement === null) {
        this._svgInnerHTML = null;
      } else {
        this._svgInnerHTML = this.svgElement.innerHTML;
      }
    }
    return this._svgInnerHTML;
  }
  get svgReactAttrs() {
    if (this._svgReactAttrs === void 0) {
      if (this.svgElement === null) {
        this._svgReactAttrs = null;
      } else {
        this._svgReactAttrs = getReactAttrs(this.svgElement, {
          ignore: ["data-icon-id"]
        });
      }
    }
    return this._svgReactAttrs;
  }
  get svgstr() {
    return this._svgstr;
  }
  set svgstr(svgstr) {
    this._svgstr = svgstr;
    const uuid = UUID.uuid4();
    const uuidOld = this._uuid;
    this._uuid = uuid;
    this._svgElement = void 0;
    this._svgInnerHTML = void 0;
    this._svgReactAttrs = void 0;
    document.querySelectorAll(`[data-icon-id="${uuidOld}"]`).forEach((oldSvgElement) => {
      if (this.svgElement) {
        oldSvgElement.replaceWith(this.svgElement.cloneNode(true));
      }
    });
    this._svgReplaced.emit();
  }
  _initReact(displayName) {
    const component = React.forwardRef((props = {}, ref2) => {
      const { className, container: container2, label, title, slot, tag = "div", ...styleProps } = { ...this._props, ...props };
      const [, setId] = React.useState(this._uuid);
      React.useEffect(() => {
        const onSvgReplaced = () => {
          setId(this._uuid);
        };
        this._svgReplaced.connect(onSvgReplaced);
        return () => {
          this._svgReplaced.disconnect(onSvgReplaced);
        };
      });
      const Tag = tag !== null && tag !== void 0 ? tag : React.Fragment;
      if (!(this.svgInnerHTML && this.svgReactAttrs)) {
        return React.createElement(React.Fragment, null);
      }
      const svgProps = { ...this.svgReactAttrs };
      if (!tag) {
        Object.assign(svgProps, {
          className: className || styleProps ? classes$1(className, LabIconStyle.styleClass(styleProps)) : void 0,
          title,
          slot
        });
      }
      const svgComponent = React.createElement("svg", { ...svgProps, ...this.svgReactAttrs, dangerouslySetInnerHTML: { __html: this.svgInnerHTML }, ref: ref2 });
      if (container2) {
        Private$q.initContainer({ container: container2, className, styleProps, title });
        return React.createElement(
          React.Fragment,
          null,
          svgComponent,
          label
        );
      } else {
        let attributes = {};
        if (Tag !== React.Fragment) {
          attributes = {
            className: className || styleProps ? classes$1(className, LabIconStyle.styleClass(styleProps)) : void 0,
            title,
            slot
          };
        }
        return React.createElement(
          Tag,
          { ...attributes },
          svgComponent,
          label
        );
      }
    });
    component.displayName = `LabIcon_${displayName}`;
    return component;
  }
  _initRender({ render: render2, unrender }) {
    if (render2) {
      this.render = render2;
      if (unrender) {
        this.unrender = unrender;
      }
    } else if (unrender) {
      console.warn("In _initRender, ignoring unrender arg since render is undefined");
    }
  }
  _initSvg({ title, uuid } = {}) {
    const svgElement = LabIcon.resolveSvg(this);
    if (!svgElement) {
      return svgElement;
    }
    if (svgElement.tagName !== "parsererror") {
      svgElement.dataset.icon = this.name;
      if (uuid) {
        svgElement.dataset.iconId = uuid;
      }
      if (title) {
        Private$q.setTitleSvg(svgElement, title);
      }
    }
    return svgElement;
  }
}
LabIcon._debug = false;
LabIcon._instances = /* @__PURE__ */ new Map();
var Private$q;
(function(Private2) {
  function blankElement({ className = "", container: container2, label, title, tag = "div", slot, ...styleProps }) {
    if ((container2 === null || container2 === void 0 ? void 0 : container2.className) === className) {
      return container2;
    }
    if (container2) {
      while (container2.firstChild) {
        container2.firstChild.remove();
      }
    } else {
      container2 = document.createElement(tag !== null && tag !== void 0 ? tag : "div");
    }
    if (label != null) {
      container2.textContent = label;
    }
    Private2.initContainer({ container: container2, className, styleProps, title });
    return container2;
  }
  Private2.blankElement = blankElement;
  Private2.blankReact = React.forwardRef(({ className = "", container: container2, label, title, tag = "div", ...styleProps }, ref2) => {
    const Tag = tag !== null && tag !== void 0 ? tag : "div";
    if (container2) {
      initContainer({ container: container2, className, styleProps, title });
      return React.createElement(React.Fragment, null);
    } else {
      return React.createElement(
        Tag,
        { className: classes$1(className, LabIconStyle.styleClass(styleProps)) },
        ref2 && blankIcon.react({ ref: ref2 }),
        label
      );
    }
  });
  Private2.blankReact.displayName = "BlankReact";
  function initContainer({ container: container2, className, styleProps, title }) {
    if (title != null) {
      container2.title = title;
    }
    const styleClass = LabIconStyle.styleClass(styleProps);
    if (className != null) {
      const classResolved = classes$1(className, styleClass);
      container2.className = classResolved;
      return classResolved;
    } else if (styleClass) {
      container2.classList.add(styleClass);
      return styleClass;
    } else {
      return "";
    }
  }
  Private2.initContainer = initContainer;
  function isResolvable(icon) {
    return !!(icon && (typeof icon === "string" || icon.name && icon.svgstr));
  }
  Private2.isResolvable = isResolvable;
  function setTitleSvg(svgNode, title) {
    const titleNodes = svgNode.getElementsByTagName("title");
    if (titleNodes.length) {
      titleNodes[0].textContent = title;
    } else {
      const titleNode = document.createElement("title");
      titleNode.textContent = title;
      svgNode.appendChild(titleNode);
    }
  }
  Private2.setTitleSvg = setTitleSvg;
  function svgstrShim(svgstr, strict = true) {
    const [, base64, raw] = decodeURIComponent(svgstr).replace(/>\s*\n\s*</g, "><").replace(/\s*\n\s*/g, " ").match(strict ? (
      // match based on data url schema
      /^(?:data:.*?(;base64)?,)?(.*)/
    ) : (
      // match based on open of svg tag
      /(?:(base64).*)?(<svg.*)/
    ));
    return base64 ? atob(raw) : raw;
  }
  Private2.svgstrShim = svgstrShim;
  class Renderer {
    constructor(_icon, _rendererOptions) {
      this._icon = _icon;
      this._rendererOptions = _rendererOptions;
    }
    // eslint-disable-next-line
    render(container2, options) {
    }
  }
  Private2.Renderer = Renderer;
  class ElementRenderer extends Renderer {
    render(container2, options) {
      var _a, _b;
      let label = (_a = options === null || options === void 0 ? void 0 : options.children) === null || _a === void 0 ? void 0 : _a[0];
      if (typeof label !== "string") {
        label = void 0;
      }
      this._icon.element({
        container: container2,
        label,
        ...(_b = this._rendererOptions) === null || _b === void 0 ? void 0 : _b.props,
        ...options === null || options === void 0 ? void 0 : options.props
      });
    }
  }
  Private2.ElementRenderer = ElementRenderer;
  class ReactRenderer extends Renderer {
    constructor() {
      super(...arguments);
      this._rootDOM = null;
    }
    render(container2, options) {
      var _a, _b;
      let label = (_a = options === null || options === void 0 ? void 0 : options.children) === null || _a === void 0 ? void 0 : _a[0];
      if (typeof label !== "string") {
        label = void 0;
      }
      const icon = this._icon;
      if (this._rootDOM !== null) {
        this._rootDOM.unmount();
      }
      this._rootDOM = createRoot(container2);
      this._rootDOM.render(React.createElement(icon.react, { container: container2, label, ...(_b = this._rendererOptions) === null || _b === void 0 ? void 0 : _b.props, ...options === null || options === void 0 ? void 0 : options.props }));
    }
    unrender(container2) {
      if (this._rootDOM !== null) {
        this._rootDOM.unmount();
        this._rootDOM = null;
      }
    }
  }
  Private2.ReactRenderer = ReactRenderer;
})(Private$q || (Private$q = {}));
const badIcon = new LabIcon({
  name: "ui-components:bad",
  svgstr: badSvgstr
});
const blankIcon = new LabIcon({
  name: "ui-components:blank",
  svgstr: blankSvgstr
});
const addAboveSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='14'%20height='14'%20fill='none'%20viewBox='0%200%2014%2014'%3e%3cg%20clip-path='url(%23addabovea)'%3e%3cpath%20fill='%23616161'%20stroke='%23616161'%20stroke-width='.7'%20d='M4.75%204.93h1.875v1.876c0%20.206.169.375.375.375a.376.376%200%200%200%20.375-.375V4.93H9.25a.376.376%200%200%200%20.375-.375.376.376%200%200%200-.375-.375H7.375V2.306A.376.376%200%200%200%207%201.93a.376.376%200%200%200-.375.375V4.18H4.75a.376.376%200%200%200-.375.375c0%20.206.169.375.375.375Z'%20class='jp-icon3'/%3e%3c/g%3e%3cpath%20fill='%23616161'%20fill-rule='evenodd'%20d='M11.5%209.5v2h-9v-2zM12%208a1%201%200%200%201%201%201v3a1%201%200%200%201-1%201H2a1%201%200%200%201-1-1V9a1%201%200%200%201%201-1z'%20class='jp-icon3'%20clip-rule='evenodd'/%3e%3cdefs%3e%3cclipPath%20id='addabovea'%3e%3cpath%20fill='%23fff'%20d='M10%201.556H4v6h6z'%20class='jp-icon3'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";
const addBelowSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='14'%20height='14'%20fill='none'%20viewBox='0%200%2014%2014'%3e%3cg%20clip-path='url(%23addbelowa)'%3e%3cpath%20fill='%23616161'%20stroke='%23616161'%20stroke-width='.7'%20d='M9.25%2010.07H7.375V8.193A.376.376%200%200%200%207%207.82a.376.376%200%200%200-.375.375v1.875H4.75a.376.376%200%200%200-.375.375c0%20.207.169.375.375.375h1.875v1.875c0%20.207.169.375.375.375a.376.376%200%200%200%20.375-.375V10.82H9.25a.376.376%200%200%200%20.375-.375.376.376%200%200%200-.375-.375Z'%20class='jp-icon3'/%3e%3c/g%3e%3cpath%20fill='%23616161'%20fill-rule='evenodd'%20d='M2.5%205.5v-2h9v2zM2%207a1%201%200%200%201-1-1V3a1%201%200%200%201%201-1h10a1%201%200%200%201%201%201v3a1%201%200%200%201-1%201z'%20class='jp-icon3'%20clip-rule='evenodd'/%3e%3cdefs%3e%3cclipPath%20id='addbelowa'%3e%3cpath%20fill='%23fff'%20d='M4%2013.444h6v-6H4z'%20class='jp-icon3'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";
const addSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M19%2013h-6v6h-2v-6H5v-2h6V5h2v6h6z'%20class='jp-icon3'/%3e%3c/svg%3e";
const bellSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20version='1.1'%20viewBox='0%200%2016%2016'%3e%3cpath%20fill='%23333'%20d='M8%20.29c-1.4%200-2.7.73-3.6%201.8-1.2%201.5-1.4%203.4-1.5%205.2-.18%202.2-.44%204-2.3%205.3l.28%201.3h5c.026.66.32%201.1.71%201.5.84.61%202%20.61%202.8%200%20.52-.4.6-1%20.71-1.5h5l.28-1.3c-1.9-.97-2.2-3.3-2.3-5.3-.13-1.8-.26-3.7-1.5-5.2-.85-1-2.2-1.8-3.6-1.8zm0%201.4c.88%200%201.9.55%202.5%201.3.88%201.1%201.1%202.7%201.2%204.4.13%201.7.23%203.6%201.3%205.2H3c1.1-1.6%201.2-3.4%201.3-5.2.13-1.7.3-3.3%201.2-4.4.59-.72%201.6-1.3%202.5-1.3m-.74%2012h1.5c-.001.28.015.79-.74.79-.73.002-.72-.53-.74-.79z'%20class='jp-icon2%20jp-icon-selectable'/%3e%3c/svg%3e";
const bugDotSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20fill='none'%20viewBox='0%200%2024%2024'%3e%3cg%20fill='%23616161'%20class='jp-icon3%20jp-icon-selectable'%3e%3cpath%20fill-rule='evenodd'%20d='M17.19%208H20v2h-2.09c.05.33.09.66.09%201v1h2v2h-2v.027a4.5%204.5%200%200%200-3.545%206.447A5.997%205.997%200%200%201%206.81%2018H4v-2h2.09c-.05-.33-.09-.66-.09-1v-1H4v-2h2v-1c0-.34.04-.67.09-1H4V8h2.81c.45-.78%201.07-1.45%201.81-1.96L7%204.41%208.41%203l2.18%202.17c.45-.11.92-.17%201.41-.17s.96.06%201.42.17L15.59%203%2017%204.41l-1.63%201.63c.75.51%201.37%201.18%201.82%201.96M10%2016h4v-2h-4zm0-4h4v-2h-4z'%20clip-rule='evenodd'/%3e%3cpath%20d='M22%2018.5a3.5%203.5%200%201%201-7%200%203.5%203.5%200%200%201%207%200'/%3e%3c/g%3e%3c/svg%3e";
const bugSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M20%208h-2.81a6%206%200%200%200-1.82-1.96L17%204.41%2015.59%203l-2.17%202.17C12.96%205.06%2012.49%205%2012%205s-.96.06-1.41.17L8.41%203%207%204.41l1.62%201.63C7.88%206.55%207.26%207.22%206.81%208H4v2h2.09c-.05.33-.09.66-.09%201v1H4v2h2v1c0%20.34.04.67.09%201H4v2h2.81c1.04%201.79%202.97%203%205.19%203s4.15-1.21%205.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20zm-6%208h-4v-2h4zm0-4h-4v-2h4z'%20class='jp-icon3%20jp-icon-selectable'/%3e%3c/svg%3e";
const buildSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M14.9%2017.45c1.35%200%202.45-1.1%202.45-2.45s-1.1-2.45-2.45-2.45c-1.36%200-2.45%201.1-2.45%202.45s1.09%202.45%202.45%202.45m5.2-1.77%201.48%201.16c.13.11.17.29.08.45l-1.4%202.42a.35.35%200%200%201-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.27%201.85c-.02.17-.17.3-.34.3h-2.8c-.18%200-.32-.13-.35-.3l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.75.7c-.15.06-.34%200-.42-.15l-1.4-2.42a.35.35%200%200%201%20.08-.45l1.48-1.16-.05-.68.05-.69-1.48-1.15a.35.35%200%200%201-.08-.45l1.4-2.42c.08-.16.27-.22.42-.16l1.75.71c.36-.28.75-.52%201.18-.69l.26-1.86c.03-.16.17-.29.35-.29h2.8c.17%200%20.32.13.34.29l.27%201.86c.42.17.82.41%201.18.69l1.74-.71c.17-.06.34%200%20.43.16l1.4%202.42c.09.15.05.34-.08.45l-1.48%201.15.05.69zM7.33%207.445A1.566%201.566%200%200%200%207.904%205.3a1.575%201.575%200%201%200-.574%202.145m2.327-2.65%201.21.157c.096.025.173.12.171.236v1.8a.214.214%200%200%201-.183.223l-1.195.17-.42.75.43%201.126c.037.106%200%20.22-.096.275l-1.559.9a.23.23%200%200%201-.294-.05l-.734-.95-.878-.001-.762.96c-.058.08-.173.1-.275.043l-1.56-.901a.23.23%200%200%201-.101-.276l.452-1.116-.246-.366-.194-.396-1.192-.166a.23.23%200%200%201-.189-.226V5.186c.002-.117.077-.206.175-.217l1.204-.175.446-.766-.456-1.11a.23.23%200%200%201%20.104-.28l1.56-.9a.225.225%200%200%201%20.285.054l.76.936.86.01.745-.949a.214.214%200%200%201%20.284-.048l1.56.9a.24.24%200%200%201%20.118.267l-.47%201.126.246.366z'%20class='jp-icon3'/%3e%3c/svg%3e";
const caretDownEmptySvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2018%2018'%3e%3cpath%20fill='%23616161'%20d='M5.2%205.9%209%209.7l3.8-3.8L14%207.1l-4.9%205-4.9-5z'%20class='jp-icon3'%20shape-rendering='geometricPrecision'/%3e%3c/svg%3e";
const caretDownEmptyThinSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2020%2020'%3e%3cpath%20fill='%23616161'%20d='M9.9%2013.6%203.6%207.4l.8-.8%205.5%205.6%205.5-5.5.7.7z'%20class='jp-icon3'%20shape-rendering='geometricPrecision'/%3e%3c/svg%3e";
const caretDownSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2018%2018'%3e%3cpath%20fill='%23616161'%20d='M5.2%207.5%209%2011.2l3.8-3.8H5.2z'%20class='jp-icon3'%20shape-rendering='geometricPrecision'/%3e%3c/svg%3e";
const caretLeftSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2018%2018'%3e%3cpath%20fill='%23616161'%20d='M10.8%2012.8%207.1%209l3.8-3.8v7.6z'%20class='jp-icon3'%20shape-rendering='geometricPrecision'/%3e%3c/svg%3e";
const caretRightSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2018%2018'%3e%3cpath%20fill='%23616161'%20d='M7.2%205.2%2010.9%209l-3.8%203.8V5.2z'%20class='jp-icon3'%20shape-rendering='geometricPrecision'/%3e%3c/svg%3e";
const caretUpEmptyThinSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2020%2020'%3e%3cpath%20fill='%23616161'%20d='M15.4%2013.3%209.9%207.7l-5.5%205.5-.8-.7%206.3-6.2%206.2%206.3z'%20class='jp-icon3'%20shape-rendering='geometricPrecision'/%3e%3c/svg%3e";
const caretUpSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2018%2018'%3e%3cpath%20fill='%23616161'%20d='M5.2%2010.5%209%206.8l3.8%203.8H5.2z'%20class='jp-icon3'%20shape-rendering='geometricPrecision'/%3e%3c/svg%3e";
const caseSensitiveSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2020%2020'%3e%3cpath%20fill='%23414141'%20d='M2%202h16v16H2z'%20class='jp-icon2'/%3e%3cpath%20fill='%23FFF'%20d='M7.6%208h.9l3.5%208h-1.1l-.9-2H6l-.9%202H4zM8%209.1%206.4%2013h3.2zm8.6.7c-.2.1-.4.1-.7.1-.2%200-.4-.1-.6-.2-.1-.1-.2-.4-.2-.7-.3.3-.6.5-.9.7-.3.1-.7.2-1.1.2-.3%200-.5%200-.7-.1l-.6-.3c-.2-.1-.3-.3-.4-.5s-.1-.4-.1-.7.1-.6.2-.8.3-.4.4-.5c.1%200%20.3-.1.6-.2.2-.1.5-.1.7-.2.3-.1.5-.1.7-.1s.4-.1.6-.1.3-.1.4-.2.2-.2.2-.4c0-1-1.1-1-1.3-1-.4%200-1.4%200-1.4%201.2h-.9c0-.4.1-.7.2-1%20.1-.2.3-.4.5-.6s.5-.3.8-.3c.3-.1.6-.1.9-.1s.5%200%20.8.1c.3%200%20.5.1.7.2s.4.3.5.5.1.4.1.8V9c0%20.1.1.2.3.2h.3zm-1.4-2.9c-1.2.6-3.1.2-3.1%201.4%200%201.4%203.1%201%203.1-.5z'%20class='jp-icon-accent2'/%3e%3c/svg%3e";
const checkSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M9%2016.17%204.83%2012l-1.42%201.41L9%2019%2021%207l-1.41-1.41z'%20class='jp-icon3%20jp-icon-selectable'/%3e%3c/svg%3e";
const circleEmptySvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M12%202C6.47%202%202%206.47%202%2012s4.47%2010%2010%2010%2010-4.47%2010-10S17.53%202%2012%202m0%2018c-4.41%200-8-3.59-8-8s3.59-8%208-8%208%203.59%208%208-3.59%208-8%208'%20class='jp-icon3'/%3e%3c/svg%3e";
const circleSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2018%2018'%3e%3ccircle%20cx='9'%20cy='9'%20r='8'%20fill='%23616161'%20class='jp-icon3'/%3e%3c/svg%3e";
const cleaningSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M16%2011h-1V3c0-1.1-.9-2-2-2h-2c-1.1%200-2%20.9-2%202v8H8c-2.76%200-5%202.24-5%205v7h18v-7c0-2.76-2.24-5-5-5m3%2010h-2v-3c0-.55-.45-1-1-1s-1%20.45-1%201v3h-2v-3c0-.55-.45-1-1-1s-1%20.45-1%201v3H9v-3c0-.55-.45-1-1-1s-1%20.45-1%201v3H5v-5c0-1.65%201.35-3%203-3h8c1.65%200%203%201.35%203%203z'%20class='jp-icon3'/%3e%3c/svg%3e";
const clearSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cmask%20id='cleara'%3e%3cpath%20fill='%23fff'%20d='M0%200h24v24H0z'/%3e%3ccircle%20cx='12'%20cy='12'%20r='8'%20fill='%23000'/%3e%3c/mask%3e%3cg%20fill='%23616161'%20class='jp-icon3'%3e%3cpath%20d='M4.929%206.343%206.343%204.93l12.728%2012.728-1.414%201.414z'/%3e%3ccircle%20cx='12'%20cy='12'%20r='10'%20mask='url(%23cleara)'/%3e%3c/g%3e%3c/svg%3e";
const closeSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3ccircle%20cx='12'%20cy='12'%20r='11'%20fill='none'%20class='jp-icon-none%20jp-icon-selectable-inverse%20jp-icon3-hover'/%3e%3cpath%20fill='%23616161'%20d='M19%206.41%2017.59%205%2012%2010.59%206.41%205%205%206.41%2010.59%2012%205%2017.59%206.41%2019%2012%2013.41%2017.59%2019%2019%2017.59%2013.41%2012z'%20class='jp-icon3%20jp-icon-selectable%20jp-icon-accent2-hover'/%3e%3ccircle%20cx='12'%20cy='12'%20r='7'%20fill='none'%20class='jp-icon-none%20jp-icon-busy'/%3e%3c/svg%3e";
const codeCheckSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M6.59%203.41%202%208l4.59%204.6L8%2011.18%204.82%208%208%204.82zm5.82%200L11%204.82%2014.18%208%2011%2011.18l1.41%201.42L17%208zm9.18%208.18-8.09%208.09L9.83%2016l-1.41%201.41%205.08%205.09L23%2013z'%20class='jp-icon3%20jp-icon-selectable'%20shape-rendering='geometricPrecision'/%3e%3c/svg%3e";
const codeSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='22'%20height='22'%20viewBox='0%200%2028%2028'%3e%3cpath%20fill='%23616161'%20d='M11.4%2018.6%206.8%2014l4.6-4.6L10%208l-6%206%206%206zm5.2%200%204.6-4.6-4.6-4.6L18%208l6%206-6%206z'%20class='jp-icon3'/%3e%3c/svg%3e";
const collapseAllSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cg%20fill='%23616161'%20class='jp-icon3'%3e%3cpath%20d='M8%202h12c1%200%202%201%202%202v12c0%201%200%202-2%202V4H6c0-2%201-2%202-2'/%3e%3cpath%20d='M18%208c0-1-1-2-2-2H4C3%206%202%207%202%208v12c0%201%201%202%202%202h12c1%200%202-1%202-2zm-2%200v12H4V8z'/%3e%3cpath%20d='M6%2013v2h8v-2z'/%3e%3c/g%3e%3c/svg%3e";
const collapseSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%208.5%2010.5'%3e%3cg%20fill='%23BDBDBD'%20class='jp-icon-output'%3e%3cpath%20d='M.019%200h8.458v1.064H.019zM0%209.52h8.491v1.059H0zm4.776-6.608H3.72V1.323h1.056z'/%3e%3cpath%20d='m4.244%205.243-1.06-1.167-1.06-1.167h4.24l-1.06%201.167zm.528%204.014H3.716V7.665h1.056z'/%3e%3cpath%20d='M4.242%205.332%205.302%206.5l1.06%201.167h-4.24L3.182%206.5z'/%3e%3c/g%3e%3c/svg%3e";
const consoleSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%20200%20200'%3e%3cpath%20fill='%230288D1'%20d='M20%2019.8h160v159.9H20z'%20class='jp-console-icon-background-color%20jp-icon-selectable'/%3e%3cpath%20fill='%23fff'%20d='M105%20127.3h40v12.8h-40zM51.1%2077%2074%2099.9l-23.3%2023.3%2010.5%2010.5%2023.3-23.3L95%2099.9%2084.5%2089.4%2061.6%2066.5z'%20class='jp-console-icon-color%20jp-icon-selectable-inverse'/%3e%3c/svg%3e";
const copySvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2018%2018'%3e%3cpath%20fill='%23616161'%20d='M11.9%201H3.2c-.8%200-1.5.7-1.5%201.5v10.2h1.5V2.5h8.7zm2.2%202.9h-8c-.8%200-1.5.7-1.5%201.5v10.2c0%20.8.7%201.5%201.5%201.5h8c.8%200%201.5-.7%201.5-1.5V5.4c-.1-.8-.7-1.5-1.5-1.5m0%2011.6h-8V5.4h8z'%20class='jp-icon3'/%3e%3c/svg%3e";
const copyrightSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M11.88%209.14c1.28.06%201.61%201.15%201.63%201.66h1.79c-.08-1.98-1.49-3.19-3.45-3.19C9.64%207.61%208%209%208%2012.14c0%201.94.93%204.24%203.84%204.24%202.22%200%203.41-1.65%203.44-2.95h-1.79c-.03.59-.45%201.38-1.63%201.44-1.31-.04-1.86-1.06-1.86-2.73%200-2.89%201.28-2.98%201.88-3M12%202C6.48%202%202%206.48%202%2012s4.48%2010%2010%2010%2010-4.48%2010-10S17.52%202%2012%202m0%2018c-4.41%200-8-3.59-8-8s3.59-8%208-8%208%203.59%208%208-3.59%208-8%208'%20class='jp-icon3'/%3e%3c/svg%3e";
const cutSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M9.64%207.64c.23-.5.36-1.05.36-1.64%200-2.21-1.79-4-4-4S2%203.79%202%206s1.79%204%204%204c.59%200%201.14-.13%201.64-.36L10%2012l-2.36%202.36C7.14%2014.13%206.59%2014%206%2014c-2.21%200-4%201.79-4%204s1.79%204%204%204%204-1.79%204-4c0-.59-.13-1.14-.36-1.64L12%2014l7%207h3v-1zM6%208c-1.1%200-2-.89-2-2s.9-2%202-2%202%20.89%202%202-.9%202-2%202m0%2012c-1.1%200-2-.89-2-2s.9-2%202-2%202%20.89%202%202-.9%202-2%202m6-7.5c-.28%200-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5M19%203l-6%206%202%202%207-7V3z'%20class='jp-icon3'/%3e%3c/svg%3e";
const deleteSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20height='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23626262'%20d='M6%2019c0%201.1.9%202%202%202h8c1.1%200%202-.9%202-2V7H6zM19%204h-3.5l-1-1h-5l-1%201H5v2h14z'%20class='jp-icon3'/%3e%3c/svg%3e";
const downloadSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M19%209h-4V3H9v6H5l7%207zM5%2018v2h14v-2z'%20class='jp-icon3'/%3e%3c/svg%3e";
const duplicateSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='14'%20height='14'%20fill='none'%20viewBox='0%200%2014%2014'%3e%3cpath%20fill='%23616161'%20fill-rule='evenodd'%20d='M2.8.875h6.096c.305%200%20.554.264.554.587s-.25.587-.554.587H3.354c-.305%200-.554.264-.554.587V9.68c0%20.322-.25.587-.554.587s-.554-.264-.554-.587V2.049c0-.646.498-1.174%201.108-1.174M5.367%2011.9V4.55h5.716v7.35zM4.142%204.142c0-.451.365-.817.816-.817h6.534c.45%200%20.816.366.816.817v8.166a.817.817%200%200%201-.816.817H4.958a.817.817%200%200%201-.816-.817z'%20class='jp-icon3'%20clip-rule='evenodd'/%3e%3cpath%20fill='%23616161'%20stroke='%23616161'%20stroke-width='.5'%20d='M9.436%208.265H8.364v1.071a.215.215%200%200%201-.214.215.215.215%200%200%201-.214-.215v-1.07H6.864a.215.215%200%200%201-.214-.215c0-.118.096-.215.214-.215h1.072v-1.07a.214.214%200%201%201%20.428-.001v1.072h1.072c.118%200%20.214.096.214.214a.215.215%200%200%201-.214.214Z'%20class='jp-icon3'/%3e%3c/svg%3e";
const editSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M3%2017.25V21h3.75L17.81%209.94l-3.75-3.75zM20.71%207.04a.996.996%200%200%200%200-1.41l-2.34-2.34a.996.996%200%200%200-1.41%200l-1.83%201.83%203.75%203.75z'%20class='jp-icon3'/%3e%3c/svg%3e";
const ellipsesSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cg%20fill='%23616161'%20class='jp-icon3'%3e%3ccircle%20cx='5'%20cy='12'%20r='2'/%3e%3ccircle%20cx='12'%20cy='12'%20r='2'/%3e%3ccircle%20cx='19'%20cy='12'%20r='2'/%3e%3c/g%3e%3c/svg%3e";
const errorSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cg%20fill='%23616161'%20class='jp-icon3'%3e%3ccircle%20cx='12'%20cy='19'%20r='2'/%3e%3cpath%20d='M10%203h4v12h-4z'/%3e%3c/g%3e%3c/svg%3e";
const expandAllSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cg%20fill='%23616161'%20class='jp-icon3'%3e%3cpath%20d='M8%202h12c1%200%202%201%202%202v12c0%201%200%202-2%202V4H6c0-2%201-2%202-2'/%3e%3cpath%20d='M18%208c0-1-1-2-2-2H4C3%206%202%207%202%208v12c0%201%201%202%202%202h12c1%200%202-1%202-2zm-2%200v12H4V8z'/%3e%3cpath%20d='M11%2010H9v3H6v2h3v3h2v-3h3v-2h-3z'/%3e%3c/g%3e%3c/svg%3e";
const expandSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%208.5%2010.5'%3e%3cg%20fill='%23BDBDBD'%20class='jp-icon-output'%3e%3cpath%20d='M.019%200h8.458v1.064H.019zM0%209.521h8.491v1.059H0zm3.712-5.822h1.056v1.589H3.712z'/%3e%3cpath%20d='m4.244%201.368%201.06%201.167%201.06%201.167h-4.24l1.06-1.167zm-.532%203.92h1.056V6.88H3.712z'/%3e%3cpath%20d='m4.242%209.213-1.06-1.167-1.06-1.167h4.24l-1.06%201.167z'/%3e%3c/g%3e%3c/svg%3e";
const extensionSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M20.5%2011H19V7c0-1.1-.9-2-2-2h-4V3.5a2.5%202.5%200%200%200-5%200V5H4c-1.1%200-1.99.9-1.99%202v3.8H3.5c1.49%200%202.7%201.21%202.7%202.7s-1.21%202.7-2.7%202.7H2V20c0%201.1.9%202%202%202h3.8v-1.5c0-1.49%201.21-2.7%202.7-2.7s2.7%201.21%202.7%202.7V22H17c1.1%200%202-.9%202-2v-4h1.5a2.5%202.5%200%200%200%200-5'%20class='jp-icon3'/%3e%3c/svg%3e";
const fastForwardSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='m4%2018%208.5-6L4%206zm9-12v12l8.5-6z'%20class='jp-icon3'/%3e%3c/svg%3e";
const fileSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2022%2022'%3e%3cpath%20fill='%23616161'%20d='m19.3%208.2-5.5-5.5c-.3-.3-.7-.5-1.2-.5H3.9c-.8.1-1.6.9-1.6%201.8v14.1c0%20.9.7%201.6%201.6%201.6h14.2c.9%200%201.6-.7%201.6-1.6V9.4c.1-.5-.1-.9-.4-1.2m-5.8-3.3%203.4%203.6h-3.4zm3.9%2012.7H4.7c-.1%200-.2%200-.2-.2V4.7c0-.2.1-.3.2-.3h7.2v4.4s0%20.8.3%201.1%201.1.3%201.1.3h4.3v7.2s-.1.2-.2.2'%20class='jp-icon3%20jp-icon-selectable'/%3e%3c/svg%3e";
const fileUploadSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M9%2016h6v-6h4l-7-7-7%207h4zm-4%202h14v2H5z'%20class='jp-icon3'/%3e%3c/svg%3e";
const filterDotSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23FFF'%20d='M14%2012v7.88c.04.3-.06.62-.29.83a.996.996%200%200%201-1.41%200l-2.01-2.01a.99.99%200%200%201-.29-.83V12h-.03L4.21%204.62a1%201%200%200%201%20.17-1.4c.19-.14.4-.22.62-.22h14c.22%200%20.43.08.62.22a1%201%200%200%201%20.17%201.4L14.03%2012z'%20class='jp-icon3'/%3e%3ccircle%20cx='18'%20cy='17'%20r='3'%20fill='%23FFF'%20class='jp-icon-dot'/%3e%3c/svg%3e";
const filterListSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M10%2018h4v-2h-4zM3%206v2h18V6zm3%207h12v-2H6z'%20class='jp-icon3'/%3e%3c/svg%3e";
const filterSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23FFF'%20d='M14%2012v7.88c.04.3-.06.62-.29.83a.996.996%200%200%201-1.41%200l-2.01-2.01a.99.99%200%200%201-.29-.83V12h-.03L4.21%204.62a1%201%200%200%201%20.17-1.4c.19-.14.4-.22.62-.22h14c.22%200%20.43.08.62.22a1%201%200%200%201%20.17%201.4L14.03%2012z'%20class='jp-icon3'/%3e%3c/svg%3e";
const folderFavoriteSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20fill='%23000'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M20%206h-8l-2-2H4c-1.1%200-2%20.9-2%202v12c0%201.1.9%202%202%202h16c1.1%200%202-.9%202-2V8c0-1.1-.9-2-2-2m-2.06%2011L15%2015.28%2012.06%2017l.78-3.33-2.59-2.24%203.41-.29L15%208l1.34%203.14%203.41.29-2.59%202.24z'%20class='jp-icon3%20jp-icon-selectable'/%3e%3c/svg%3e";
const folderSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M10%204H4c-1.1%200-1.99.9-1.99%202L2%2018c0%201.1.9%202%202%202h16c1.1%200%202-.9%202-2V8c0-1.1-.9-2-2-2h-8z'%20class='jp-icon3%20jp-icon-selectable'/%3e%3c/svg%3e";
const historySvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M13.5%208H12v5l4.28%202.54.72-1.21-3.5-2.08zM13%203a9%209%200%200%200-9%209H1l3.96%204.03L9%2012H6a7%207%200%200%201%207-7%207%207%200%200%201%207%207%207%207%200%200%201-7%207c-1.93%200-3.68-.79-4.94-2.06l-1.42%201.42A8.9%208.9%200%200%200%2013%2021a9%209%200%200%200%209-9%209%209%200%200%200-9-9'%20class='jp-icon3'/%3e%3c/svg%3e";
const homeSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20fill='%23000'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M10%2020v-6h4v6h5v-8h3L12%203%202%2012h3v8z'%20class='jp-icon3%20jp-icon-selectable'/%3e%3c/svg%3e";
const html5Svgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%20512%20512'%3e%3cpath%20fill='%23000'%20d='M108.4%200h23v22.8h21.2V0h23v69h-23V46h-21v23h-23.2M206%2023h-20.3V0h63.7v23H229v46h-23m53.5-69h24.1l14.8%2024.3L313.2%200h24.1v69h-23V34.8l-16.1%2024.8-16.1-24.8V69h-22.6m89.2-69h23v46.2h32.6V69h-55.6'%20class='jp-icon0%20jp-icon-selectable'/%3e%3cpath%20fill='%23e44d26'%20d='m107.6%20471-33-370.4h362.8l-33%20370.2L255.7%20512'%20class='jp-icon-selectable'/%3e%3cpath%20fill='%23f16529'%20d='M256%20480.5V131h148.3L376%20447'%20class='jp-icon-selectable'/%3e%3cpath%20fill='%23ebebeb'%20d='M142%20176.3h114v45.4h-64.2l4.2%2046.5h60v45.3H154.4m2%2022.8H202l3.2%2036.3%2050.8%2013.6v47.4l-93.2-26'%20class='jp-icon-selectable-inverse'/%3e%3cpath%20fill='%23fff'%20d='M369.6%20176.3H255.8v45.4h109.6m-4.1%2046.5H255.8v45.4h56l-5.3%2059-50.7%2013.6v47.2l93-25.8'%20class='jp-icon-selectable-inverse'/%3e%3c/svg%3e";
const imageSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2022%2022'%3e%3cpath%20fill='%23FFF'%20d='M2.2%202.2h17.5v17.5H2.2z'%20class='jp-icon-brand4%20jp-icon-selectable-inverse'/%3e%3cpath%20fill='%233F51B5'%20d='M2.2%202.2v17.5h17.5l.1-17.5zm12.1%202.2c1.2%200%202.2%201%202.2%202.2s-1%202.2-2.2%202.2-2.2-1-2.2-2.2%201-2.2%202.2-2.2M4.4%2017.6l3.3-8.8%203.3%206.6%202.2-3.2%204.4%205.4z'%20class='jp-icon-brand0%20jp-icon-selectable'/%3e%3c/svg%3e";
const infoSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2050.978%2050.978'%3e%3cg%20fill='%23616161'%20class='jp-icon3'%3e%3cpath%20d='M43.52%207.458C38.711%202.648%2032.307%200%2025.489%200%2018.67%200%2012.266%202.648%207.458%207.458c-9.943%209.941-9.943%2026.119%200%2036.062%204.809%204.809%2011.212%207.456%2018.031%207.458h.002c6.816%200%2013.221-2.648%2018.029-7.458%204.809-4.809%207.457-11.212%207.457-18.03%200-6.82-2.649-13.224-7.457-18.032m-1.414%2034.647c-4.432%204.431-10.332%206.872-16.615%206.872h-.002c-6.285-.001-12.187-2.441-16.617-6.872-9.162-9.163-9.162-24.071%200-33.233C13.303%204.44%2019.204%202%2025.489%202c6.284%200%2012.186%202.44%2016.617%206.872%204.431%204.431%206.871%2010.332%206.871%2016.617%200%206.283-2.441%2012.186-6.871%2016.616'/%3e%3cpath%20d='M23.578%2032.218q-.034-2.602.496-3.972t2.272-3.253q.702-.805%201.367-1.575.939-1.13%201.436-2.175.496-1.061.495-2.5%200-1.643-.779-2.979-.848-1.319-2.806-1.369-2.703.085-3.55%201.832a5.3%205.3%200%200%200-.607%201.814%2011.3%2011.3%200%200%200-.207%202.174h-2.937q-.136-3.312%201.493-5.719%201.593-2.459%205.378-2.527%203.24.034%205.141%201.758%201.918%201.74%201.95%204.811%200%201.712-.41%202.911a7.6%207.6%200%200%201-1.268%202.243%2022%2022%200%200%201-1.73%202.002%2034%2034%200%200%200-1.987%202.346%205.2%205.2%200%200%200-.565%201.199q-.24%201.438-.171%202.979zm0%206.002v-3.484h3.076v3.484z'/%3e%3c/g%3e%3c/svg%3e";
const inspectorSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M20%204H4c-1.1%200-1.99.9-1.99%202L2%2018c0%201.1.9%202%202%202h16c1.1%200%202-.9%202-2V6c0-1.1-.9-2-2-2m-5%2014H4v-4h11zm0-5H4V9h11zm5%205h-4V9h4z'%20class='jp-inspector-icon-color%20jp-icon-selectable'/%3e%3c/svg%3e";
const jsonSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2022%2022'%3e%3cg%20fill='%23F9A825'%20class='jp-json-icon-color%20jp-icon-selectable'%3e%3cpath%20d='M20.2%2011.8c-1.6%200-1.7.5-1.7%201%200%20.4.1.9.1%201.3.1.5.1.9.1%201.3%200%201.7-1.4%202.3-3.5%202.3h-.9v-1.9h.5c1.1%200%201.4%200%201.4-.8%200-.3%200-.6-.1-1%200-.4-.1-.8-.1-1.2%200-1.3%200-1.8%201.3-2-1.3-.2-1.3-.7-1.3-2%200-.4.1-.8.1-1.2.1-.4.1-.7.1-1%200-.8-.4-.7-1.4-.8h-.5V4.1h.9c2.2%200%203.5.7%203.5%202.3%200%20.4-.1.9-.1%201.3-.1.5-.1.9-.1%201.3%200%20.5.2%201%201.7%201zM1.8%2010.1c1.6%200%201.7-.5%201.7-1%200-.4-.1-.9-.1-1.3-.1-.5-.1-.9-.1-1.3%200-1.6%201.4-2.3%203.5-2.3h.9v1.9h-.5c-1%200-1.4%200-1.4.8%200%20.3%200%20.6.1%201%200%20.2.1.6.1%201%200%201.3%200%201.8-1.3%202C6%2011.2%206%2011.7%206%2013c0%20.4-.1.8-.1%201.2-.1.3-.1.7-.1%201%200%20.8.3.8%201.4.8h.5v1.9h-.9c-2.1%200-3.5-.6-3.5-2.3%200-.4.1-.9.1-1.3.1-.5.1-.9.1-1.3%200-.5-.2-1-1.7-1z'/%3e%3ccircle%20cx='11'%20cy='13.8'%20r='2.1'/%3e%3ccircle%20cx='11'%20cy='8.2'%20r='2.1'/%3e%3c/g%3e%3c/svg%3e";
const juliaSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%20325%20300'%3e%3cpath%20fill='%23cb3c33'%20d='M150.898%20225c0%2041.422-33.578%2075-75%2075s-75-33.578-75-75%2033.579-75%2075-75%2075%2033.578%2075%2075'%20class='jp-brand0%20jp-icon-selectable'/%3e%3cpath%20fill='%23389826'%20d='M237.5%2075c0%2041.422-33.578%2075-75%2075s-75-33.578-75-75%2033.578-75%2075-75%2075%2033.578%2075%2075'%20class='jp-brand0%20jp-icon-selectable'/%3e%3cpath%20fill='%239558b2'%20d='M324.102%20225c0%2041.422-33.579%2075-75%2075s-75-33.578-75-75%2033.578-75%2075-75%2075%2033.578%2075%2075'%20class='jp-brand0%20jp-icon-selectable'/%3e%3c/svg%3e";
const jupyterFaviconSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='152'%20height='165'%20version='1.1'%20viewBox='0%200%20152%20165'%3e%3cpath%20fill='%23F37726'%20d='M76.021%20140.163c-32.64%200-61.145-11.927-75.942-29.58%205.51%2015.84%2015.781%2029.567%2029.39%2039.278a80.17%2080.17%200%200%200%2046.57%2014.929%2080.17%2080.17%200%200%200%2046.57-14.929c13.61-9.711%2023.88-23.437%2029.391-39.278-14.833%2017.653-43.338%2029.58-75.979%2029.58m-.005-114.832c32.64%200%2061.146%2011.927%2075.943%2029.58a80.9%2080.9%200%200%200-29.391-39.278A80.16%2080.16%200%200%200%2075.998.705a80.16%2080.16%200%200%200-46.57%2014.928A80.9%2080.9%200%200%200%20.038%2054.912c14.832-17.617%2043.338-29.58%2075.978-29.58'%20class='jp-jupyter-icon-color'/%3e%3c/svg%3e";
const jupyterSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='39'%20height='51'%20viewBox='0%200%2039%2051'%3e%3cpath%20fill='%23F37726'%20d='M20.005%2038.114c-7.85%200-14.706-2.876-18.265-7.134a19.5%2019.5%200%200%200%207.069%209.473%2019.24%2019.24%200%200%200%2011.2%203.6c4.013%200%207.927-1.258%2011.2-3.6a19.5%2019.5%200%200%200%207.069-9.473c-3.567%204.258-10.423%207.134-18.273%207.134m-.002-27.694c7.85%200%2014.706%202.876%2018.265%207.133a19.5%2019.5%200%200%200-7.069-9.473A19.24%2019.24%200%200%200%2020%204.48a19.24%2019.24%200%200%200-11.2%203.6%2019.5%2019.5%200%200%200-7.069%209.473c3.567-4.248%2010.423-7.134%2018.273-7.134'%20class='jp-jupyter-icon-color'/%3e%3cpath%20fill='%23616161'%20d='M37.194%203.154a3%203%200%200%201-.426%201.672%202.96%202.96%200%200%201-1.275%201.153%202.93%202.93%200%200%201-3.238-.505%203%203%200%200%201-.776-3.21c.2-.553.558-1.033%201.029-1.38a2.93%202.93%200%200%201%203.733.209c.576.532.919%201.274.953%202.061M9.228%2046.393a3.77%203.77%200%200%201-.536%202.11%203.73%203.73%200%200%201-1.608%201.452%203.69%203.69%200%200%201-4.082-.638%203.75%203.75%200%200%201-1.097-1.875%203.8%203.8%200%200%201%20.122-2.173%203.74%203.74%200%200%201%201.299-1.739%203.696%203.696%200%200%201%204.704.268%203.76%203.76%200%200%201%201.198%202.595M2.635%209.456a2.17%202.17%200%200%201-1.227-.318%202.2%202.2%200%200%201-.845-.951A2.22%202.22%200%200%201%20.935%205.77a2.16%202.16%200%200%201%202.356-.577c.405.15.757.418%201.011.77a2.21%202.21%200%200%201-.156%202.783%202.17%202.17%200%200%201-1.511.71'%20class='jp-icon3'/%3e%3c/svg%3e";
const jupyterlabWordmarkSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='200'%20viewBox='0%200%201860.8%20475'%3e%3cpath%20fill='%234E4E4E'%20d='M53.324%20293.087c0%2048.7-3.7%2064.7-13.6%2076.4-10.8%2010-25%2015.5-39.7%2015.5l3.7%2029c22.8.3%2044.8-7.9%2061.9-23.1%2017.8-18.5%2024-44.1%2024-83.3v-184.3h-36.4v170.1zm271.42-22.179c0%2021%200%2039.5%201.7%2055.4h-31.8l-2.1-33.3h-.8c-6.7%2011.6-16.4%2021.3-28%2027.9s-24.8%2010-38.2%209.8c-31.4%200-69-17.7-69-89v-118.8h36.4v112.7c0%2038.7%2011.6%2064.7%2044.6%2064.7%2010.3-.2%2020.4-3.5%2028.9-9.4s15.1-14.3%2018.9-23.9c2.2-6.1%203.3-12.5%203.3-18.9v-125h36.4v147.8zm68.512-81.525c0-26-.8-47-1.7-66.7h32.7l1.7%2034.8h.8c7.1-12.5%2017.5-22.8%2030.1-29.7%2012.5-7%2026.7-10.3%2041-9.8%2048.3%200%2084.7%2041.7%2084.7%20103.3%200%2073.1-43.7%20109.2-91%20109.2-12.1.5-24.2-2.2-35-7.8s-19.9-13.9-26.6-24.2h-.8v110.5h-36v-220zm36%2054.2c.1%205.1.6%2010.1%201.7%2015.1%203%2012.3%209.9%2023.3%2019.8%2031.1s22.1%2012.1%2034.7%2012.1c38.5%200%2060.7-31.9%2060.7-78.5%200-40.7-21.1-75.6-59.5-75.6-12.9.4-25.3%205.1-35.3%2013.4-9.9%208.3-16.9%2019.7-19.6%2032.4-1.5%204.9-2.3%2010-2.5%2015.1zm217.572-120.485%2043.7%20120.1c4.5%2013.4%209.5%2029.4%2012.8%2041.7h.8c3.7-12.2%207.9-27.7%2012.8-42.4l39.7-119.2h38.5l-54.4%20144.8c-26%2069.7-43.7%20105.4-68.6%20127.2-12.5%2011.7-27.9%2020-44.6%2023.9l-9.1-31.1c11.7-3.9%2022.5-10.1%2031.8-18.1%2013.2-11.1%2023.7-25.2%2030.6-41.2%201.5-2.8%202.5-5.7%202.9-8.8-.3-3.3-1.2-6.6-2.5-9.7l-73.8-187.1h39.7zM890.649%2064.65v58.3h52v28.2h-52v109.5c0%2025%207%2039.5%2027.3%2039.5%207.1.1%2014.2-.7%2021.1-2.5l1.7%2027.7c-10.3%203.7-21.3%205.4-32.2%205-7.3.4-14.6-.7-21.3-3.4-6.8-2.7-12.9-6.8-17.9-12.1-10.3-10.9-14.1-29-14.1-52.9v-110.8h-31v-28.2h31v-48.7zm119.111%20166.711c.8%2050%2032.2%2070.6%2068.6%2070.6%2019%20.6%2037.9-3%2055.3-10.5l6.2%2026.4c-20.9%208.9-43.5%2013.1-66.2%2012.6-61.5%200-98.3-41.2-98.3-102.5%200-61.4%2035.5-109.6%2093.7-109.6%2065.2%200%2082.7%2058.3%2082.7%2095.7-.1%205.8-.5%2011.5-1.2%2017.2h-140.8zm106.6-26.4c.4-23.5-9.5-60.1-50.4-60.1-36.8%200-52.8%2034.4-55.7%2060.1zm88.317-18.505c0-23.9-.4-44.5-1.7-63.4h31.8l1.2%2039.9h1.7c9.1-27.3%2031-44.5%2055.3-44.5%203.5-.1%207%20.4%2010.3%201.2v34.8c-4.1-.9-8.2-1.3-12.4-1.2-25.6%200-43.7%2019.7-48.7%2047.4-1%205.7-1.6%2011.5-1.7%2017.2v108.3h-36v-139.7z'%20class='jp-icon2'/%3e%3cpath%20fill='%23F37726'%20d='M1352.3%20326.2h37V28h-37zm252.5%200c-2.5-13.9-3.4-31.1-3.4-48.7v-76c0-40.7-15.1-83.1-77.3-83.1-25.6%200-50%207.1-66.8%2018.1l8.4%2024.4c14.3-9.2%2034-15.1%2053-15.1%2041.6%200%2046.2%2030.2%2046.2%2047v4.2c-78.6-.4-122.3%2026.5-122.3%2075.6%200%2029.4%2021%2058.4%2062.2%2058.4%2029%200%2050.9-14.3%2062.2-30.2h1.3l2.9%2025.6h33.6zm-39.1-68.5c0%203.8-.8%208-2.1%2011.8-5.9%2017.2-22.7%2034-49.2%2034-18.9%200-34.9-11.3-34.9-35.3%200-39.5%2045.8-46.6%2086.2-45.8zm132.8%2068.5%201.7-33.6h1.3c15.1%2026.9%2038.7%2038.2%2068.1%2038.2%2045.4%200%2091.2-36.1%2091.2-108.8.4-61.7-35.3-103.7-85.7-103.7-32.8%200-56.3%2014.7-69.3%2037.4h-.8V28h-36.6v245.7c0%2018.1-.8%2038.6-1.7%2052.5zm6.3-118c0-5.9%201.3-10.9%202.1-15.1%207.6-28.1%2031.1-45.4%2056.3-45.4%2039.5%200%2060.5%2034.9%2060.5%2075.6%200%2046.6-23.1%2078.1-61.8%2078.1-26.9%200-48.3-17.6-55.5-43.3-.8-4.2-1.7-8.8-1.7-13.4v-36.5z'%20class='jp-jupyter-icon-color'/%3e%3c/svg%3e";
const kernelSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M15%209H9v6h6zm-2%204h-2v-2h2zm8-2V9h-2V7c0-1.1-.9-2-2-2h-2V3h-2v2h-2V3H9v2H7c-1.1%200-2%20.9-2%202v2H3v2h2v2H3v2h2v2c0%201.1.9%202%202%202h2v2h2v-2h2v2h2v-2h2c1.1%200%202-.9%202-2v-2h2v-2h-2v-2zm-4%206H7V7h10z'%20class='jp-icon2'/%3e%3c/svg%3e";
const keyboardSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M20%205H4c-1.1%200-1.99.9-1.99%202L2%2017c0%201.1.9%202%202%202h16c1.1%200%202-.9%202-2V7c0-1.1-.9-2-2-2m-9%203h2v2h-2zm0%203h2v2h-2zM8%208h2v2H8zm0%203h2v2H8zm-1%202H5v-2h2zm0-3H5V8h2zm9%207H8v-2h8zm0-4h-2v-2h2zm0-3h-2V8h2zm3%203h-2v-2h2zm0-3h-2V8h2z'%20class='jp-icon3%20jp-icon-selectable'/%3e%3c/svg%3e";
const launchSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='32'%20viewBox='0%200%2032%2032'%3e%3cg%20fill='%23616161'%20class='jp-icon3%20jp-icon-selectable'%3e%3cpath%20d='M26%2028H6a2.003%202.003%200%200%201-2-2V6a2.003%202.003%200%200%201%202-2h10v2H6v20h20V16h2v10a2.003%202.003%200%200%201-2%202'/%3e%3cpath%20d='M20%202v2h6.586L18%2012.586%2019.414%2014%2028%205.414V12h2V2z'/%3e%3c/g%3e%3c/svg%3e";
const launcherSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M19%2019H5V5h7V3H5a2%202%200%200%200-2%202v14a2%202%200%200%200%202%202h14c1.1%200%202-.9%202-2v-7h-2zM14%203v2h3.59l-9.83%209.83%201.41%201.41L19%206.41V10h2V3z'%20class='jp-icon3%20jp-icon-selectable'/%3e%3c/svg%3e";
const lineFormSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23fff'%20d='M5.88%204.12%2013.76%2012l-7.88%207.88L8%2022l10-10L8%202z'/%3e%3c/svg%3e";
const linkSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M3.9%2012c0-1.71%201.39-3.1%203.1-3.1h4V7H7c-2.76%200-5%202.24-5%205s2.24%205%205%205h4v-1.9H7c-1.71%200-3.1-1.39-3.1-3.1M8%2013h8v-2H8zm9-6h-4v1.9h4c1.71%200%203.1%201.39%203.1%203.1s-1.39%203.1-3.1%203.1h-4V17h4c2.76%200%205-2.24%205-5s-2.24-5-5-5'%20class='jp-icon3'/%3e%3c/svg%3e";
const listSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M19%205v14H5V5zm1.1-2H3.9c-.5%200-.9.4-.9.9v16.2c0%20.4.4.9.9.9h16.2c.4%200%20.9-.5.9-.9V3.9c0-.5-.5-.9-.9-.9M11%207h6v2h-6zm0%204h6v2h-6zm0%204h6v2h-6zM7%207h2v2H7zm0%204h2v2H7zm0%204h2v2H7z'%20class='jp-icon2%20jp-icon-selectable'/%3e%3c/svg%3e";
const lockSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2023'%3e%3cpath%20fill='%23333'%20d='M12%2017a2%202%200%200%200%202-2%202%202%200%200%200-2-2%202%202%200%200%200-2%202%202%202%200%200%200%202%202m6-9a2%202%200%200%201%202%202v10a2%202%200%200%201-2%202H6a2%202%200%200%201-2-2V10a2%202%200%200%201%202-2h1V6a5%205%200%200%201%205-5%205%205%200%200%201%205%205v2zm-6-5a3%203%200%200%200-3%203v2h6V6a3%203%200%200%200-3-3'%20class='jp-icon4'/%3e%3c/svg%3e";
const markdownSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2022%2022'%3e%3cpath%20fill='%237B1FA2'%20d='M5%2014.9h12l-6.1%206zm9.4-6.8c0-1.3-.1-2.9-.1-4.5-.4%201.4-.9%202.9-1.3%204.3l-1.3%204.3h-2L8.5%207.9c-.4-1.3-.7-2.9-1-4.3-.1%201.6-.1%203.2-.2%204.6L7%2012.4H4.8l.7-11h3.3L10%205c.4%201.2.7%202.7%201%203.9.3-1.2.7-2.6%201-3.9l1.2-3.7h3.3l.6%2011h-2.4z'%20class='jp-icon-contrast0%20jp-icon-selectable'/%3e%3c/svg%3e";
const mermaidSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20version='1.1'%20viewBox='0%200%20491%20675'%3e%3cpath%20fill='%23ff3670'%20d='M85%2092c-46%200-85%2037-85%2085v321c0%2046%2037%2085%2085%2085h321c46%200%2085-37%2085-85V177c0-46-37-85-85-85zm-2%20111c72-3.1%20139%2041%20162%20109%2025-67%2091-112%20162-109%202.4%2057-25%20111-72%20144-24%2016-39%2044-39%2074v51H192v-51c.08-29-15-57-39-74-47-32-75-86-72-144z'%20class='jp-icon-contrast2%20jp-icon-selectable'/%3e%3c/svg%3e";
const moveDownSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='14'%20height='14'%20fill='none'%20viewBox='0%200%2014%2014'%3e%3cpath%20fill='%23616161'%20d='M12.471%207.529a.748.748%200%200%200-1.057-1.058L7.75%2010.127V1.75a.75.75%200%200%200-1.5%200v8.378l-3.653-3.66a.753.753%200%201%200-1.065%201.064l4.76%204.76a1%201%200%200%200%201.415%200z'%20class='jp-icon3'/%3e%3c/svg%3e";
const moveUpSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='14'%20height='14'%20fill='none'%20viewBox='0%200%2014%2014'%3e%3cpath%20fill='%23616161'%20d='M1.529%206.471a.748.748%200%200%200%201.057%201.058L6.25%203.873v8.377a.75.75%200%200%200%201.5%200V3.873l3.653%203.659a.753.753%200%201%200%201.065-1.064l-4.76-4.76a1%201%200%200%200-1.415%200z'%20class='jp-icon3'/%3e%3c/svg%3e";
const newFolderSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M20%206h-8l-2-2H4c-1.11%200-1.99.89-1.99%202L2%2018c0%201.11.89%202%202%202h16c1.11%200%202-.89%202-2V8c0-1.11-.89-2-2-2m-1%208h-3v3h-2v-3h-3v-2h3V9h2v3h3z'%20class='jp-icon3'/%3e%3c/svg%3e";
const notTrustedSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20fill='none'%20viewBox='0%200%2025%2025'%3e%3cpath%20stroke='%23333'%20stroke-width='2'%20d='M4.86%2014.44c-1.034-2.67-.996-5.382-.61-7.24%201.232-.267%202.83-.797%204.351-1.355a92%2092%200%200%200%204.387-1.75%2068%2068%200%200%200%204.23%201.748c1.532.57%203.182%201.11%204.536%201.37.382%201.859.417%204.564-.615%207.228-1.109%202.862-3.472%205.743-8.139%207.494-4.667-1.75-7.03-4.632-8.14-7.494Zm11.824-5.12-7.368%207.365m7.368-.001L9.316%209.319'%20class='jp-icon2'/%3e%3c/svg%3e";
const notebookSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2022%2022'%3e%3cg%20fill='%23EF6C00'%20class='jp-notebook-icon-color%20jp-icon-selectable'%3e%3cpath%20d='M18.7%203.3v15.4H3.3V3.3zm1.5-1.5H1.8v18.3h18.3z'/%3e%3cpath%20d='m16.5%2016.5-5.4-4.3-5.6%204.3v-11h11z'/%3e%3c/g%3e%3c/svg%3e";
const numberingSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='22'%20height='22'%20viewBox='0%200%2028%2028'%3e%3cpath%20fill='%23616161'%20d='M4%2019h2v.5H5v1h1v.5H4v1h3v-4H4zm1-9h1V6H4v1h1zm-1%203h1.8L4%2015.1v.9h3v-1H5.2L7%2012.9V12H4zm5-6v2h14V7zm0%2014h14v-2H9zm0-6h14v-2H9z'%20class='jp-icon3'/%3e%3c/svg%3e";
const offlineBoltSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M12%202.02c-5.51%200-9.98%204.47-9.98%209.98s4.47%209.98%209.98%209.98%209.98-4.47%209.98-9.98S17.51%202.02%2012%202.02M11.48%2020v-6.26H8L13%204v6.26h3.35z'%20class='jp-icon3'/%3e%3c/svg%3e";
const paletteSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cg%20fill='%23616161'%20class='jp-icon3'%3e%3cpath%20d='M18%2013v7H4V6h5.02c.05-.71.22-1.38.48-2H4c-1.1%200-2%20.9-2%202v14c0%201.1.9%202%202%202h14c1.1%200%202-.9%202-2v-5zm1.3-4.11c.44-.7.7-1.51.7-2.39C20%204.01%2017.99%202%2015.5%202S11%204.01%2011%206.5s2.01%204.5%204.49%204.5c.88%200%201.7-.26%202.39-.7L21%2013.42%2022.42%2012zM15.5%209a2.5%202.5%200%200%201%200-5%202.5%202.5%200%200%201%200%205'/%3e%3cpath%20fill-rule='evenodd'%20d='M4%206h5.019a6.5%206.5%200%200%200%203.015%206H9v2h7v-1.019c.57-.043%201.12-.16%201.64-.341L18%2013v7H4zm4%202H6v2h2zm-2%204h2v2H6zm2%204H6v2h2zm1%200h7v2H9z'%20clip-rule='evenodd'/%3e%3c/g%3e%3c/svg%3e";
const pasteSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M19%202h-4.18C14.4.84%2013.3%200%2012%200S9.6.84%209.18%202H5c-1.1%200-2%20.9-2%202v16c0%201.1.9%202%202%202h14c1.1%200%202-.9%202-2V4c0-1.1-.9-2-2-2m-7%200c.55%200%201%20.45%201%201s-.45%201-1%201-1-.45-1-1%20.45-1%201-1m7%2018H5V4h2v3h10V4h2z'%20class='jp-icon3'/%3e%3c/svg%3e";
const pdfSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2022%2022'%3e%3cpath%20fill='%23FF2A2A'%20d='m17.933%2013.667%203.987%203.987-1.117%201.117-2.51-2.51-1.066%201.067%202.36%202.36-1.117%201.117-2.36-2.36-2.43%202.429-1.477-1.478zm-6.163-3.93-3.496%203.496.53.53q.905.906%201.83.932.929.031%201.784-.825.852-.852.822-1.773t-.94-1.83zm-.36-2.594%201.557%201.558q1.305%201.305%201.754%202.13.456.825.468%201.727.015.79-.296%201.493-.31.702-.951%201.343-.649.648-1.355.963-.702.31-1.493.295-.905-.015-1.738-.472-.829-.46-2.118-1.75L5.68%2012.874zm-5.76-5.76L8.1%203.835Q9.195%204.93%209.291%206q.103%201.07-.795%201.968-.901.902-1.976.802-1.067-.1-2.16-1.193l-.975-.975L1.397%208.59-.08%207.113Zm.406%202.548-1.6%201.6.817.818q.43.43.871.457.445.023.829-.361t.357-.825-.457-.871z'%20class='jp-icon-selectable'/%3e%3c/svg%3e";
const pythonSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='-10%20-10%20131.161%20132.389'%3e%3cpath%20fill='%23306998'%20d='M54.919%200c-4.584.022-8.961.413-12.813%201.095C30.76%203.099%2028.7%207.295%2028.7%2015.032v10.219h26.813v3.406H18.638c-7.793%200-14.616%204.684-16.75%2013.594-2.462%2010.213-2.571%2016.586%200%2027.25%201.905%207.938%206.457%2013.594%2014.25%2013.594h9.218v-12.25c0-8.85%207.657-16.657%2016.75-16.657h26.782c7.454%200%2013.406-6.138%2013.406-13.625v-25.53c0-7.267-6.13-12.726-13.406-13.938C64.282.328%2059.502-.02%2054.918%200m-14.5%208.22c2.77%200%205.031%202.298%205.031%205.125%200%202.816-2.262%205.093-5.031%205.093-2.78%200-5.031-2.277-5.031-5.093%200-2.827%202.251-5.125%205.03-5.125'%20class='jp-icon-selectable'/%3e%3cpath%20fill='%23ffd43b'%20d='M85.638%2028.657v11.906c0%209.231-7.826%2017-16.75%2017H42.106c-7.336%200-13.406%206.279-13.406%2013.625V96.72c0%207.266%206.319%2011.54%2013.406%2013.625%208.488%202.495%2016.627%202.946%2026.782%200%206.75-1.955%2013.406-5.888%2013.406-13.625V86.5H55.513v-3.405H95.7c7.793%200%2010.696-5.436%2013.406-13.594%202.8-8.399%202.68-16.476%200-27.25-1.925-7.758-5.604-13.594-13.406-13.594zM70.575%2093.313c2.78%200%205.031%202.278%205.031%205.094%200%202.827-2.251%205.125-5.031%205.125-2.77%200-5.031-2.298-5.031-5.125%200-2.816%202.261-5.094%205.031-5.094'%20class='jp-icon-selectable'/%3e%3c/svg%3e";
const rKernelSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2022%2022'%3e%3cpath%20fill='%232196F3'%20d='M4.4%202.5c1.2-.1%202.9-.3%204.9-.3%202.5%200%204.1.4%205.2%201.3%201%20.7%201.5%201.9%201.5%203.5%200%202-1.4%203.5-2.9%204.1%201.2.4%201.7%201.6%202.2%203%20.6%201.9%201%203.9%201.3%204.6h-3.8c-.3-.4-.8-1.7-1.2-3.7s-1.2-2.6-2.6-2.6h-.9v6.4H4.4zm3.7%206.9h1.4c1.9%200%202.9-.9%202.9-2.3s-1-2.3-2.8-2.3c-.7%200-1.3%200-1.6.2v4.5h.1z'%20class='jp-icon-contrast3%20jp-icon-selectable'/%3e%3c/svg%3e";
const reactSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='150%20150%20541.9%20295.3'%3e%3cg%20fill='%2361DAFB'%20class='jp-icon-brand2%20jp-icon-selectable'%3e%3cpath%20d='M666.3%20296.5c0-32.5-40.7-63.3-103.1-82.4%2014.4-63.6%208-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6%200%208.3.9%2011.4%202.6%2013.6%207.8%2019.5%2037.5%2014.9%2075.7-1.1%209.4-2.9%2019.3-5.1%2029.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50%2032.6-30.3%2063.2-46.9%2084-46.9V78c-27.5%200-63.5%2019.6-99.9%2053.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7%200%2051.4%2016.5%2084%2046.6-14%2014.7-28%2031.4-41.3%2049.9-22.6%202.4-44%206.1-63.6%2011-2.3-10-4-19.7-5.2-29-4.7-38.2%201.1-67.9%2014.6-75.8%203-1.8%206.9-2.6%2011.5-2.6V78.5c-8.4%200-16%201.8-22.6%205.6-28.1%2016.2-34.4%2066.7-19.9%20130.1-62.2%2019.2-102.7%2049.9-102.7%2082.3%200%2032.5%2040.7%2063.3%20103.1%2082.4-14.4%2063.6-8%20114.2%2020.2%20130.4%206.5%203.8%2014.1%205.6%2022.5%205.6%2027.5%200%2063.5-19.6%2099.9-53.6%2036.4%2033.8%2072.4%2053.2%2099.9%2053.2%208.4%200%2016-1.8%2022.6-5.6%2028.1-16.2%2034.4-66.7%2019.9-130.1%2062-19.1%20102.5-49.9%20102.5-82.3m-130.2-66.7c-3.7%2012.9-8.3%2026.2-13.5%2039.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4%2014.2%202.1%2027.9%204.7%2041%207.9m-45.8%20106.5c-7.8%2013.5-15.8%2026.3-24.1%2038.2-14.9%201.3-30%202-45.2%202-15.1%200-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8%206.2-13.4%2013.2-26.8%2020.7-39.9%207.8-13.5%2015.8-26.3%2024.1-38.2%2014.9-1.3%2030-2%2045.2-2%2015.1%200%2030.2.7%2045%201.9%208.3%2011.9%2016.4%2024.6%2024.2%2038%207.6%2013.1%2014.5%2026.4%2020.8%2039.8-6.3%2013.4-13.2%2026.8-20.7%2039.9m32.3-13c5.4%2013.4%2010%2026.8%2013.8%2039.8-13.1%203.2-26.9%205.9-41.2%208%204.9-7.7%209.8-15.6%2014.4-23.7%204.6-8%208.9-16.1%2013-24.1M421.2%20430c-9.3-9.6-18.6-20.3-27.8-32%209%20.4%2018.2.7%2027.5.7%209.4%200%2018.7-.2%2027.8-.7-9%2011.7-18.3%2022.4-27.5%2032m-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9%203.7-12.9%208.3-26.2%2013.5-39.5%204.1%208%208.4%2016%2013.1%2024q7.05%2012%2014.4%2023.4M420.7%20163c9.3%209.6%2018.6%2020.3%2027.8%2032-9-.4-18.2-.7-27.5-.7-9.4%200-18.7.2-27.8.7%209-11.7%2018.3-22.4%2027.5-32m-74%2058.9c-4.9%207.7-9.8%2015.6-14.4%2023.7-4.6%208-8.9%2016-13%2024-5.4-13.4-10-26.8-13.8-39.8%2013.1-3.1%2026.9-5.8%2041.2-7.9m-90.5%20125.2c-35.4-15.1-58.3-34.9-58.3-50.6s22.9-35.6%2058.3-50.6c8.6-3.7%2018-7%2027.7-10.1%205.7%2019.6%2013.2%2040%2022.5%2060.9-9.2%2020.8-16.6%2041.1-22.2%2060.6-9.9-3.1-19.3-6.5-28-10.2M310%20490c-13.6-7.8-19.5-37.5-14.9-75.7%201.1-9.4%202.9-19.3%205.1-29.4%2019.6%204.8%2041%208.5%2063.5%2010.9%2013.5%2018.5%2027.5%2035.3%2041.6%2050-32.6%2030.3-63.2%2046.9-84%2046.9-4.5-.1-8.3-1-11.3-2.7m237.2-76.2c4.7%2038.2-1.1%2067.9-14.6%2075.8-3%201.8-6.9%202.6-11.5%202.6-20.7%200-51.4-16.5-84-46.6%2014-14.7%2028-31.4%2041.3-49.9%2022.6-2.4%2044-6.1%2063.6-11%202.3%2010.1%204.1%2019.8%205.2%2029.1m38.5-66.7c-8.6%203.7-18%207-27.7%2010.1-5.7-19.6-13.2-40-22.5-60.9%209.2-20.8%2016.6-41.1%2022.2-60.6%209.9%203.1%2019.3%206.5%2028.1%2010.2%2035.4%2015.1%2058.3%2034.9%2058.3%2050.6-.1%2015.7-23%2035.6-58.4%2050.6M320.8%2078.4'/%3e%3ccircle%20cx='420.9'%20cy='296.5'%20r='45.7'/%3e%3c/g%3e%3c/svg%3e";
const redoSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M18.4%2010.6C16.55%208.99%2014.15%208%2011.5%208c-4.65%200-8.58%203.03-9.96%207.22L3.9%2016a8%208%200%200%201%207.6-5.5c1.95%200%203.73.72%205.12%201.88L13%2016h9V7z'%20class='jp-icon3'/%3e%3c/svg%3e";
const regexSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2020%2020'%3e%3cpath%20fill='%23414141'%20d='M2%202h16v16H2z'%20class='jp-icon2'/%3e%3cg%20fill='%23FFF'%20class='jp-icon-accent2'%3e%3ccircle%20cx='5.5'%20cy='14.5'%20r='1.5'/%3e%3cpath%20d='M12%204h1v8h-1z'/%3e%3cpath%20d='m8.786%209.567%206.928-4%20.5.866-6.928%204z'/%3e%3cpath%20d='m8.786%206.433.5-.866%206.928%204-.5.866z'/%3e%3c/g%3e%3c/svg%3e";
const runSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M8%205v14l11-7z'%20class='jp-icon3'/%3e%3c/svg%3e";
const runningSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%20512%20512'%3e%3cpath%20fill='%23616161'%20d='M256%208C119%208%208%20119%208%20256s111%20248%20248%20248%20248-111%20248-248S393%208%20256%208m96%20328c0%208.8-7.2%2016-16%2016H176c-8.8%200-16-7.2-16-16V176c0-8.8%207.2-16%2016-16h160c8.8%200%2016%207.2%2016%2016z'%20class='jp-icon3'/%3e%3c/svg%3e";
const saveSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M17%203H5a2%202%200%200%200-2%202v14a2%202%200%200%200%202%202h14c1.1%200%202-.9%202-2V7zm-5%2016c-1.66%200-3-1.34-3-3s1.34-3%203-3%203%201.34%203%203-1.34%203-3%203m3-10H5V5h10z'%20class='jp-icon3'/%3e%3c/svg%3e";
const searchSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2018%2018'%3e%3cpath%20fill='%23616161'%20d='M12.1%2010.9h-.7l-.2-.2c.8-.9%201.3-2.2%201.3-3.5%200-3-2.4-5.4-5.4-5.4S1.8%204.2%201.8%207.1s2.4%205.4%205.4%205.4c1.3%200%202.5-.5%203.5-1.3l.2.2v.7l4.1%204.1%201.2-1.2zm-5%200c-2.1%200-3.7-1.7-3.7-3.7s1.7-3.7%203.7-3.7%203.7%201.7%203.7%203.7-1.6%203.7-3.7%203.7'%20class='jp-icon3'/%3e%3c/svg%3e";
const settingsSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M19.43%2012.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49%201c-.52-.4-1.08-.73-1.69-.98l-.38-2.65A.49.49%200%200%200%2014%202h-4c-.25%200-.46.18-.49.42l-.38%202.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49%200-.61.22l-2%203.46c-.13.22-.07.49.12.64l2.11%201.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11%201.65c-.19.15-.24.42-.12.64l2%203.46c.12.22.39.3.61.22l2.49-1c.52.4%201.08.73%201.69.98l.38%202.65c.03.24.24.42.49.42h4c.25%200%20.46-.18.49-.42l.38-2.65c.61-.25%201.17-.59%201.69-.98l2.49%201c.23.09.49%200%20.61-.22l2-3.46c.12-.22.07-.49-.12-.64zM12%2015.5c-1.93%200-3.5-1.57-3.5-3.5s1.57-3.5%203.5-3.5%203.5%201.57%203.5%203.5-1.57%203.5-3.5%203.5'%20class='jp-icon3%20jp-icon-selectable'/%3e%3c/svg%3e";
const shareSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M18%202c-1.645%200-3%201.355-3%203%200%20.191.022.377.057.559L7.922%209.72A2.97%202.97%200%200%200%206%209c-1.645%200-3%201.355-3%203s1.355%203%203%203c.732%200%201.399-.278%201.922-.72l7.135%204.16A3%203%200%200%200%2015%2019c0%201.645%201.355%203%203%203s3-1.355%203-3-1.355-3-3-3a2.97%202.97%200%200%200-1.922.723l-7.135-4.164C8.978%2012.377%209%2012.19%209%2012s-.022-.377-.057-.559l7.135-4.162C16.601%207.722%2017.268%208%2018%208c1.645%200%203-1.355%203-3s-1.355-3-3-3m0%202c.564%200%201%20.436%201%201s-.436%201-1%201-1-.436-1-1%20.436-1%201-1M6%2011c.564%200%201%20.436%201%201s-.436%201-1%201-1-.436-1-1%20.436-1%201-1m12%207c.564%200%201%20.436%201%201s-.436%201-1%201-1-.436-1-1%20.436-1%201-1'%20class='jp-icon3'/%3e%3c/svg%3e";
const spreadsheetSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2022%2022'%3e%3cpath%20fill='%234CAF50'%20d='M2.2%202.2v17.6h17.6V2.2zm15.4%207.7h-5.5V4.4h5.5zM9.9%204.4v5.5H4.4V4.4zm-5.5%207.7h5.5v5.5H4.4zm7.7%205.5v-5.5h5.5v5.5z'%20class='jp-icon-contrast1%20jp-icon-selectable'/%3e%3c/svg%3e";
const stopSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M6%206h12v12H6z'%20class='jp-icon3'/%3e%3c/svg%3e";
const tabSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M21%203H3c-1.1%200-2%20.9-2%202v14c0%201.1.9%202%202%202h18c1.1%200%202-.9%202-2V5c0-1.1-.9-2-2-2m0%2016H3V5h10v4h8z'%20class='jp-icon3'/%3e%3c/svg%3e";
const tableRowsSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M21%208H3V4h18zm0%202H3v4h18zm0%206H3v4h18z'%20class='jp-icon3'/%3e%3c/svg%3e";
const tagSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='28'%20height='28'%20viewBox='0%200%2043%2028'%3e%3cpath%20fill='%23616161'%20d='M28.833%2012.334%2033%2016.501l4.166-4.167zM16.21%2021.61c-.523.52-1.366.52-1.885%200l-7.342-6.885c-.41-.386-.9-1.115-.935-1.677-.095-1.52-.028-4.429.018-5.971A1.093%201.093%200%200%201%207.118%206.03c1.97-.046%206.146-.095%206.534.293l8.085%207.315c.519.52.048%201.833-.475%202.356zM9.775%208.265a1.126%201.126%200%201%200-1.593%201.592%201.126%201.126%200%200%200%201.593-1.592'%20class='jp-icon3'/%3e%3c/svg%3e";
const terminalSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23333'%20d='M2%202h20v20H2z'%20class='jp-terminal-icon-background-color%20jp-icon-selectable'/%3e%3cpath%20fill='%23fff'%20d='M9.01%2014.762q0-.246-.077-.434a.9.9%200%200%200-.234-.351%201.6%201.6%200%200%200-.422-.288%205%205%200%200%200-.627-.263q-.592-.211-1.078-.446a3.5%203.5%200%200%201-.832-.544%202.2%202.2%200%200%201-.528-.721%202.4%202.4%200%200%201-.187-.985q0-.498.17-.908a2.1%202.1%200%200%201%20.48-.72q.31-.306.75-.493.44-.188.979-.24V7.11h.937v1.272q.527.07.95.287.421.217.714.568.3.345.457.82.165.47.164%201.055H8.998q0-.709-.323-1.072-.322-.37-.873-.37-.299%200-.521.083a.9.9%200%200%200-.358.223.9.9%200%200%200-.21.334q-.066.194-.065.421%200%20.23.064.41a.9.9%200%200%200%20.229.329q.165.152.428.293.263.134.656.275.591.223%201.072.463.48.235.82.55.346.312.528.727.187.41.187.973%200%20.515-.17.932-.17.41-.486.709t-.762.48a3.7%203.7%200%200%201-.996.229v1.148h-.931V17.1a4%204%200%200%201-.967-.217%202.6%202.6%200%200%201-.832-.504%202.4%202.4%200%200%201-.574-.826q-.217-.505-.217-1.207h1.635q0%20.421.123.709.123.281.316.45.2.165.451.235.252.07.516.07.627%200%20.949-.292a.98.98%200%200%200%20.322-.756m8.36%203.51h-5.343V17h5.344z'%20class='jp-terminal-icon-color%20jp-icon-selectable-inverse'/%3e%3c/svg%3e";
const textEditorSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M15%2015H3v2h12zm0-8H3v2h12zM3%2013h18v-2H3zm0%208h18v-2H3zM3%203v2h18V3z'%20class='jp-text-editor-icon-color%20jp-icon-selectable'/%3e%3c/svg%3e";
const tocSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M7%205h14v2H7zm0%208v-2h14v2zM4%204.5A1.5%201.5%200%200%201%205.5%206%201.5%201.5%200%200%201%204%207.5%201.5%201.5%200%200%201%202.5%206%201.5%201.5%200%200%201%204%204.5m0%206A1.5%201.5%200%200%201%205.5%2012%201.5%201.5%200%200%201%204%2013.5%201.5%201.5%200%200%201%202.5%2012%201.5%201.5%200%200%201%204%2010.5M7%2019v-2h14v2zm-3-2.5A1.5%201.5%200%200%201%205.5%2018%201.5%201.5%200%200%201%204%2019.5%201.5%201.5%200%200%201%202.5%2018%201.5%201.5%200%200%201%204%2016.5'%20class='jp-icon3%20jp-icon-selectable'/%3e%3c/svg%3e";
const treeViewSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M22%2011V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3z'%20class='jp-icon3'/%3e%3c/svg%3e";
const trustedSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20fill='none'%20viewBox='0%200%2024%2025'%3e%3cpath%20stroke='%23333'%20stroke-width='2'%20d='M3.86%2014.44c-1.034-2.67-.996-5.382-.61-7.24%201.232-.267%202.83-.797%204.351-1.355a92%2092%200%200%200%204.387-1.75%2068%2068%200%200%200%204.23%201.748c1.532.57%203.182%201.11%204.536%201.37.382%201.859.417%204.564-.615%207.228-1.109%202.862-3.472%205.743-8.139%207.494-4.667-1.75-7.03-4.632-8.14-7.494Z'%20class='jp-icon2'/%3e%3cpath%20fill='%23333'%20stroke='%23333'%20d='m10.86%2014.733-2.133-1.866-.727.63L10.86%2016%2016%2010.5l-.721-.632z'%20class='jp-icon2'/%3e%3c/svg%3e";
const undoSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M12.5%208c-2.65%200-5.05.99-6.9%202.6L2%207v9h9l-3.62-3.62c1.39-1.16%203.16-1.88%205.12-1.88%203.54%200%206.55%202.31%207.6%205.5l2.37-.78C21.08%2011.03%2017.15%208%2012.5%208'%20class='jp-icon3'/%3e%3c/svg%3e";
const userSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2024%2024'%3e%3cpath%20fill='%23616161'%20d='M16%207a4%204%200%201%201-8%200%204%204%200%200%201%208%200m-4%207a7%207%200%200%200-7%207h14a7%207%200%200%200-7-7'%20class='jp-icon3'/%3e%3c/svg%3e";
const usersSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20version='1.1'%20viewBox='0%200%2036%2024'%3e%3cg%20fill='%23616161'%20class='jp-icon3'%20transform='translate(-3.628%20.1)scale(1.7327)'%3e%3cpath%20d='M18.279%205.265c-1.58%200-2.964.85-3.718%202.115a6.7%206.7%200%200%201%202.81%202.21h5.23a4.32%204.32%200%200%200-4.322-4.325m2.186-2.875a2.19%202.19%200%200%201-2.188%202.188%202.19%202.19%200%200%201-2.189-2.189A2.19%202.19%200%200%201%2018.277.201a2.19%202.19%200%200%201%202.188%202.188M5.385%206.633a3.02%203.02%200%200%200-3.02%203.02h4.22a6.7%206.7%200%200%201%201.44-1.467%203.02%203.02%200%200%200-2.64-1.553m1.53-2.01a1.53%201.53%200%200%201-1.529%201.53%201.53%201.53%200%200%201-1.53-1.53%201.53%201.53%200%200%201%201.53-1.53%201.53%201.53%200%200%201%201.53%201.53m-.781%208.912a5.865%205.865%200%200%201%2011.73%200z'/%3e%3ccircle%20cx='12'%20cy='3.768'%20r='2.969'/%3e%3c/g%3e%3c/svg%3e";
const vegaSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2022%2022'%3e%3cg%20fill='%23212121'%20class='jp-icon1%20jp-icon-selectable'%3e%3cpath%20d='m10.6%205.4%202.2-3.2H2.2v7.3l4-6.6z'/%3e%3cpath%20d='m15.8%202.2-4.4%206.6L7%206.3l-4.8%208v5.5h17.6V2.2zm-7%2015.4H5.5v-4.4h3.3zm4.4%200H9.8V9.8h3.4zm4.4%200h-3.4V6.5h3.4z'/%3e%3c/g%3e%3c/svg%3e";
const wordSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2020%2020'%3e%3cpath%20fill='%23414141'%20d='M2%202h16v16H2z'%20class='jp-icon2'/%3e%3cpath%20fill='%23fff'%20d='M4.57%208.8q.068-1.89%202.42-1.89%201.16%200%201.68.42.567.41.567%201.16v3.47q0%20.462.514.462.103%200%20.2-.023v.714q-.399.103-.651.103-.452%200-.693-.22-.231-.2-.284-.662-.956.872-2%20.872-.903%200-1.47-.472-.525-.472-.525-1.26%200-.262.045-.472.057-.22.116-.378.068-.168.231-.304l.262-.242q.116-.091.368-.168.262-.091.4-.126.135-.045.471-.103t.504-.08l.567-.08q.556-.068.777-.22.22-.153.22-.442v-.252q0-.43-.357-.662-.336-.23-.976-.23-.662%200-.998.261-.336.252-.399.798zm1.89%203.68q.788%200%201.26-.41.504-.42.504-.903v-1.05q-.284.136-.861.231l-.987.158q-.42.068-.766.326-.336.252-.336.704t.304.704.861.252zm3.97-7.88h.945v3.15q.651-.976%201.89-.976%201.16%200%201.89.84.682.84.682%202.31t-.704%202.42q-.704.882-1.89.882-1.26%200-1.89-1.02v.766h-.85zm2.62%203.04q-.746%200-1.16.64-.452.63-.452%201.68t.452%201.68%201.16.63q.777%200%201.26-.63.494-.64.494-1.68%200-1.05-.472-1.68-.462-.64-1.26-.64zm-9.89%208.2%2013.6.008c.007%200%200-2.6%200-2.6%200-.008-1.15%200-1.15%200-.007%200-.008%201.5-.008%201.5l-11.3-.001-.006-1.5c0-.008-1.17.001-1.17.001z'%20class='jp-icon-accent2'/%3e%3c/svg%3e";
const yamlSvgstr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='16'%20viewBox='0%200%2022%2022'%3e%3cg%20fill='%23D81B60'%20class='jp-icon-contrast2%20jp-icon-selectable'%3e%3cpath%20d='M7.2%2018.6v-5.4L3%205.6h3.3l1.4%203.1c.3.9.6%201.6%201%202.5.3-.8.6-1.6%201-2.5l1.4-3.1h3.4l-4.4%207.6v5.5z'/%3e%3ccircle%20cx='17.6'%20cy='16.5'%20r='2.1'/%3e%3ccircle%20cx='17.6'%20cy='11'%20r='2.1'/%3e%3c/g%3e%3c/svg%3e";
new LabIcon({ name: "ui-components:add-above", svgstr: addAboveSvgstr });
new LabIcon({ name: "ui-components:add-below", svgstr: addBelowSvgstr });
const addIcon = new LabIcon({ name: "ui-components:add", svgstr: addSvgstr });
new LabIcon({ name: "ui-components:bell", svgstr: bellSvgstr });
new LabIcon({ name: "ui-components:bug-dot", svgstr: bugDotSvgstr });
new LabIcon({ name: "ui-components:bug", svgstr: bugSvgstr });
new LabIcon({ name: "ui-components:build", svgstr: buildSvgstr });
const caretDownEmptyIcon = new LabIcon({ name: "ui-components:caret-down-empty", svgstr: caretDownEmptySvgstr });
new LabIcon({ name: "ui-components:caret-down-empty-thin", svgstr: caretDownEmptyThinSvgstr });
new LabIcon({ name: "ui-components:caret-down", svgstr: caretDownSvgstr });
new LabIcon({ name: "ui-components:caret-left", svgstr: caretLeftSvgstr });
new LabIcon({ name: "ui-components:caret-right", svgstr: caretRightSvgstr });
new LabIcon({ name: "ui-components:caret-up-empty-thin", svgstr: caretUpEmptyThinSvgstr });
new LabIcon({ name: "ui-components:caret-up", svgstr: caretUpSvgstr });
new LabIcon({ name: "ui-components:case-sensitive", svgstr: caseSensitiveSvgstr });
new LabIcon({ name: "ui-components:check", svgstr: checkSvgstr });
new LabIcon({ name: "ui-components:circle-empty", svgstr: circleEmptySvgstr });
new LabIcon({ name: "ui-components:circle", svgstr: circleSvgstr });
new LabIcon({ name: "ui-components:cleaning", svgstr: cleaningSvgstr });
new LabIcon({ name: "ui-components:clear", svgstr: clearSvgstr });
const closeIcon = new LabIcon({ name: "ui-components:close", svgstr: closeSvgstr });
new LabIcon({ name: "ui-components:code-check", svgstr: codeCheckSvgstr });
new LabIcon({ name: "ui-components:code", svgstr: codeSvgstr });
new LabIcon({ name: "ui-components:collapse-all", svgstr: collapseAllSvgstr });
const collapseIcon = new LabIcon({ name: "ui-components:collapse", svgstr: collapseSvgstr });
new LabIcon({ name: "ui-components:console", svgstr: consoleSvgstr });
new LabIcon({ name: "ui-components:copy", svgstr: copySvgstr });
new LabIcon({ name: "ui-components:copyright", svgstr: copyrightSvgstr });
new LabIcon({ name: "ui-components:cut", svgstr: cutSvgstr });
new LabIcon({ name: "ui-components:delete", svgstr: deleteSvgstr });
new LabIcon({ name: "ui-components:download", svgstr: downloadSvgstr });
new LabIcon({ name: "ui-components:duplicate", svgstr: duplicateSvgstr });
new LabIcon({ name: "ui-components:edit", svgstr: editSvgstr });
const ellipsesIcon = new LabIcon({ name: "ui-components:ellipses", svgstr: ellipsesSvgstr });
new LabIcon({ name: "ui-components:error", svgstr: errorSvgstr });
new LabIcon({ name: "ui-components:expand-all", svgstr: expandAllSvgstr });
const expandIcon = new LabIcon({ name: "ui-components:expand", svgstr: expandSvgstr });
new LabIcon({ name: "ui-components:extension", svgstr: extensionSvgstr });
new LabIcon({ name: "ui-components:fast-forward", svgstr: fastForwardSvgstr });
new LabIcon({ name: "ui-components:file", svgstr: fileSvgstr });
new LabIcon({ name: "ui-components:file-upload", svgstr: fileUploadSvgstr });
new LabIcon({ name: "ui-components:filter-dot", svgstr: filterDotSvgstr });
new LabIcon({ name: "ui-components:filter", svgstr: filterSvgstr });
new LabIcon({ name: "ui-components:filter-list", svgstr: filterListSvgstr });
new LabIcon({ name: "ui-components:folder-favorite", svgstr: folderFavoriteSvgstr });
new LabIcon({ name: "ui-components:folder", svgstr: folderSvgstr });
new LabIcon({ name: "ui-components:history", svgstr: historySvgstr });
new LabIcon({ name: "ui-components:home", svgstr: homeSvgstr });
new LabIcon({ name: "ui-components:html5", svgstr: html5Svgstr });
new LabIcon({ name: "ui-components:image", svgstr: imageSvgstr });
new LabIcon({ name: "ui-components:info", svgstr: infoSvgstr });
new LabIcon({ name: "ui-components:inspector", svgstr: inspectorSvgstr });
new LabIcon({ name: "ui-components:json", svgstr: jsonSvgstr });
new LabIcon({ name: "ui-components:julia", svgstr: juliaSvgstr });
new LabIcon({ name: "ui-components:jupyter-favicon", svgstr: jupyterFaviconSvgstr });
new LabIcon({ name: "ui-components:jupyter", svgstr: jupyterSvgstr });
new LabIcon({ name: "ui-components:jupyterlab-wordmark", svgstr: jupyterlabWordmarkSvgstr });
new LabIcon({ name: "ui-components:kernel", svgstr: kernelSvgstr });
new LabIcon({ name: "ui-components:keyboard", svgstr: keyboardSvgstr });
new LabIcon({ name: "ui-components:launch", svgstr: launchSvgstr });
new LabIcon({ name: "ui-components:launcher", svgstr: launcherSvgstr });
new LabIcon({ name: "ui-components:line-form", svgstr: lineFormSvgstr });
new LabIcon({ name: "ui-components:link", svgstr: linkSvgstr });
new LabIcon({ name: "ui-components:list", svgstr: listSvgstr });
new LabIcon({ name: "ui-components:lock", svgstr: lockSvgstr });
new LabIcon({ name: "ui-components:markdown", svgstr: markdownSvgstr });
new LabIcon({ name: "ui-components:mermaid", svgstr: mermaidSvgstr });
new LabIcon({ name: "ui-components:move-down", svgstr: moveDownSvgstr });
new LabIcon({ name: "ui-components:move-up", svgstr: moveUpSvgstr });
new LabIcon({ name: "ui-components:new-folder", svgstr: newFolderSvgstr });
new LabIcon({ name: "ui-components:not-trusted", svgstr: notTrustedSvgstr });
new LabIcon({ name: "ui-components:notebook", svgstr: notebookSvgstr });
new LabIcon({ name: "ui-components:numbering", svgstr: numberingSvgstr });
new LabIcon({ name: "ui-components:offline-bolt", svgstr: offlineBoltSvgstr });
new LabIcon({ name: "ui-components:palette", svgstr: paletteSvgstr });
new LabIcon({ name: "ui-components:paste", svgstr: pasteSvgstr });
new LabIcon({ name: "ui-components:pdf", svgstr: pdfSvgstr });
new LabIcon({ name: "ui-components:python", svgstr: pythonSvgstr });
new LabIcon({ name: "ui-components:r-kernel", svgstr: rKernelSvgstr });
new LabIcon({ name: "ui-components:react", svgstr: reactSvgstr });
new LabIcon({ name: "ui-components:redo", svgstr: redoSvgstr });
new LabIcon({ name: "ui-components:refresh", svgstr: refreshSvgstr });
new LabIcon({ name: "ui-components:regex", svgstr: regexSvgstr });
new LabIcon({ name: "ui-components:run", svgstr: runSvgstr });
new LabIcon({ name: "ui-components:running", svgstr: runningSvgstr });
new LabIcon({ name: "ui-components:save", svgstr: saveSvgstr });
new LabIcon({ name: "ui-components:search", svgstr: searchSvgstr });
new LabIcon({ name: "ui-components:settings", svgstr: settingsSvgstr });
new LabIcon({ name: "ui-components:share", svgstr: shareSvgstr });
new LabIcon({ name: "ui-components:spreadsheet", svgstr: spreadsheetSvgstr });
new LabIcon({ name: "ui-components:stop", svgstr: stopSvgstr });
new LabIcon({ name: "ui-components:tab", svgstr: tabSvgstr });
new LabIcon({ name: "ui-components:table-rows", svgstr: tableRowsSvgstr });
new LabIcon({ name: "ui-components:tag", svgstr: tagSvgstr });
new LabIcon({ name: "ui-components:terminal", svgstr: terminalSvgstr });
new LabIcon({ name: "ui-components:text-editor", svgstr: textEditorSvgstr });
new LabIcon({ name: "ui-components:toc", svgstr: tocSvgstr });
new LabIcon({ name: "ui-components:tree-view", svgstr: treeViewSvgstr });
new LabIcon({ name: "ui-components:trusted", svgstr: trustedSvgstr });
new LabIcon({ name: "ui-components:undo", svgstr: undoSvgstr });
new LabIcon({ name: "ui-components:user", svgstr: userSvgstr });
new LabIcon({ name: "ui-components:users", svgstr: usersSvgstr });
new LabIcon({ name: "ui-components:vega", svgstr: vegaSvgstr });
new LabIcon({ name: "ui-components:word", svgstr: wordSvgstr });
new LabIcon({ name: "ui-components:yaml", svgstr: yamlSvgstr });
function normalizeDomain(domain) {
  return domain.replace("-", "_");
}
class Gettext {
  constructor(options) {
    options = options || {};
    this._defaults = {
      domain: "messages",
      locale: document.documentElement.getAttribute("lang") || "en",
      pluralFunc: function(n) {
        return { nplurals: 2, plural: n != 1 ? 1 : 0 };
      },
      contextDelimiter: String.fromCharCode(4),
      stringsPrefix: ""
    };
    this._locale = (options.locale || this._defaults.locale).replace("_", "-");
    this._domain = normalizeDomain(options.domain || this._defaults.domain);
    this._contextDelimiter = options.contextDelimiter || this._defaults.contextDelimiter;
    this._stringsPrefix = options.stringsPrefix || this._defaults.stringsPrefix;
    this._pluralFuncs = {};
    this._dictionary = {};
    this._pluralForms = {};
    if (options.messages) {
      this._dictionary[this._domain] = {};
      this._dictionary[this._domain][this._locale] = options.messages;
    }
    if (options.pluralForms) {
      this._pluralForms[this._locale] = options.pluralForms;
    }
  }
  /**
   * Set current context delimiter.
   *
   * @param delimiter - The delimiter to set.
   */
  setContextDelimiter(delimiter) {
    this._contextDelimiter = delimiter;
  }
  /**
   * Get current context delimiter.
   *
   * @returns The current delimiter.
   */
  getContextDelimiter() {
    return this._contextDelimiter;
  }
  /**
   * Set current locale.
   *
   * @param locale - The locale to set.
   */
  setLocale(locale) {
    this._locale = locale.replace("_", "-");
  }
  /**
   * Get current locale.
   *
   * @returns The current locale.
   */
  getLocale() {
    return this._locale;
  }
  /**
   * Set current domain.
   *
   * @param domain - The domain to set.
   */
  setDomain(domain) {
    this._domain = normalizeDomain(domain);
  }
  /**
   * Get current domain.
   *
   * @returns The current domain string.
   */
  getDomain() {
    return this._domain;
  }
  /**
   * Set current strings prefix.
   *
   * @param prefix - The string prefix to set.
   */
  setStringsPrefix(prefix) {
    this._stringsPrefix = prefix;
  }
  /**
   * Get current strings prefix.
   *
   * @returns The strings prefix.
   */
  getStringsPrefix() {
    return this._stringsPrefix;
  }
  /**
   * `sprintf` equivalent, takes a string and some arguments to make a
   * computed string.
   *
   * @param fmt - The string to interpolate.
   * @param args - The variables to use in interpolation.
   *
   * ### Examples
   * strfmt("%1 dogs are in %2", 7, "the kitchen"); => "7 dogs are in the kitchen"
   * strfmt("I like %1, bananas and %1", "apples"); => "I like apples, bananas and apples"
   */
  static strfmt(fmt, ...args) {
    return fmt.replace(/%%/g, "%% ").replace(/%(\d+)/g, function(str, p1) {
      return args[p1 - 1];
    }).replace(/%% /g, "%");
  }
  /**
   * Load json translations strings (In Jed 2.x format).
   *
   * @param jsonData - The translation strings plus metadata.
   * @param domain - The translation domain, e.g. "jupyterlab".
   */
  loadJSON(jsonData, domain) {
    if (!jsonData[""] || !jsonData[""]["language"] || !jsonData[""]["pluralForms"]) {
      throw new Error(`Wrong jsonData, it must have an empty key ("") with "language" and "pluralForms" information: ${jsonData}`);
    }
    domain = normalizeDomain(domain);
    let headers = jsonData[""];
    let jsonDataCopy = JSON.parse(JSON.stringify(jsonData));
    delete jsonDataCopy[""];
    this.setMessages(domain || this._defaults.domain, headers["language"], jsonDataCopy, headers["pluralForms"]);
  }
  /**
   * Shorthand for gettext.
   *
   * @param msgid - The singular string to translate.
   * @param args - Any additional values to use with interpolation.
   *
   * @returns A translated string if found, or the original string.
   *
   * ### Notes
   * This is not a private method (starts with an underscore) it is just
   * a shorter and standard way to call these methods.
   */
  __(msgid, ...args) {
    return this.gettext(msgid, ...args);
  }
  /**
   * Shorthand for ngettext.
   *
   * @param msgid - The singular string to translate.
   * @param msgid_plural - The plural string to translate.
   * @param n - The number for pluralization.
   * @param args - Any additional values to use with interpolation.
   *
   * @returns A translated string if found, or the original string.
   *
   * ### Notes
   * This is not a private method (starts with an underscore) it is just
   * a shorter and standard way to call these methods.
   */
  _n(msgid, msgid_plural, n, ...args) {
    return this.ngettext(msgid, msgid_plural, n, ...args);
  }
  /**
   * Shorthand for pgettext.
   *
   * @param msgctxt - The message context.
   * @param msgid - The singular string to translate.
   * @param args - Any additional values to use with interpolation.
   *
   * @returns A translated string if found, or the original string.
   *
   * ### Notes
   * This is not a private method (starts with an underscore) it is just
   * a shorter and standard way to call these methods.
   */
  _p(msgctxt, msgid, ...args) {
    return this.pgettext(msgctxt, msgid, ...args);
  }
  /**
   * Shorthand for npgettext.
   *
   * @param msgctxt - The message context.
   * @param msgid - The singular string to translate.
   * @param msgid_plural - The plural string to translate.
   * @param n - The number for pluralization.
   * @param args - Any additional values to use with interpolation.
   *
   * @returns A translated string if found, or the original string.
   *
   * ### Notes
   * This is not a private method (starts with an underscore) it is just
   * a shorter and standard way to call these methods.
   */
  _np(msgctxt, msgid, msgid_plural, n, ...args) {
    return this.npgettext(msgctxt, msgid, msgid_plural, n, ...args);
  }
  /**
   * Translate a singular string with extra interpolation values.
   *
   * @param msgid - The singular string to translate.
   * @param args - Any additional values to use with interpolation.
   *
   * @returns A translated string if found, or the original string.
   */
  gettext(msgid, ...args) {
    return this.dcnpgettext("", "", msgid, "", 0, ...args);
  }
  /**
   * Translate a plural string with extra interpolation values.
   *
   * @param msgid - The singular string to translate.
   * @param args - Any additional values to use with interpolation.
   *
   * @returns A translated string if found, or the original string.
   */
  ngettext(msgid, msgid_plural, n, ...args) {
    return this.dcnpgettext("", "", msgid, msgid_plural, n, ...args);
  }
  /**
   * Translate a contextualized singular string with extra interpolation values.
   *
   * @param msgctxt - The message context.
   * @param msgid - The singular string to translate.
   * @param args - Any additional values to use with interpolation.
   *
   * @returns A translated string if found, or the original string.
   *
   * ### Notes
   * This is not a private method (starts with an underscore) it is just
   * a shorter and standard way to call these methods.
   */
  pgettext(msgctxt, msgid, ...args) {
    return this.dcnpgettext("", msgctxt, msgid, "", 0, ...args);
  }
  /**
   * Translate a contextualized plural string with extra interpolation values.
   *
   * @param msgctxt - The message context.
   * @param msgid - The singular string to translate.
   * @param msgid_plural - The plural string to translate.
   * @param n - The number for pluralization.
   * @param args - Any additional values to use with interpolation
   *
   * @returns A translated string if found, or the original string.
   */
  npgettext(msgctxt, msgid, msgid_plural, n, ...args) {
    return this.dcnpgettext("", msgctxt, msgid, msgid_plural, n, ...args);
  }
  /**
   * Translate a singular string with extra interpolation values.
   *
   * @param domain - The translations domain.
   * @param msgctxt - The message context.
   * @param msgid - The singular string to translate.
   * @param msgid_plural - The plural string to translate.
   * @param n - The number for pluralization.
   * @param args - Any additional values to use with interpolation
   *
   * @returns A translated string if found, or the original string.
   */
  dcnpgettext(domain, msgctxt, msgid, msgid_plural, n, ...args) {
    domain = normalizeDomain(domain) || this._domain;
    let translation;
    let key2 = msgctxt ? msgctxt + this._contextDelimiter + msgid : msgid;
    let options = { pluralForm: false };
    let exist = false;
    let locale = this._locale;
    let locales = this.expandLocale(this._locale);
    for (let i2 in locales) {
      locale = locales[i2];
      exist = this._dictionary[domain] && this._dictionary[domain][locale] && this._dictionary[domain][locale][key2];
      if (msgid_plural) {
        exist = exist && this._dictionary[domain][locale][key2].length > 1;
      } else {
        exist = exist && this._dictionary[domain][locale][key2].length == 1;
      }
      if (exist) {
        options.locale = locale;
        break;
      }
    }
    if (!exist) {
      translation = [msgid];
      options.pluralFunc = this._defaults.pluralFunc;
    } else {
      translation = this._dictionary[domain][locale][key2];
    }
    if (!msgid_plural) {
      return this.t(translation, n, options, ...args);
    }
    options.pluralForm = true;
    let value = exist ? translation : [msgid, msgid_plural];
    return this.t(value, n, options, ...args);
  }
  /**
   * Split a locale into parent locales. "es-CO" -> ["es-CO", "es"]
   *
   * @param locale - The locale string.
   *
   * @returns An array of locales.
   */
  expandLocale(locale) {
    let locales = [locale];
    let i2 = locale.lastIndexOf("-");
    while (i2 > 0) {
      locale = locale.slice(0, i2);
      locales.push(locale);
      i2 = locale.lastIndexOf("-");
    }
    return locales;
  }
  /**
   * Split a locale into parent locales. "es-CO" -> ["es-CO", "es"]
   *
   * @param pluralForm - Plural form string..
   * @returns An function to compute plural forms.
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  getPluralFunc(pluralForm) {
    let pf_re = new RegExp("^\\s*nplurals\\s*=\\s*[0-9]+\\s*;\\s*plural\\s*=\\s*(?:\\s|[-\\?\\|&=!<>+*/%:;n0-9_()])+");
    if (!pf_re.test(pluralForm))
      throw new Error(Gettext.strfmt('The plural form "%1" is not valid', pluralForm));
    return new Function("n", "let plural, nplurals; " + pluralForm + " return { nplurals: nplurals, plural: (plural === true ? 1 : (plural ? plural : 0)) };");
  }
  /**
   * Remove the context delimiter from string.
   *
   * @param str - Translation string.
   * @returns A translation string without context.
   */
  removeContext(str) {
    if (str.indexOf(this._contextDelimiter) !== -1) {
      let parts = str.split(this._contextDelimiter);
      return parts[1];
    }
    return str;
  }
  /**
   * Proper translation function that handle plurals and directives.
   *
   * @param messages - List of translation strings.
   * @param n - The number for pluralization.
   * @param options - Translation options.
   * @param args - Any variables to interpolate.
   *
   * @returns A translation string without context.
   *
   * ### Notes
   * Contains juicy parts of https://github.com/Orange-OpenSource/gettext.js/blob/master/lib.gettext.js
   */
  t(messages2, n, options, ...args) {
    if (!options.pluralForm)
      return this._stringsPrefix + Gettext.strfmt(this.removeContext(messages2[0]), ...args);
    let plural;
    if (options.pluralFunc) {
      plural = options.pluralFunc(n);
    } else if (!this._pluralFuncs[options.locale || ""]) {
      this._pluralFuncs[options.locale || ""] = this.getPluralFunc(this._pluralForms[options.locale || ""]);
      plural = this._pluralFuncs[options.locale || ""](n);
    } else {
      plural = this._pluralFuncs[options.locale || ""](n);
    }
    if ("undefined" === typeof !plural.plural || plural.plural > plural.nplurals || messages2.length <= plural.plural)
      plural.plural = 0;
    return this._stringsPrefix + Gettext.strfmt(this.removeContext(messages2[plural.plural]), ...[n].concat(args));
  }
  /**
   * Set messages after loading them.
   *
   * @param domain - The translation domain.
   * @param locale - The translation locale.
   * @param messages - List of translation strings.
   * @param pluralForms - Plural form string.
   *
   * ### Notes
   * Contains juicy parts of https://github.com/Orange-OpenSource/gettext.js/blob/master/lib.gettext.js
   */
  setMessages(domain, locale, messages2, pluralForms) {
    domain = normalizeDomain(domain);
    if (pluralForms)
      this._pluralForms[locale] = pluralForms;
    if (!this._dictionary[domain])
      this._dictionary[domain] = {};
    this._dictionary[domain][locale] = messages2;
  }
}
class NullTranslator {
  constructor(bundle) {
    this.languageCode = "en";
    this._languageBundle = bundle;
  }
  load(domain) {
    return this._languageBundle;
  }
}
class NullLanguageBundle {
  __(msgid, ...args) {
    return this.gettext(msgid, ...args);
  }
  _n(msgid, msgid_plural, n, ...args) {
    return this.ngettext(msgid, msgid_plural, n, ...args);
  }
  _p(msgctxt, msgid, ...args) {
    return this.pgettext(msgctxt, msgid, ...args);
  }
  _np(msgctxt, msgid, msgid_plural, n, ...args) {
    return this.npgettext(msgctxt, msgid, msgid_plural, n, ...args);
  }
  gettext(msgid, ...args) {
    return Gettext.strfmt(msgid, ...args);
  }
  ngettext(msgid, msgid_plural, n, ...args) {
    return Gettext.strfmt(n == 1 ? msgid : msgid_plural, ...[n].concat(args));
  }
  pgettext(msgctxt, msgid, ...args) {
    return Gettext.strfmt(msgid, ...args);
  }
  npgettext(msgctxt, msgid, msgid_plural, n, ...args) {
    return this.ngettext(msgid, msgid_plural, n, ...args);
  }
  dcnpgettext(domain, msgctxt, msgid, msgid_plural, n, ...args) {
    return this.ngettext(msgid, msgid_plural, n, ...args);
  }
}
const nullTranslator = new NullTranslator(new NullLanguageBundle());
var lib$7 = {};
var dataconnector = {};
Object.defineProperty(dataconnector, "__esModule", { value: true });
dataconnector.DataConnector = void 0;
class DataConnector {
  /**
   * Retrieve the list of items available from the data connector.
   *
   * @param query - The optional query filter to apply to the connector request.
   *
   * @returns A promise that always rejects with an error.
   *
   * #### Notes
   * Subclasses should reimplement if they support a back-end that can list.
   */
  async list(query) {
    throw new Error("DataConnector#list method has not been implemented.");
  }
  /**
   * Remove a value using the data connector.
   *
   * @param id - The identifier for the data being removed.
   *
   * @returns A promise that always rejects with an error.
   *
   * #### Notes
   * Subclasses should reimplement if they support a back-end that can remove.
   */
  async remove(id) {
    throw new Error("DataConnector#remove method has not been implemented.");
  }
  /**
   * Save a value using the data connector.
   *
   * @param id - The identifier for the data being saved.
   *
   * @param value - The data being saved.
   *
   * @returns A promise that always rejects with an error.
   *
   * #### Notes
   * Subclasses should reimplement if they support a back-end that can save.
   */
  async save(id, value) {
    throw new Error("DataConnector#save method has not been implemented.");
  }
}
dataconnector.DataConnector = DataConnector;
var interfaces = {};
Object.defineProperty(interfaces, "__esModule", { value: true });
var restorablepool = {};
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(index_es6$2);
Object.defineProperty(restorablepool, "__esModule", { value: true });
restorablepool.RestorablePool = void 0;
const coreutils_1$c = require$$1$2;
const properties_1 = require$$1$1;
const signaling_1$5 = require$$0$1;
class RestorablePool {
  /**
   * Create a new restorable pool.
   *
   * @param options - The instantiation options for a restorable pool.
   */
  constructor(options) {
    this._added = new signaling_1$5.Signal(this);
    this._current = null;
    this._currentChanged = new signaling_1$5.Signal(this);
    this._hasRestored = false;
    this._isDisposed = false;
    this._objects = /* @__PURE__ */ new Set();
    this._restore = null;
    this._restored = new coreutils_1$c.PromiseDelegate();
    this._updated = new signaling_1$5.Signal(this);
    this.namespace = options.namespace;
  }
  /**
   * A signal emitted when an object object is added.
   *
   * #### Notes
   * This signal will only fire when an object is added to the pool.
   * It will not fire if an object injected into the pool.
   */
  get added() {
    return this._added;
  }
  /**
   * The current object.
   *
   * #### Notes
   * The restorable pool does not set `current`. It is intended for client use.
   *
   * If `current` is set to an object that does not exist in the pool, it is a
   * no-op.
   */
  get current() {
    return this._current;
  }
  set current(obj) {
    if (this._current === obj) {
      return;
    }
    if (obj !== null && this._objects.has(obj)) {
      this._current = obj;
      this._currentChanged.emit(this._current);
    }
  }
  /**
   * A signal emitted when the current widget changes.
   */
  get currentChanged() {
    return this._currentChanged;
  }
  /**
   * Test whether the pool is disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * A promise resolved when the restorable pool has been restored.
   */
  get restored() {
    return this._restored.promise;
  }
  /**
   * The number of objects held by the pool.
   */
  get size() {
    return this._objects.size;
  }
  /**
   * A signal emitted when an object is updated.
   */
  get updated() {
    return this._updated;
  }
  /**
   * Add a new object to the pool.
   *
   * @param obj - The object object being added.
   *
   * #### Notes
   * The object passed into the pool is added synchronously; its existence in
   * the pool can be checked with the `has()` method. The promise this method
   * returns resolves after the object has been added and saved to an underlying
   * restoration connector, if one is available.
   */
  async add(obj) {
    var _a, _b;
    if (obj.isDisposed) {
      const warning2 = "A disposed object cannot be added.";
      console.warn(warning2, obj);
      throw new Error(warning2);
    }
    if (this._objects.has(obj)) {
      const warning2 = "This object already exists in the pool.";
      console.warn(warning2, obj);
      throw new Error(warning2);
    }
    this._objects.add(obj);
    obj.disposed.connect(this._onInstanceDisposed, this);
    if (Private$p.injectedProperty.get(obj)) {
      return;
    }
    if (this._restore) {
      const { connector } = this._restore;
      const objName = this._restore.name(obj);
      if (objName) {
        const name2 = `${this.namespace}:${objName}`;
        const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
        Private$p.nameProperty.set(obj, name2);
        await connector.save(name2, { data });
      }
    }
    this._added.emit(obj);
  }
  /**
   * Dispose of the resources held by the pool.
   *
   * #### Notes
   * Disposing a pool does not affect the underlying data in the data connector,
   * it simply disposes the client-side pool without making any connector calls.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._current = null;
    this._isDisposed = true;
    this._objects.clear();
    signaling_1$5.Signal.clearData(this);
  }
  /**
   * Find the first object in the pool that satisfies a filter function.
   *
   * @param fn The filter function to call on each object.
   */
  find(fn) {
    const values = this._objects.values();
    for (const value of values) {
      if (fn(value)) {
        return value;
      }
    }
    return void 0;
  }
  /**
   * Iterate through each object in the pool.
   *
   * @param fn - The function to call on each object.
   */
  forEach(fn) {
    this._objects.forEach(fn);
  }
  /**
   * Filter the objects in the pool based on a predicate.
   *
   * @param fn - The function by which to filter.
   */
  filter(fn) {
    const filtered = [];
    this.forEach((obj) => {
      if (fn(obj)) {
        filtered.push(obj);
      }
    });
    return filtered;
  }
  /**
   * Inject an object into the restorable pool without the pool handling its
   * restoration lifecycle.
   *
   * @param obj - The object to inject into the pool.
   */
  inject(obj) {
    Private$p.injectedProperty.set(obj, true);
    return this.add(obj);
  }
  /**
   * Check if this pool has the specified object.
   *
   * @param obj - The object whose existence is being checked.
   */
  has(obj) {
    return this._objects.has(obj);
  }
  /**
   * Restore the objects in this pool's namespace.
   *
   * @param options - The configuration options that describe restoration.
   *
   * @returns A promise that resolves when restoration has completed.
   *
   * #### Notes
   * This function should almost never be invoked by client code. Its primary
   * use case is to be invoked by a layout restorer plugin that handles
   * multiple restorable pools and, when ready, asks them each to restore their
   * respective objects.
   */
  async restore(options) {
    if (this._hasRestored) {
      throw new Error("This pool has already been restored.");
    }
    this._hasRestored = true;
    const { command, connector, registry, when } = options;
    const namespace = this.namespace;
    const promises = when ? [connector.list(namespace)].concat(when) : [connector.list(namespace)];
    this._restore = options;
    const [saved] = await Promise.all(promises);
    const values = await Promise.all(saved.ids.map(async (id, index) => {
      const value = saved.values[index];
      const args = value && value.data;
      if (args === void 0) {
        return connector.remove(id);
      }
      return registry.execute(command, args).catch(() => connector.remove(id));
    }));
    this._restored.resolve();
    return values;
  }
  /**
   * Save the restore data for a given object.
   *
   * @param obj - The object being saved.
   */
  async save(obj) {
    var _a, _b;
    const injected = Private$p.injectedProperty.get(obj);
    if (!this._restore || !this.has(obj) || injected) {
      return;
    }
    const { connector } = this._restore;
    const objName = this._restore.name(obj);
    const oldName = Private$p.nameProperty.get(obj);
    const newName = objName ? `${this.namespace}:${objName}` : "";
    if (oldName && oldName !== newName) {
      await connector.remove(oldName);
    }
    Private$p.nameProperty.set(obj, newName);
    if (newName) {
      const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
      await connector.save(newName, { data });
    }
    if (oldName !== newName) {
      this._updated.emit(obj);
    }
  }
  /**
   * Clean up after disposed objects.
   */
  _onInstanceDisposed(obj) {
    this._objects.delete(obj);
    if (obj === this._current) {
      this._current = null;
      this._currentChanged.emit(this._current);
    }
    if (Private$p.injectedProperty.get(obj)) {
      return;
    }
    if (!this._restore) {
      return;
    }
    const { connector } = this._restore;
    const name2 = Private$p.nameProperty.get(obj);
    if (name2) {
      void connector.remove(name2);
    }
  }
}
restorablepool.RestorablePool = RestorablePool;
var Private$p;
(function(Private2) {
  Private2.injectedProperty = new properties_1.AttachedProperty({
    name: "injected",
    create: () => false
  });
  Private2.nameProperty = new properties_1.AttachedProperty({
    name: "name",
    create: () => ""
  });
})(Private$p || (Private$p = {}));
var statedb = {};
Object.defineProperty(statedb, "__esModule", { value: true });
statedb.StateDB = void 0;
const signaling_1$4 = require$$0$1;
class StateDB {
  /**
   * Create a new state database.
   *
   * @param options - The instantiation options for a state database.
   */
  constructor(options = {}) {
    this._changed = new signaling_1$4.Signal(this);
    const { connector, transform } = options;
    this._connector = connector || new StateDB.Connector();
    if (!transform) {
      this._ready = Promise.resolve(void 0);
    } else {
      this._ready = transform.then((transformation) => {
        const { contents: contents2, type } = transformation;
        switch (type) {
          case "cancel":
            return;
          case "clear":
            return this._clear();
          case "merge":
            return this._merge(contents2 || {});
          case "overwrite":
            return this._overwrite(contents2 || {});
          default:
            return;
        }
      });
    }
  }
  /**
   * A signal that emits the change type any time a value changes.
   */
  get changed() {
    return this._changed;
  }
  /**
   * Clear the entire database.
   */
  async clear() {
    await this._ready;
    await this._clear();
  }
  /**
   * Retrieve a saved bundle from the database.
   *
   * @param id - The identifier used to retrieve a data bundle.
   *
   * @returns A promise that bears a data payload if available.
   *
   * #### Notes
   * The `id` values of stored items in the state database are formatted:
   * `'namespace:identifier'`, which is the same convention that command
   * identifiers in JupyterLab use as well. While this is not a technical
   * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
   * using the `list(namespace: string)` method.
   *
   * The promise returned by this method may be rejected if an error occurs in
   * retrieving the data. Non-existence of an `id` will succeed with the `value`
   * `undefined`.
   */
  async fetch(id) {
    await this._ready;
    return this._fetch(id);
  }
  /**
   * Retrieve all the saved bundles for a namespace.
   *
   * @param namespace The namespace prefix to retrieve.
   *
   * @returns A promise that bears a collection of payloads for a namespace.
   *
   * #### Notes
   * Namespaces are entirely conventional entities. The `id` values of stored
   * items in the state database are formatted: `'namespace:identifier'`, which
   * is the same convention that command identifiers in JupyterLab use as well.
   *
   * If there are any errors in retrieving the data, they will be logged to the
   * console in order to optimistically return any extant data without failing.
   * This promise will always succeed.
   */
  async list(namespace) {
    await this._ready;
    return this._list(namespace);
  }
  /**
   * Remove a value from the database.
   *
   * @param id - The identifier for the data being removed.
   *
   * @returns A promise that is rejected if remove fails and succeeds otherwise.
   */
  async remove(id) {
    await this._ready;
    await this._remove(id);
    this._changed.emit({ id, type: "remove" });
  }
  /**
   * Save a value in the database.
   *
   * @param id - The identifier for the data being saved.
   *
   * @param value - The data being saved.
   *
   * @returns A promise that is rejected if saving fails and succeeds otherwise.
   *
   * #### Notes
   * The `id` values of stored items in the state database are formatted:
   * `'namespace:identifier'`, which is the same convention that command
   * identifiers in JupyterLab use as well. While this is not a technical
   * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
   * using the `list(namespace: string)` method.
   */
  async save(id, value) {
    await this._ready;
    await this._save(id, value);
    this._changed.emit({ id, type: "save" });
  }
  /**
   * Return a serialized copy of the state database's entire contents.
   *
   * @returns A promise that resolves with the database contents as JSON.
   */
  async toJSON() {
    await this._ready;
    const { ids, values } = await this._list();
    return values.reduce((acc, val, idx) => {
      acc[ids[idx]] = val;
      return acc;
    }, {});
  }
  /**
   * Clear the entire database.
   */
  async _clear() {
    await Promise.all((await this._list()).ids.map((id) => this._remove(id)));
  }
  /**
   * Fetch a value from the database.
   */
  async _fetch(id) {
    const value = await this._connector.fetch(id);
    if (value) {
      return JSON.parse(value).v;
    }
  }
  /**
   * Fetch a list from the database.
   */
  async _list(namespace = "") {
    const { ids, values } = await this._connector.list(namespace);
    return {
      ids,
      values: values.map((val) => JSON.parse(val).v)
    };
  }
  /**
   * Merge data into the state database.
   */
  async _merge(contents2) {
    await Promise.all(Object.keys(contents2).map((key2) => contents2[key2] && this._save(key2, contents2[key2])));
  }
  /**
   * Overwrite the entire database with new contents.
   */
  async _overwrite(contents2) {
    await this._clear();
    await this._merge(contents2);
  }
  /**
   * Remove a key in the database.
   */
  async _remove(id) {
    return this._connector.remove(id);
  }
  /**
   * Save a key and its value in the database.
   */
  async _save(id, value) {
    return this._connector.save(id, JSON.stringify({ v: value }));
  }
}
statedb.StateDB = StateDB;
(function(StateDB2) {
  class Connector {
    constructor() {
      this._storage = {};
    }
    /**
     * Retrieve an item from the data connector.
     */
    async fetch(id) {
      return this._storage[id];
    }
    /**
     * Retrieve the list of items available from the data connector.
     *
     * @param namespace - If not empty, only keys whose first token before `:`
     * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.
     */
    async list(namespace = "") {
      return Object.keys(this._storage).reduce((acc, val) => {
        if (namespace === "" ? true : namespace === val.split(":")[0]) {
          acc.ids.push(val);
          acc.values.push(this._storage[val]);
        }
        return acc;
      }, { ids: [], values: [] });
    }
    /**
     * Remove a value using the data connector.
     */
    async remove(id) {
      delete this._storage[id];
    }
    /**
     * Save a value using the data connector.
     */
    async save(id, value) {
      this._storage[id] = value;
    }
  }
  StateDB2.Connector = Connector;
})(StateDB || (statedb.StateDB = StateDB = {}));
var tokens = {};
Object.defineProperty(tokens, "__esModule", { value: true });
tokens.IStateDB = void 0;
const coreutils_1$b = require$$1$2;
tokens.IStateDB = new coreutils_1$b.Token("@jupyterlab/coreutils:IStateDB", `A service for the JupyterLab state database.
  Use this if you want to store data that will persist across page loads.
  See "state database" for more information.`);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(dataconnector, exports);
  __exportStar(interfaces, exports);
  __exportStar(restorablepool, exports);
  __exportStar(statedb, exports);
  __exportStar(tokens, exports);
})(lib$7);
var lib$6 = {};
var basemanager = {};
var serverconnection = {};
var serialize$1 = {};
var messages = {};
Object.defineProperty(messages, "__esModule", { value: true });
messages.supportedKernelWebSocketProtocols = messages.isInputReplyMsg = messages.isInputRequestMsg = messages.isDebugReplyMsg = messages.isDebugRequestMsg = messages.isExecuteReplyMsg = messages.isInfoRequestMsg = messages.isCommMsgMsg = messages.isCommCloseMsg = messages.isCommOpenMsg = messages.isDebugEventMsg = messages.isClearOutputMsg = messages.isStatusMsg = messages.isErrorMsg = messages.isExecuteResultMsg = messages.isExecuteInputMsg = messages.isUpdateDisplayDataMsg = messages.isDisplayDataMsg = messages.isStreamMsg = messages.createMessage = void 0;
const coreutils_1$a = require$$1$2;
function createMessage(options) {
  var _a, _b, _c, _d, _e;
  return {
    buffers: (_a = options.buffers) !== null && _a !== void 0 ? _a : [],
    channel: options.channel,
    content: options.content,
    header: {
      date: (/* @__PURE__ */ new Date()).toISOString(),
      msg_id: (_b = options.msgId) !== null && _b !== void 0 ? _b : coreutils_1$a.UUID.uuid4(),
      msg_type: options.msgType,
      session: options.session,
      username: (_c = options.username) !== null && _c !== void 0 ? _c : "",
      version: "5.2"
    },
    metadata: (_d = options.metadata) !== null && _d !== void 0 ? _d : {},
    parent_header: (_e = options.parentHeader) !== null && _e !== void 0 ? _e : {}
  };
}
messages.createMessage = createMessage;
function isStreamMsg(msg) {
  return msg.header.msg_type === "stream";
}
messages.isStreamMsg = isStreamMsg;
function isDisplayDataMsg(msg) {
  return msg.header.msg_type === "display_data";
}
messages.isDisplayDataMsg = isDisplayDataMsg;
function isUpdateDisplayDataMsg(msg) {
  return msg.header.msg_type === "update_display_data";
}
messages.isUpdateDisplayDataMsg = isUpdateDisplayDataMsg;
function isExecuteInputMsg(msg) {
  return msg.header.msg_type === "execute_input";
}
messages.isExecuteInputMsg = isExecuteInputMsg;
function isExecuteResultMsg(msg) {
  return msg.header.msg_type === "execute_result";
}
messages.isExecuteResultMsg = isExecuteResultMsg;
function isErrorMsg(msg) {
  return msg.header.msg_type === "error";
}
messages.isErrorMsg = isErrorMsg;
function isStatusMsg(msg) {
  return msg.header.msg_type === "status";
}
messages.isStatusMsg = isStatusMsg;
function isClearOutputMsg(msg) {
  return msg.header.msg_type === "clear_output";
}
messages.isClearOutputMsg = isClearOutputMsg;
function isDebugEventMsg(msg) {
  return msg.header.msg_type === "debug_event";
}
messages.isDebugEventMsg = isDebugEventMsg;
function isCommOpenMsg(msg) {
  return msg.header.msg_type === "comm_open";
}
messages.isCommOpenMsg = isCommOpenMsg;
function isCommCloseMsg(msg) {
  return msg.header.msg_type === "comm_close";
}
messages.isCommCloseMsg = isCommCloseMsg;
function isCommMsgMsg(msg) {
  return msg.header.msg_type === "comm_msg";
}
messages.isCommMsgMsg = isCommMsgMsg;
function isInfoRequestMsg(msg) {
  return msg.header.msg_type === "kernel_info_request";
}
messages.isInfoRequestMsg = isInfoRequestMsg;
function isExecuteReplyMsg(msg) {
  return msg.header.msg_type === "execute_reply";
}
messages.isExecuteReplyMsg = isExecuteReplyMsg;
function isDebugRequestMsg(msg) {
  return msg.header.msg_type === "debug_request";
}
messages.isDebugRequestMsg = isDebugRequestMsg;
function isDebugReplyMsg(msg) {
  return msg.header.msg_type === "debug_reply";
}
messages.isDebugReplyMsg = isDebugReplyMsg;
function isInputRequestMsg(msg) {
  return msg.header.msg_type === "input_request";
}
messages.isInputRequestMsg = isInputRequestMsg;
function isInputReplyMsg(msg) {
  return msg.header.msg_type === "input_reply";
}
messages.isInputReplyMsg = isInputReplyMsg;
var supportedKernelWebSocketProtocols;
(function(supportedKernelWebSocketProtocols2) {
  supportedKernelWebSocketProtocols2["v1KernelWebsocketJupyterOrg"] = "v1.kernel.websocket.jupyter.org";
})(supportedKernelWebSocketProtocols || (messages.supportedKernelWebSocketProtocols = supportedKernelWebSocketProtocols = {}));
var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result2 = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$5(result2, mod, k);
  }
  __setModuleDefault$5(result2, mod);
  return result2;
};
Object.defineProperty(serialize$1, "__esModule", { value: true });
serialize$1.deserialize = serialize$1.serialize = void 0;
const KernelMessage$2 = __importStar$5(messages);
function serialize(msg, protocol = "") {
  switch (protocol) {
    case KernelMessage$2.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
      return Private$o.serializeV1KernelWebsocketJupyterOrg(msg);
    default:
      return Private$o.serializeDefault(msg);
  }
}
serialize$1.serialize = serialize;
function deserialize(data, protocol = "") {
  switch (protocol) {
    case KernelMessage$2.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
      return Private$o.deserializeV1KernelWebsocketJupyterOrg(data);
    default:
      return Private$o.deserializeDefault(data);
  }
}
serialize$1.deserialize = deserialize;
var Private$o;
(function(Private2) {
  function deserializeV1KernelWebsocketJupyterOrg(binMsg) {
    let msg;
    const data = new DataView(binMsg);
    const offsetNumber = Number(data.getBigUint64(
      0,
      true
      /* littleEndian */
    ));
    let offsets = [];
    for (let i2 = 0; i2 < offsetNumber; i2++) {
      offsets.push(Number(data.getBigUint64(
        8 * (i2 + 1),
        true
        /* littleEndian */
      )));
    }
    const decoder = new TextDecoder("utf8");
    const channel = decoder.decode(binMsg.slice(offsets[0], offsets[1]));
    const header = JSON.parse(decoder.decode(binMsg.slice(offsets[1], offsets[2])));
    const parent_header = JSON.parse(decoder.decode(binMsg.slice(offsets[2], offsets[3])));
    const metadata = JSON.parse(decoder.decode(binMsg.slice(offsets[3], offsets[4])));
    const content = JSON.parse(decoder.decode(binMsg.slice(offsets[4], offsets[5])));
    let buffers = [];
    for (let i2 = 5; i2 < offsets.length - 1; i2++) {
      buffers.push(new DataView(binMsg.slice(offsets[i2], offsets[i2 + 1])));
    }
    msg = {
      channel,
      header,
      parent_header,
      metadata,
      content,
      buffers
    };
    return msg;
  }
  Private2.deserializeV1KernelWebsocketJupyterOrg = deserializeV1KernelWebsocketJupyterOrg;
  function serializeV1KernelWebsocketJupyterOrg(msg) {
    const header = JSON.stringify(msg.header);
    const parentHeader = msg.parent_header == null ? "{}" : JSON.stringify(msg.parent_header);
    const metadata = JSON.stringify(msg.metadata);
    const content = JSON.stringify(msg.content);
    const buffers = msg.buffers !== void 0 ? msg.buffers : [];
    const offsetNumber = 1 + 4 + buffers.length + 1;
    let offsets = [];
    offsets.push(8 * (1 + offsetNumber));
    offsets.push(msg.channel.length + offsets[offsets.length - 1]);
    const encoder = new TextEncoder();
    const channelEncoded = encoder.encode(msg.channel);
    const headerEncoded = encoder.encode(header);
    const parentHeaderEncoded = encoder.encode(parentHeader);
    const metadataEncoded = encoder.encode(metadata);
    const contentEncoded = encoder.encode(content);
    const binMsgNoBuff = new Uint8Array(channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length + contentEncoded.length);
    binMsgNoBuff.set(channelEncoded);
    binMsgNoBuff.set(headerEncoded, channelEncoded.length);
    binMsgNoBuff.set(parentHeaderEncoded, channelEncoded.length + headerEncoded.length);
    binMsgNoBuff.set(metadataEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length);
    binMsgNoBuff.set(contentEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length);
    for (let length2 of [
      headerEncoded.length,
      parentHeaderEncoded.length,
      metadataEncoded.length,
      contentEncoded.length
    ]) {
      offsets.push(length2 + offsets[offsets.length - 1]);
    }
    let buffersByteLength = 0;
    for (let buffer of buffers) {
      let length2 = buffer.byteLength;
      offsets.push(length2 + offsets[offsets.length - 1]);
      buffersByteLength += length2;
    }
    const binMsg = new Uint8Array(8 * (1 + offsetNumber) + binMsgNoBuff.byteLength + buffersByteLength);
    const word = new ArrayBuffer(8);
    const data = new DataView(word);
    data.setBigUint64(
      0,
      BigInt(offsetNumber),
      true
      /* littleEndian */
    );
    binMsg.set(new Uint8Array(word), 0);
    for (let i2 = 0; i2 < offsets.length; i2++) {
      data.setBigUint64(
        0,
        BigInt(offsets[i2]),
        true
        /* littleEndian */
      );
      binMsg.set(new Uint8Array(word), 8 * (i2 + 1));
    }
    binMsg.set(binMsgNoBuff, offsets[0]);
    for (let i2 = 0; i2 < buffers.length; i2++) {
      const buffer = buffers[i2];
      binMsg.set(new Uint8Array(ArrayBuffer.isView(buffer) ? buffer.buffer : buffer), offsets[5 + i2]);
    }
    return binMsg.buffer;
  }
  Private2.serializeV1KernelWebsocketJupyterOrg = serializeV1KernelWebsocketJupyterOrg;
  function deserializeDefault(data) {
    let value;
    if (typeof data === "string") {
      value = JSON.parse(data);
    } else {
      value = deserializeBinary(data);
    }
    return value;
  }
  Private2.deserializeDefault = deserializeDefault;
  function serializeDefault(msg) {
    var _a;
    let value;
    if ((_a = msg.buffers) === null || _a === void 0 ? void 0 : _a.length) {
      value = serializeBinary(msg);
    } else {
      value = JSON.stringify(msg);
    }
    return value;
  }
  Private2.serializeDefault = serializeDefault;
  function deserializeBinary(buf) {
    const data = new DataView(buf);
    const nbufs = data.getUint32(0);
    const offsets = [];
    if (nbufs < 2) {
      throw new Error("Invalid incoming Kernel Message");
    }
    for (let i2 = 1; i2 <= nbufs; i2++) {
      offsets.push(data.getUint32(i2 * 4));
    }
    const jsonBytes = new Uint8Array(buf.slice(offsets[0], offsets[1]));
    const msg = JSON.parse(new TextDecoder("utf8").decode(jsonBytes));
    msg.buffers = [];
    for (let i2 = 1; i2 < nbufs; i2++) {
      const start = offsets[i2];
      const stop = offsets[i2 + 1] || buf.byteLength;
      msg.buffers.push(new DataView(buf.slice(start, stop)));
    }
    return msg;
  }
  function serializeBinary(msg) {
    const offsets = [];
    const buffers = [];
    const encoder = new TextEncoder();
    let origBuffers = [];
    if (msg.buffers !== void 0) {
      origBuffers = msg.buffers;
      delete msg["buffers"];
    }
    const jsonUtf8 = encoder.encode(JSON.stringify(msg));
    buffers.push(jsonUtf8.buffer);
    for (let i2 = 0; i2 < origBuffers.length; i2++) {
      const b = origBuffers[i2];
      buffers.push(ArrayBuffer.isView(b) ? b.buffer : b);
    }
    const nbufs = buffers.length;
    offsets.push(4 * (nbufs + 1));
    for (let i2 = 0; i2 + 1 < buffers.length; i2++) {
      offsets.push(offsets[offsets.length - 1] + buffers[i2].byteLength);
    }
    const msgBuf = new Uint8Array(offsets[offsets.length - 1] + buffers[buffers.length - 1].byteLength);
    const view = new DataView(msgBuf.buffer);
    view.setUint32(0, nbufs);
    for (let i2 = 0; i2 < offsets.length; i2++) {
      view.setUint32(4 * (i2 + 1), offsets[i2]);
    }
    for (let i2 = 0; i2 < buffers.length; i2++) {
      msgBuf.set(new Uint8Array(buffers[i2]), offsets[i2]);
    }
    return msgBuf.buffer;
  }
})(Private$o || (Private$o = {}));
var ws = {};
var hasRequiredWs;
function requireWs() {
  if (hasRequiredWs) return ws;
  hasRequiredWs = 1;
  Object.defineProperty(ws, "__esModule", { value: true });
  ws.default = WebSocket;
  return ws;
}
Object.defineProperty(serverconnection, "__esModule", { value: true });
serverconnection.ServerConnection = void 0;
const coreutils_1$9 = lib$9;
const serialize_1 = serialize$1;
let WEBSOCKET;
if (typeof window === "undefined") {
  WEBSOCKET = requireWs();
} else {
  WEBSOCKET = WebSocket;
}
var ServerConnection;
(function(ServerConnection2) {
  function makeSettings(options) {
    return Private$n.makeSettings(options);
  }
  ServerConnection2.makeSettings = makeSettings;
  function makeRequest(url2, init, settings) {
    return Private$n.handleRequest(url2, init, settings);
  }
  ServerConnection2.makeRequest = makeRequest;
  class ResponseError extends Error {
    /**
     * Create a ResponseError from a response, handling the traceback and message
     * as appropriate.
     *
     * @param response The response object.
     *
     * @returns A promise that resolves with a `ResponseError` object.
     */
    static async create(response) {
      try {
        const data = await response.json();
        const { message, traceback } = data;
        if (traceback) {
          console.error(traceback);
        }
        return new ResponseError(response, message !== null && message !== void 0 ? message : ResponseError._defaultMessage(response), traceback !== null && traceback !== void 0 ? traceback : "");
      } catch (e) {
        console.debug(e);
        return new ResponseError(response);
      }
    }
    /**
     * Create a new response error.
     */
    constructor(response, message = ResponseError._defaultMessage(response), traceback = "") {
      super(message);
      this.response = response;
      this.traceback = traceback;
    }
    static _defaultMessage(response) {
      return `Invalid response: ${response.status} ${response.statusText}`;
    }
  }
  ServerConnection2.ResponseError = ResponseError;
  class NetworkError extends TypeError {
    /**
     * Create a new network error.
     */
    constructor(original) {
      super(original.message);
      this.stack = original.stack;
    }
  }
  ServerConnection2.NetworkError = NetworkError;
})(ServerConnection || (serverconnection.ServerConnection = ServerConnection = {}));
var Private$n;
(function(Private2) {
  function makeSettings(options = {}) {
    var _a;
    const pageBaseUrl = coreutils_1$9.PageConfig.getBaseUrl();
    const pageWsUrl = coreutils_1$9.PageConfig.getWsUrl();
    const baseUrl = coreutils_1$9.URLExt.normalize(options.baseUrl) || pageBaseUrl;
    let wsUrl = options.wsUrl;
    if (!wsUrl && baseUrl === pageBaseUrl) {
      wsUrl = pageWsUrl;
    }
    if (!wsUrl && baseUrl.indexOf("http") === 0) {
      wsUrl = "ws" + baseUrl.slice(4);
    }
    wsUrl = wsUrl !== null && wsUrl !== void 0 ? wsUrl : pageWsUrl;
    const appendTokenConfig = coreutils_1$9.PageConfig.getOption("appendToken").toLowerCase();
    let appendToken;
    if (appendTokenConfig === "") {
      appendToken = typeof window === "undefined" || typeof process !== "undefined" && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.JEST_WORKER_ID) !== void 0 || coreutils_1$9.URLExt.getHostName(pageBaseUrl) !== coreutils_1$9.URLExt.getHostName(wsUrl);
    } else {
      appendToken = appendTokenConfig === "true";
    }
    return {
      init: { cache: "no-store", credentials: "same-origin" },
      fetch,
      Headers,
      Request,
      WebSocket: WEBSOCKET,
      token: coreutils_1$9.PageConfig.getToken(),
      appUrl: coreutils_1$9.PageConfig.getOption("appUrl"),
      appendToken,
      serializer: { serialize: serialize_1.serialize, deserialize: serialize_1.deserialize },
      ...options,
      baseUrl,
      wsUrl
    };
  }
  Private2.makeSettings = makeSettings;
  function handleRequest(url2, init, settings) {
    var _a;
    if (url2.indexOf(settings.baseUrl) !== 0) {
      throw new Error("Can only be used for notebook server requests");
    }
    const cache2 = (_a = init.cache) !== null && _a !== void 0 ? _a : settings.init.cache;
    if (cache2 === "no-store") {
      url2 += (/\?/.test(url2) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
    }
    const request = new settings.Request(url2, { ...settings.init, ...init });
    let authenticated = false;
    if (settings.token) {
      authenticated = true;
      request.headers.append("Authorization", `token ${settings.token}`);
    }
    if (typeof document !== "undefined") {
      const xsrfToken = getCookie("_xsrf");
      if (xsrfToken !== void 0) {
        authenticated = true;
        request.headers.append("X-XSRFToken", xsrfToken);
      }
    }
    if (!request.headers.has("Content-Type") && authenticated) {
      request.headers.set("Content-Type", "application/json");
    }
    return settings.fetch.call(null, request).catch((e) => {
      throw new ServerConnection.NetworkError(e);
    });
  }
  Private2.handleRequest = handleRequest;
  function getCookie(name2) {
    let cookie = "";
    try {
      cookie = document.cookie;
    } catch (e) {
      return;
    }
    const matches2 = cookie.match("\\b" + name2 + "=([^;]*)\\b");
    return matches2 === null || matches2 === void 0 ? void 0 : matches2[1];
  }
})(Private$n || (Private$n = {}));
Object.defineProperty(basemanager, "__esModule", { value: true });
basemanager.BaseManager = void 0;
const signaling_1$3 = require$$0$1;
const serverconnection_1$7 = serverconnection;
class BaseManager {
  constructor(options) {
    var _a;
    this._isDisposed = false;
    this._disposed = new signaling_1$3.Signal(this);
    this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1$7.ServerConnection.makeSettings();
  }
  /**
   * A signal emitted when the delegate is disposed.
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * Test whether the delegate has been disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Whether the manager is active.
   */
  get isActive() {
    return true;
  }
  /**
   * Dispose of the delegate and invoke the callback function.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._isDisposed = true;
    this._disposed.emit(void 0);
    signaling_1$3.Signal.clearData(this);
  }
}
basemanager.BaseManager = BaseManager;
var config = {};
var hasRequiredConfig;
function requireConfig() {
  if (hasRequiredConfig) return config;
  hasRequiredConfig = 1;
  Object.defineProperty(config, "__esModule", { value: true });
  config.ConfigWithDefaults = config.ConfigSection = void 0;
  const coreutils_12 = lib$9;
  const __1 = requireLib();
  const SERVICE_CONFIG_URL = "api/config";
  var ConfigSection;
  (function(ConfigSection2) {
    function create2(options) {
      const section = new DefaultConfigSection(options);
      return section.load().then(() => {
        return section;
      });
    }
    ConfigSection2.create = create2;
  })(ConfigSection || (config.ConfigSection = ConfigSection = {}));
  class DefaultConfigSection {
    /**
     * Construct a new config section.
     */
    constructor(options) {
      var _a;
      this._url = "unknown";
      const settings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
      this._url = coreutils_12.URLExt.join(settings.baseUrl, SERVICE_CONFIG_URL, encodeURIComponent(options.name));
    }
    /**
     * Get the data for this section.
     */
    get data() {
      return this._data;
    }
    /**
     * Load the initial data for this section.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    async load() {
      const response = await __1.ServerConnection.makeRequest(this._url, {}, this.serverSettings);
      if (response.status !== 200) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      this._data = await response.json();
    }
    /**
     * Modify the stored config values.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     *
     * Updates the local data immediately, sends the change to the server,
     * and updates the local data with the response, and fulfils the promise
     * with that data.
     */
    async update(newdata) {
      this._data = { ...this._data, ...newdata };
      const init = {
        method: "PATCH",
        body: JSON.stringify(newdata)
      };
      const response = await __1.ServerConnection.makeRequest(this._url, init, this.serverSettings);
      if (response.status !== 200) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      this._data = await response.json();
      return this._data;
    }
  }
  class ConfigWithDefaults {
    /**
     * Create a new config with defaults.
     */
    constructor(options) {
      var _a, _b;
      this._className = "";
      this._section = options.section;
      this._defaults = (_a = options.defaults) !== null && _a !== void 0 ? _a : {};
      this._className = (_b = options.className) !== null && _b !== void 0 ? _b : "";
    }
    /**
     * Get data from the config section or fall back to defaults.
     */
    get(key2) {
      const data = this._classData();
      return key2 in data ? data[key2] : this._defaults[key2];
    }
    /**
     * Set a config value.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     *
     * Sends the update to the server, and changes our local copy of the data
     * immediately.
     */
    set(key2, value) {
      const d = {};
      d[key2] = value;
      if (this._className) {
        const d2 = {};
        d2[this._className] = d;
        return this._section.update(d2);
      } else {
        return this._section.update(d);
      }
    }
    /**
     * Get data from the Section with our classname, if available.
     *
     * #### Notes
     * If we have no classname, get all of the data in the Section
     */
    _classData() {
      const data = this._section.data;
      if (this._className && this._className in data) {
        return data[this._className];
      }
      return data;
    }
  }
  config.ConfigWithDefaults = ConfigWithDefaults;
  return config;
}
var contents = {};
var validate$4 = {};
var validate$3 = {};
Object.defineProperty(validate$3, "__esModule", { value: true });
validate$3.validateProperty = void 0;
function validateProperty(object, name2, typeName, values = []) {
  if (!object.hasOwnProperty(name2)) {
    throw Error(`Missing property '${name2}'`);
  }
  const value = object[name2];
  if (typeName !== void 0) {
    let valid = true;
    switch (typeName) {
      case "array":
        valid = Array.isArray(value);
        break;
      case "object":
        valid = typeof value !== "undefined";
        break;
      default:
        valid = typeof value === typeName;
    }
    if (!valid) {
      throw new Error(`Property '${name2}' is not of type '${typeName}'`);
    }
    if (values.length > 0) {
      let valid2 = true;
      switch (typeName) {
        case "string":
        case "number":
        case "boolean":
          valid2 = values.includes(value);
          break;
        default:
          valid2 = values.findIndex((v) => v === value) >= 0;
          break;
      }
      if (!valid2) {
        throw new Error(`Property '${name2}' is not one of the valid values ${JSON.stringify(values)}`);
      }
    }
  }
}
validate$3.validateProperty = validateProperty;
Object.defineProperty(validate$4, "__esModule", { value: true });
validate$4.validateCheckpointModel = validate$4.validateContentsModel = void 0;
const validate_1$4 = validate$3;
function validateContentsModel(model) {
  (0, validate_1$4.validateProperty)(model, "name", "string");
  (0, validate_1$4.validateProperty)(model, "path", "string");
  (0, validate_1$4.validateProperty)(model, "type", "string");
  (0, validate_1$4.validateProperty)(model, "created", "string");
  (0, validate_1$4.validateProperty)(model, "last_modified", "string");
  (0, validate_1$4.validateProperty)(model, "mimetype", "object");
  (0, validate_1$4.validateProperty)(model, "content", "object");
  (0, validate_1$4.validateProperty)(model, "format", "object");
}
validate$4.validateContentsModel = validateContentsModel;
function validateCheckpointModel(model) {
  (0, validate_1$4.validateProperty)(model, "id", "string");
  (0, validate_1$4.validateProperty)(model, "last_modified", "string");
}
validate$4.validateCheckpointModel = validateCheckpointModel;
var hasRequiredContents;
function requireContents() {
  if (hasRequiredContents) return contents;
  hasRequiredContents = 1;
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result2, mod, k);
    }
    __setModuleDefault2(result2, mod);
    return result2;
  };
  Object.defineProperty(contents, "__esModule", { value: true });
  contents.Drive = contents.ContentsManager = contents.Contents = void 0;
  const coreutils_12 = lib$9;
  const signaling_12 = require$$0$1;
  const __1 = requireLib();
  const validate2 = __importStar2(validate$4);
  const SERVICE_DRIVE_URL = "api/contents";
  const FILES_URL = "files";
  var Contents;
  (function(Contents2) {
    function validateContentsModel2(contents2) {
      validate2.validateContentsModel(contents2);
    }
    Contents2.validateContentsModel = validateContentsModel2;
    function validateCheckpointModel2(checkpoint) {
      validate2.validateCheckpointModel(checkpoint);
    }
    Contents2.validateCheckpointModel = validateCheckpointModel2;
  })(Contents || (contents.Contents = Contents = {}));
  class ContentsManager {
    /**
     * Construct a new contents manager object.
     *
     * @param options - The options used to initialize the object.
     */
    constructor(options = {}) {
      var _a, _b;
      this._isDisposed = false;
      this._additionalDrives = /* @__PURE__ */ new Map();
      this._fileChanged = new signaling_12.Signal(this);
      const serverSettings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
      this._defaultDrive = (_b = options.defaultDrive) !== null && _b !== void 0 ? _b : new Drive({ serverSettings });
      this._defaultDrive.fileChanged.connect(this._onFileChanged, this);
    }
    /**
     * A signal emitted when a file operation takes place.
     */
    get fileChanged() {
      return this._fileChanged;
    }
    /**
     * Test whether the manager has been disposed.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Dispose of the resources held by the manager.
     */
    dispose() {
      if (this.isDisposed) {
        return;
      }
      this._isDisposed = true;
      signaling_12.Signal.clearData(this);
    }
    /**
     * Add an `IDrive` to the manager.
     */
    addDrive(drive) {
      this._additionalDrives.set(drive.name, drive);
      drive.fileChanged.connect(this._onFileChanged, this);
    }
    /**
     * Given a path, get a shared model factory from the
     * relevant backend. Returns `null` if the backend
     * does not provide one.
     */
    getSharedModelFactory(path2) {
      var _a;
      const [drive] = this._driveForPath(path2);
      return (_a = drive === null || drive === void 0 ? void 0 : drive.sharedModelFactory) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Given a path of the form `drive:local/portion/of/it.txt`
     * get the local part of it.
     *
     * @param path the path.
     *
     * @returns The local part of the path.
     */
    localPath(path2) {
      const parts = path2.split("/");
      const firstParts = parts[0].split(":");
      if (firstParts.length === 1 || !this._additionalDrives.has(firstParts[0])) {
        return coreutils_12.PathExt.removeSlash(path2);
      }
      return coreutils_12.PathExt.join(firstParts.slice(1).join(":"), ...parts.slice(1));
    }
    /**
     * Normalize a global path. Reduces '..' and '.' parts, and removes
     * leading slashes from the local part of the path, while retaining
     * the drive name if it exists.
     *
     * @param path the path.
     *
     * @returns The normalized path.
     */
    normalize(path2) {
      const parts = path2.split(":");
      if (parts.length === 1) {
        return coreutils_12.PathExt.normalize(path2);
      }
      return `${parts[0]}:${coreutils_12.PathExt.normalize(parts.slice(1).join(":"))}`;
    }
    /**
     * Resolve a global path, starting from the root path. Behaves like
     * posix-path.resolve, with 3 differences:
     *  - will never prepend cwd
     *  - if root has a drive name, the result is prefixed with "<drive>:"
     *  - before adding drive name, leading slashes are removed
     *
     * @param path the path.
     *
     * @returns The normalized path.
     */
    resolvePath(root2, path2) {
      const driveName = this.driveName(root2);
      const localPath = this.localPath(root2);
      const resolved = coreutils_12.PathExt.resolve("/", localPath, path2);
      return driveName ? `${driveName}:${resolved}` : resolved;
    }
    /**
     * Given a path of the form `drive:local/portion/of/it.txt`
     * get the name of the drive. If the path is missing
     * a drive portion, returns an empty string.
     *
     * @param path the path.
     *
     * @returns The drive name for the path, or the empty string.
     */
    driveName(path2) {
      const parts = path2.split("/");
      const firstParts = parts[0].split(":");
      if (firstParts.length === 1) {
        return "";
      }
      if (this._additionalDrives.has(firstParts[0])) {
        return firstParts[0];
      }
      return "";
    }
    /**
     * Get a file or directory.
     *
     * @param path The path to the file.
     *
     * @param options The options used to fetch the file.
     *
     * @returns A promise which resolves with the file content.
     */
    get(path2, options) {
      const [drive, localPath] = this._driveForPath(path2);
      return drive.get(localPath, options).then((contentsModel) => {
        const listing = [];
        if (contentsModel.type === "directory" && contentsModel.content) {
          for (const item of contentsModel.content) {
            listing.push({ ...item, path: this._toGlobalPath(drive, item.path) });
          }
          return {
            ...contentsModel,
            path: this._toGlobalPath(drive, localPath),
            content: listing,
            serverPath: contentsModel.path
          };
        } else {
          return {
            ...contentsModel,
            path: this._toGlobalPath(drive, localPath),
            serverPath: contentsModel.path
          };
        }
      });
    }
    /**
     * Get an encoded download url given a file path.
     *
     * @param path - An absolute POSIX file path on the server.
     *
     * #### Notes
     * It is expected that the path contains no relative paths.
     *
     * The returned URL may include a query parameter.
     */
    getDownloadUrl(path2) {
      const [drive, localPath] = this._driveForPath(path2);
      return drive.getDownloadUrl(localPath);
    }
    /**
     * Create a new untitled file or directory in the specified directory path.
     *
     * @param options The options used to create the file.
     *
     * @returns A promise which resolves with the created file content when the
     *    file is created.
     */
    newUntitled(options = {}) {
      if (options.path) {
        const globalPath = this.normalize(options.path);
        const [drive, localPath] = this._driveForPath(globalPath);
        return drive.newUntitled({ ...options, path: localPath }).then((contentsModel) => {
          return {
            ...contentsModel,
            path: coreutils_12.PathExt.join(globalPath, contentsModel.name),
            serverPath: contentsModel.path
          };
        });
      } else {
        return this._defaultDrive.newUntitled(options);
      }
    }
    /**
     * Delete a file.
     *
     * @param path - The path to the file.
     *
     * @returns A promise which resolves when the file is deleted.
     */
    delete(path2) {
      const [drive, localPath] = this._driveForPath(path2);
      return drive.delete(localPath);
    }
    /**
     * Rename a file or directory.
     *
     * @param path - The original file path.
     *
     * @param newPath - The new file path.
     *
     * @returns A promise which resolves with the new file contents model when
     *   the file is renamed.
     */
    rename(path2, newPath) {
      const [drive1, path1] = this._driveForPath(path2);
      const [drive2, path22] = this._driveForPath(newPath);
      if (drive1 !== drive2) {
        throw Error("ContentsManager: renaming files must occur within a Drive");
      }
      return drive1.rename(path1, path22).then((contentsModel) => {
        return {
          ...contentsModel,
          path: this._toGlobalPath(drive1, path22),
          serverPath: contentsModel.path
        };
      });
    }
    /**
     * Save a file.
     *
     * @param path - The desired file path.
     *
     * @param options - Optional overrides to the model.
     *
     * @returns A promise which resolves with the file content model when the
     *   file is saved.
     *
     * #### Notes
     * Ensure that `model.content` is populated for the file.
     */
    save(path2, options = {}) {
      const globalPath = this.normalize(path2);
      const [drive, localPath] = this._driveForPath(path2);
      return drive.save(localPath, { ...options, path: localPath }).then((contentsModel) => {
        return {
          ...contentsModel,
          path: globalPath,
          serverPath: contentsModel.path
        };
      });
    }
    /**
     * Copy a file into a given directory.
     *
     * @param path - The original file path.
     *
     * @param toDir - The destination directory path.
     *
     * @returns A promise which resolves with the new contents model when the
     *  file is copied.
     *
     * #### Notes
     * The server will select the name of the copied file.
     */
    copy(fromFile, toDir) {
      const [drive1, path1] = this._driveForPath(fromFile);
      const [drive2, path2] = this._driveForPath(toDir);
      if (drive1 === drive2) {
        return drive1.copy(path1, path2).then((contentsModel) => {
          return {
            ...contentsModel,
            path: this._toGlobalPath(drive1, contentsModel.path),
            serverPath: contentsModel.path
          };
        });
      } else {
        throw Error("Copying files between drives is not currently implemented");
      }
    }
    /**
     * Create a checkpoint for a file.
     *
     * @param path - The path of the file.
     *
     * @returns A promise which resolves with the new checkpoint model when the
     *   checkpoint is created.
     */
    createCheckpoint(path2) {
      const [drive, localPath] = this._driveForPath(path2);
      return drive.createCheckpoint(localPath);
    }
    /**
     * List available checkpoints for a file.
     *
     * @param path - The path of the file.
     *
     * @returns A promise which resolves with a list of checkpoint models for
     *    the file.
     */
    listCheckpoints(path2) {
      const [drive, localPath] = this._driveForPath(path2);
      return drive.listCheckpoints(localPath);
    }
    /**
     * Restore a file to a known checkpoint state.
     *
     * @param path - The path of the file.
     *
     * @param checkpointID - The id of the checkpoint to restore.
     *
     * @returns A promise which resolves when the checkpoint is restored.
     */
    restoreCheckpoint(path2, checkpointID) {
      const [drive, localPath] = this._driveForPath(path2);
      return drive.restoreCheckpoint(localPath, checkpointID);
    }
    /**
     * Delete a checkpoint for a file.
     *
     * @param path - The path of the file.
     *
     * @param checkpointID - The id of the checkpoint to delete.
     *
     * @returns A promise which resolves when the checkpoint is deleted.
     */
    deleteCheckpoint(path2, checkpointID) {
      const [drive, localPath] = this._driveForPath(path2);
      return drive.deleteCheckpoint(localPath, checkpointID);
    }
    /**
     * Given a drive and a local path, construct a fully qualified
     * path. The inverse of `_driveForPath`.
     *
     * @param drive an `IDrive`.
     *
     * @param localPath the local path on the drive.
     *
     * @returns the fully qualified path.
     */
    _toGlobalPath(drive, localPath) {
      if (drive === this._defaultDrive) {
        return coreutils_12.PathExt.removeSlash(localPath);
      } else {
        return `${drive.name}:${coreutils_12.PathExt.removeSlash(localPath)}`;
      }
    }
    /**
     * Given a path, get the `IDrive to which it refers,
     * where the path satisfies the pattern
     * `'driveName:path/to/file'`. If there is no `driveName`
     * prepended to the path, it returns the default drive.
     *
     * @param path a path to a file.
     *
     * @returns A tuple containing an `IDrive` object for the path,
     * and a local path for that drive.
     */
    _driveForPath(path2) {
      const driveName = this.driveName(path2);
      const localPath = this.localPath(path2);
      if (driveName) {
        return [this._additionalDrives.get(driveName), localPath];
      } else {
        return [this._defaultDrive, localPath];
      }
    }
    /**
     * Respond to fileChanged signals from the drives attached to
     * the manager. This prepends the drive name to the path if necessary,
     * and then forwards the signal.
     */
    _onFileChanged(sender, args) {
      var _a, _b;
      if (sender === this._defaultDrive) {
        this._fileChanged.emit(args);
      } else {
        let newValue = null;
        let oldValue = null;
        if ((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.path) {
          newValue = {
            ...args.newValue,
            path: this._toGlobalPath(sender, args.newValue.path)
          };
        }
        if ((_b = args.oldValue) === null || _b === void 0 ? void 0 : _b.path) {
          oldValue = {
            ...args.oldValue,
            path: this._toGlobalPath(sender, args.oldValue.path)
          };
        }
        this._fileChanged.emit({
          type: args.type,
          newValue,
          oldValue
        });
      }
    }
  }
  contents.ContentsManager = ContentsManager;
  class Drive {
    /**
     * Construct a new contents manager object.
     *
     * @param options - The options used to initialize the object.
     */
    constructor(options = {}) {
      var _a, _b, _c;
      this._isDisposed = false;
      this._fileChanged = new signaling_12.Signal(this);
      this.name = (_a = options.name) !== null && _a !== void 0 ? _a : "Default";
      this._apiEndpoint = (_b = options.apiEndpoint) !== null && _b !== void 0 ? _b : SERVICE_DRIVE_URL;
      this.serverSettings = (_c = options.serverSettings) !== null && _c !== void 0 ? _c : __1.ServerConnection.makeSettings();
    }
    /**
     * A signal emitted when a file operation takes place.
     */
    get fileChanged() {
      return this._fileChanged;
    }
    /**
     * Test whether the manager has been disposed.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Dispose of the resources held by the manager.
     */
    dispose() {
      if (this.isDisposed) {
        return;
      }
      this._isDisposed = true;
      signaling_12.Signal.clearData(this);
    }
    /**
     * Get a file or directory.
     *
     * @param localPath The path to the file.
     *
     * @param options The options used to fetch the file.
     *
     * @returns A promise which resolves with the file content.
     *
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
     */
    async get(localPath, options) {
      let url2 = this._getUrl(localPath);
      if (options) {
        if (options.type === "notebook") {
          delete options["format"];
        }
        const content = options.content ? "1" : "0";
        const hash = options.hash ? "1" : "0";
        const params2 = { ...options, content, hash };
        url2 += coreutils_12.URLExt.objectToQueryString(params2);
      }
      const settings = this.serverSettings;
      const response = await __1.ServerConnection.makeRequest(url2, {}, settings);
      if (response.status !== 200) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      validate2.validateContentsModel(data);
      return data;
    }
    /**
     * Get an encoded download url given a file path.
     *
     * @param localPath - An absolute POSIX file path on the server.
     *
     * #### Notes
     * It is expected that the path contains no relative paths.
     *
     * The returned URL may include a query parameter.
     */
    getDownloadUrl(localPath) {
      const baseUrl = this.serverSettings.baseUrl;
      let url2 = coreutils_12.URLExt.join(baseUrl, FILES_URL, coreutils_12.URLExt.encodeParts(localPath));
      let cookie = "";
      try {
        cookie = document.cookie;
      } catch (e) {
      }
      const xsrfTokenMatch = cookie.match("\\b_xsrf=([^;]*)\\b");
      if (xsrfTokenMatch) {
        const fullUrl = new URL(url2);
        fullUrl.searchParams.append("_xsrf", xsrfTokenMatch[1]);
        url2 = fullUrl.toString();
      }
      return Promise.resolve(url2);
    }
    /**
     * Create a new untitled file or directory in the specified directory path.
     *
     * @param options The options used to create the file.
     *
     * @returns A promise which resolves with the created file content when the
     *    file is created.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
     */
    async newUntitled(options = {}) {
      var _a;
      let body = "{}";
      if (options) {
        if (options.ext) {
          options.ext = Private2.normalizeExtension(options.ext);
        }
        body = JSON.stringify(options);
      }
      const settings = this.serverSettings;
      const url2 = this._getUrl((_a = options.path) !== null && _a !== void 0 ? _a : "");
      const init = {
        method: "POST",
        body
      };
      const response = await __1.ServerConnection.makeRequest(url2, init, settings);
      if (response.status !== 201) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      validate2.validateContentsModel(data);
      this._fileChanged.emit({
        type: "new",
        oldValue: null,
        newValue: data
      });
      return data;
    }
    /**
     * Delete a file.
     *
     * @param localPath - The path to the file.
     *
     * @returns A promise which resolves when the file is deleted.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
     */
    async delete(localPath) {
      const url2 = this._getUrl(localPath);
      const settings = this.serverSettings;
      const init = { method: "DELETE" };
      const response = await __1.ServerConnection.makeRequest(url2, init, settings);
      if (response.status !== 204) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      this._fileChanged.emit({
        type: "delete",
        oldValue: { path: localPath },
        newValue: null
      });
    }
    /**
     * Rename a file or directory.
     *
     * @param oldLocalPath - The original file path.
     *
     * @param newLocalPath - The new file path.
     *
     * @returns A promise which resolves with the new file contents model when
     *   the file is renamed.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
     */
    async rename(oldLocalPath, newLocalPath) {
      const settings = this.serverSettings;
      const url2 = this._getUrl(oldLocalPath);
      const init = {
        method: "PATCH",
        body: JSON.stringify({ path: newLocalPath })
      };
      const response = await __1.ServerConnection.makeRequest(url2, init, settings);
      if (response.status !== 200) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      validate2.validateContentsModel(data);
      this._fileChanged.emit({
        type: "rename",
        oldValue: { path: oldLocalPath },
        newValue: data
      });
      return data;
    }
    /**
     * Save a file.
     *
     * @param localPath - The desired file path.
     *
     * @param options - Optional overrides to the model.
     *
     * @returns A promise which resolves with the file content model when the
     *   file is saved.
     *
     * #### Notes
     * Ensure that `model.content` is populated for the file.
     *
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
     */
    async save(localPath, options = {}) {
      const settings = this.serverSettings;
      const url2 = this._getUrl(localPath);
      const init = {
        method: "PUT",
        body: JSON.stringify(options)
      };
      const response = await __1.ServerConnection.makeRequest(url2, init, settings);
      if (response.status !== 200 && response.status !== 201) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      validate2.validateContentsModel(data);
      this._fileChanged.emit({
        type: "save",
        oldValue: null,
        newValue: data
      });
      return data;
    }
    /**
     * Copy a file into a given directory.
     *
     * @param localPath - The original file path.
     *
     * @param toDir - The destination directory path.
     *
     * @returns A promise which resolves with the new contents model when the
     *  file is copied.
     *
     * #### Notes
     * The server will select the name of the copied file.
     *
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
     */
    async copy(fromFile, toDir) {
      const settings = this.serverSettings;
      const url2 = this._getUrl(toDir);
      const init = {
        method: "POST",
        body: JSON.stringify({ copy_from: fromFile })
      };
      const response = await __1.ServerConnection.makeRequest(url2, init, settings);
      if (response.status !== 201) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      validate2.validateContentsModel(data);
      this._fileChanged.emit({
        type: "new",
        oldValue: null,
        newValue: data
      });
      return data;
    }
    /**
     * Create a checkpoint for a file.
     *
     * @param localPath - The path of the file.
     *
     * @returns A promise which resolves with the new checkpoint model when the
     *   checkpoint is created.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
     */
    async createCheckpoint(localPath) {
      const url2 = this._getUrl(localPath, "checkpoints");
      const init = { method: "POST" };
      const response = await __1.ServerConnection.makeRequest(url2, init, this.serverSettings);
      if (response.status !== 201) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      validate2.validateCheckpointModel(data);
      return data;
    }
    /**
     * List available checkpoints for a file.
     *
     * @param localPath - The path of the file.
     *
     * @returns A promise which resolves with a list of checkpoint models for
     *    the file.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
     */
    async listCheckpoints(localPath) {
      const url2 = this._getUrl(localPath, "checkpoints");
      const response = await __1.ServerConnection.makeRequest(url2, {}, this.serverSettings);
      if (response.status !== 200) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid Checkpoint list");
      }
      for (let i2 = 0; i2 < data.length; i2++) {
        validate2.validateCheckpointModel(data[i2]);
      }
      return data;
    }
    /**
     * Restore a file to a known checkpoint state.
     *
     * @param localPath - The path of the file.
     *
     * @param checkpointID - The id of the checkpoint to restore.
     *
     * @returns A promise which resolves when the checkpoint is restored.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
     */
    async restoreCheckpoint(localPath, checkpointID) {
      const url2 = this._getUrl(localPath, "checkpoints", checkpointID);
      const init = { method: "POST" };
      const response = await __1.ServerConnection.makeRequest(url2, init, this.serverSettings);
      if (response.status !== 204) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    /**
     * Delete a checkpoint for a file.
     *
     * @param localPath - The path of the file.
     *
     * @param checkpointID - The id of the checkpoint to delete.
     *
     * @returns A promise which resolves when the checkpoint is deleted.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
     */
    async deleteCheckpoint(localPath, checkpointID) {
      const url2 = this._getUrl(localPath, "checkpoints", checkpointID);
      const init = { method: "DELETE" };
      const response = await __1.ServerConnection.makeRequest(url2, init, this.serverSettings);
      if (response.status !== 204) {
        const err = await __1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    /**
     * Get a REST url for a file given a path.
     */
    _getUrl(...args) {
      const parts = args.map((path2) => coreutils_12.URLExt.encodeParts(path2));
      const baseUrl = this.serverSettings.baseUrl;
      return coreutils_12.URLExt.join(baseUrl, this._apiEndpoint, ...parts);
    }
  }
  contents.Drive = Drive;
  var Private2;
  (function(Private3) {
    function normalizeExtension(extension) {
      if (extension.length > 0 && extension.indexOf(".") !== 0) {
        extension = `.${extension}`;
      }
      return extension;
    }
    Private3.normalizeExtension = normalizeExtension;
  })(Private2 || (Private2 = {}));
  return contents;
}
var event = {};
class Poll {
  /**
   * Instantiate a new poll with exponential backoff in case of failure.
   *
   * @param options - The poll instantiation options.
   */
  constructor(options) {
    var _a;
    this._disposed = new Signal(this);
    this._lingered = 0;
    this._tick = new PromiseDelegate();
    this._ticked = new Signal(this);
    this._factory = options.factory;
    this._linger = (_a = options.linger) !== null && _a !== void 0 ? _a : Private$m.DEFAULT_LINGER;
    this._standby = options.standby || Private$m.DEFAULT_STANDBY;
    this._state = { ...Private$m.DEFAULT_STATE, timestamp: (/* @__PURE__ */ new Date()).getTime() };
    const frequency = options.frequency || {};
    const max2 = Math.max(frequency.interval || 0, frequency.max || 0, Private$m.DEFAULT_FREQUENCY.max);
    this.frequency = { ...Private$m.DEFAULT_FREQUENCY, ...frequency, ...{ max: max2 } };
    this.name = options.name || Private$m.DEFAULT_NAME;
    if ("auto" in options ? options.auto : true) {
      setTimeout(() => this.start());
    }
  }
  /**
   * A signal emitted when the poll is disposed.
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * The polling frequency parameters.
   */
  get frequency() {
    return this._frequency;
  }
  set frequency(frequency) {
    if (this.isDisposed || JSONExt.deepEqual(frequency, this.frequency || {})) {
      return;
    }
    let { backoff, interval, max: max2 } = frequency;
    interval = Math.round(interval);
    max2 = Math.round(max2);
    if (typeof backoff === "number" && backoff < 1) {
      throw new Error("Poll backoff growth factor must be at least 1");
    }
    if ((interval < 0 || interval > max2) && interval !== Poll.NEVER) {
      throw new Error("Poll interval must be between 0 and max");
    }
    if (max2 > Poll.MAX_INTERVAL && max2 !== Poll.NEVER) {
      throw new Error(`Max interval must be less than ${Poll.MAX_INTERVAL}`);
    }
    this._frequency = { backoff, interval, max: max2 };
  }
  /**
   * Whether the poll is disposed.
   */
  get isDisposed() {
    return this.state.phase === "disposed";
  }
  /**
   * Indicates when the poll switches to standby.
   */
  get standby() {
    return this._standby;
  }
  set standby(standby) {
    if (this.isDisposed || this.standby === standby) {
      return;
    }
    this._standby = standby;
  }
  /**
   * The poll state, which is the content of the current poll tick.
   */
  get state() {
    return this._state;
  }
  /**
   * A promise that resolves when the poll next ticks.
   */
  get tick() {
    return this._tick.promise;
  }
  /**
   * A signal emitted when the poll ticks and fires off a new request.
   */
  get ticked() {
    return this._ticked;
  }
  /**
   * Return an async iterator that yields every tick.
   */
  async *[Symbol.asyncIterator]() {
    while (!this.isDisposed) {
      yield this.state;
      await this.tick.catch(() => void 0);
    }
  }
  /**
   * Dispose the poll.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._state = {
      ...Private$m.DISPOSED_STATE,
      timestamp: (/* @__PURE__ */ new Date()).getTime()
    };
    this._tick.promise.catch((_) => void 0);
    this._tick.reject(new Error(`Poll (${this.name}) is disposed.`));
    this._disposed.emit(void 0);
    Signal.clearData(this);
  }
  /**
   * Refreshes the poll. Schedules `refreshed` tick if necessary.
   *
   * @returns A promise that resolves after tick is scheduled and never rejects.
   *
   * #### Notes
   * The returned promise resolves after the tick is scheduled, but before
   * the polling action is run. To wait until after the poll action executes,
   * await the `poll.tick` promise: `await poll.refresh(); await poll.tick;`
   */
  refresh() {
    return this.schedule({
      cancel: ({ phase }) => phase === "refreshed",
      interval: Poll.IMMEDIATE,
      phase: "refreshed"
    });
  }
  /**
   * Schedule the next poll tick.
   *
   * @param next - The next poll state data to schedule. Defaults to standby.
   *
   * @param next.cancel - Cancels state transition if function returns `true`.
   *
   * @returns A promise that resolves when the next poll state is active.
   *
   * #### Notes
   * This method is not meant to be invoked by user code typically. It is public
   * to allow poll instances to be composed into classes that schedule ticks.
   */
  async schedule(next = {}) {
    if (this.isDisposed) {
      return;
    }
    if (next.cancel && next.cancel(this.state)) {
      return;
    }
    const pending = this._tick;
    const scheduled = new PromiseDelegate();
    const state = {
      interval: this.frequency.interval,
      payload: null,
      phase: "standby",
      timestamp: (/* @__PURE__ */ new Date()).getTime(),
      ...next
    };
    this._state = state;
    this._tick = scheduled;
    clearTimeout(this._timeout);
    this._ticked.emit(this.state);
    pending.resolve(this);
    await pending.promise;
    if (state.interval === Poll.NEVER) {
      this._timeout = void 0;
      return;
    }
    const execute = () => {
      if (this.isDisposed || this.tick !== scheduled.promise) {
        return;
      }
      this._execute();
    };
    this._timeout = setTimeout(execute, state.interval);
  }
  /**
   * Starts the poll. Schedules `started` tick if necessary.
   *
   * @returns A promise that resolves after tick is scheduled and never rejects.
   */
  start() {
    return this.schedule({
      cancel: ({ phase }) => phase !== "constructed" && phase !== "standby" && phase !== "stopped",
      interval: Poll.IMMEDIATE,
      phase: "started"
    });
  }
  /**
   * Stops the poll. Schedules `stopped` tick if necessary.
   *
   * @returns A promise that resolves after tick is scheduled and never rejects.
   */
  stop() {
    return this.schedule({
      cancel: ({ phase }) => phase === "stopped",
      interval: Poll.NEVER,
      phase: "stopped"
    });
  }
  /**
   * Whether the poll is hidden.
   *
   * #### Notes
   * This property is only relevant in a browser context.
   */
  get hidden() {
    return Private$m.hidden;
  }
  /**
   * Execute a new poll factory promise or stand by if necessary.
   */
  _execute() {
    let standby = typeof this.standby === "function" ? this.standby() : this.standby;
    if (standby === "never") {
      standby = false;
    } else if (standby === "when-hidden") {
      if (this.hidden) {
        standby = ++this._lingered > this._linger;
      } else {
        this._lingered = 0;
        standby = false;
      }
    }
    if (standby) {
      void this.schedule();
      return;
    }
    const pending = this.tick;
    this._factory(this.state).then((resolved) => {
      if (this.isDisposed || this.tick !== pending) {
        return;
      }
      void this.schedule({
        payload: resolved,
        phase: this.state.phase === "rejected" ? "reconnected" : "resolved"
      });
    }).catch((rejected) => {
      if (this.isDisposed || this.tick !== pending) {
        return;
      }
      void this.schedule({
        interval: Private$m.sleep(this.frequency, this.state),
        payload: rejected,
        phase: "rejected"
      });
    });
  }
}
(function(Poll2) {
  Poll2.IMMEDIATE = 0;
  Poll2.MAX_INTERVAL = 2147483647;
  Poll2.NEVER = Infinity;
})(Poll || (Poll = {}));
var Private$m;
(function(Private2) {
  Private2.DEFAULT_BACKOFF = 3;
  Private2.DEFAULT_FREQUENCY = {
    backoff: true,
    interval: 1e3,
    max: 30 * 1e3
  };
  Private2.DEFAULT_LINGER = 1;
  Private2.DEFAULT_NAME = "unknown";
  Private2.DEFAULT_STANDBY = "when-hidden";
  Private2.DEFAULT_STATE = {
    interval: Poll.NEVER,
    payload: null,
    phase: "constructed",
    timestamp: (/* @__PURE__ */ new Date(0)).getTime()
  };
  Private2.DISPOSED_STATE = {
    interval: Poll.NEVER,
    payload: null,
    phase: "disposed",
    timestamp: (/* @__PURE__ */ new Date(0)).getTime()
  };
  function sleep(frequency, last2) {
    const { backoff, interval, max: max2 } = frequency;
    if (interval === Poll.NEVER) {
      return interval;
    }
    const growth = backoff === true ? Private2.DEFAULT_BACKOFF : backoff === false ? 1 : backoff;
    const random = getRandomIntInclusive(interval, last2.interval * growth);
    return Math.min(max2, random);
  }
  Private2.sleep = sleep;
  Private2.hidden = (() => {
    if (typeof document === "undefined") {
      return false;
    }
    document.addEventListener("visibilitychange", () => {
      Private2.hidden = document.visibilityState === "hidden";
    });
    document.addEventListener("pagehide", () => {
      Private2.hidden = document.visibilityState === "hidden";
    });
    return document.visibilityState === "hidden";
  })();
  function getRandomIntInclusive(min2, max2) {
    min2 = Math.ceil(min2);
    max2 = Math.floor(max2);
    return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
  }
})(Private$m || (Private$m = {}));
class RateLimiter {
  /**
   * Instantiate a rate limiter.
   *
   * @param fn - The function to rate limit.
   *
   * @param limit - The rate limit; defaults to 500ms.
   */
  constructor(fn, limit2 = 500) {
    this.args = void 0;
    this.payload = null;
    this.limit = limit2;
    this.poll = new Poll({
      auto: false,
      factory: async () => {
        const { args } = this;
        this.args = void 0;
        return fn(...args);
      },
      frequency: { backoff: false, interval: Poll.NEVER, max: Poll.NEVER },
      standby: "never"
    });
    this.payload = new PromiseDelegate();
    this.poll.ticked.connect((_, state) => {
      const { payload } = this;
      if (state.phase === "resolved") {
        this.payload = new PromiseDelegate();
        payload.resolve(state.payload);
        return;
      }
      if (state.phase === "rejected" || state.phase === "stopped") {
        this.payload = new PromiseDelegate();
        payload.promise.catch((_2) => void 0);
        payload.reject(state.payload);
        return;
      }
    }, this);
  }
  /**
   * Whether the rate limiter is disposed.
   */
  get isDisposed() {
    return this.payload === null;
  }
  /**
   * Disposes the rate limiter.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.args = void 0;
    this.payload = null;
    this.poll.dispose();
  }
  /**
   * Stop the function if it is mid-flight.
   */
  async stop() {
    return this.poll.stop();
  }
}
class Debouncer extends RateLimiter {
  /**
   * Invokes the function and only executes after rate limit has elapsed.
   * Each invocation resets the timer.
   */
  invoke(...args) {
    this.args = args;
    void this.poll.schedule({ interval: this.limit, phase: "invoked" });
    return this.payload.promise;
  }
}
class Throttler extends RateLimiter {
  /**
   * Instantiate a throttler.
   *
   * @param fn - The function being throttled.
   *
   * @param options - Throttling configuration or throttling limit in ms.
   *
   * #### Notes
   * The `edge` defaults to `leading`; the `limit` defaults to `500`.
   */
  constructor(fn, options) {
    super(fn, typeof options === "number" ? options : options && options.limit);
    this._trailing = false;
    if (typeof options !== "number" && options && options.edge === "trailing") {
      this._trailing = true;
    }
    this._interval = this._trailing ? this.limit : Poll.IMMEDIATE;
  }
  /**
   * Throttles function invocations if one is currently in flight.
   */
  invoke(...args) {
    const idle = this.poll.state.phase !== "invoked";
    if (idle || this._trailing) {
      this.args = args;
    }
    if (idle) {
      void this.poll.schedule({ interval: this._interval, phase: "invoked" });
    }
    return this.payload.promise;
  }
}
const index_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Debouncer,
  get Poll() {
    return Poll;
  },
  RateLimiter,
  Throttler
}, Symbol.toStringTag, { value: "Module" }));
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(index_es6);
Object.defineProperty(event, "__esModule", { value: true });
event.EventManager = void 0;
const coreutils_1$8 = lib$9;
const polling_1$2 = require$$2$1;
const signaling_1$2 = require$$0$1;
const serverconnection_1$6 = serverconnection;
const SERVICE_EVENTS_URL = "api/events";
class EventManager {
  /**
   * Create a new event manager.
   */
  constructor(options = {}) {
    var _a;
    this._socket = null;
    this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1$6.ServerConnection.makeSettings();
    this._poll = new polling_1$2.Poll({ factory: () => this._subscribe() });
    this._stream = new signaling_1$2.Stream(this);
    void this._poll.start();
  }
  /**
   * Whether the event manager is disposed.
   */
  get isDisposed() {
    return this._poll.isDisposed;
  }
  /**
   * An event stream that emits and yields each new event.
   */
  get stream() {
    return this._stream;
  }
  /**
   * Dispose the event manager.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._poll.dispose();
    const socket = this._socket;
    if (socket) {
      this._socket = null;
      socket.onopen = () => void 0;
      socket.onerror = () => void 0;
      socket.onmessage = () => void 0;
      socket.onclose = () => void 0;
      socket.close();
    }
    signaling_1$2.Signal.clearData(this);
    this._stream.stop();
  }
  /**
   * Post an event request to be emitted by the event bus.
   */
  async emit(event2) {
    const { serverSettings } = this;
    const { baseUrl } = serverSettings;
    const { makeRequest, ResponseError } = serverconnection_1$6.ServerConnection;
    const url2 = coreutils_1$8.URLExt.join(baseUrl, SERVICE_EVENTS_URL);
    const init = { body: JSON.stringify(event2), method: "POST" };
    const response = await makeRequest(url2, init, serverSettings);
    if (response.status !== 204) {
      throw new ResponseError(response);
    }
  }
  /**
   * Subscribe to event bus emissions.
   */
  _subscribe() {
    return new Promise((_, reject) => {
      if (this.isDisposed) {
        return;
      }
      const { appendToken, token, WebSocket: WebSocket2, wsUrl } = this.serverSettings;
      let url2 = coreutils_1$8.URLExt.join(wsUrl, SERVICE_EVENTS_URL, "subscribe");
      if (appendToken && token !== "") {
        url2 += `?token=${encodeURIComponent(token)}`;
      }
      const socket = this._socket = new WebSocket2(url2);
      const stream = this._stream;
      socket.onclose = () => reject(new Error("EventManager socket closed"));
      socket.onmessage = (msg) => msg.data && stream.emit(JSON.parse(msg.data));
    });
  }
}
event.EventManager = EventManager;
var kernel$1 = {};
var kernel = {};
Object.defineProperty(kernel, "__esModule", { value: true });
var restapi$4 = {};
var validate$2 = {};
Object.defineProperty(validate$2, "__esModule", { value: true });
validate$2.validateModels = validate$2.validateModel = validate$2.validateMessage = void 0;
const validate_1$3 = validate$3;
const HEADER_FIELDS = ["username", "version", "session", "msg_id", "msg_type"];
const IOPUB_CONTENT_FIELDS = {
  stream: { name: "string", text: "string" },
  display_data: { data: "object", metadata: "object" },
  execute_input: { code: "string", execution_count: "number" },
  execute_result: {
    execution_count: "number",
    data: "object",
    metadata: "object"
  },
  error: { ename: "string", evalue: "string", traceback: "object" },
  status: {
    execution_state: [
      "string",
      ["starting", "idle", "busy", "restarting", "dead"]
    ]
  },
  clear_output: { wait: "boolean" },
  comm_open: { comm_id: "string", target_name: "string", data: "object" },
  comm_msg: { comm_id: "string", data: "object" },
  comm_close: { comm_id: "string" },
  shutdown_reply: { restart: "boolean" }
  // Emitted by the IPython kernel.
};
function validateHeader(header) {
  for (let i2 = 0; i2 < HEADER_FIELDS.length; i2++) {
    (0, validate_1$3.validateProperty)(header, HEADER_FIELDS[i2], "string");
  }
}
function validateMessage(msg) {
  (0, validate_1$3.validateProperty)(msg, "metadata", "object");
  (0, validate_1$3.validateProperty)(msg, "content", "object");
  (0, validate_1$3.validateProperty)(msg, "channel", "string");
  validateHeader(msg.header);
  if (msg.channel === "iopub") {
    validateIOPubContent(msg);
  }
}
validate$2.validateMessage = validateMessage;
function validateIOPubContent(msg) {
  if (msg.channel === "iopub") {
    const fields = IOPUB_CONTENT_FIELDS[msg.header.msg_type];
    if (fields === void 0) {
      return;
    }
    const names = Object.keys(fields);
    const content = msg.content;
    for (let i2 = 0; i2 < names.length; i2++) {
      let args = fields[names[i2]];
      if (!Array.isArray(args)) {
        args = [args];
      }
      (0, validate_1$3.validateProperty)(content, names[i2], ...args);
    }
  }
}
function validateModel$1(model) {
  (0, validate_1$3.validateProperty)(model, "name", "string");
  (0, validate_1$3.validateProperty)(model, "id", "string");
}
validate$2.validateModel = validateModel$1;
function validateModels$1(models) {
  if (!Array.isArray(models)) {
    throw new Error("Invalid kernel list");
  }
  models.forEach((d) => validateModel$1(d));
}
validate$2.validateModels = validateModels$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getKernelModel = exports.shutdownKernel = exports.interruptKernel = exports.restartKernel = exports.startNew = exports.listRunning = exports.KERNEL_SERVICE_URL = void 0;
  const serverconnection_12 = serverconnection;
  const coreutils_12 = lib$9;
  const validate_12 = validate$2;
  exports.KERNEL_SERVICE_URL = "api/kernels";
  async function listRunning(settings = serverconnection_12.ServerConnection.makeSettings()) {
    const url2 = coreutils_12.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL);
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, {}, settings);
    if (response.status !== 200) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    (0, validate_12.validateModels)(data);
    return data;
  }
  exports.listRunning = listRunning;
  async function startNew(options = {}, settings = serverconnection_12.ServerConnection.makeSettings()) {
    const url2 = coreutils_12.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL);
    const init = {
      method: "POST",
      body: JSON.stringify(options)
    };
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, init, settings);
    if (response.status !== 201) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    (0, validate_12.validateModel)(data);
    return data;
  }
  exports.startNew = startNew;
  async function restartKernel(id, settings = serverconnection_12.ServerConnection.makeSettings()) {
    const url2 = coreutils_12.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL, encodeURIComponent(id), "restart");
    const init = { method: "POST" };
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, init, settings);
    if (response.status !== 200) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    (0, validate_12.validateModel)(data);
  }
  exports.restartKernel = restartKernel;
  async function interruptKernel(id, settings = serverconnection_12.ServerConnection.makeSettings()) {
    const url2 = coreutils_12.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL, encodeURIComponent(id), "interrupt");
    const init = { method: "POST" };
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, init, settings);
    if (response.status !== 204) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
  }
  exports.interruptKernel = interruptKernel;
  async function shutdownKernel(id, settings = serverconnection_12.ServerConnection.makeSettings()) {
    const url2 = coreutils_12.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL, encodeURIComponent(id));
    const init = { method: "DELETE" };
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, init, settings);
    if (response.status === 404) {
      const msg = `The kernel "${id}" does not exist on the server`;
      console.warn(msg);
    } else if (response.status !== 204) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
  }
  exports.shutdownKernel = shutdownKernel;
  async function getKernelModel(id, settings = serverconnection_12.ServerConnection.makeSettings()) {
    const url2 = coreutils_12.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL, encodeURIComponent(id));
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, {}, settings);
    if (response.status === 404) {
      return void 0;
    } else if (response.status !== 200) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    (0, validate_12.validateModel)(data);
    return data;
  }
  exports.getKernelModel = getKernelModel;
})(restapi$4);
var _default$2 = {};
var comm = {};
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(index_es6$1);
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result2 = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$4(result2, mod, k);
  }
  __setModuleDefault$4(result2, mod);
  return result2;
};
Object.defineProperty(comm, "__esModule", { value: true });
comm.CommHandler = void 0;
const disposable_1$1 = require$$1;
const KernelMessage$1 = __importStar$4(messages);
class CommHandler extends disposable_1$1.DisposableDelegate {
  /**
   * Construct a new comm channel.
   */
  constructor(target2, id, kernel2, disposeCb) {
    super(disposeCb);
    this._target = "";
    this._id = "";
    this._id = id;
    this._target = target2;
    this._kernel = kernel2;
  }
  /**
   * The unique id for the comm channel.
   */
  get commId() {
    return this._id;
  }
  /**
   * The target name for the comm channel.
   */
  get targetName() {
    return this._target;
  }
  /**
   * Get the callback for a comm close event.
   *
   * #### Notes
   * This is called when the comm is closed from either the server or client.
   *
   * **See also:** [[ICommClose]], [[close]]
   */
  get onClose() {
    return this._onClose;
  }
  /**
   * Set the callback for a comm close event.
   *
   * #### Notes
   * This is called when the comm is closed from either the server or client. If
   * the function returns a promise, and the kernel was closed from the server,
   * kernel message processing will pause until the returned promise is
   * fulfilled.
   *
   * **See also:** [[close]]
   */
  set onClose(cb) {
    this._onClose = cb;
  }
  /**
   * Get the callback for a comm message received event.
   */
  get onMsg() {
    return this._onMsg;
  }
  /**
   * Set the callback for a comm message received event.
   *
   * #### Notes
   * This is called when a comm message is received. If the function returns a
   * promise, kernel message processing will pause until it is fulfilled.
   */
  set onMsg(cb) {
    this._onMsg = cb;
  }
  /**
   * Open a comm with optional data and metadata.
   *
   * #### Notes
   * This sends a `comm_open` message to the server.
   *
   * **See also:** [[ICommOpen]]
   */
  open(data, metadata, buffers = []) {
    if (this.isDisposed || this._kernel.isDisposed) {
      throw new Error("Cannot open");
    }
    const msg = KernelMessage$1.createMessage({
      msgType: "comm_open",
      channel: "shell",
      username: this._kernel.username,
      session: this._kernel.clientId,
      content: {
        comm_id: this._id,
        target_name: this._target,
        data: data !== null && data !== void 0 ? data : {}
      },
      metadata,
      buffers
    });
    return this._kernel.sendShellMessage(msg, false, true);
  }
  /**
   * Send a `comm_msg` message to the kernel.
   *
   * #### Notes
   * This is a no-op if the comm has been closed.
   *
   * **See also:** [[ICommMsg]]
   */
  send(data, metadata, buffers = [], disposeOnDone = true) {
    if (this.isDisposed || this._kernel.isDisposed) {
      throw new Error("Cannot send");
    }
    const msg = KernelMessage$1.createMessage({
      msgType: "comm_msg",
      channel: "shell",
      username: this._kernel.username,
      session: this._kernel.clientId,
      content: {
        comm_id: this._id,
        data
      },
      metadata,
      buffers
    });
    return this._kernel.sendShellMessage(msg, false, disposeOnDone);
  }
  /**
   * Close the comm.
   *
   * #### Notes
   * This will send a `comm_close` message to the kernel, and call the
   * `onClose` callback if set.
   *
   * This is a no-op if the comm is already closed.
   *
   * **See also:** [[ICommClose]], [[onClose]]
   */
  close(data, metadata, buffers = []) {
    if (this.isDisposed || this._kernel.isDisposed) {
      throw new Error("Cannot close");
    }
    const msg = KernelMessage$1.createMessage({
      msgType: "comm_close",
      channel: "shell",
      username: this._kernel.username,
      session: this._kernel.clientId,
      content: {
        comm_id: this._id,
        data: data !== null && data !== void 0 ? data : {}
      },
      metadata,
      buffers
    });
    const future2 = this._kernel.sendShellMessage(msg, false, true);
    const onClose = this._onClose;
    if (onClose) {
      const ioMsg = KernelMessage$1.createMessage({
        msgType: "comm_close",
        channel: "iopub",
        username: this._kernel.username,
        session: this._kernel.clientId,
        content: {
          comm_id: this._id,
          data: data !== null && data !== void 0 ? data : {}
        },
        metadata,
        buffers
      });
      void onClose(ioMsg);
    }
    this.dispose();
    return future2;
  }
}
comm.CommHandler = CommHandler;
var future = {};
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result2 = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result2, mod, k);
  }
  __setModuleDefault$3(result2, mod);
  return result2;
};
Object.defineProperty(future, "__esModule", { value: true });
future.KernelShellFutureHandler = future.KernelControlFutureHandler = future.KernelFutureHandler = void 0;
const coreutils_1$7 = require$$1$2;
const disposable_1 = require$$1;
const KernelMessage = __importStar$3(messages);
class KernelFutureHandler extends disposable_1.DisposableDelegate {
  /**
   * Construct a new KernelFutureHandler.
   */
  constructor(cb, msg, expectReply, disposeOnDone, kernel2) {
    super(cb);
    this._status = 0;
    this._stdin = Private$l.noOp;
    this._iopub = Private$l.noOp;
    this._reply = Private$l.noOp;
    this._done = new coreutils_1$7.PromiseDelegate();
    this._hooks = new Private$l.HookList();
    this._disposeOnDone = true;
    this._msg = msg;
    if (!expectReply) {
      this._setFlag(Private$l.KernelFutureFlag.GotReply);
    }
    this._disposeOnDone = disposeOnDone;
    this._kernel = kernel2;
  }
  /**
   * Get the original outgoing message.
   */
  get msg() {
    return this._msg;
  }
  /**
   * A promise that resolves when the future is done.
   */
  get done() {
    return this._done.promise;
  }
  /**
   * Get the reply handler.
   */
  get onReply() {
    return this._reply;
  }
  /**
   * Set the reply handler.
   */
  set onReply(cb) {
    this._reply = cb;
  }
  /**
   * Get the iopub handler.
   */
  get onIOPub() {
    return this._iopub;
  }
  /**
   * Set the iopub handler.
   */
  set onIOPub(cb) {
    this._iopub = cb;
  }
  /**
   * Get the stdin handler.
   */
  get onStdin() {
    return this._stdin;
  }
  /**
   * Set the stdin handler.
   */
  set onStdin(cb) {
    this._stdin = cb;
  }
  /**
   * Register hook for IOPub messages.
   *
   * @param hook - The callback invoked for an IOPub message.
   *
   * #### Notes
   * The IOPub hook system allows you to preempt the handlers for IOPub
   * messages handled by the future.
   *
   * The most recently registered hook is run first. A hook can return a
   * boolean or a promise to a boolean, in which case all kernel message
   * processing pauses until the promise is fulfilled. If a hook return value
   * resolves to false, any later hooks will not run and the function will
   * return a promise resolving to false. If a hook throws an error, the error
   * is logged to the console and the next hook is run. If a hook is
   * registered during the hook processing, it will not run until the next
   * message. If a hook is removed during the hook processing, it will be
   * deactivated immediately.
   */
  registerMessageHook(hook) {
    if (this.isDisposed) {
      throw new Error("Kernel future is disposed");
    }
    this._hooks.add(hook);
  }
  /**
   * Remove a hook for IOPub messages.
   *
   * @param hook - The hook to remove.
   *
   * #### Notes
   * If a hook is removed during the hook processing, it will be deactivated immediately.
   */
  removeMessageHook(hook) {
    if (this.isDisposed) {
      return;
    }
    this._hooks.remove(hook);
  }
  /**
   * Send an `input_reply` message.
   */
  sendInputReply(content, parent_header) {
    this._kernel.sendInputReply(content, parent_header);
  }
  /**
   * Dispose and unregister the future.
   */
  dispose() {
    this._stdin = Private$l.noOp;
    this._iopub = Private$l.noOp;
    this._reply = Private$l.noOp;
    this._hooks = null;
    if (!this._testFlag(Private$l.KernelFutureFlag.IsDone)) {
      this._done.promise.catch(() => {
      });
      this._done.reject(new Error(`Canceled future for ${this.msg.header.msg_type} message before replies were done`));
    }
    super.dispose();
  }
  /**
   * Handle an incoming kernel message.
   */
  async handleMsg(msg) {
    switch (msg.channel) {
      case "control":
      case "shell":
        if (msg.channel === this.msg.channel && msg.parent_header.msg_id === this.msg.header.msg_id) {
          await this._handleReply(msg);
        }
        break;
      case "stdin":
        await this._handleStdin(msg);
        break;
      case "iopub":
        await this._handleIOPub(msg);
        break;
    }
  }
  async _handleReply(msg) {
    const reply = this._reply;
    if (reply) {
      await reply(msg);
    }
    this._replyMsg = msg;
    this._setFlag(Private$l.KernelFutureFlag.GotReply);
    if (this._testFlag(Private$l.KernelFutureFlag.GotIdle)) {
      this._handleDone();
    }
  }
  async _handleStdin(msg) {
    this._kernel.hasPendingInput = true;
    const stdin = this._stdin;
    if (stdin) {
      await stdin(msg);
    }
  }
  async _handleIOPub(msg) {
    const process2 = await this._hooks.process(msg);
    const iopub = this._iopub;
    if (process2 && iopub) {
      await iopub(msg);
    }
    if (KernelMessage.isStatusMsg(msg) && msg.content.execution_state === "idle") {
      this._setFlag(Private$l.KernelFutureFlag.GotIdle);
      if (this._testFlag(Private$l.KernelFutureFlag.GotReply)) {
        this._handleDone();
      }
    }
  }
  _handleDone() {
    if (this._testFlag(Private$l.KernelFutureFlag.IsDone)) {
      return;
    }
    this._setFlag(Private$l.KernelFutureFlag.IsDone);
    this._done.resolve(this._replyMsg);
    if (this._disposeOnDone) {
      this.dispose();
    }
  }
  /**
   * Test whether the given future flag is set.
   */
  _testFlag(flag) {
    return (this._status & flag) !== 0;
  }
  /**
   * Set the given future flag.
   */
  _setFlag(flag) {
    this._status |= flag;
  }
}
future.KernelFutureHandler = KernelFutureHandler;
class KernelControlFutureHandler extends KernelFutureHandler {
}
future.KernelControlFutureHandler = KernelControlFutureHandler;
class KernelShellFutureHandler extends KernelFutureHandler {
}
future.KernelShellFutureHandler = KernelShellFutureHandler;
var Private$l;
(function(Private2) {
  Private2.noOp = () => {
  };
  const defer = (() => {
    const ok = typeof requestAnimationFrame === "function";
    return ok ? requestAnimationFrame : setImmediate;
  })();
  class HookList {
    constructor() {
      this._hooks = [];
    }
    /**
     * Register a hook.
     *
     * @param hook - The callback to register.
     */
    add(hook) {
      this.remove(hook);
      this._hooks.push(hook);
    }
    /**
     * Remove a hook, if it exists in the hook list.
     *
     * @param hook - The callback to remove.
     */
    remove(hook) {
      const index = this._hooks.indexOf(hook);
      if (index >= 0) {
        this._hooks[index] = null;
        this._scheduleCompact();
      }
    }
    /**
     * Process a message through the hooks.
     *
     * @returns a promise resolving to false if any hook resolved as false,
     * otherwise true
     *
     * #### Notes
     * The most recently registered hook is run first. A hook can return a
     * boolean or a promise to a boolean, in which case processing pauses until
     * the promise is fulfilled. If a hook return value resolves to false, any
     * later hooks will not run and the function will return a promise resolving
     * to false. If a hook throws an error, the error is logged to the console
     * and the next hook is run. If a hook is registered during the hook
     * processing, it will not run until the next message. If a hook is removed
     * during the hook processing, it will be deactivated immediately.
     */
    async process(msg) {
      await this._processing;
      const processing = new coreutils_1$7.PromiseDelegate();
      this._processing = processing.promise;
      let continueHandling;
      for (let i2 = this._hooks.length - 1; i2 >= 0; i2--) {
        const hook = this._hooks[i2];
        if (hook === null) {
          continue;
        }
        try {
          continueHandling = await hook(msg);
        } catch (err) {
          continueHandling = true;
          console.error(err);
        }
        if (continueHandling === false) {
          processing.resolve(void 0);
          return false;
        }
      }
      processing.resolve(void 0);
      return true;
    }
    /**
     * Schedule a cleanup of the list, removing any hooks that have been nulled out.
     */
    _scheduleCompact() {
      if (!this._compactScheduled) {
        this._compactScheduled = true;
        defer(() => {
          this._processing = this._processing.then(() => {
            this._compactScheduled = false;
            this._compact();
          });
        });
      }
    }
    /**
     * Compact the list, removing any nulls.
     */
    _compact() {
      let numNulls = 0;
      for (let i2 = 0, len = this._hooks.length; i2 < len; i2++) {
        const hook = this._hooks[i2];
        if (this._hooks[i2] === null) {
          numNulls++;
        } else {
          this._hooks[i2 - numNulls] = hook;
        }
      }
      this._hooks.length -= numNulls;
    }
  }
  Private2.HookList = HookList;
  (function(KernelFutureFlag) {
    KernelFutureFlag[KernelFutureFlag["GotReply"] = 1] = "GotReply";
    KernelFutureFlag[KernelFutureFlag["GotIdle"] = 2] = "GotIdle";
    KernelFutureFlag[KernelFutureFlag["IsDone"] = 4] = "IsDone";
    KernelFutureFlag[KernelFutureFlag["DisposeOnDone"] = 8] = "DisposeOnDone";
  })(Private2.KernelFutureFlag || (Private2.KernelFutureFlag = {}));
})(Private$l || (Private$l = {}));
var kernelspec$1 = {};
var kernelspec = {};
Object.defineProperty(kernelspec, "__esModule", { value: true });
var restapi$3 = {};
var validate$1 = {};
Object.defineProperty(validate$1, "__esModule", { value: true });
validate$1.validateSpecModels = validate$1.validateSpecModel = void 0;
const validate_1$2 = validate$3;
function validateSpecModel(data) {
  const spec = data.spec;
  if (!spec) {
    throw new Error("Invalid kernel spec");
  }
  (0, validate_1$2.validateProperty)(data, "name", "string");
  (0, validate_1$2.validateProperty)(data, "resources", "object");
  (0, validate_1$2.validateProperty)(spec, "language", "string");
  (0, validate_1$2.validateProperty)(spec, "display_name", "string");
  (0, validate_1$2.validateProperty)(spec, "argv", "array");
  let metadata = null;
  if (spec.hasOwnProperty("metadata")) {
    (0, validate_1$2.validateProperty)(spec, "metadata", "object");
    metadata = spec.metadata;
  }
  let env = null;
  if (spec.hasOwnProperty("env")) {
    (0, validate_1$2.validateProperty)(spec, "env", "object");
    env = spec.env;
  }
  return {
    name: data.name,
    resources: data.resources,
    language: spec.language,
    display_name: spec.display_name,
    argv: spec.argv,
    metadata,
    env
  };
}
validate$1.validateSpecModel = validateSpecModel;
function validateSpecModels(data) {
  if (!data.hasOwnProperty("kernelspecs")) {
    throw new Error("No kernelspecs found");
  }
  let keys2 = Object.keys(data.kernelspecs);
  const kernelspecs = /* @__PURE__ */ Object.create(null);
  let defaultSpec = data.default;
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const ks = data.kernelspecs[keys2[i2]];
    try {
      kernelspecs[keys2[i2]] = validateSpecModel(ks);
    } catch (err) {
      console.warn(`Removing errant kernel spec: ${keys2[i2]}`);
    }
  }
  keys2 = Object.keys(kernelspecs);
  if (!keys2.length) {
    throw new Error("No valid kernelspecs found");
  }
  if (!defaultSpec || typeof defaultSpec !== "string" || !(defaultSpec in kernelspecs)) {
    defaultSpec = keys2[0];
    console.warn(`Default kernel not found, using '${keys2[0]}'`);
  }
  return {
    default: defaultSpec,
    kernelspecs
  };
}
validate$1.validateSpecModels = validateSpecModels;
Object.defineProperty(restapi$3, "__esModule", { value: true });
restapi$3.getSpecs = void 0;
const serverconnection_1$5 = serverconnection;
const validate_1$1 = validate$1;
const coreutils_1$6 = lib$9;
const KERNELSPEC_SERVICE_URL = "api/kernelspecs";
async function getSpecs(settings = serverconnection_1$5.ServerConnection.makeSettings()) {
  const url2 = coreutils_1$6.URLExt.join(settings.baseUrl, KERNELSPEC_SERVICE_URL);
  const response = await serverconnection_1$5.ServerConnection.makeRequest(url2, {}, settings);
  if (response.status !== 200) {
    const err = await serverconnection_1$5.ServerConnection.ResponseError.create(response);
    throw err;
  }
  const data = await response.json();
  return (0, validate_1$1.validateSpecModels)(data);
}
restapi$3.getSpecs = getSpecs;
var manager$4 = {};
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result2 = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result2, mod, k);
  }
  __setModuleDefault$2(result2, mod);
  return result2;
};
Object.defineProperty(manager$4, "__esModule", { value: true });
manager$4.KernelSpecManager = void 0;
const coreutils_1$5 = require$$1$2;
const polling_1$1 = require$$2$1;
const signaling_1$1 = require$$0$1;
const restapi$2 = __importStar$2(restapi$3);
const basemanager_1$1 = basemanager;
class KernelSpecManager extends basemanager_1$1.BaseManager {
  /**
   * Construct a new kernel spec manager.
   *
   * @param options - The default options for kernel.
   */
  constructor(options = {}) {
    var _a;
    super(options);
    this._isReady = false;
    this._connectionFailure = new signaling_1$1.Signal(this);
    this._specs = null;
    this._specsChanged = new signaling_1$1.Signal(this);
    this._ready = Promise.all([this.requestSpecs()]).then((_) => void 0).catch((_) => void 0).then(() => {
      if (this.isDisposed) {
        return;
      }
      this._isReady = true;
    });
    this._pollSpecs = new polling_1$1.Poll({
      auto: false,
      factory: () => this.requestSpecs(),
      frequency: {
        interval: 61 * 1e3,
        backoff: true,
        max: 300 * 1e3
      },
      name: `@jupyterlab/services:KernelSpecManager#specs`,
      standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
    });
    void this.ready.then(() => {
      void this._pollSpecs.start();
    });
  }
  /**
   * Test whether the manager is ready.
   */
  get isReady() {
    return this._isReady;
  }
  /**
   * A promise that fulfills when the manager is ready.
   */
  get ready() {
    return this._ready;
  }
  /**
   * Get the most recently fetched kernel specs.
   */
  get specs() {
    return this._specs;
  }
  /**
   * A signal emitted when the specs change.
   */
  get specsChanged() {
    return this._specsChanged;
  }
  /**
   * A signal emitted when there is a connection failure.
   */
  get connectionFailure() {
    return this._connectionFailure;
  }
  /**
   * Dispose of the resources used by the manager.
   */
  dispose() {
    this._pollSpecs.dispose();
    super.dispose();
  }
  /**
   * Force a refresh of the specs from the server.
   *
   * @returns A promise that resolves when the specs are fetched.
   *
   * #### Notes
   * This is intended to be called only in response to a user action,
   * since the manager maintains its internal state.
   */
  async refreshSpecs() {
    await this._pollSpecs.refresh();
    await this._pollSpecs.tick;
  }
  /**
   * Execute a request to the server to poll specs and update state.
   */
  async requestSpecs() {
    const specs = await restapi$2.getSpecs(this.serverSettings);
    if (this.isDisposed) {
      return;
    }
    if (!coreutils_1$5.JSONExt.deepEqual(specs, this._specs)) {
      this._specs = specs;
      this._specsChanged.emit(specs);
    }
  }
}
manager$4.KernelSpecManager = KernelSpecManager;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result2, mod, k);
    }
    __setModuleDefault2(result2, mod);
    return result2;
  };
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KernelSpecAPI = exports.KernelSpec = void 0;
  const KernelSpec = __importStar2(kernelspec);
  exports.KernelSpec = KernelSpec;
  const KernelSpecAPI = __importStar2(restapi$3);
  exports.KernelSpecAPI = KernelSpecAPI;
  __exportStar(manager$4, exports);
})(kernelspec$1);
var hasRequired_default$2;
function require_default$2() {
  if (hasRequired_default$2) return _default$2;
  hasRequired_default$2 = 1;
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result2, mod, k);
    }
    __setModuleDefault2(result2, mod);
    return result2;
  };
  Object.defineProperty(_default$2, "__esModule", { value: true });
  _default$2.KernelConnection = void 0;
  const coreutils_12 = lib$9;
  const coreutils_22 = require$$1$2;
  const signaling_12 = require$$0$1;
  const __1 = requireLib();
  const comm_1 = comm;
  const KernelMessage2 = __importStar2(messages);
  const future_1 = future;
  const validate2 = __importStar2(validate$2);
  const kernelspec_1 = kernelspec$1;
  const restapi2 = __importStar2(restapi$4);
  const KERNEL_INFO_TIMEOUT = 3e3;
  const RESTARTING_KERNEL_SESSION = "_RESTARTING_";
  const STARTING_KERNEL_SESSION = "";
  class KernelConnection {
    /**
     * Construct a kernel object.
     */
    constructor(options) {
      var _a, _b, _c, _d;
      this._createSocket = (useProtocols = true) => {
        this._errorIfDisposed();
        this._clearSocket();
        this._updateConnectionStatus("connecting");
        const settings = this.serverSettings;
        const partialUrl = coreutils_12.URLExt.join(settings.wsUrl, restapi2.KERNEL_SERVICE_URL, encodeURIComponent(this._id));
        const display2 = partialUrl.replace(/^((?:\w+:)?\/\/)(?:[^@\/]+@)/, "$1");
        console.debug(`Starting WebSocket: ${display2}`);
        let url2 = coreutils_12.URLExt.join(partialUrl, "channels?session_id=" + encodeURIComponent(this._clientId));
        const token = settings.token;
        if (settings.appendToken && token !== "") {
          url2 = url2 + `&token=${encodeURIComponent(token)}`;
        }
        const supportedProtocols = useProtocols ? this._supportedProtocols : [];
        this._ws = new settings.WebSocket(url2, supportedProtocols);
        this._ws.binaryType = "arraybuffer";
        let alreadyCalledOnclose = false;
        const getKernelModel = async (evt) => {
          var _a2, _b2;
          if (this._isDisposed) {
            return;
          }
          this._reason = "";
          this._model = void 0;
          try {
            const model = await restapi2.getKernelModel(this._id, settings);
            this._model = model;
            if ((model === null || model === void 0 ? void 0 : model.execution_state) === "dead") {
              this._updateStatus("dead");
            } else {
              this._onWSClose(evt);
            }
          } catch (err) {
            if (err instanceof __1.ServerConnection.NetworkError || ((_a2 = err.response) === null || _a2 === void 0 ? void 0 : _a2.status) === 503 || ((_b2 = err.response) === null || _b2 === void 0 ? void 0 : _b2.status) === 424) {
              const timeout = Private2.getRandomIntInclusive(10, 30) * 1e3;
              setTimeout(getKernelModel, timeout, evt);
            } else {
              this._reason = "Kernel died unexpectedly";
              this._updateStatus("dead");
            }
          }
          return;
        };
        const earlyClose = async (evt) => {
          if (alreadyCalledOnclose) {
            return;
          }
          alreadyCalledOnclose = true;
          await getKernelModel(evt);
          return;
        };
        this._ws.onmessage = this._onWSMessage;
        this._ws.onopen = this._onWSOpen;
        this._ws.onclose = earlyClose;
        this._ws.onerror = earlyClose;
      };
      this._onWSOpen = (evt) => {
        if (this._ws.protocol !== "" && !this._supportedProtocols.includes(this._ws.protocol)) {
          console.log("Server selected unknown kernel wire protocol:", this._ws.protocol);
          this._updateStatus("dead");
          throw new Error(`Unknown kernel wire protocol:  ${this._ws.protocol}`);
        }
        this._selectedProtocol = this._ws.protocol;
        this._ws.onclose = this._onWSClose;
        this._ws.onerror = this._onWSClose;
        this._updateConnectionStatus("connected");
      };
      this._onWSMessage = (evt) => {
        let msg;
        try {
          msg = this.serverSettings.serializer.deserialize(evt.data, this._ws.protocol);
          validate2.validateMessage(msg);
        } catch (error) {
          error.message = `Kernel message validation error: ${error.message}`;
          throw error;
        }
        this._kernelSession = msg.header.session;
        this._msgChain = this._msgChain.then(() => {
          return this._handleMessage(msg);
        }).catch((error) => {
          if (error.message.startsWith("Canceled future for ")) {
            console.error(error);
          }
        });
        this._anyMessage.emit({ msg, direction: "recv" });
      };
      this._onWSClose = (evt) => {
        if (!this.isDisposed) {
          this._reconnect();
        }
      };
      this._id = "";
      this._name = "";
      this._status = "unknown";
      this._connectionStatus = "connecting";
      this._kernelSession = "";
      this._isDisposed = false;
      this._ws = null;
      this._username = "";
      this._reconnectLimit = 7;
      this._reconnectAttempt = 0;
      this._reconnectTimeout = null;
      this._supportedProtocols = Object.values(KernelMessage2.supportedKernelWebSocketProtocols);
      this._selectedProtocol = "";
      this._futures = /* @__PURE__ */ new Map();
      this._comms = /* @__PURE__ */ new Map();
      this._targetRegistry = /* @__PURE__ */ Object.create(null);
      this._info = new coreutils_22.PromiseDelegate();
      this._pendingMessages = [];
      this._statusChanged = new signaling_12.Signal(this);
      this._connectionStatusChanged = new signaling_12.Signal(this);
      this._disposed = new signaling_12.Signal(this);
      this._iopubMessage = new signaling_12.Signal(this);
      this._anyMessage = new signaling_12.Signal(this);
      this._pendingInput = new signaling_12.Signal(this);
      this._unhandledMessage = new signaling_12.Signal(this);
      this._displayIdToParentIds = /* @__PURE__ */ new Map();
      this._msgIdToDisplayIds = /* @__PURE__ */ new Map();
      this._msgChain = Promise.resolve();
      this._hasPendingInput = false;
      this._reason = "";
      this._noOp = () => {
      };
      this._name = options.model.name;
      this._id = options.model.id;
      this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
      this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_22.UUID.uuid4();
      this._username = (_c = options.username) !== null && _c !== void 0 ? _c : "";
      this.handleComms = (_d = options.handleComms) !== null && _d !== void 0 ? _d : true;
      this._createSocket();
    }
    get disposed() {
      return this._disposed;
    }
    /**
     * A signal emitted when the kernel status changes.
     */
    get statusChanged() {
      return this._statusChanged;
    }
    /**
     * A signal emitted when the kernel status changes.
     */
    get connectionStatusChanged() {
      return this._connectionStatusChanged;
    }
    /**
     * A signal emitted for iopub kernel messages.
     *
     * #### Notes
     * This signal is emitted after the iopub message is handled asynchronously.
     */
    get iopubMessage() {
      return this._iopubMessage;
    }
    /**
     * A signal emitted for unhandled kernel message.
     *
     * #### Notes
     * This signal is emitted for a message that was not handled. It is emitted
     * during the asynchronous message handling code.
     */
    get unhandledMessage() {
      return this._unhandledMessage;
    }
    /**
     * The kernel model
     */
    get model() {
      return this._model || {
        id: this.id,
        name: this.name,
        reason: this._reason
      };
    }
    /**
     * A signal emitted for any kernel message.
     *
     * #### Notes
     * This signal is emitted when a message is received, before it is handled
     * asynchronously.
     *
     * This message is emitted when a message is queued for sending (either in
     * the websocket buffer, or our own pending message buffer). The message may
     * actually be sent across the wire at a later time.
     *
     * The message emitted in this signal should not be modified in any way.
     */
    get anyMessage() {
      return this._anyMessage;
    }
    /**
     * A signal emitted when a kernel has pending inputs from the user.
     */
    get pendingInput() {
      return this._pendingInput;
    }
    /**
     * The id of the server-side kernel.
     */
    get id() {
      return this._id;
    }
    /**
     * The name of the server-side kernel.
     */
    get name() {
      return this._name;
    }
    /**
     * The client username.
     */
    get username() {
      return this._username;
    }
    /**
     * The client unique id.
     */
    get clientId() {
      return this._clientId;
    }
    /**
     * The current status of the kernel.
     */
    get status() {
      return this._status;
    }
    /**
     * The current connection status of the kernel connection.
     */
    get connectionStatus() {
      return this._connectionStatus;
    }
    /**
     * Test whether the kernel has been disposed.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * The cached kernel info.
     *
     * @returns A promise that resolves to the kernel info.
     */
    get info() {
      return this._info.promise;
    }
    /**
     * The kernel spec.
     *
     * @returns A promise that resolves to the kernel spec.
     */
    get spec() {
      if (this._specPromise) {
        return this._specPromise;
      }
      this._specPromise = kernelspec_1.KernelSpecAPI.getSpecs(this.serverSettings).then((specs) => {
        return specs.kernelspecs[this._name];
      });
      return this._specPromise;
    }
    /**
     * Clone the current kernel with a new clientId.
     */
    clone(options = {}) {
      return new KernelConnection({
        model: this.model,
        username: this.username,
        serverSettings: this.serverSettings,
        // handleComms defaults to false since that is safer
        handleComms: false,
        ...options
      });
    }
    /**
     * Dispose of the resources held by the kernel.
     */
    dispose() {
      if (this.isDisposed) {
        return;
      }
      this._isDisposed = true;
      this._disposed.emit();
      this._updateConnectionStatus("disconnected");
      this._clearKernelState();
      this._pendingMessages = [];
      this._clearSocket();
      signaling_12.Signal.clearData(this);
    }
    /**
     * Send a shell message to the kernel.
     *
     * #### Notes
     * Send a message to the kernel's shell channel, yielding a future object
     * for accepting replies.
     *
     * If `expectReply` is given and `true`, the future is disposed when both a
     * shell reply and an idle status message are received. If `expectReply`
     * is not given or is `false`, the future is resolved when an idle status
     * message is received.
     * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
     * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
     *
     * All replies are validated as valid kernel messages.
     *
     * If the kernel status is `dead`, this will throw an error.
     */
    sendShellMessage(msg, expectReply = false, disposeOnDone = true) {
      return this._sendKernelShellControl(future_1.KernelShellFutureHandler, msg, expectReply, disposeOnDone);
    }
    /**
     * Send a control message to the kernel.
     *
     * #### Notes
     * Send a message to the kernel's control channel, yielding a future object
     * for accepting replies.
     *
     * If `expectReply` is given and `true`, the future is disposed when both a
     * control reply and an idle status message are received. If `expectReply`
     * is not given or is `false`, the future is resolved when an idle status
     * message is received.
     * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
     * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
     *
     * All replies are validated as valid kernel messages.
     *
     * If the kernel status is `dead`, this will throw an error.
     */
    sendControlMessage(msg, expectReply = false, disposeOnDone = true) {
      return this._sendKernelShellControl(future_1.KernelControlFutureHandler, msg, expectReply, disposeOnDone);
    }
    _sendKernelShellControl(ctor, msg, expectReply = false, disposeOnDone = true) {
      this._sendMessage(msg);
      this._anyMessage.emit({ msg, direction: "send" });
      const future2 = new ctor(() => {
        const msgId = msg.header.msg_id;
        this._futures.delete(msgId);
        const displayIds = this._msgIdToDisplayIds.get(msgId);
        if (!displayIds) {
          return;
        }
        displayIds.forEach((displayId) => {
          const msgIds = this._displayIdToParentIds.get(displayId);
          if (msgIds) {
            const idx = msgIds.indexOf(msgId);
            if (idx === -1) {
              return;
            }
            if (msgIds.length === 1) {
              this._displayIdToParentIds.delete(displayId);
            } else {
              msgIds.splice(idx, 1);
              this._displayIdToParentIds.set(displayId, msgIds);
            }
          }
        });
        this._msgIdToDisplayIds.delete(msgId);
      }, msg, expectReply, disposeOnDone, this);
      this._futures.set(msg.header.msg_id, future2);
      return future2;
    }
    /**
     * Send a message on the websocket.
     *
     * If queue is true, queue the message for later sending if we cannot send
     * now. Otherwise throw an error.
     *
     * #### Notes
     * As an exception to the queueing, if we are sending a kernel_info_request
     * message while we think the kernel is restarting, we send the message
     * immediately without queueing. This is so that we can trigger a message
     * back, which will then clear the kernel restarting state.
     */
    _sendMessage(msg, queue = true) {
      if (this.status === "dead") {
        throw new Error("Kernel is dead");
      }
      if ((this._kernelSession === STARTING_KERNEL_SESSION || this._kernelSession === RESTARTING_KERNEL_SESSION) && KernelMessage2.isInfoRequestMsg(msg)) {
        if (this.connectionStatus === "connected") {
          this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
          return;
        } else {
          throw new Error("Could not send message: status is not connected");
        }
      }
      if (queue && this._pendingMessages.length > 0) {
        this._pendingMessages.push(msg);
        return;
      }
      if (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION) {
        this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
      } else if (queue) {
        this._pendingMessages.push(msg);
      } else {
        throw new Error("Could not send message");
      }
    }
    /**
     * Interrupt a kernel.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     *
     * It is assumed that the API call does not mutate the kernel id or name.
     *
     * The promise will be rejected if the kernel status is `Dead` or if the
     * request fails or the response is invalid.
     */
    async interrupt() {
      this.hasPendingInput = false;
      if (this.status === "dead") {
        throw new Error("Kernel is dead");
      }
      return restapi2.interruptKernel(this.id, this.serverSettings);
    }
    /**
     * Request a kernel restart.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels)
     * and validates the response model.
     *
     * Any existing Future or Comm objects are cleared once the kernel has
     * actually be restarted.
     *
     * The promise is fulfilled on a valid server response (after the kernel restarts)
     * and rejected otherwise.
     *
     * It is assumed that the API call does not mutate the kernel id or name.
     *
     * The promise will be rejected if the request fails or the response is
     * invalid.
     */
    async restart() {
      if (this.status === "dead") {
        throw new Error("Kernel is dead");
      }
      this._updateStatus("restarting");
      this._clearKernelState();
      this._kernelSession = RESTARTING_KERNEL_SESSION;
      await restapi2.restartKernel(this.id, this.serverSettings);
      await this.reconnect();
      this.hasPendingInput = false;
    }
    /**
     * Reconnect to a kernel.
     *
     * #### Notes
     * This may try multiple times to reconnect to a kernel, and will sever any
     * existing connection.
     */
    reconnect() {
      this._errorIfDisposed();
      const result2 = new coreutils_22.PromiseDelegate();
      const fulfill = (sender, status) => {
        if (status === "connected") {
          result2.resolve();
          this.connectionStatusChanged.disconnect(fulfill, this);
        } else if (status === "disconnected") {
          result2.reject(new Error("Kernel connection disconnected"));
          this.connectionStatusChanged.disconnect(fulfill, this);
        }
      };
      this.connectionStatusChanged.connect(fulfill, this);
      this._reconnectAttempt = 0;
      this._reconnect();
      return result2.promise;
    }
    /**
     * Shutdown a kernel.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
     *
     * The promise is fulfilled on a valid response and rejected otherwise.
     *
     * On a valid response, disposes this kernel connection.
     *
     * If the kernel is already `dead`, disposes this kernel connection without
     * a server request.
     */
    async shutdown() {
      if (this.status !== "dead") {
        await restapi2.shutdownKernel(this.id, this.serverSettings);
      }
      this.handleShutdown();
    }
    /**
     * Handles a kernel shutdown.
     *
     * #### Notes
     * This method should be called if we know from outside information that a
     * kernel is dead (for example, we cannot find the kernel model on the
     * server).
     */
    handleShutdown() {
      this._updateStatus("dead");
      this.dispose();
    }
    /**
     * Send a `kernel_info_request` message.
     *
     * #### Notes
     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#kernel-info).
     *
     * Fulfills with the `kernel_info_response` content when the shell reply is
     * received and validated.
     */
    async requestKernelInfo() {
      const msg = KernelMessage2.createMessage({
        msgType: "kernel_info_request",
        channel: "shell",
        username: this._username,
        session: this._clientId,
        content: {}
      });
      let reply;
      try {
        reply = await Private2.handleShellMessage(this, msg);
      } catch (e) {
        if (this.isDisposed) {
          return;
        } else {
          throw e;
        }
      }
      this._errorIfDisposed();
      if (!reply) {
        return;
      }
      if (reply.content.status === void 0) {
        reply.content.status = "ok";
      }
      if (reply.content.status !== "ok") {
        this._info.reject("Kernel info reply errored");
        return reply;
      }
      this._info.resolve(reply.content);
      this._kernelSession = reply.header.session;
      return reply;
    }
    /**
     * Send a `complete_request` message.
     *
     * #### Notes
     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#completion).
     *
     * Fulfills with the `complete_reply` content when the shell reply is
     * received and validated.
     */
    requestComplete(content) {
      const msg = KernelMessage2.createMessage({
        msgType: "complete_request",
        channel: "shell",
        username: this._username,
        session: this._clientId,
        content
      });
      return Private2.handleShellMessage(this, msg);
    }
    /**
     * Send an `inspect_request` message.
     *
     * #### Notes
     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#introspection).
     *
     * Fulfills with the `inspect_reply` content when the shell reply is
     * received and validated.
     */
    requestInspect(content) {
      const msg = KernelMessage2.createMessage({
        msgType: "inspect_request",
        channel: "shell",
        username: this._username,
        session: this._clientId,
        content
      });
      return Private2.handleShellMessage(this, msg);
    }
    /**
     * Send a `history_request` message.
     *
     * #### Notes
     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#history).
     *
     * Fulfills with the `history_reply` content when the shell reply is
     * received and validated.
     */
    requestHistory(content) {
      const msg = KernelMessage2.createMessage({
        msgType: "history_request",
        channel: "shell",
        username: this._username,
        session: this._clientId,
        content
      });
      return Private2.handleShellMessage(this, msg);
    }
    /**
     * Send an `execute_request` message.
     *
     * #### Notes
     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#execute).
     *
     * Future `onReply` is called with the `execute_reply` content when the
     * shell reply is received and validated. The future will resolve when
     * this message is received and the `idle` iopub status is received.
     * The future will also be disposed at this point unless `disposeOnDone`
     * is specified and `false`, in which case it is up to the caller to dispose
     * of the future.
     *
     * **See also:** [[IExecuteReply]]
     */
    requestExecute(content, disposeOnDone = true, metadata) {
      const defaults = {
        silent: false,
        store_history: true,
        user_expressions: {},
        allow_stdin: true,
        stop_on_error: false
      };
      const msg = KernelMessage2.createMessage({
        msgType: "execute_request",
        channel: "shell",
        username: this._username,
        session: this._clientId,
        content: { ...defaults, ...content },
        metadata
      });
      return this.sendShellMessage(msg, true, disposeOnDone);
    }
    /**
     * Send an experimental `debug_request` message.
     *
     * @hidden
     *
     * #### Notes
     * Debug messages are experimental messages that are not in the official
     * kernel message specification. As such, this function is *NOT* considered
     * part of the public API, and may change without notice.
     */
    requestDebug(content, disposeOnDone = true) {
      const msg = KernelMessage2.createMessage({
        msgType: "debug_request",
        channel: "control",
        username: this._username,
        session: this._clientId,
        content
      });
      return this.sendControlMessage(msg, true, disposeOnDone);
    }
    /**
     * Send an `is_complete_request` message.
     *
     * #### Notes
     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#code-completeness).
     *
     * Fulfills with the `is_complete_response` content when the shell reply is
     * received and validated.
     */
    requestIsComplete(content) {
      const msg = KernelMessage2.createMessage({
        msgType: "is_complete_request",
        channel: "shell",
        username: this._username,
        session: this._clientId,
        content
      });
      return Private2.handleShellMessage(this, msg);
    }
    /**
     * Send a `comm_info_request` message.
     *
     * #### Notes
     * Fulfills with the `comm_info_reply` content when the shell reply is
     * received and validated.
     */
    requestCommInfo(content) {
      const msg = KernelMessage2.createMessage({
        msgType: "comm_info_request",
        channel: "shell",
        username: this._username,
        session: this._clientId,
        content
      });
      return Private2.handleShellMessage(this, msg);
    }
    /**
     * Send an `input_reply` message.
     *
     * #### Notes
     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messages-on-the-stdin-router-dealer-sockets).
     */
    sendInputReply(content, parent_header) {
      const msg = KernelMessage2.createMessage({
        msgType: "input_reply",
        channel: "stdin",
        username: this._username,
        session: this._clientId,
        content
      });
      msg.parent_header = parent_header;
      this._sendMessage(msg);
      this._anyMessage.emit({ msg, direction: "send" });
      this.hasPendingInput = false;
    }
    /**
     * Create a new comm.
     *
     * #### Notes
     * If a client-side comm already exists with the given commId, an error is thrown.
     * If the kernel does not handle comms, an error is thrown.
     */
    createComm(targetName, commId = coreutils_22.UUID.uuid4()) {
      if (!this.handleComms) {
        throw new Error("Comms are disabled on this kernel connection");
      }
      if (this._comms.has(commId)) {
        throw new Error("Comm is already created");
      }
      const comm2 = new comm_1.CommHandler(targetName, commId, this, () => {
        this._unregisterComm(commId);
      });
      this._comms.set(commId, comm2);
      return comm2;
    }
    /**
     * Check if a comm exists.
     */
    hasComm(commId) {
      return this._comms.has(commId);
    }
    /**
     * Register a comm target handler.
     *
     * @param targetName - The name of the comm target.
     *
     * @param callback - The callback invoked for a comm open message.
     *
     * @returns A disposable used to unregister the comm target.
     *
     * #### Notes
     * Only one comm target can be registered to a target name at a time, an
     * existing callback for the same target name will be overridden.  A registered
     * comm target handler will take precedence over a comm which specifies a
     * `target_module`.
     *
     * If the callback returns a promise, kernel message processing will pause
     * until the returned promise is fulfilled.
     */
    registerCommTarget(targetName, callback) {
      if (!this.handleComms) {
        return;
      }
      this._targetRegistry[targetName] = callback;
    }
    /**
     * Remove a comm target handler.
     *
     * @param targetName - The name of the comm target to remove.
     *
     * @param callback - The callback to remove.
     *
     * #### Notes
     * The comm target is only removed if the callback argument matches.
     */
    removeCommTarget(targetName, callback) {
      if (!this.handleComms) {
        return;
      }
      if (!this.isDisposed && this._targetRegistry[targetName] === callback) {
        delete this._targetRegistry[targetName];
      }
    }
    /**
     * Register an IOPub message hook.
     *
     * @param msg_id - The parent_header message id the hook will intercept.
     *
     * @param hook - The callback invoked for the message.
     *
     * #### Notes
     * The IOPub hook system allows you to preempt the handlers for IOPub
     * messages that are responses to a given message id.
     *
     * The most recently registered hook is run first. A hook can return a
     * boolean or a promise to a boolean, in which case all kernel message
     * processing pauses until the promise is fulfilled. If a hook return value
     * resolves to false, any later hooks will not run and the function will
     * return a promise resolving to false. If a hook throws an error, the error
     * is logged to the console and the next hook is run. If a hook is
     * registered during the hook processing, it will not run until the next
     * message. If a hook is removed during the hook processing, it will be
     * deactivated immediately.
     *
     * See also [[IFuture.registerMessageHook]].
     */
    registerMessageHook(msgId, hook) {
      var _a;
      const future2 = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
      if (future2) {
        future2.registerMessageHook(hook);
      }
    }
    /**
     * Remove an IOPub message hook.
     *
     * @param msg_id - The parent_header message id the hook intercepted.
     *
     * @param hook - The callback invoked for the message.
     *
     */
    removeMessageHook(msgId, hook) {
      var _a;
      const future2 = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
      if (future2) {
        future2.removeMessageHook(hook);
      }
    }
    /**
     * Remove the input guard, if any.
     */
    removeInputGuard() {
      this.hasPendingInput = false;
    }
    /**
     * Handle a message with a display id.
     *
     * @returns Whether the message was handled.
     */
    async _handleDisplayId(displayId, msg) {
      var _a, _b;
      const msgId = msg.parent_header.msg_id;
      let parentIds = this._displayIdToParentIds.get(displayId);
      if (parentIds) {
        const updateMsg = {
          header: coreutils_22.JSONExt.deepCopy(msg.header),
          parent_header: coreutils_22.JSONExt.deepCopy(msg.parent_header),
          metadata: coreutils_22.JSONExt.deepCopy(msg.metadata),
          content: coreutils_22.JSONExt.deepCopy(msg.content),
          channel: msg.channel,
          buffers: msg.buffers ? msg.buffers.slice() : []
        };
        updateMsg.header.msg_type = "update_display_data";
        await Promise.all(parentIds.map(async (parentId) => {
          const future2 = this._futures && this._futures.get(parentId);
          if (future2) {
            await future2.handleMsg(updateMsg);
          }
        }));
      }
      if (msg.header.msg_type === "update_display_data") {
        return true;
      }
      parentIds = (_a = this._displayIdToParentIds.get(displayId)) !== null && _a !== void 0 ? _a : [];
      if (parentIds.indexOf(msgId) === -1) {
        parentIds.push(msgId);
      }
      this._displayIdToParentIds.set(displayId, parentIds);
      const displayIds = (_b = this._msgIdToDisplayIds.get(msgId)) !== null && _b !== void 0 ? _b : [];
      if (displayIds.indexOf(msgId) === -1) {
        displayIds.push(msgId);
      }
      this._msgIdToDisplayIds.set(msgId, displayIds);
      return false;
    }
    /**
     * Forcefully clear the socket state.
     *
     * #### Notes
     * This will clear all socket state without calling any handlers and will
     * not update the connection status. If you call this method, you are
     * responsible for updating the connection status as needed and recreating
     * the socket if you plan to reconnect.
     */
    _clearSocket() {
      if (this._ws !== null) {
        this._ws.onopen = this._noOp;
        this._ws.onclose = this._noOp;
        this._ws.onerror = this._noOp;
        this._ws.onmessage = this._noOp;
        this._ws.close();
        this._ws = null;
      }
    }
    /**
     * Handle status iopub messages from the kernel.
     */
    _updateStatus(status) {
      if (this._status === status || this._status === "dead") {
        return;
      }
      this._status = status;
      Private2.logKernelStatus(this);
      this._statusChanged.emit(status);
      if (status === "dead") {
        this.dispose();
      }
    }
    /**
     * Send pending messages to the kernel.
     */
    _sendPending() {
      while (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION && this._pendingMessages.length > 0) {
        this._sendMessage(this._pendingMessages[0], false);
        this._pendingMessages.shift();
      }
    }
    /**
     * Clear the internal state.
     */
    _clearKernelState() {
      this._kernelSession = "";
      this._pendingMessages = [];
      this._futures.forEach((future2) => {
        future2.dispose();
      });
      this._comms.forEach((comm2) => {
        comm2.dispose();
      });
      this._msgChain = Promise.resolve();
      this._futures = /* @__PURE__ */ new Map();
      this._comms = /* @__PURE__ */ new Map();
      this._displayIdToParentIds.clear();
      this._msgIdToDisplayIds.clear();
    }
    /**
     * Check to make sure it is okay to proceed to handle a message.
     *
     * #### Notes
     * Because we handle messages asynchronously, before a message is handled the
     * kernel might be disposed or restarted (and have a different session id).
     * This function throws an error in each of these cases. This is meant to be
     * called at the start of an asynchronous message handler to cancel message
     * processing if the message no longer is valid.
     */
    _assertCurrentMessage(msg) {
      this._errorIfDisposed();
      if (msg.header.session !== this._kernelSession) {
        throw new Error(`Canceling handling of old message: ${msg.header.msg_type}`);
      }
    }
    /**
     * Handle a `comm_open` kernel message.
     */
    async _handleCommOpen(msg) {
      this._assertCurrentMessage(msg);
      const content = msg.content;
      const comm2 = new comm_1.CommHandler(content.target_name, content.comm_id, this, () => {
        this._unregisterComm(content.comm_id);
      });
      this._comms.set(content.comm_id, comm2);
      try {
        const target2 = await Private2.loadObject(content.target_name, content.target_module, this._targetRegistry);
        await target2(comm2, msg);
      } catch (e) {
        comm2.close();
        console.error("Exception opening new comm");
        throw e;
      }
    }
    /**
     * Handle 'comm_close' kernel message.
     */
    async _handleCommClose(msg) {
      this._assertCurrentMessage(msg);
      const content = msg.content;
      const comm2 = this._comms.get(content.comm_id);
      if (!comm2) {
        console.error("Comm not found for comm id " + content.comm_id);
        return;
      }
      this._unregisterComm(comm2.commId);
      const onClose = comm2.onClose;
      if (onClose) {
        await onClose(msg);
      }
      comm2.dispose();
    }
    /**
     * Handle a 'comm_msg' kernel message.
     */
    async _handleCommMsg(msg) {
      this._assertCurrentMessage(msg);
      const content = msg.content;
      const comm2 = this._comms.get(content.comm_id);
      if (!comm2) {
        return;
      }
      const onMsg = comm2.onMsg;
      if (onMsg) {
        await onMsg(msg);
      }
    }
    /**
     * Unregister a comm instance.
     */
    _unregisterComm(commId) {
      this._comms.delete(commId);
    }
    /**
     * Handle connection status changes.
     */
    _updateConnectionStatus(connectionStatus) {
      if (this._connectionStatus === connectionStatus) {
        return;
      }
      this._connectionStatus = connectionStatus;
      if (connectionStatus !== "connecting") {
        this._reconnectAttempt = 0;
        clearTimeout(this._reconnectTimeout);
      }
      if (this.status !== "dead") {
        if (connectionStatus === "connected") {
          let restarting = this._kernelSession === RESTARTING_KERNEL_SESSION;
          let p = this.requestKernelInfo();
          let sendPendingCalled = false;
          let sendPendingOnce = () => {
            if (sendPendingCalled) {
              return;
            }
            sendPendingCalled = true;
            if (restarting && this._kernelSession === RESTARTING_KERNEL_SESSION) {
              this._kernelSession = "";
            }
            clearTimeout(timeoutHandle);
            if (this._pendingMessages.length > 0) {
              this._sendPending();
            }
          };
          void p.then(sendPendingOnce);
          let timeoutHandle = setTimeout(sendPendingOnce, KERNEL_INFO_TIMEOUT);
        } else {
          this._updateStatus("unknown");
        }
      }
      this._connectionStatusChanged.emit(connectionStatus);
    }
    async _handleMessage(msg) {
      var _a, _b;
      let handled = false;
      if (msg.parent_header && msg.channel === "iopub" && (KernelMessage2.isDisplayDataMsg(msg) || KernelMessage2.isUpdateDisplayDataMsg(msg) || KernelMessage2.isExecuteResultMsg(msg))) {
        const transient = (_a = msg.content.transient) !== null && _a !== void 0 ? _a : {};
        const displayId = transient["display_id"];
        if (displayId) {
          handled = await this._handleDisplayId(displayId, msg);
          this._assertCurrentMessage(msg);
        }
      }
      if (!handled && msg.parent_header) {
        const parentHeader = msg.parent_header;
        const future2 = (_b = this._futures) === null || _b === void 0 ? void 0 : _b.get(parentHeader.msg_id);
        if (future2) {
          await future2.handleMsg(msg);
          this._assertCurrentMessage(msg);
        } else {
          const owned = parentHeader.session === this.clientId;
          if (msg.channel !== "iopub" && owned) {
            this._unhandledMessage.emit(msg);
          }
        }
      }
      if (msg.channel === "iopub") {
        switch (msg.header.msg_type) {
          case "status": {
            const executionState = msg.content.execution_state;
            if (executionState === "restarting") {
              void Promise.resolve().then(async () => {
                this._updateStatus("autorestarting");
                this._clearKernelState();
                await this.reconnect();
              });
            }
            this._updateStatus(executionState);
            break;
          }
          case "comm_open":
            if (this.handleComms) {
              await this._handleCommOpen(msg);
            }
            break;
          case "comm_msg":
            if (this.handleComms) {
              await this._handleCommMsg(msg);
            }
            break;
          case "comm_close":
            if (this.handleComms) {
              await this._handleCommClose(msg);
            }
            break;
        }
        if (!this.isDisposed) {
          this._assertCurrentMessage(msg);
          this._iopubMessage.emit(msg);
        }
      }
    }
    /**
     * Attempt a connection if we have not exhausted connection attempts.
     */
    _reconnect() {
      this._errorIfDisposed();
      clearTimeout(this._reconnectTimeout);
      if (this._reconnectAttempt < this._reconnectLimit) {
        this._updateConnectionStatus("connecting");
        const timeout = Private2.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
        console.warn(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
        const useProtocols = this._selectedProtocol !== "" ? true : false;
        this._reconnectTimeout = setTimeout(this._createSocket, timeout, useProtocols);
        this._reconnectAttempt += 1;
      } else {
        this._updateConnectionStatus("disconnected");
      }
      this._clearSocket();
    }
    /**
     * Utility function to throw an error if this instance is disposed.
     */
    _errorIfDisposed() {
      if (this.isDisposed) {
        throw new Error("Kernel connection is disposed");
      }
    }
    get hasPendingInput() {
      return this._hasPendingInput;
    }
    set hasPendingInput(value) {
      this._hasPendingInput = value;
      this._pendingInput.emit(value);
    }
  }
  _default$2.KernelConnection = KernelConnection;
  var Private2;
  (function(Private3) {
    function logKernelStatus(kernel2) {
      switch (kernel2.status) {
        case "idle":
        case "busy":
        case "unknown":
          return;
        default:
          console.debug(`Kernel: ${kernel2.status} (${kernel2.id})`);
          break;
      }
    }
    Private3.logKernelStatus = logKernelStatus;
    async function handleShellMessage(kernel2, msg) {
      const future2 = kernel2.sendShellMessage(msg, true);
      return future2.done;
    }
    Private3.handleShellMessage = handleShellMessage;
    function loadObject(name2, moduleName, registry) {
      return new Promise((resolve3, reject) => {
        if (moduleName) {
          if (typeof requirejs === "undefined") {
            throw new Error("requirejs not found");
          }
          requirejs([moduleName], (mod) => {
            if (mod[name2] === void 0) {
              const msg = `Object '${name2}' not found in module '${moduleName}'`;
              reject(new Error(msg));
            } else {
              resolve3(mod[name2]);
            }
          }, reject);
        } else {
          if (registry === null || registry === void 0 ? void 0 : registry[name2]) {
            resolve3(registry[name2]);
          } else {
            reject(new Error(`Object '${name2}' not found in registry`));
          }
        }
      });
    }
    Private3.loadObject = loadObject;
    function getRandomIntInclusive(min2, max2) {
      min2 = Math.ceil(min2);
      max2 = Math.floor(max2);
      return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
    }
    Private3.getRandomIntInclusive = getRandomIntInclusive;
  })(Private2 || (Private2 = {}));
  return _default$2;
}
var manager$3 = {};
var hasRequiredManager$3;
function requireManager$3() {
  if (hasRequiredManager$3) return manager$3;
  hasRequiredManager$3 = 1;
  Object.defineProperty(manager$3, "__esModule", { value: true });
  manager$3.KernelManager = void 0;
  const polling_12 = require$$2$1;
  const signaling_12 = require$$0$1;
  const __1 = requireLib();
  const basemanager_12 = basemanager;
  const restapi_1 = restapi$4;
  const default_1 = require_default$2();
  class KernelManager extends basemanager_12.BaseManager {
    /**
     * Construct a new kernel manager.
     *
     * @param options - The default options for kernel.
     */
    constructor(options = {}) {
      var _a;
      super(options);
      this._isReady = false;
      this._kernelConnections = /* @__PURE__ */ new Set();
      this._models = /* @__PURE__ */ new Map();
      this._runningChanged = new signaling_12.Signal(this);
      this._connectionFailure = new signaling_12.Signal(this);
      this._pollModels = new polling_12.Poll({
        auto: false,
        factory: () => this.requestRunning(),
        frequency: {
          interval: 10 * 1e3,
          backoff: true,
          max: 300 * 1e3
        },
        name: `@jupyterlab/services:KernelManager#models`,
        standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
      });
      this._ready = (async () => {
        await this._pollModels.start();
        await this._pollModels.tick;
        this._isReady = true;
      })();
    }
    /**
     * Test whether the manager is ready.
     */
    get isReady() {
      return this._isReady;
    }
    /**
     * A promise that fulfills when the manager is ready.
     */
    get ready() {
      return this._ready;
    }
    /**
     * A signal emitted when the running kernels change.
     */
    get runningChanged() {
      return this._runningChanged;
    }
    /**
     * A signal emitted when there is a connection failure.
     */
    get connectionFailure() {
      return this._connectionFailure;
    }
    /**
     * Dispose of the resources used by the manager.
     */
    dispose() {
      if (this.isDisposed) {
        return;
      }
      this._models.clear();
      this._kernelConnections.forEach((x2) => x2.dispose());
      this._pollModels.dispose();
      super.dispose();
    }
    /**
     * Connect to an existing kernel.
     *
     * @returns The new kernel connection.
     *
     * #### Notes
     * This will use the manager's server settings and ignore any server
     * settings passed in the options.
     */
    connectTo(options) {
      var _a;
      const { id } = options.model;
      let handleComms = (_a = options.handleComms) !== null && _a !== void 0 ? _a : true;
      if (options.handleComms === void 0) {
        for (const kc of this._kernelConnections) {
          if (kc.id === id && kc.handleComms) {
            handleComms = false;
            break;
          }
        }
      }
      const kernelConnection = new default_1.KernelConnection({
        handleComms,
        ...options,
        serverSettings: this.serverSettings
      });
      this._onStarted(kernelConnection);
      if (!this._models.has(id)) {
        void this.refreshRunning().catch(() => {
        });
      }
      return kernelConnection;
    }
    /**
     * Create an iterator over the most recent running kernels.
     *
     * @returns A new iterator over the running kernels.
     */
    running() {
      return this._models.values();
    }
    /**
     * The number of running kernels.
     */
    get runningCount() {
      return this._models.size;
    }
    /**
     * Force a refresh of the running kernels.
     *
     * @returns A promise that resolves when the running list has been refreshed.
     *
     * #### Notes
     * This is not typically meant to be called by the user, since the
     * manager maintains its own internal state.
     */
    async refreshRunning() {
      await this._pollModels.refresh();
      await this._pollModels.tick;
    }
    /**
     * Start a new kernel.
     *
     * @param createOptions - The kernel creation options
     *
     * @param connectOptions - The kernel connection options
     *
     * @returns A promise that resolves with the kernel connection.
     *
     * #### Notes
     * The manager `serverSettings` will be always be used.
     */
    async startNew(createOptions = {}, connectOptions = {}) {
      const model = await (0, restapi_1.startNew)(createOptions, this.serverSettings);
      return this.connectTo({
        ...connectOptions,
        model
      });
    }
    /**
     * Shut down a kernel by id.
     *
     * @param id - The id of the target kernel.
     *
     * @returns A promise that resolves when the operation is complete.
     */
    async shutdown(id) {
      await (0, restapi_1.shutdownKernel)(id, this.serverSettings);
      await this.refreshRunning();
    }
    /**
     * Shut down all kernels.
     *
     * @returns A promise that resolves when all of the kernels are shut down.
     */
    async shutdownAll() {
      await this.refreshRunning();
      await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownKernel)(id, this.serverSettings)));
      await this.refreshRunning();
    }
    /**
     * Find a kernel by id.
     *
     * @param id - The id of the target kernel.
     *
     * @returns A promise that resolves with the kernel's model.
     */
    async findById(id) {
      if (this._models.has(id)) {
        return this._models.get(id);
      }
      await this.refreshRunning();
      return this._models.get(id);
    }
    /**
     * Execute a request to the server to poll running kernels and update state.
     */
    async requestRunning() {
      var _a, _b;
      let models;
      try {
        models = await (0, restapi_1.listRunning)(this.serverSettings);
      } catch (err) {
        if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
          this._connectionFailure.emit(err);
        }
        throw err;
      }
      if (this.isDisposed) {
        return;
      }
      if (this._models.size === models.length && models.every((model) => {
        const existing = this._models.get(model.id);
        if (!existing) {
          return false;
        }
        return existing.connections === model.connections && existing.execution_state === model.execution_state && existing.last_activity === model.last_activity && existing.name === model.name && existing.reason === model.reason && existing.traceback === model.traceback;
      })) {
        return;
      }
      this._models = new Map(models.map((x2) => [x2.id, x2]));
      this._kernelConnections.forEach((kc) => {
        if (!this._models.has(kc.id)) {
          kc.handleShutdown();
        }
      });
      this._runningChanged.emit(models);
    }
    /**
     * Handle a kernel starting.
     */
    _onStarted(kernelConnection) {
      this._kernelConnections.add(kernelConnection);
      kernelConnection.statusChanged.connect(this._onStatusChanged, this);
      kernelConnection.disposed.connect(this._onDisposed, this);
    }
    _onDisposed(kernelConnection) {
      this._kernelConnections.delete(kernelConnection);
      void this.refreshRunning().catch(() => {
      });
    }
    _onStatusChanged(kernelConnection, status) {
      if (status === "dead") {
        void this.refreshRunning().catch(() => {
        });
      }
    }
  }
  manager$3.KernelManager = KernelManager;
  (function(KernelManager2) {
    class NoopManager extends KernelManager2 {
      constructor() {
        super(...arguments);
        this._readyPromise = new Promise(() => {
        });
      }
      /**
       * Whether the manager is active.
       */
      get isActive() {
        return false;
      }
      /**
       * Used for testing.
       */
      get parentReady() {
        return super.ready;
      }
      /**
       * Start a new kernel - throws an error since it is not supported.
       */
      async startNew(createOptions = {}, connectOptions = {}) {
        return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
      }
      /**
       * Connect to an existing kernel - throws an error since it is not supported.
       */
      connectTo(options) {
        throw new Error("Not implemented in no-op Kernel Manager");
      }
      /**
       * Shut down a kernel by id - throws an error since it is not supported.
       */
      async shutdown(id) {
        return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
      }
      /**
       * A promise that fulfills when the manager is ready (never).
       */
      get ready() {
        return this.parentReady.then(() => this._readyPromise);
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        return Promise.resolve();
      }
    }
    KernelManager2.NoopManager = NoopManager;
  })(KernelManager || (manager$3.KernelManager = KernelManager = {}));
  return manager$3;
}
var hasRequiredKernel;
function requireKernel() {
  if (hasRequiredKernel) return kernel$1;
  hasRequiredKernel = 1;
  (function(exports) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result2, mod, k);
      }
      __setModuleDefault2(result2, mod);
      return result2;
    };
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KernelConnection = exports.KernelAPI = exports.KernelMessage = exports.Kernel = void 0;
    const Kernel = __importStar2(kernel);
    exports.Kernel = Kernel;
    const KernelMessage2 = __importStar2(messages);
    exports.KernelMessage = KernelMessage2;
    const KernelAPI = __importStar2(restapi$4);
    exports.KernelAPI = KernelAPI;
    const default_1 = require_default$2();
    Object.defineProperty(exports, "KernelConnection", { enumerable: true, get: function() {
      return default_1.KernelConnection;
    } });
    __exportStar(requireManager$3(), exports);
  })(kernel$1);
  return kernel$1;
}
var manager$2 = {};
var builder = {};
Object.defineProperty(builder, "__esModule", { value: true });
builder.BuildManager = void 0;
const coreutils_1$4 = lib$9;
const serverconnection_1$4 = serverconnection;
const BUILD_SETTINGS_URL = "api/build";
class BuildManager {
  /**
   * Create a new setting manager.
   */
  constructor(options = {}) {
    var _a;
    this._url = "";
    this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1$4.ServerConnection.makeSettings();
    const { baseUrl, appUrl } = this.serverSettings;
    this._url = coreutils_1$4.URLExt.join(baseUrl, appUrl, BUILD_SETTINGS_URL);
  }
  /**
   * Test whether the build service is available.
   */
  get isAvailable() {
    return coreutils_1$4.PageConfig.getOption("buildAvailable").toLowerCase() === "true";
  }
  /**
   * Test whether to check build status automatically.
   */
  get shouldCheck() {
    return coreutils_1$4.PageConfig.getOption("buildCheck").toLowerCase() === "true";
  }
  /**
   * Get whether the application should be built.
   */
  getStatus() {
    const { _url, serverSettings } = this;
    const promise = serverconnection_1$4.ServerConnection.makeRequest(_url, {}, serverSettings);
    return promise.then((response) => {
      if (response.status !== 200) {
        throw new serverconnection_1$4.ServerConnection.ResponseError(response);
      }
      return response.json();
    }).then((data) => {
      if (typeof data.status !== "string") {
        throw new Error("Invalid data");
      }
      if (typeof data.message !== "string") {
        throw new Error("Invalid data");
      }
      return data;
    });
  }
  /**
   * Build the application.
   */
  build() {
    const { _url, serverSettings } = this;
    const init = { method: "POST" };
    const promise = serverconnection_1$4.ServerConnection.makeRequest(_url, init, serverSettings);
    return promise.then((response) => {
      if (response.status === 400) {
        throw new serverconnection_1$4.ServerConnection.ResponseError(response, "Build aborted");
      }
      if (response.status !== 200) {
        const message = `Build failed with ${response.status}.

        If you are experiencing the build failure after installing an extension (or trying to include previously installed extension after updating JupyterLab) please check the extension repository for new installation instructions as many extensions migrated to the prebuilt extensions system which no longer requires rebuilding JupyterLab (but uses a different installation procedure, typically involving a package manager such as 'pip' or 'conda').

        If you specifically intended to install a source extension, please run 'jupyter lab build' on the server for full output.`;
        throw new serverconnection_1$4.ServerConnection.ResponseError(response, message);
      }
    });
  }
  /**
   * Cancel an active build.
   */
  cancel() {
    const { _url, serverSettings } = this;
    const init = { method: "DELETE" };
    const promise = serverconnection_1$4.ServerConnection.makeRequest(_url, init, serverSettings);
    return promise.then((response) => {
      if (response.status !== 204) {
        throw new serverconnection_1$4.ServerConnection.ResponseError(response);
      }
    });
  }
}
builder.BuildManager = BuildManager;
var nbconvert = {};
Object.defineProperty(nbconvert, "__esModule", { value: true });
nbconvert.NbConvertManager = void 0;
const coreutils_1$3 = lib$9;
const serverconnection_1$3 = serverconnection;
const coreutils_2$1 = require$$1$2;
const NBCONVERT_SETTINGS_URL = "api/nbconvert";
class NbConvertManager {
  /**
   * Create a new nbconvert manager.
   */
  constructor(options = {}) {
    var _a;
    this._exportFormats = null;
    this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1$3.ServerConnection.makeSettings();
  }
  /**
   * Fetch and cache the export formats from the expensive nbconvert handler.
   */
  async fetchExportFormats() {
    this._requestingFormats = new coreutils_2$1.PromiseDelegate();
    this._exportFormats = null;
    const base2 = this.serverSettings.baseUrl;
    const url2 = coreutils_1$3.URLExt.join(base2, NBCONVERT_SETTINGS_URL);
    const { serverSettings } = this;
    const response = await serverconnection_1$3.ServerConnection.makeRequest(url2, {}, serverSettings);
    if (response.status !== 200) {
      const err = await serverconnection_1$3.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    const exportList = {};
    const keys2 = Object.keys(data);
    keys2.forEach(function(key2) {
      const mimeType = data[key2].output_mimetype;
      exportList[key2] = { output_mimetype: mimeType };
    });
    this._exportFormats = exportList;
    this._requestingFormats.resolve(exportList);
    return exportList;
  }
  /**
   * Get the list of export formats, preferring pre-cached ones.
   */
  async getExportFormats(force = true) {
    if (this._requestingFormats) {
      return this._requestingFormats.promise;
    }
    if (force || !this._exportFormats) {
      return await this.fetchExportFormats();
    }
    return this._exportFormats;
  }
}
nbconvert.NbConvertManager = NbConvertManager;
var session$1 = {};
var session = {};
Object.defineProperty(session, "__esModule", { value: true });
var restapi$1 = {};
var validate = {};
Object.defineProperty(validate, "__esModule", { value: true });
validate.validateModels = validate.updateLegacySessionModel = validate.validateModel = void 0;
const validate_1 = validate$2;
const validate_2 = validate$3;
function validateModel(data) {
  (0, validate_2.validateProperty)(data, "id", "string");
  (0, validate_2.validateProperty)(data, "type", "string");
  (0, validate_2.validateProperty)(data, "name", "string");
  (0, validate_2.validateProperty)(data, "path", "string");
  (0, validate_2.validateProperty)(data, "kernel", "object");
  (0, validate_1.validateModel)(data.kernel);
}
validate.validateModel = validateModel;
function updateLegacySessionModel(data) {
  if (data.path === void 0 && data.notebook !== void 0) {
    data.path = data.notebook.path;
    data.type = "notebook";
    data.name = "";
  }
}
validate.updateLegacySessionModel = updateLegacySessionModel;
function validateModels(models) {
  if (!Array.isArray(models)) {
    throw new Error("Invalid session list");
  }
  models.forEach((d) => validateModel(d));
}
validate.validateModels = validateModels;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.updateSession = exports.startSession = exports.getSessionModel = exports.shutdownSession = exports.getSessionUrl = exports.listRunning = exports.SESSION_SERVICE_URL = void 0;
  const serverconnection_12 = serverconnection;
  const coreutils_12 = lib$9;
  const validate_12 = validate;
  exports.SESSION_SERVICE_URL = "api/sessions";
  async function listRunning(settings = serverconnection_12.ServerConnection.makeSettings()) {
    const url2 = coreutils_12.URLExt.join(settings.baseUrl, exports.SESSION_SERVICE_URL);
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, {}, settings);
    if (response.status !== 200) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    if (!Array.isArray(data)) {
      throw new Error("Invalid Session list");
    }
    data.forEach((m2) => {
      (0, validate_12.updateLegacySessionModel)(m2);
      (0, validate_12.validateModel)(m2);
    });
    return data;
  }
  exports.listRunning = listRunning;
  function getSessionUrl(baseUrl, id) {
    const servicesBase = coreutils_12.URLExt.join(baseUrl, exports.SESSION_SERVICE_URL);
    const result2 = coreutils_12.URLExt.join(servicesBase, id);
    if (!result2.startsWith(servicesBase)) {
      throw new Error("Can only be used for services requests");
    }
    return result2;
  }
  exports.getSessionUrl = getSessionUrl;
  async function shutdownSession(id, settings = serverconnection_12.ServerConnection.makeSettings()) {
    var _a;
    const url2 = getSessionUrl(settings.baseUrl, id);
    const init = { method: "DELETE" };
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, init, settings);
    if (response.status === 404) {
      const data = await response.json();
      const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The session "${id}"" does not exist on the server`;
      console.warn(msg);
    } else if (response.status === 410) {
      throw new serverconnection_12.ServerConnection.ResponseError(response, "The kernel was deleted but the session was not");
    } else if (response.status !== 204) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
  }
  exports.shutdownSession = shutdownSession;
  async function getSessionModel(id, settings = serverconnection_12.ServerConnection.makeSettings()) {
    const url2 = getSessionUrl(settings.baseUrl, id);
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, {}, settings);
    if (response.status !== 200) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    (0, validate_12.updateLegacySessionModel)(data);
    (0, validate_12.validateModel)(data);
    return data;
  }
  exports.getSessionModel = getSessionModel;
  async function startSession(options, settings = serverconnection_12.ServerConnection.makeSettings()) {
    const url2 = coreutils_12.URLExt.join(settings.baseUrl, exports.SESSION_SERVICE_URL);
    const init = {
      method: "POST",
      body: JSON.stringify(options)
    };
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, init, settings);
    if (response.status !== 201) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    (0, validate_12.updateLegacySessionModel)(data);
    (0, validate_12.validateModel)(data);
    return data;
  }
  exports.startSession = startSession;
  async function updateSession(model, settings = serverconnection_12.ServerConnection.makeSettings()) {
    const url2 = getSessionUrl(settings.baseUrl, model.id);
    const init = {
      method: "PATCH",
      body: JSON.stringify(model)
    };
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, init, settings);
    if (response.status !== 200) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    (0, validate_12.updateLegacySessionModel)(data);
    (0, validate_12.validateModel)(data);
    return data;
  }
  exports.updateSession = updateSession;
})(restapi$1);
var manager$1 = {};
var _default$1 = {};
var hasRequired_default$1;
function require_default$1() {
  if (hasRequired_default$1) return _default$1;
  hasRequired_default$1 = 1;
  Object.defineProperty(_default$1, "__esModule", { value: true });
  _default$1.SessionConnection = void 0;
  const signaling_12 = require$$0$1;
  const __1 = requireLib();
  const restapi_1 = restapi$1;
  const coreutils_12 = require$$1$2;
  class SessionConnection {
    /**
     * Construct a new session.
     */
    constructor(options) {
      var _a, _b, _c, _d;
      this._id = "";
      this._path = "";
      this._name = "";
      this._type = "";
      this._kernel = null;
      this._isDisposed = false;
      this._disposed = new signaling_12.Signal(this);
      this._kernelChanged = new signaling_12.Signal(this);
      this._statusChanged = new signaling_12.Signal(this);
      this._connectionStatusChanged = new signaling_12.Signal(this);
      this._pendingInput = new signaling_12.Signal(this);
      this._iopubMessage = new signaling_12.Signal(this);
      this._unhandledMessage = new signaling_12.Signal(this);
      this._anyMessage = new signaling_12.Signal(this);
      this._propertyChanged = new signaling_12.Signal(this);
      this._id = options.model.id;
      this._name = options.model.name;
      this._path = options.model.path;
      this._type = options.model.type;
      this._username = (_a = options.username) !== null && _a !== void 0 ? _a : "";
      this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4();
      this._connectToKernel = options.connectToKernel;
      this._kernelConnectionOptions = (_c = options.kernelConnectionOptions) !== null && _c !== void 0 ? _c : {};
      this.serverSettings = (_d = options.serverSettings) !== null && _d !== void 0 ? _d : __1.ServerConnection.makeSettings();
      this.setupKernel(options.model.kernel);
    }
    /**
     * A signal emitted when the session is disposed.
     */
    get disposed() {
      return this._disposed;
    }
    /**
     * A signal emitted when the kernel changes.
     */
    get kernelChanged() {
      return this._kernelChanged;
    }
    /**
     * A signal proxied from the connection about the kernel status.
     */
    get statusChanged() {
      return this._statusChanged;
    }
    /**
     * A signal proxied from the kernel about the connection status.
     */
    get connectionStatusChanged() {
      return this._connectionStatusChanged;
    }
    /**
     * A signal proxied from the kernel pending input.
     */
    get pendingInput() {
      return this._pendingInput;
    }
    /**
     * A signal proxied from the kernel about iopub kernel messages.
     */
    get iopubMessage() {
      return this._iopubMessage;
    }
    /**
     * A signal proxied from the kernel for an unhandled kernel message.
     */
    get unhandledMessage() {
      return this._unhandledMessage;
    }
    /**
     * A signal proxied from the kernel emitted for any kernel message.
     *
     * #### Notes
     * The behavior is undefined if the message is modified during message
     * handling. As such, it should be treated as read-only.
     */
    get anyMessage() {
      return this._anyMessage;
    }
    /**
     * A signal emitted when a session property changes.
     */
    get propertyChanged() {
      return this._propertyChanged;
    }
    /**
     * Get the session id.
     */
    get id() {
      return this._id;
    }
    /**
     * Get the session kernel connection object.
     *
     * #### Notes
     * This is a read-only property, and can be altered by [changeKernel].
     */
    get kernel() {
      return this._kernel;
    }
    /**
     * Get the session path.
     */
    get path() {
      return this._path;
    }
    /**
     * Get the session type.
     */
    get type() {
      return this._type;
    }
    /**
     * Get the session name.
     */
    get name() {
      return this._name;
    }
    /**
     * Get the model associated with the session.
     */
    get model() {
      return {
        id: this.id,
        kernel: this.kernel && { id: this.kernel.id, name: this.kernel.name },
        path: this._path,
        type: this._type,
        name: this._name
      };
    }
    /**
     * Test whether the session has been disposed.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Update the session based on a session model from the server.
     *
     * #### Notes
     * This only updates this session connection instance. Use `setPath`,
     * `setName`, `setType`, and `changeKernel` to change the session values on
     * the server.
     */
    update(model) {
      const oldModel = this.model;
      this._path = model.path;
      this._name = model.name;
      this._type = model.type;
      if (this._kernel === null && model.kernel !== null || this._kernel !== null && model.kernel === null || this._kernel !== null && model.kernel !== null && this._kernel.id !== model.kernel.id) {
        if (this._kernel !== null) {
          this._kernel.dispose();
        }
        const oldValue = this._kernel || null;
        this.setupKernel(model.kernel);
        const newValue = this._kernel || null;
        this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
      }
      this._handleModelChange(oldModel);
    }
    /**
     * Dispose of the resources held by the session.
     */
    dispose() {
      if (this.isDisposed) {
        return;
      }
      this._isDisposed = true;
      this._disposed.emit();
      if (this._kernel) {
        this._kernel.dispose();
        const oldValue = this._kernel;
        this._kernel = null;
        const newValue = this._kernel;
        this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
      }
      signaling_12.Signal.clearData(this);
    }
    /**
     * Change the session path.
     *
     * @param path - The new session path.
     *
     * @returns A promise that resolves when the session has renamed.
     *
     * #### Notes
     * This uses the Jupyter REST API, and the response is validated.
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    async setPath(path2) {
      if (this.isDisposed) {
        throw new Error("Session is disposed");
      }
      await this._patch({ path: path2 });
    }
    /**
     * Change the session name.
     */
    async setName(name2) {
      if (this.isDisposed) {
        throw new Error("Session is disposed");
      }
      await this._patch({ name: name2 });
    }
    /**
     * Change the session type.
     */
    async setType(type) {
      if (this.isDisposed) {
        throw new Error("Session is disposed");
      }
      await this._patch({ type });
    }
    /**
     * Change the kernel.
     *
     * @param options - The name or id of the new kernel.
     *
     * #### Notes
     * This shuts down the existing kernel and creates a new kernel,
     * keeping the existing session ID and session path.
     */
    async changeKernel(options) {
      if (this.isDisposed) {
        throw new Error("Session is disposed");
      }
      await this._patch({ kernel: options });
      return this.kernel;
    }
    /**
     * Kill the kernel and shutdown the session.
     *
     * @returns - The promise fulfilled on a valid response from the server.
     *
     * #### Notes
     * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions), and validates the response.
     * Disposes of the session and emits a [sessionDied] signal on success.
     */
    async shutdown() {
      if (this.isDisposed) {
        throw new Error("Session is disposed");
      }
      await (0, restapi_1.shutdownSession)(this.id, this.serverSettings);
      this.dispose();
    }
    /**
     * Create a new kernel connection and connect to its signals.
     *
     * #### Notes
     * This method is not meant to be subclassed.
     */
    setupKernel(model) {
      if (model === null) {
        this._kernel = null;
        return;
      }
      const kc = this._connectToKernel({
        ...this._kernelConnectionOptions,
        model,
        username: this._username,
        clientId: this._clientId,
        serverSettings: this.serverSettings
      });
      this._kernel = kc;
      kc.statusChanged.connect(this.onKernelStatus, this);
      kc.connectionStatusChanged.connect(this.onKernelConnectionStatus, this);
      kc.pendingInput.connect(this.onPendingInput, this);
      kc.unhandledMessage.connect(this.onUnhandledMessage, this);
      kc.iopubMessage.connect(this.onIOPubMessage, this);
      kc.anyMessage.connect(this.onAnyMessage, this);
    }
    /**
     * Handle to changes in the Kernel status.
     */
    onKernelStatus(sender, state) {
      this._statusChanged.emit(state);
    }
    /**
     * Handle to changes in the Kernel status.
     */
    onKernelConnectionStatus(sender, state) {
      this._connectionStatusChanged.emit(state);
    }
    /**
     * Handle a change in the pendingInput.
     */
    onPendingInput(sender, state) {
      this._pendingInput.emit(state);
    }
    /**
     * Handle iopub kernel messages.
     */
    onIOPubMessage(sender, msg) {
      this._iopubMessage.emit(msg);
    }
    /**
     * Handle unhandled kernel messages.
     */
    onUnhandledMessage(sender, msg) {
      this._unhandledMessage.emit(msg);
    }
    /**
     * Handle any kernel messages.
     */
    onAnyMessage(sender, args) {
      this._anyMessage.emit(args);
    }
    /**
     * Send a PATCH to the server, updating the session path or the kernel.
     */
    async _patch(body) {
      const model = await (0, restapi_1.updateSession)({ ...body, id: this._id }, this.serverSettings);
      this.update(model);
      return model;
    }
    /**
     * Handle a change to the model.
     */
    _handleModelChange(oldModel) {
      if (oldModel.name !== this._name) {
        this._propertyChanged.emit("name");
      }
      if (oldModel.type !== this._type) {
        this._propertyChanged.emit("type");
      }
      if (oldModel.path !== this._path) {
        this._propertyChanged.emit("path");
      }
    }
  }
  _default$1.SessionConnection = SessionConnection;
  return _default$1;
}
var hasRequiredManager$2;
function requireManager$2() {
  if (hasRequiredManager$2) return manager$1;
  hasRequiredManager$2 = 1;
  Object.defineProperty(manager$1, "__esModule", { value: true });
  manager$1.SessionManager = void 0;
  const polling_12 = require$$2$1;
  const signaling_12 = require$$0$1;
  const serverconnection_12 = serverconnection;
  const basemanager_12 = basemanager;
  const default_1 = require_default$1();
  const restapi_1 = restapi$1;
  class SessionManager extends basemanager_12.BaseManager {
    /**
     * Construct a new session manager.
     *
     * @param options - The default options for each session.
     */
    constructor(options) {
      var _a;
      super(options);
      this._isReady = false;
      this._sessionConnections = /* @__PURE__ */ new Set();
      this._models = /* @__PURE__ */ new Map();
      this._runningChanged = new signaling_12.Signal(this);
      this._connectionFailure = new signaling_12.Signal(this);
      this._connectToKernel = (options2) => {
        return this._kernelManager.connectTo(options2);
      };
      this._kernelManager = options.kernelManager;
      this._pollModels = new polling_12.Poll({
        auto: false,
        factory: () => this.requestRunning(),
        frequency: {
          interval: 10 * 1e3,
          backoff: true,
          max: 300 * 1e3
        },
        name: `@jupyterlab/services:SessionManager#models`,
        standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
      });
      this._ready = (async () => {
        await this._pollModels.start();
        await this._pollModels.tick;
        if (this._kernelManager.isActive) {
          await this._kernelManager.ready;
        }
        this._isReady = true;
      })();
    }
    /**
     * Test whether the manager is ready.
     */
    get isReady() {
      return this._isReady;
    }
    /**
     * A promise that fulfills when the manager is ready.
     */
    get ready() {
      return this._ready;
    }
    /**
     * A signal emitted when the running sessions change.
     */
    get runningChanged() {
      return this._runningChanged;
    }
    /**
     * A signal emitted when there is a connection failure.
     */
    get connectionFailure() {
      return this._connectionFailure;
    }
    /**
     * Dispose of the resources used by the manager.
     */
    dispose() {
      if (this.isDisposed) {
        return;
      }
      this._models.clear();
      this._sessionConnections.forEach((x2) => x2.dispose());
      this._pollModels.dispose();
      super.dispose();
    }
    /*
     * Connect to a running session.  See also [[connectToSession]].
     */
    connectTo(options) {
      const sessionConnection = new default_1.SessionConnection({
        ...options,
        connectToKernel: this._connectToKernel,
        serverSettings: this.serverSettings
      });
      this._onStarted(sessionConnection);
      if (!this._models.has(options.model.id)) {
        void this.refreshRunning().catch(() => {
        });
      }
      return sessionConnection;
    }
    /**
     * Create an iterator over the most recent running sessions.
     *
     * @returns A new iterator over the running sessions.
     */
    running() {
      return this._models.values();
    }
    /**
     * Force a refresh of the running sessions.
     *
     * @returns A promise that with the list of running sessions.
     *
     * #### Notes
     * This is not typically meant to be called by the user, since the
     * manager maintains its own internal state.
     */
    async refreshRunning() {
      await this._pollModels.refresh();
      await this._pollModels.tick;
    }
    /**
     * Start a new session.  See also [[startNewSession]].
     *
     * @param createOptions - Options for creating the session
     *
     * @param connectOptions - Options for connecting to the session
     */
    async startNew(createOptions, connectOptions = {}) {
      const model = await (0, restapi_1.startSession)(createOptions, this.serverSettings);
      await this.refreshRunning();
      return this.connectTo({ ...connectOptions, model });
    }
    /**
     * Shut down a session by id.
     */
    async shutdown(id) {
      await (0, restapi_1.shutdownSession)(id, this.serverSettings);
      await this.refreshRunning();
    }
    /**
     * Shut down all sessions.
     *
     * @returns A promise that resolves when all of the kernels are shut down.
     */
    async shutdownAll() {
      await this.refreshRunning();
      await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownSession)(id, this.serverSettings)));
      await this.refreshRunning();
    }
    /**
     * Find a session associated with a path and stop it if it is the only session
     * using that kernel.
     *
     * @param path - The path in question.
     *
     * @returns A promise that resolves when the relevant sessions are stopped.
     */
    async stopIfNeeded(path2) {
      try {
        const sessions = await (0, restapi_1.listRunning)(this.serverSettings);
        const matches2 = sessions.filter((value) => value.path === path2);
        if (matches2.length === 1) {
          const id = matches2[0].id;
          await this.shutdown(id);
        }
      } catch (error) {
      }
    }
    /**
     * Find a session by id.
     */
    async findById(id) {
      if (this._models.has(id)) {
        return this._models.get(id);
      }
      await this.refreshRunning();
      return this._models.get(id);
    }
    /**
     * Find a session by path.
     */
    async findByPath(path2) {
      for (const m2 of this._models.values()) {
        if (m2.path === path2) {
          return m2;
        }
      }
      await this.refreshRunning();
      for (const m2 of this._models.values()) {
        if (m2.path === path2) {
          return m2;
        }
      }
      return void 0;
    }
    /**
     * Execute a request to the server to poll running kernels and update state.
     */
    async requestRunning() {
      var _a, _b;
      let models;
      try {
        models = await (0, restapi_1.listRunning)(this.serverSettings);
      } catch (err) {
        if (err instanceof serverconnection_12.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
          this._connectionFailure.emit(err);
        }
        throw err;
      }
      if (this.isDisposed) {
        return;
      }
      if (this._models.size === models.length && models.every((model) => {
        var _a2, _b2, _c, _d;
        const existing = this._models.get(model.id);
        if (!existing) {
          return false;
        }
        return ((_a2 = existing.kernel) === null || _a2 === void 0 ? void 0 : _a2.id) === ((_b2 = model.kernel) === null || _b2 === void 0 ? void 0 : _b2.id) && ((_c = existing.kernel) === null || _c === void 0 ? void 0 : _c.name) === ((_d = model.kernel) === null || _d === void 0 ? void 0 : _d.name) && existing.name === model.name && existing.path === model.path && existing.type === model.type;
      })) {
        return;
      }
      this._models = new Map(models.map((x2) => [x2.id, x2]));
      this._sessionConnections.forEach((sc) => {
        if (this._models.has(sc.id)) {
          sc.update(this._models.get(sc.id));
        } else {
          sc.dispose();
        }
      });
      this._runningChanged.emit(models);
    }
    /**
     * Handle a session starting.
     */
    _onStarted(sessionConnection) {
      this._sessionConnections.add(sessionConnection);
      sessionConnection.disposed.connect(this._onDisposed, this);
      sessionConnection.propertyChanged.connect(this._onChanged, this);
      sessionConnection.kernelChanged.connect(this._onChanged, this);
    }
    _onDisposed(sessionConnection) {
      this._sessionConnections.delete(sessionConnection);
      void this.refreshRunning().catch(() => {
      });
    }
    _onChanged() {
      void this.refreshRunning().catch(() => {
      });
    }
  }
  manager$1.SessionManager = SessionManager;
  (function(SessionManager2) {
    class NoopManager extends SessionManager2 {
      constructor() {
        super(...arguments);
        this._readyPromise = new Promise(() => {
        });
      }
      /**
       * Whether the manager is active.
       */
      get isActive() {
        return false;
      }
      /**
       * Used for testing.
       */
      get parentReady() {
        return super.ready;
      }
      /**
       * Start a new session - throw an error since it is not supported.
       */
      async startNew(createOptions, connectOptions = {}) {
        return Promise.reject(new Error("Not implemented in no-op Session Manager"));
      }
      /*
       * Connect to a running session - throw an error since it is not supported.
       */
      connectTo(options) {
        throw Error("Not implemented in no-op Session Manager");
      }
      /**
       * A promise that fulfills when the manager is ready (never).
       */
      get ready() {
        return this.parentReady.then(() => this._readyPromise);
      }
      /**
       * Shut down a session by id - throw an error since it is not supported.
       */
      async shutdown(id) {
        return Promise.reject(new Error("Not implemented in no-op Session Manager"));
      }
      /**
       * Execute a request to the server to poll running sessions and update state.
       */
      async requestRunning() {
        return Promise.resolve();
      }
    }
    SessionManager2.NoopManager = NoopManager;
  })(SessionManager || (manager$1.SessionManager = SessionManager = {}));
  return manager$1;
}
var hasRequiredSession;
function requireSession() {
  if (hasRequiredSession) return session$1;
  hasRequiredSession = 1;
  (function(exports) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result2, mod, k);
      }
      __setModuleDefault2(result2, mod);
      return result2;
    };
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SessionAPI = exports.Session = void 0;
    const Session = __importStar2(session);
    exports.Session = Session;
    const SessionAPI = __importStar2(restapi$1);
    exports.SessionAPI = SessionAPI;
    __exportStar(requireManager$2(), exports);
  })(session$1);
  return session$1;
}
var setting = {};
Object.defineProperty(setting, "__esModule", { value: true });
setting.SettingManager = void 0;
const coreutils_1$2 = lib$9;
const statedb_1$1 = lib$7;
const serverconnection_1$2 = serverconnection;
const SERVICE_SETTINGS_URL = "api/settings";
class SettingManager extends statedb_1$1.DataConnector {
  /**
   * Create a new setting manager.
   */
  constructor(options = {}) {
    var _a;
    super();
    this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1$2.ServerConnection.makeSettings();
  }
  /**
   * Fetch a plugin's settings.
   *
   * @param id - The plugin's ID.
   *
   * @returns A promise that resolves if successful.
   */
  async fetch(id) {
    if (!id) {
      throw new Error("Plugin `id` parameter is required for settings fetch.");
    }
    const { serverSettings } = this;
    const { baseUrl, appUrl } = serverSettings;
    const { makeRequest, ResponseError } = serverconnection_1$2.ServerConnection;
    const base2 = baseUrl + appUrl;
    const url2 = Private$k.url(base2, id);
    const response = await makeRequest(url2, {}, serverSettings);
    if (response.status !== 200) {
      const err = await ResponseError.create(response);
      throw err;
    }
    return response.json();
  }
  /**
   * Fetch the list of all plugin setting bundles.
   *
   * @returns A promise that resolves if successful.
   */
  async list(query) {
    var _a, _b, _c, _d;
    const { serverSettings } = this;
    const { baseUrl, appUrl } = serverSettings;
    const { makeRequest, ResponseError } = serverconnection_1$2.ServerConnection;
    const base2 = baseUrl + appUrl;
    const url2 = Private$k.url(base2, "", query === "ids");
    const response = await makeRequest(url2, {}, serverSettings);
    if (response.status !== 200) {
      throw new ResponseError(response);
    }
    const json = await response.json();
    const ids = (_b = (_a = json === null || json === void 0 ? void 0 : json["settings"]) === null || _a === void 0 ? void 0 : _a.map((plugin2) => plugin2.id)) !== null && _b !== void 0 ? _b : [];
    let values = [];
    if (!query) {
      values = (_d = (_c = json === null || json === void 0 ? void 0 : json["settings"]) === null || _c === void 0 ? void 0 : _c.map((plugin2) => {
        plugin2.data = { composite: {}, user: {} };
        return plugin2;
      })) !== null && _d !== void 0 ? _d : [];
    }
    return { ids, values };
  }
  /**
   * Save a plugin's settings.
   *
   * @param id - The plugin's ID.
   *
   * @param raw - The user setting values as a raw string of JSON with comments.
   *
   * @returns A promise that resolves if successful.
   */
  async save(id, raw) {
    const { serverSettings } = this;
    const { baseUrl, appUrl } = serverSettings;
    const { makeRequest, ResponseError } = serverconnection_1$2.ServerConnection;
    const base2 = baseUrl + appUrl;
    const url2 = Private$k.url(base2, id);
    const init = { body: JSON.stringify({ raw }), method: "PUT" };
    const response = await makeRequest(url2, init, serverSettings);
    if (response.status !== 204) {
      throw new ResponseError(response);
    }
  }
}
setting.SettingManager = SettingManager;
var Private$k;
(function(Private2) {
  function url2(base2, id, idsOnly) {
    const idsOnlyParam = idsOnly ? coreutils_1$2.URLExt.objectToQueryString({ ids_only: true }) : "";
    const settingsBase = coreutils_1$2.URLExt.join(base2, SERVICE_SETTINGS_URL);
    const result2 = coreutils_1$2.URLExt.join(settingsBase, id);
    if (!result2.startsWith(settingsBase)) {
      throw new Error("Can only be used for workspaces requests");
    }
    return `${result2}${idsOnlyParam}`;
  }
  Private2.url = url2;
})(Private$k || (Private$k = {}));
var terminal$1 = {};
var terminal = {};
var restapi = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shutdownTerminal = exports.listRunning = exports.startNew = exports.isAvailable = exports.TERMINAL_SERVICE_URL = void 0;
  const coreutils_12 = lib$9;
  const serverconnection_12 = serverconnection;
  exports.TERMINAL_SERVICE_URL = "api/terminals";
  function isAvailable() {
    const available = String(coreutils_12.PageConfig.getOption("terminalsAvailable"));
    return available.toLowerCase() === "true";
  }
  exports.isAvailable = isAvailable;
  async function startNew(settings = serverconnection_12.ServerConnection.makeSettings(), name2, cwd) {
    Private2.errorIfNotAvailable();
    const url2 = coreutils_12.URLExt.join(settings.baseUrl, exports.TERMINAL_SERVICE_URL);
    const init = {
      method: "POST",
      body: JSON.stringify({ name: name2, cwd })
    };
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, init, settings);
    if (response.status !== 200) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    return data;
  }
  exports.startNew = startNew;
  async function listRunning(settings = serverconnection_12.ServerConnection.makeSettings()) {
    Private2.errorIfNotAvailable();
    const url2 = coreutils_12.URLExt.join(settings.baseUrl, exports.TERMINAL_SERVICE_URL);
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, {}, settings);
    if (response.status !== 200) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
    const data = await response.json();
    if (!Array.isArray(data)) {
      throw new Error("Invalid terminal list");
    }
    return data;
  }
  exports.listRunning = listRunning;
  async function shutdownTerminal(name2, settings = serverconnection_12.ServerConnection.makeSettings()) {
    var _a;
    Private2.errorIfNotAvailable();
    const workspacesBase = coreutils_12.URLExt.join(settings.baseUrl, exports.TERMINAL_SERVICE_URL);
    const url2 = coreutils_12.URLExt.join(workspacesBase, name2);
    if (!url2.startsWith(workspacesBase)) {
      throw new Error("Can only be used for terminal requests");
    }
    const init = { method: "DELETE" };
    const response = await serverconnection_12.ServerConnection.makeRequest(url2, init, settings);
    if (response.status === 404) {
      const data = await response.json();
      const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The terminal session "${name2}"" does not exist on the server`;
      console.warn(msg);
    } else if (response.status !== 204) {
      const err = await serverconnection_12.ServerConnection.ResponseError.create(response);
      throw err;
    }
  }
  exports.shutdownTerminal = shutdownTerminal;
  var Private2;
  (function(Private3) {
    function errorIfNotAvailable() {
      if (!isAvailable()) {
        throw new Error("Terminals Unavailable");
      }
    }
    Private3.errorIfNotAvailable = errorIfNotAvailable;
  })(Private2 || (Private2 = {}));
})(restapi);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAvailable = void 0;
  const restapi_1 = restapi;
  Object.defineProperty(exports, "isAvailable", { enumerable: true, get: function() {
    return restapi_1.isAvailable;
  } });
})(terminal);
var manager = {};
var _default = {};
var hasRequired_default;
function require_default() {
  if (hasRequired_default) return _default;
  hasRequired_default = 1;
  Object.defineProperty(_default, "__esModule", { value: true });
  _default.TerminalConnection = void 0;
  const coreutils_12 = lib$9;
  const coreutils_22 = require$$1$2;
  const signaling_12 = require$$0$1;
  const __1 = requireLib();
  const restapi_1 = restapi;
  class TerminalConnection {
    /**
     * Construct a new terminal session.
     */
    constructor(options) {
      var _a;
      this._createSocket = () => {
        this._errorIfDisposed();
        this._clearSocket();
        this._updateConnectionStatus("connecting");
        const name2 = this._name;
        const settings = this.serverSettings;
        let url2 = coreutils_12.URLExt.join(settings.wsUrl, "terminals", "websocket", encodeURIComponent(name2));
        const token = settings.token;
        if (settings.appendToken && token !== "") {
          url2 = url2 + `?token=${encodeURIComponent(token)}`;
        }
        this._ws = new settings.WebSocket(url2);
        this._ws.onmessage = this._onWSMessage;
        this._ws.onclose = this._onWSClose;
        this._ws.onerror = this._onWSClose;
      };
      this._onWSMessage = (event2) => {
        if (this._isDisposed) {
          return;
        }
        const data = JSON.parse(event2.data);
        if (data[0] === "disconnect") {
          this.dispose();
        }
        if (this._connectionStatus === "connecting") {
          if (data[0] === "setup") {
            this._updateConnectionStatus("connected");
          }
          return;
        }
        this._messageReceived.emit({
          type: data[0],
          content: data.slice(1)
        });
      };
      this._onWSClose = (event2) => {
        console.warn(`Terminal websocket closed: ${event2.code}`);
        if (!this.isDisposed) {
          this._reconnect();
        }
      };
      this._connectionStatus = "connecting";
      this._connectionStatusChanged = new signaling_12.Signal(this);
      this._isDisposed = false;
      this._disposed = new signaling_12.Signal(this);
      this._messageReceived = new signaling_12.Signal(this);
      this._reconnectTimeout = null;
      this._ws = null;
      this._noOp = () => {
      };
      this._reconnectLimit = 7;
      this._reconnectAttempt = 0;
      this._pendingMessages = [];
      this._name = options.model.name;
      this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
      this._createSocket();
    }
    /**
     * A signal emitted when the session is disposed.
     */
    get disposed() {
      return this._disposed;
    }
    /**
     * A signal emitted when a message is received from the server.
     */
    get messageReceived() {
      return this._messageReceived;
    }
    /**
     * Get the name of the terminal session.
     */
    get name() {
      return this._name;
    }
    /**
     * Get the model for the terminal session.
     */
    get model() {
      return { name: this._name };
    }
    /**
     * Test whether the session is disposed.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Dispose of the resources held by the session.
     */
    dispose() {
      if (this._isDisposed) {
        return;
      }
      this._isDisposed = true;
      this._disposed.emit();
      this._updateConnectionStatus("disconnected");
      this._clearSocket();
      signaling_12.Signal.clearData(this);
    }
    /**
     * Send a message to the terminal session.
     *
     * #### Notes
     * If the connection is down, the message will be queued for sending when
     * the connection comes back up.
     */
    send(message) {
      this._sendMessage(message);
    }
    /**
     * Send a message on the websocket, or possibly queue for later sending.
     *
     * @param queue - whether to queue the message if it cannot be sent
     */
    _sendMessage(message, queue = true) {
      if (this._isDisposed || !message.content) {
        return;
      }
      if (this.connectionStatus === "connected" && this._ws) {
        const msg = [message.type, ...message.content];
        this._ws.send(JSON.stringify(msg));
      } else if (queue) {
        this._pendingMessages.push(message);
      } else {
        throw new Error(`Could not send message: ${JSON.stringify(message)}`);
      }
    }
    /**
     * Send pending messages to the kernel.
     */
    _sendPending() {
      while (this.connectionStatus === "connected" && this._pendingMessages.length > 0) {
        this._sendMessage(this._pendingMessages[0], false);
        this._pendingMessages.shift();
      }
    }
    /**
     * Reconnect to a terminal.
     *
     * #### Notes
     * This may try multiple times to reconnect to a terminal, and will sever
     * any existing connection.
     */
    reconnect() {
      this._errorIfDisposed();
      const result2 = new coreutils_22.PromiseDelegate();
      const fulfill = (sender, status) => {
        if (status === "connected") {
          result2.resolve();
          this.connectionStatusChanged.disconnect(fulfill, this);
        } else if (status === "disconnected") {
          result2.reject(new Error("Terminal connection disconnected"));
          this.connectionStatusChanged.disconnect(fulfill, this);
        }
      };
      this.connectionStatusChanged.connect(fulfill, this);
      this._reconnectAttempt = 0;
      this._reconnect();
      return result2.promise;
    }
    /**
     * Attempt a connection if we have not exhausted connection attempts.
     */
    _reconnect() {
      this._errorIfDisposed();
      clearTimeout(this._reconnectTimeout);
      if (this._reconnectAttempt < this._reconnectLimit) {
        this._updateConnectionStatus("connecting");
        const timeout = Private2.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
        console.error(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
        this._reconnectTimeout = setTimeout(this._createSocket, timeout);
        this._reconnectAttempt += 1;
      } else {
        this._updateConnectionStatus("disconnected");
      }
      this._clearSocket();
    }
    /**
     * Forcefully clear the socket state.
     *
     * #### Notes
     * This will clear all socket state without calling any handlers and will
     * not update the connection status. If you call this method, you are
     * responsible for updating the connection status as needed and recreating
     * the socket if you plan to reconnect.
     */
    _clearSocket() {
      if (this._ws !== null) {
        this._ws.onopen = this._noOp;
        this._ws.onclose = this._noOp;
        this._ws.onerror = this._noOp;
        this._ws.onmessage = this._noOp;
        this._ws.close();
        this._ws = null;
      }
    }
    /**
     * Shut down the terminal session.
     */
    async shutdown() {
      await (0, restapi_1.shutdownTerminal)(this.name, this.serverSettings);
      this.dispose();
    }
    /**
     * Clone the current terminal connection.
     */
    clone() {
      return new TerminalConnection(this);
    }
    /**
     * Handle connection status changes.
     */
    _updateConnectionStatus(connectionStatus) {
      if (this._connectionStatus === connectionStatus) {
        return;
      }
      this._connectionStatus = connectionStatus;
      if (connectionStatus !== "connecting") {
        this._reconnectAttempt = 0;
        clearTimeout(this._reconnectTimeout);
      }
      if (connectionStatus === "connected") {
        this._sendPending();
      }
      this._connectionStatusChanged.emit(connectionStatus);
    }
    /**
     * Utility function to throw an error if this instance is disposed.
     */
    _errorIfDisposed() {
      if (this.isDisposed) {
        throw new Error("Terminal connection is disposed");
      }
    }
    /**
     * A signal emitted when the terminal connection status changes.
     */
    get connectionStatusChanged() {
      return this._connectionStatusChanged;
    }
    /**
     * The current connection status of the terminal connection.
     */
    get connectionStatus() {
      return this._connectionStatus;
    }
  }
  _default.TerminalConnection = TerminalConnection;
  var Private2;
  (function(Private3) {
    function getTermUrl(baseUrl, name2) {
      return coreutils_12.URLExt.join(baseUrl, restapi_1.TERMINAL_SERVICE_URL, encodeURIComponent(name2));
    }
    Private3.getTermUrl = getTermUrl;
    function getRandomIntInclusive(min2, max2) {
      min2 = Math.ceil(min2);
      max2 = Math.floor(max2);
      return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
    }
    Private3.getRandomIntInclusive = getRandomIntInclusive;
  })(Private2 || (Private2 = {}));
  return _default;
}
var hasRequiredManager$1;
function requireManager$1() {
  if (hasRequiredManager$1) return manager;
  hasRequiredManager$1 = 1;
  Object.defineProperty(manager, "__esModule", { value: true });
  manager.TerminalManager = void 0;
  const polling_12 = require$$2$1;
  const signaling_12 = require$$0$1;
  const __1 = requireLib();
  const basemanager_12 = basemanager;
  const restapi_1 = restapi;
  const default_1 = require_default();
  class TerminalManager extends basemanager_12.BaseManager {
    /**
     * Construct a new terminal manager.
     */
    constructor(options = {}) {
      var _a;
      super(options);
      this._isReady = false;
      this._names = [];
      this._terminalConnections = /* @__PURE__ */ new Set();
      this._runningChanged = new signaling_12.Signal(this);
      this._connectionFailure = new signaling_12.Signal(this);
      if (!this.isAvailable()) {
        this._ready = Promise.reject("Terminals unavailable");
        this._ready.catch((_) => void 0);
        return;
      }
      this._pollModels = new polling_12.Poll({
        auto: false,
        factory: () => this.requestRunning(),
        frequency: {
          interval: 10 * 1e3,
          backoff: true,
          max: 300 * 1e3
        },
        name: `@jupyterlab/services:TerminalManager#models`,
        standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
      });
      this._ready = (async () => {
        await this._pollModels.start();
        await this._pollModels.tick;
        this._isReady = true;
      })();
    }
    /**
     * Test whether the manager is ready.
     */
    get isReady() {
      return this._isReady;
    }
    /**
     * A promise that fulfills when the manager is ready.
     */
    get ready() {
      return this._ready;
    }
    /**
     * A signal emitted when the running terminals change.
     */
    get runningChanged() {
      return this._runningChanged;
    }
    /**
     * A signal emitted when there is a connection failure.
     */
    get connectionFailure() {
      return this._connectionFailure;
    }
    /**
     * Dispose of the resources used by the manager.
     */
    dispose() {
      if (this.isDisposed) {
        return;
      }
      this._names.length = 0;
      this._terminalConnections.forEach((x2) => x2.dispose());
      this._pollModels.dispose();
      super.dispose();
    }
    /**
     * Whether the terminal service is available.
     */
    isAvailable() {
      return (0, restapi_1.isAvailable)();
    }
    /*
     * Connect to a running terminal.
     *
     * @param options - The options used to connect to the terminal.
     *
     * @returns The new terminal connection instance.
     *
     * #### Notes
     * The manager `serverSettings` will be used.
     */
    connectTo(options) {
      const terminalConnection = new default_1.TerminalConnection({
        ...options,
        serverSettings: this.serverSettings
      });
      this._onStarted(terminalConnection);
      if (!this._names.includes(options.model.name)) {
        void this.refreshRunning().catch(() => {
        });
      }
      return terminalConnection;
    }
    /**
     * Create an iterator over the most recent running terminals.
     *
     * @returns A new iterator over the running terminals.
     */
    running() {
      return this._models[Symbol.iterator]();
    }
    /**
     * Force a refresh of the running terminals.
     *
     * @returns A promise that with the list of running terminals.
     *
     * #### Notes
     * This is intended to be called only in response to a user action,
     * since the manager maintains its internal state.
     */
    async refreshRunning() {
      await this._pollModels.refresh();
      await this._pollModels.tick;
    }
    /**
     * Create a new terminal session.
     *
     * @param options - The options used to create the terminal.
     *
     * @returns A promise that resolves with the terminal connection instance.
     *
     * #### Notes
     * The manager `serverSettings` will be used unless overridden in the
     * options.
     */
    async startNew(options) {
      const model = await (0, restapi_1.startNew)(this.serverSettings, options === null || options === void 0 ? void 0 : options.name, options === null || options === void 0 ? void 0 : options.cwd);
      await this.refreshRunning();
      return this.connectTo({ model });
    }
    /**
     * Shut down a terminal session by name.
     */
    async shutdown(name2) {
      await (0, restapi_1.shutdownTerminal)(name2, this.serverSettings);
      await this.refreshRunning();
    }
    /**
     * Shut down all terminal sessions.
     *
     * @returns A promise that resolves when all of the sessions are shut down.
     */
    async shutdownAll() {
      await this.refreshRunning();
      await Promise.all(this._names.map((name2) => (0, restapi_1.shutdownTerminal)(name2, this.serverSettings)));
      await this.refreshRunning();
    }
    /**
     * Execute a request to the server to poll running terminals and update state.
     */
    async requestRunning() {
      var _a, _b;
      let models;
      try {
        models = await (0, restapi_1.listRunning)(this.serverSettings);
      } catch (err) {
        if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
          this._connectionFailure.emit(err);
        }
        throw err;
      }
      if (this.isDisposed) {
        return;
      }
      const names = models.map(({ name: name2 }) => name2).sort();
      if (names === this._names) {
        return;
      }
      this._names = names;
      this._terminalConnections.forEach((tc) => {
        if (!names.includes(tc.name)) {
          tc.dispose();
        }
      });
      this._runningChanged.emit(this._models);
    }
    /**
     * Handle a session starting.
     */
    _onStarted(terminalConnection) {
      this._terminalConnections.add(terminalConnection);
      terminalConnection.disposed.connect(this._onDisposed, this);
    }
    /**
     * Handle a session terminating.
     */
    _onDisposed(terminalConnection) {
      this._terminalConnections.delete(terminalConnection);
      void this.refreshRunning().catch(() => {
      });
    }
    get _models() {
      return this._names.map((name2) => {
        return { name: name2 };
      });
    }
  }
  manager.TerminalManager = TerminalManager;
  (function(TerminalManager2) {
    class NoopManager extends TerminalManager2 {
      constructor() {
        super(...arguments);
        this._readyPromise = new Promise(() => {
        });
      }
      /**
       * Whether the manager is active.
       */
      get isActive() {
        return false;
      }
      /**
       * Used for testing.
       */
      get parentReady() {
        return super.ready;
      }
      /**
       * A promise that fulfills when the manager is ready (never).
       */
      get ready() {
        return this.parentReady.then(() => this._readyPromise);
      }
      /**
       * Create a new terminal session - throw an error since it is not supported.
       *
       */
      async startNew(options) {
        return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
      }
      /*
       * Connect to a running terminal - throw an error since it is not supported.
       */
      connectTo(options) {
        throw Error("Not implemented in no-op Terminal Manager");
      }
      /**
       * Shut down a session by id - throw an error since it is not supported.
       */
      async shutdown(id) {
        return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
      }
      /**
       * Execute a request to the server to poll running sessions and update state.
       */
      async requestRunning() {
        return Promise.resolve();
      }
    }
    TerminalManager2.NoopManager = NoopManager;
  })(TerminalManager || (manager.TerminalManager = TerminalManager = {}));
  return manager;
}
var hasRequiredTerminal;
function requireTerminal() {
  if (hasRequiredTerminal) return terminal$1;
  hasRequiredTerminal = 1;
  (function(exports) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result2, mod, k);
      }
      __setModuleDefault2(result2, mod);
      return result2;
    };
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TerminalAPI = exports.Terminal = void 0;
    const Terminal = __importStar2(terminal);
    exports.Terminal = Terminal;
    const TerminalAPI = __importStar2(restapi);
    exports.TerminalAPI = TerminalAPI;
    __exportStar(requireManager$1(), exports);
  })(terminal$1);
  return terminal$1;
}
var user = {};
Object.defineProperty(user, "__esModule", { value: true });
user.UserManager = void 0;
const coreutils_1$1 = lib$9;
const coreutils_2 = require$$1$2;
const polling_1 = require$$2$1;
const signaling_1 = require$$0$1;
const serverconnection_1$1 = serverconnection;
const basemanager_1 = basemanager;
const SERVICE_USER_URL = "api/me";
const SERVICE_ID = "@jupyterlab/services:UserManager#user";
class UserManager extends basemanager_1.BaseManager {
  /**
   * Create a new user manager.
   */
  constructor(options = {}) {
    var _a;
    super(options);
    this._isReady = false;
    this._userChanged = new signaling_1.Signal(this);
    this._connectionFailure = new signaling_1.Signal(this);
    this._ready = this.requestUser().then(() => {
      if (this.isDisposed) {
        return;
      }
      this._isReady = true;
    }).catch((_) => (
      // Return a promise that will never resolve, so user service is never ready
      // This typically occurs when the backend has no user service
      new Promise(() => {
      })
    ));
    this._pollSpecs = new polling_1.Poll({
      auto: false,
      factory: () => this.requestUser(),
      frequency: {
        interval: 61 * 1e3,
        backoff: true,
        max: 300 * 1e3
      },
      name: SERVICE_ID,
      standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
    });
    void this.ready.then(() => {
      void this._pollSpecs.start();
    });
  }
  /**
   * Test whether the manager is ready.
   */
  get isReady() {
    return this._isReady;
  }
  /**
   * A promise that fulfills when the manager is ready.
   */
  get ready() {
    return this._ready;
  }
  /**
   * Get the most recently fetched identity.
   */
  get identity() {
    return this._identity;
  }
  /**
   * Get the most recently fetched permissions.
   */
  get permissions() {
    return this._permissions;
  }
  /**
   * A signal emitted when the user changes.
   */
  get userChanged() {
    return this._userChanged;
  }
  /**
   * A signal emitted when there is a connection failure.
   */
  get connectionFailure() {
    return this._connectionFailure;
  }
  /**
   * Dispose of the resources used by the manager.
   */
  dispose() {
    this._pollSpecs.dispose();
    super.dispose();
  }
  /**
   * Force a refresh of the specs from the server.
   *
   * @returns A promise that resolves when the specs are fetched.
   *
   * #### Notes
   * This is intended to be called only in response to a user action,
   * since the manager maintains its internal state.
   */
  async refreshUser() {
    await this._pollSpecs.refresh();
    await this._pollSpecs.tick;
  }
  /**
   * Execute a request to the server to poll the user and update state.
   */
  async requestUser() {
    if (this.isDisposed) {
      return;
    }
    const { baseUrl } = this.serverSettings;
    const { makeRequest, ResponseError } = serverconnection_1$1.ServerConnection;
    const url2 = coreutils_1$1.URLExt.join(baseUrl, SERVICE_USER_URL);
    const response = await makeRequest(url2, {}, this.serverSettings);
    if (response.status !== 200) {
      const err = await ResponseError.create(response);
      throw err;
    }
    const oldUser = {
      identity: this._identity,
      permissions: this._permissions
    };
    const newUser = await response.json();
    const identity = newUser.identity;
    const { localStorage: localStorage2 } = window;
    const data = localStorage2.getItem(SERVICE_ID);
    if (data && (!identity.initials || !identity.color)) {
      const localUser = JSON.parse(data);
      identity.initials = identity.initials || localUser.initials || identity.name.substring(0, 1);
      identity.color = identity.color || localUser.color || Private$j.getRandomColor();
    }
    if (!coreutils_2.JSONExt.deepEqual(newUser, oldUser)) {
      this._identity = identity;
      this._permissions = newUser.permissions;
      localStorage2.setItem(SERVICE_ID, JSON.stringify(identity));
      this._userChanged.emit(newUser);
    }
  }
}
user.UserManager = UserManager;
var Private$j;
(function(Private2) {
  const userColors = [
    "var(--jp-collaborator-color1)",
    "var(--jp-collaborator-color2)",
    "var(--jp-collaborator-color3)",
    "var(--jp-collaborator-color4)",
    "var(--jp-collaborator-color5)",
    "var(--jp-collaborator-color6)",
    "var(--jp-collaborator-color7)"
  ];
  Private2.getRandomColor = () => userColors[Math.floor(Math.random() * userColors.length)];
})(Private$j || (Private$j = {}));
var workspace = {};
Object.defineProperty(workspace, "__esModule", { value: true });
workspace.WorkspaceManager = void 0;
const coreutils_1 = lib$9;
const statedb_1 = lib$7;
const serverconnection_1 = serverconnection;
const SERVICE_WORKSPACES_URL = "api/workspaces";
class WorkspaceManager extends statedb_1.DataConnector {
  /**
   * Create a new workspace manager.
   */
  constructor(options = {}) {
    var _a;
    super();
    this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
  }
  /**
   * Fetch a workspace.
   *
   * @param id - The workspace's ID.
   *
   * @returns A promise that resolves if successful.
   */
  async fetch(id) {
    const { serverSettings } = this;
    const { baseUrl, appUrl } = serverSettings;
    const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
    const base2 = baseUrl + appUrl;
    const url2 = Private$i.url(base2, id);
    const response = await makeRequest(url2, {}, serverSettings);
    if (response.status !== 200) {
      const err = await ResponseError.create(response);
      throw err;
    }
    return response.json();
  }
  /**
   * Fetch the list of workspace IDs that exist on the server.
   *
   * @returns A promise that resolves if successful.
   */
  async list() {
    const { serverSettings } = this;
    const { baseUrl, appUrl } = serverSettings;
    const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
    const base2 = baseUrl + appUrl;
    const url2 = Private$i.url(base2, "");
    const response = await makeRequest(url2, {}, serverSettings);
    if (response.status !== 200) {
      const err = await ResponseError.create(response);
      throw err;
    }
    const result2 = await response.json();
    return result2.workspaces;
  }
  /**
   * Remove a workspace from the server.
   *
   * @param id - The workspaces's ID.
   *
   * @returns A promise that resolves if successful.
   */
  async remove(id) {
    const { serverSettings } = this;
    const { baseUrl, appUrl } = serverSettings;
    const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
    const base2 = baseUrl + appUrl;
    const url2 = Private$i.url(base2, id);
    const init = { method: "DELETE" };
    const response = await makeRequest(url2, init, serverSettings);
    if (response.status !== 204) {
      const err = await ResponseError.create(response);
      throw err;
    }
  }
  /**
   * Save a workspace.
   *
   * @param id - The workspace's ID.
   *
   * @param workspace - The workspace being saved.
   *
   * @returns A promise that resolves if successful.
   */
  async save(id, workspace2) {
    const { serverSettings } = this;
    const { baseUrl, appUrl } = serverSettings;
    const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
    const base2 = baseUrl + appUrl;
    const url2 = Private$i.url(base2, id);
    const init = { body: JSON.stringify(workspace2), method: "PUT" };
    const response = await makeRequest(url2, init, serverSettings);
    if (response.status !== 204) {
      const err = await ResponseError.create(response);
      throw err;
    }
  }
}
workspace.WorkspaceManager = WorkspaceManager;
var Private$i;
(function(Private2) {
  function url2(base2, id) {
    const workspacesBase = coreutils_1.URLExt.join(base2, SERVICE_WORKSPACES_URL);
    const result2 = coreutils_1.URLExt.join(workspacesBase, id);
    if (!result2.startsWith(workspacesBase)) {
      throw new Error("Can only be used for workspaces requests");
    }
    return result2;
  }
  Private2.url = url2;
})(Private$i || (Private$i = {}));
var hasRequiredManager;
function requireManager() {
  if (hasRequiredManager) return manager$2;
  hasRequiredManager = 1;
  Object.defineProperty(manager$2, "__esModule", { value: true });
  manager$2.ServiceManager = void 0;
  const signaling_12 = require$$0$1;
  const builder_1 = builder;
  const contents_1 = requireContents();
  const event_1 = event;
  const kernel_1 = requireKernel();
  const kernelspec_1 = kernelspec$1;
  const nbconvert_1 = nbconvert;
  const serverconnection_12 = serverconnection;
  const session_1 = requireSession();
  const setting_1 = setting;
  const terminal_1 = requireTerminal();
  const user_1 = user;
  const workspace_1 = workspace;
  class ServiceManager {
    /**
     * Construct a new services provider.
     */
    constructor(options = {}) {
      var _a, _b;
      this._isDisposed = false;
      this._connectionFailure = new signaling_12.Signal(this);
      this._isReady = false;
      const defaultDrive = options.defaultDrive;
      const serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_12.ServerConnection.makeSettings();
      const standby = (_b = options.standby) !== null && _b !== void 0 ? _b : "when-hidden";
      const normalized = { defaultDrive, serverSettings, standby };
      this.serverSettings = serverSettings;
      this.contents = options.contents || new contents_1.ContentsManager(normalized);
      this.events = options.events || new event_1.EventManager(normalized);
      this.kernels = options.kernels || new kernel_1.KernelManager(normalized);
      this.sessions = options.sessions || new session_1.SessionManager({
        ...normalized,
        kernelManager: this.kernels
      });
      this.settings = options.settings || new setting_1.SettingManager(normalized);
      this.terminals = options.terminals || new terminal_1.TerminalManager(normalized);
      this.builder = options.builder || new builder_1.BuildManager(normalized);
      this.workspaces = options.workspaces || new workspace_1.WorkspaceManager(normalized);
      this.nbconvert = options.nbconvert || new nbconvert_1.NbConvertManager(normalized);
      this.kernelspecs = options.kernelspecs || new kernelspec_1.KernelSpecManager(normalized);
      this.user = options.user || new user_1.UserManager(normalized);
      this.kernelspecs.connectionFailure.connect(this._onConnectionFailure, this);
      this.sessions.connectionFailure.connect(this._onConnectionFailure, this);
      this.terminals.connectionFailure.connect(this._onConnectionFailure, this);
      const readyList = [this.sessions.ready, this.kernelspecs.ready];
      if (this.terminals.isAvailable()) {
        readyList.push(this.terminals.ready);
      }
      this._readyPromise = Promise.all(readyList).then(() => {
        this._isReady = true;
      });
    }
    /**
     * A signal emitted when there is a connection failure with the kernel.
     */
    get connectionFailure() {
      return this._connectionFailure;
    }
    /**
     * Test whether the service manager is disposed.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Dispose of the resources used by the manager.
     */
    dispose() {
      if (this.isDisposed) {
        return;
      }
      this._isDisposed = true;
      signaling_12.Signal.clearData(this);
      this.contents.dispose();
      this.events.dispose();
      this.sessions.dispose();
      this.terminals.dispose();
    }
    /**
     * Test whether the manager is ready.
     */
    get isReady() {
      return this._isReady;
    }
    /**
     * A promise that fulfills when the manager is ready.
     */
    get ready() {
      return this._readyPromise;
    }
    _onConnectionFailure(sender, err) {
      this._connectionFailure.emit(err);
    }
  }
  manager$2.ServiceManager = ServiceManager;
  return manager$2;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$6;
  hasRequiredLib = 1;
  (function(exports) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(basemanager, exports);
    __exportStar(requireConfig(), exports);
    __exportStar(requireContents(), exports);
    __exportStar(event, exports);
    __exportStar(requireKernel(), exports);
    __exportStar(kernelspec$1, exports);
    __exportStar(requireManager(), exports);
    __exportStar(serverconnection, exports);
    __exportStar(requireSession(), exports);
    __exportStar(setting, exports);
    __exportStar(requireTerminal(), exports);
    __exportStar(user, exports);
    __exportStar(workspace, exports);
    __exportStar(nbconvert, exports);
  })(lib$6);
  return lib$6;
}
var libExports = requireLib();
function clamp(i2, min2, max2) {
  if (isNaN(i2) || i2 <= min2) {
    return min2;
  } else if (i2 >= max2) {
    return max2;
  }
  return i2;
}
function normalize(i2, min2, max2) {
  if (isNaN(i2) || i2 <= min2) {
    return 0;
  } else if (i2 >= max2) {
    return 1;
  }
  return i2 / (max2 - min2);
}
function denormalize(i2, min2, max2) {
  if (isNaN(i2)) {
    return min2;
  }
  return min2 + i2 * (max2 - min2);
}
function degreesToRadians(i2) {
  return i2 * (Math.PI / 180);
}
function radiansToDegrees(i2) {
  return i2 * (180 / Math.PI);
}
function getHexStringForByte(i2) {
  const s = Math.round(clamp(i2, 0, 255)).toString(16);
  if (s.length === 1) {
    return "0" + s;
  }
  return s;
}
function lerp(i2, min2, max2) {
  if (isNaN(i2) || i2 <= 0) {
    return min2;
  } else if (i2 >= 1) {
    return max2;
  }
  return min2 + i2 * (max2 - min2);
}
function lerpAnglesInDegrees(i2, min2, max2) {
  if (i2 <= 0) {
    return min2 % 360;
  } else if (i2 >= 1) {
    return max2 % 360;
  }
  const a = (min2 - max2 + 360) % 360;
  const b = (max2 - min2 + 360) % 360;
  if (a <= b) {
    return (min2 - a * i2 + 360) % 360;
  }
  return (min2 + a * i2 + 360) % 360;
}
function roundToPrecisionSmall(i2, precision) {
  const factor = Math.pow(10, precision);
  return Math.round(i2 * factor) / factor;
}
class ColorHSL {
  constructor(hue, sat, lum) {
    this.h = hue;
    this.s = sat;
    this.l = lum;
  }
  /**
   * Construct a {@link ColorHSL} from a config object.
   */
  static fromObject(data) {
    if (data && !isNaN(data.h) && !isNaN(data.s) && !isNaN(data.l)) {
      return new ColorHSL(data.h, data.s, data.l);
    }
    return null;
  }
  /**
   * Determines if a color is equal to another
   * @param rhs - the value to compare
   */
  equalValue(rhs) {
    return this.h === rhs.h && this.s === rhs.s && this.l === rhs.l;
  }
  /**
   * Returns a new {@link ColorHSL} rounded to the provided precision
   * @param precision - the precision to round to
   */
  roundToPrecision(precision) {
    return new ColorHSL(roundToPrecisionSmall(this.h, precision), roundToPrecisionSmall(this.s, precision), roundToPrecisionSmall(this.l, precision));
  }
  /**
   * Returns the {@link ColorHSL} formatted as an object.
   */
  toObject() {
    return { h: this.h, s: this.s, l: this.l };
  }
}
class ColorHSV {
  constructor(hue, sat, val) {
    this.h = hue;
    this.s = sat;
    this.v = val;
  }
  /**
   * Construct a {@link ColorHSV} from a config object.
   */
  static fromObject(data) {
    if (data && !isNaN(data.h) && !isNaN(data.s) && !isNaN(data.v)) {
      return new ColorHSV(data.h, data.s, data.v);
    }
    return null;
  }
  /**
   * Determines if a color is equal to another
   * @param rhs - the value to compare
   */
  equalValue(rhs) {
    return this.h === rhs.h && this.s === rhs.s && this.v === rhs.v;
  }
  /**
   * Returns a new {@link ColorHSV} rounded to the provided precision
   * @param precision - the precision to round to
   */
  roundToPrecision(precision) {
    return new ColorHSV(roundToPrecisionSmall(this.h, precision), roundToPrecisionSmall(this.s, precision), roundToPrecisionSmall(this.v, precision));
  }
  /**
   * Returns the {@link ColorHSV} formatted as an object.
   */
  toObject() {
    return { h: this.h, s: this.s, v: this.v };
  }
}
class ColorLAB {
  constructor(l, a, b) {
    this.l = l;
    this.a = a;
    this.b = b;
  }
  /**
   * Construct a {@link ColorLAB} from a config object.
   */
  static fromObject(data) {
    if (data && !isNaN(data.l) && !isNaN(data.a) && !isNaN(data.b)) {
      return new ColorLAB(data.l, data.a, data.b);
    }
    return null;
  }
  /**
   * Determines if a color is equal to another
   * @param rhs - the value to compare
   */
  equalValue(rhs) {
    return this.l === rhs.l && this.a === rhs.a && this.b === rhs.b;
  }
  /**
   * Returns a new {@link ColorLAB} rounded to the provided precision
   * @param precision - the precision to round to
   */
  roundToPrecision(precision) {
    return new ColorLAB(roundToPrecisionSmall(this.l, precision), roundToPrecisionSmall(this.a, precision), roundToPrecisionSmall(this.b, precision));
  }
  /**
   * Returns the {@link ColorLAB} formatted as an object.
   */
  toObject() {
    return { l: this.l, a: this.a, b: this.b };
  }
}
ColorLAB.epsilon = 216 / 24389;
ColorLAB.kappa = 24389 / 27;
class ColorLCH {
  constructor(l, c, h2) {
    this.l = l;
    this.c = c;
    this.h = h2;
  }
  /**
   * Construct a {@link ColorLCH} from a config object.
   * @param data - the config object
   */
  static fromObject(data) {
    if (data && !isNaN(data.l) && !isNaN(data.c) && !isNaN(data.h)) {
      return new ColorLCH(data.l, data.c, data.h);
    }
    return null;
  }
  /**
   * Determines if one color is equal to another.
   * @param rhs - the color to compare
   */
  equalValue(rhs) {
    return this.l === rhs.l && this.c === rhs.c && this.h === rhs.h;
  }
  /**
   * Returns a new {@link ColorLCH} rounded to the provided precision
   * @param precision - the precision to round to
   */
  roundToPrecision(precision) {
    return new ColorLCH(roundToPrecisionSmall(this.l, precision), roundToPrecisionSmall(this.c, precision), roundToPrecisionSmall(this.h, precision));
  }
  /**
   * Converts the {@link ColorLCH} to a config object.
   */
  toObject() {
    return { l: this.l, c: this.c, h: this.h };
  }
}
class ColorRGBA64 {
  /**
   *
   * @param red - the red value
   * @param green - the green value
   * @param blue - the blue value
   * @param alpha - the alpha value
   */
  constructor(red, green, blue, alpha) {
    this.r = red;
    this.g = green;
    this.b = blue;
    this.a = typeof alpha === "number" && !isNaN(alpha) ? alpha : 1;
  }
  /**
   * Construct a {@link ColorRGBA64} from a {@link ColorRGBA64Config}
   * @param data - the config object
   */
  static fromObject(data) {
    return data && !isNaN(data.r) && !isNaN(data.g) && !isNaN(data.b) ? new ColorRGBA64(data.r, data.g, data.b, data.a) : null;
  }
  /**
   * Determines if one color is equal to another.
   * @param rhs - the color to compare
   */
  equalValue(rhs) {
    return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
  }
  /**
   * Returns the color formatted as a string; #RRGGBB
   */
  toStringHexRGB() {
    return "#" + [this.r, this.g, this.b].map(this.formatHexValue).join("");
  }
  /**
   * Returns the color formatted as a string; #RRGGBBAA
   */
  toStringHexRGBA() {
    return this.toStringHexRGB() + this.formatHexValue(this.a);
  }
  /**
   * Returns the color formatted as a string; #AARRGGBB
   */
  toStringHexARGB() {
    return "#" + [this.a, this.r, this.g, this.b].map(this.formatHexValue).join("");
  }
  /**
   * Returns the color formatted as a string; "rgb(0xRR, 0xGG, 0xBB)"
   */
  toStringWebRGB() {
    return `rgb(${Math.round(denormalize(this.r, 0, 255))},${Math.round(denormalize(this.g, 0, 255))},${Math.round(denormalize(this.b, 0, 255))})`;
  }
  /**
   * Returns the color formatted as a string; "rgba(0xRR, 0xGG, 0xBB, a)"
   * @remarks
   * Note that this follows the convention of putting alpha in the range [0.0,1.0] while the other three channels are [0,255]
   */
  toStringWebRGBA() {
    return `rgba(${Math.round(denormalize(this.r, 0, 255))},${Math.round(denormalize(this.g, 0, 255))},${Math.round(denormalize(this.b, 0, 255))},${clamp(this.a, 0, 1)})`;
  }
  /**
   * Returns a new {@link ColorRGBA64} rounded to the provided precision
   * @param precision - the precision to round to
   */
  roundToPrecision(precision) {
    return new ColorRGBA64(roundToPrecisionSmall(this.r, precision), roundToPrecisionSmall(this.g, precision), roundToPrecisionSmall(this.b, precision), roundToPrecisionSmall(this.a, precision));
  }
  /**
   * Returns a new {@link ColorRGBA64} with channel values clamped between 0 and 1.
   */
  clamp() {
    return new ColorRGBA64(clamp(this.r, 0, 1), clamp(this.g, 0, 1), clamp(this.b, 0, 1), clamp(this.a, 0, 1));
  }
  /**
   * Converts the {@link ColorRGBA64} to a {@link ColorRGBA64Config}.
   */
  toObject() {
    return { r: this.r, g: this.g, b: this.b, a: this.a };
  }
  formatHexValue(value) {
    return getHexStringForByte(denormalize(value, 0, 255));
  }
}
class ColorXYZ {
  constructor(x2, y, z) {
    this.x = x2;
    this.y = y;
    this.z = z;
  }
  /**
   * Construct a {@link ColorXYZ} from a config object.
   */
  static fromObject(data) {
    if (data && !isNaN(data.x) && !isNaN(data.y) && !isNaN(data.z)) {
      return new ColorXYZ(data.x, data.y, data.z);
    }
    return null;
  }
  /**
   * Determines if a color is equal to another
   * @param rhs - the value to compare
   */
  equalValue(rhs) {
    return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
  }
  /**
   * Returns a new {@link ColorXYZ} rounded to the provided precision
   * @param precision - the precision to round to
   */
  roundToPrecision(precision) {
    return new ColorXYZ(roundToPrecisionSmall(this.x, precision), roundToPrecisionSmall(this.y, precision), roundToPrecisionSmall(this.z, precision));
  }
  /**
   * Returns the {@link ColorXYZ} formatted as an object.
   */
  toObject() {
    return { x: this.x, y: this.y, z: this.z };
  }
}
ColorXYZ.whitePoint = new ColorXYZ(0.95047, 1, 1.08883);
function rgbToLinearLuminance(rgb) {
  return rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722;
}
function rgbToRelativeLuminance(rgb) {
  function luminanceHelper(i2) {
    if (i2 <= 0.03928) {
      return i2 / 12.92;
    }
    return Math.pow((i2 + 0.055) / 1.055, 2.4);
  }
  return rgbToLinearLuminance(new ColorRGBA64(luminanceHelper(rgb.r), luminanceHelper(rgb.g), luminanceHelper(rgb.b), 1));
}
const calculateContrastRatio = (a, b) => (a + 0.05) / (b + 0.05);
function contrastRatio(a, b) {
  const luminanceA = rgbToRelativeLuminance(a);
  const luminanceB = rgbToRelativeLuminance(b);
  return luminanceA > luminanceB ? calculateContrastRatio(luminanceA, luminanceB) : calculateContrastRatio(luminanceB, luminanceA);
}
function rgbToHSL(rgb) {
  const max2 = Math.max(rgb.r, rgb.g, rgb.b);
  const min2 = Math.min(rgb.r, rgb.g, rgb.b);
  const delta = max2 - min2;
  let hue = 0;
  if (delta !== 0) {
    if (max2 === rgb.r) {
      hue = 60 * ((rgb.g - rgb.b) / delta % 6);
    } else if (max2 === rgb.g) {
      hue = 60 * ((rgb.b - rgb.r) / delta + 2);
    } else {
      hue = 60 * ((rgb.r - rgb.g) / delta + 4);
    }
  }
  if (hue < 0) {
    hue += 360;
  }
  const lum = (max2 + min2) / 2;
  let sat = 0;
  if (delta !== 0) {
    sat = delta / (1 - Math.abs(2 * lum - 1));
  }
  return new ColorHSL(hue, sat, lum);
}
function hslToRGB(hsl, alpha = 1) {
  const c = (1 - Math.abs(2 * hsl.l - 1)) * hsl.s;
  const x2 = c * (1 - Math.abs(hsl.h / 60 % 2 - 1));
  const m2 = hsl.l - c / 2;
  let r = 0;
  let g = 0;
  let b = 0;
  if (hsl.h < 60) {
    r = c;
    g = x2;
    b = 0;
  } else if (hsl.h < 120) {
    r = x2;
    g = c;
    b = 0;
  } else if (hsl.h < 180) {
    r = 0;
    g = c;
    b = x2;
  } else if (hsl.h < 240) {
    r = 0;
    g = x2;
    b = c;
  } else if (hsl.h < 300) {
    r = x2;
    g = 0;
    b = c;
  } else if (hsl.h < 360) {
    r = c;
    g = 0;
    b = x2;
  }
  return new ColorRGBA64(r + m2, g + m2, b + m2, alpha);
}
function rgbToHSV(rgb) {
  const max2 = Math.max(rgb.r, rgb.g, rgb.b);
  const min2 = Math.min(rgb.r, rgb.g, rgb.b);
  const delta = max2 - min2;
  let hue = 0;
  if (delta !== 0) {
    if (max2 === rgb.r) {
      hue = 60 * ((rgb.g - rgb.b) / delta % 6);
    } else if (max2 === rgb.g) {
      hue = 60 * ((rgb.b - rgb.r) / delta + 2);
    } else {
      hue = 60 * ((rgb.r - rgb.g) / delta + 4);
    }
  }
  if (hue < 0) {
    hue += 360;
  }
  let sat = 0;
  if (max2 !== 0) {
    sat = delta / max2;
  }
  return new ColorHSV(hue, sat, max2);
}
function hsvToRGB(hsv, alpha = 1) {
  const c = hsv.s * hsv.v;
  const x2 = c * (1 - Math.abs(hsv.h / 60 % 2 - 1));
  const m2 = hsv.v - c;
  let r = 0;
  let g = 0;
  let b = 0;
  if (hsv.h < 60) {
    r = c;
    g = x2;
    b = 0;
  } else if (hsv.h < 120) {
    r = x2;
    g = c;
    b = 0;
  } else if (hsv.h < 180) {
    r = 0;
    g = c;
    b = x2;
  } else if (hsv.h < 240) {
    r = 0;
    g = x2;
    b = c;
  } else if (hsv.h < 300) {
    r = x2;
    g = 0;
    b = c;
  } else if (hsv.h < 360) {
    r = c;
    g = 0;
    b = x2;
  }
  return new ColorRGBA64(r + m2, g + m2, b + m2, alpha);
}
function lchToLAB(lch) {
  let a = 0;
  let b = 0;
  if (lch.h !== 0) {
    a = Math.cos(degreesToRadians(lch.h)) * lch.c;
    b = Math.sin(degreesToRadians(lch.h)) * lch.c;
  }
  return new ColorLAB(lch.l, a, b);
}
function labToLCH(lab) {
  let h2 = 0;
  if (Math.abs(lab.b) > 1e-3 || Math.abs(lab.a) > 1e-3) {
    h2 = radiansToDegrees(Math.atan2(lab.b, lab.a));
  }
  if (h2 < 0) {
    h2 += 360;
  }
  const c = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
  return new ColorLCH(lab.l, c, h2);
}
function labToXYZ(lab) {
  const fy = (lab.l + 16) / 116;
  const fx = fy + lab.a / 500;
  const fz = fy - lab.b / 200;
  const xcubed = Math.pow(fx, 3);
  const ycubed = Math.pow(fy, 3);
  const zcubed = Math.pow(fz, 3);
  let x2 = 0;
  if (xcubed > ColorLAB.epsilon) {
    x2 = xcubed;
  } else {
    x2 = (116 * fx - 16) / ColorLAB.kappa;
  }
  let y = 0;
  if (lab.l > ColorLAB.epsilon * ColorLAB.kappa) {
    y = ycubed;
  } else {
    y = lab.l / ColorLAB.kappa;
  }
  let z = 0;
  if (zcubed > ColorLAB.epsilon) {
    z = zcubed;
  } else {
    z = (116 * fz - 16) / ColorLAB.kappa;
  }
  x2 = ColorXYZ.whitePoint.x * x2;
  y = ColorXYZ.whitePoint.y * y;
  z = ColorXYZ.whitePoint.z * z;
  return new ColorXYZ(x2, y, z);
}
function xyzToLAB(xyz) {
  function xyzToLABHelper(i2) {
    if (i2 > ColorLAB.epsilon) {
      return Math.pow(i2, 1 / 3);
    }
    return (ColorLAB.kappa * i2 + 16) / 116;
  }
  const x2 = xyzToLABHelper(xyz.x / ColorXYZ.whitePoint.x);
  const y = xyzToLABHelper(xyz.y / ColorXYZ.whitePoint.y);
  const z = xyzToLABHelper(xyz.z / ColorXYZ.whitePoint.z);
  const l = 116 * y - 16;
  const a = 500 * (x2 - y);
  const b = 200 * (y - z);
  return new ColorLAB(l, a, b);
}
function rgbToXYZ(rgb) {
  function rgbToXYZHelper(i2) {
    if (i2 <= 0.04045) {
      return i2 / 12.92;
    }
    return Math.pow((i2 + 0.055) / 1.055, 2.4);
  }
  const r = rgbToXYZHelper(rgb.r);
  const g = rgbToXYZHelper(rgb.g);
  const b = rgbToXYZHelper(rgb.b);
  const x2 = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
  const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;
  const z = r * 0.0193339 + g * 0.119192 + b * 0.9503041;
  return new ColorXYZ(x2, y, z);
}
function xyzToRGB(xyz, alpha = 1) {
  function xyzToRGBHelper(i2) {
    if (i2 <= 31308e-7) {
      return i2 * 12.92;
    }
    return 1.055 * Math.pow(i2, 1 / 2.4) - 0.055;
  }
  const r = xyzToRGBHelper(xyz.x * 3.2404542 - xyz.y * 1.5371385 - xyz.z * 0.4985314);
  const g = xyzToRGBHelper(xyz.x * -0.969266 + xyz.y * 1.8760108 + xyz.z * 0.041556);
  const b = xyzToRGBHelper(xyz.x * 0.0556434 - xyz.y * 0.2040259 + xyz.z * 1.0572252);
  return new ColorRGBA64(r, g, b, alpha);
}
function rgbToLAB(rgb) {
  return xyzToLAB(rgbToXYZ(rgb));
}
function labToRGB(lab, alpha = 1) {
  return xyzToRGB(labToXYZ(lab), alpha);
}
function rgbToLCH(rgb) {
  return labToLCH(rgbToLAB(rgb));
}
function lchToRGB(lch, alpha = 1) {
  return labToRGB(lchToLAB(lch), alpha);
}
function saturateViaLCH(input2, saturation, saturationConstant = 18) {
  const lch = rgbToLCH(input2);
  let sat = lch.c + saturation * saturationConstant;
  if (sat < 0) {
    sat = 0;
  }
  return lchToRGB(new ColorLCH(lch.l, sat, lch.h));
}
function blendMultiplyChannel(bottom, top2) {
  return bottom * top2;
}
function blendMultiply(bottom, top2) {
  return new ColorRGBA64(blendMultiplyChannel(bottom.r, top2.r), blendMultiplyChannel(bottom.g, top2.g), blendMultiplyChannel(bottom.b, top2.b), 1);
}
function blendOverlayChannel(bottom, top2) {
  if (bottom < 0.5) {
    return clamp(2 * top2 * bottom, 0, 1);
  }
  return clamp(1 - 2 * (1 - top2) * (1 - bottom), 0, 1);
}
function blendOverlay(bottom, top2) {
  return new ColorRGBA64(blendOverlayChannel(bottom.r, top2.r), blendOverlayChannel(bottom.g, top2.g), blendOverlayChannel(bottom.b, top2.b), 1);
}
var ColorBlendMode;
(function(ColorBlendMode2) {
  ColorBlendMode2[ColorBlendMode2["Burn"] = 0] = "Burn";
  ColorBlendMode2[ColorBlendMode2["Color"] = 1] = "Color";
  ColorBlendMode2[ColorBlendMode2["Darken"] = 2] = "Darken";
  ColorBlendMode2[ColorBlendMode2["Dodge"] = 3] = "Dodge";
  ColorBlendMode2[ColorBlendMode2["Lighten"] = 4] = "Lighten";
  ColorBlendMode2[ColorBlendMode2["Multiply"] = 5] = "Multiply";
  ColorBlendMode2[ColorBlendMode2["Overlay"] = 6] = "Overlay";
  ColorBlendMode2[ColorBlendMode2["Screen"] = 7] = "Screen";
})(ColorBlendMode || (ColorBlendMode = {}));
function interpolateRGB(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorRGBA64(lerp(position, left.r, right.r), lerp(position, left.g, right.g), lerp(position, left.b, right.b), lerp(position, left.a, right.a));
}
function interpolateHSL(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorHSL(lerpAnglesInDegrees(position, left.h, right.h), lerp(position, left.s, right.s), lerp(position, left.l, right.l));
}
function interpolateHSV(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorHSV(lerpAnglesInDegrees(position, left.h, right.h), lerp(position, left.s, right.s), lerp(position, left.v, right.v));
}
function interpolateXYZ(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorXYZ(lerp(position, left.x, right.x), lerp(position, left.y, right.y), lerp(position, left.z, right.z));
}
function interpolateLAB(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorLAB(lerp(position, left.l, right.l), lerp(position, left.a, right.a), lerp(position, left.b, right.b));
}
function interpolateLCH(position, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  return new ColorLCH(lerp(position, left.l, right.l), lerp(position, left.c, right.c), lerpAnglesInDegrees(position, left.h, right.h));
}
var ColorInterpolationSpace;
(function(ColorInterpolationSpace2) {
  ColorInterpolationSpace2[ColorInterpolationSpace2["RGB"] = 0] = "RGB";
  ColorInterpolationSpace2[ColorInterpolationSpace2["HSL"] = 1] = "HSL";
  ColorInterpolationSpace2[ColorInterpolationSpace2["HSV"] = 2] = "HSV";
  ColorInterpolationSpace2[ColorInterpolationSpace2["XYZ"] = 3] = "XYZ";
  ColorInterpolationSpace2[ColorInterpolationSpace2["LAB"] = 4] = "LAB";
  ColorInterpolationSpace2[ColorInterpolationSpace2["LCH"] = 5] = "LCH";
})(ColorInterpolationSpace || (ColorInterpolationSpace = {}));
function interpolateByColorSpace(position, space, left, right) {
  if (isNaN(position) || position <= 0) {
    return left;
  } else if (position >= 1) {
    return right;
  }
  switch (space) {
    case ColorInterpolationSpace.HSL:
      return hslToRGB(interpolateHSL(position, rgbToHSL(left), rgbToHSL(right)));
    case ColorInterpolationSpace.HSV:
      return hsvToRGB(interpolateHSV(position, rgbToHSV(left), rgbToHSV(right)));
    case ColorInterpolationSpace.XYZ:
      return xyzToRGB(interpolateXYZ(position, rgbToXYZ(left), rgbToXYZ(right)));
    case ColorInterpolationSpace.LAB:
      return labToRGB(interpolateLAB(position, rgbToLAB(left), rgbToLAB(right)));
    case ColorInterpolationSpace.LCH:
      return lchToRGB(interpolateLCH(position, rgbToLCH(left), rgbToLCH(right)));
    default:
      return interpolateRGB(position, left, right);
  }
}
class ColorScale {
  constructor(stops) {
    if (stops == null || stops.length === 0) {
      throw new Error("The stops argument must be non-empty");
    } else {
      this.stops = this.sortColorScaleStops(stops);
    }
  }
  static createBalancedColorScale(colors) {
    if (colors == null || colors.length === 0) {
      throw new Error("The colors argument must be non-empty");
    }
    const stops = new Array(colors.length);
    for (let i2 = 0; i2 < colors.length; i2++) {
      if (i2 === 0) {
        stops[i2] = { color: colors[i2], position: 0 };
      } else if (i2 === colors.length - 1) {
        stops[i2] = { color: colors[i2], position: 1 };
      } else {
        stops[i2] = {
          color: colors[i2],
          position: i2 * (1 / (colors.length - 1))
        };
      }
    }
    return new ColorScale(stops);
  }
  getColor(position, interpolationMode = ColorInterpolationSpace.RGB) {
    if (this.stops.length === 1) {
      return this.stops[0].color;
    } else if (position <= 0) {
      return this.stops[0].color;
    } else if (position >= 1) {
      return this.stops[this.stops.length - 1].color;
    }
    let lowerIndex = 0;
    for (let i2 = 0; i2 < this.stops.length; i2++) {
      if (this.stops[i2].position <= position) {
        lowerIndex = i2;
      }
    }
    let upperIndex = lowerIndex + 1;
    if (upperIndex >= this.stops.length) {
      upperIndex = this.stops.length - 1;
    }
    const scalePosition = (position - this.stops[lowerIndex].position) * (1 / (this.stops[upperIndex].position - this.stops[lowerIndex].position));
    return interpolateByColorSpace(scalePosition, interpolationMode, this.stops[lowerIndex].color, this.stops[upperIndex].color);
  }
  trim(lowerBound, upperBound, interpolationMode = ColorInterpolationSpace.RGB) {
    if (lowerBound < 0 || upperBound > 1 || upperBound < lowerBound) {
      throw new Error("Invalid bounds");
    }
    if (lowerBound === upperBound) {
      return new ColorScale([
        { color: this.getColor(lowerBound, interpolationMode), position: 0 }
      ]);
    }
    const containedStops = [];
    for (let i2 = 0; i2 < this.stops.length; i2++) {
      if (this.stops[i2].position >= lowerBound && this.stops[i2].position <= upperBound) {
        containedStops.push(this.stops[i2]);
      }
    }
    if (containedStops.length === 0) {
      return new ColorScale([
        { color: this.getColor(lowerBound), position: lowerBound },
        { color: this.getColor(upperBound), position: upperBound }
      ]);
    }
    if (containedStops[0].position !== lowerBound) {
      containedStops.unshift({
        color: this.getColor(lowerBound),
        position: lowerBound
      });
    }
    if (containedStops[containedStops.length - 1].position !== upperBound) {
      containedStops.push({
        color: this.getColor(upperBound),
        position: upperBound
      });
    }
    const range2 = upperBound - lowerBound;
    const finalStops = new Array(containedStops.length);
    for (let i2 = 0; i2 < containedStops.length; i2++) {
      finalStops[i2] = {
        color: containedStops[i2].color,
        position: (containedStops[i2].position - lowerBound) / range2
      };
    }
    return new ColorScale(finalStops);
  }
  findNextColor(position, contrast2, searchDown = false, interpolationMode = ColorInterpolationSpace.RGB, contrastErrorMargin = 5e-3, maxSearchIterations = 32) {
    if (isNaN(position) || position <= 0) {
      position = 0;
    } else if (position >= 1) {
      position = 1;
    }
    const startingColor = this.getColor(position, interpolationMode);
    const finalPosition = searchDown ? 0 : 1;
    const finalColor = this.getColor(finalPosition, interpolationMode);
    const finalContrast = contrastRatio(startingColor, finalColor);
    if (finalContrast <= contrast2) {
      return finalPosition;
    }
    let testRangeMin = searchDown ? 0 : position;
    let testRangeMax = searchDown ? position : 0;
    let mid = finalPosition;
    let iterations = 0;
    while (iterations <= maxSearchIterations) {
      mid = Math.abs(testRangeMax - testRangeMin) / 2 + testRangeMin;
      const midColor = this.getColor(mid, interpolationMode);
      const midContrast = contrastRatio(startingColor, midColor);
      if (Math.abs(midContrast - contrast2) <= contrastErrorMargin) {
        return mid;
      } else if (midContrast > contrast2) {
        if (searchDown) {
          testRangeMin = mid;
        } else {
          testRangeMax = mid;
        }
      } else {
        if (searchDown) {
          testRangeMax = mid;
        } else {
          testRangeMin = mid;
        }
      }
      iterations++;
    }
    return mid;
  }
  clone() {
    const newStops = new Array(this.stops.length);
    for (let i2 = 0; i2 < newStops.length; i2++) {
      newStops[i2] = {
        color: this.stops[i2].color,
        position: this.stops[i2].position
      };
    }
    return new ColorScale(newStops);
  }
  sortColorScaleStops(stops) {
    return stops.sort((a, b) => {
      const A = a.position;
      const B = b.position;
      if (A < B) {
        return -1;
      } else if (A > B) {
        return 1;
      } else {
        return 0;
      }
    });
  }
}
const namedColorsConfigs = {
  aliceblue: {
    r: 0.941176,
    g: 0.972549,
    b: 1
  },
  antiquewhite: {
    r: 0.980392,
    g: 0.921569,
    b: 0.843137
  },
  aqua: {
    r: 0,
    g: 1,
    b: 1
  },
  aquamarine: {
    r: 0.498039,
    g: 1,
    b: 0.831373
  },
  azure: {
    r: 0.941176,
    g: 1,
    b: 1
  },
  beige: {
    r: 0.960784,
    g: 0.960784,
    b: 0.862745
  },
  bisque: {
    r: 1,
    g: 0.894118,
    b: 0.768627
  },
  black: {
    r: 0,
    g: 0,
    b: 0
  },
  blanchedalmond: {
    r: 1,
    g: 0.921569,
    b: 0.803922
  },
  blue: {
    r: 0,
    g: 0,
    b: 1
  },
  blueviolet: {
    r: 0.541176,
    g: 0.168627,
    b: 0.886275
  },
  brown: {
    r: 0.647059,
    g: 0.164706,
    b: 0.164706
  },
  burlywood: {
    r: 0.870588,
    g: 0.721569,
    b: 0.529412
  },
  cadetblue: {
    r: 0.372549,
    g: 0.619608,
    b: 0.627451
  },
  chartreuse: {
    r: 0.498039,
    g: 1,
    b: 0
  },
  chocolate: {
    r: 0.823529,
    g: 0.411765,
    b: 0.117647
  },
  coral: {
    r: 1,
    g: 0.498039,
    b: 0.313725
  },
  cornflowerblue: {
    r: 0.392157,
    g: 0.584314,
    b: 0.929412
  },
  cornsilk: {
    r: 1,
    g: 0.972549,
    b: 0.862745
  },
  crimson: {
    r: 0.862745,
    g: 0.078431,
    b: 0.235294
  },
  cyan: {
    r: 0,
    g: 1,
    b: 1
  },
  darkblue: {
    r: 0,
    g: 0,
    b: 0.545098
  },
  darkcyan: {
    r: 0,
    g: 0.545098,
    b: 0.545098
  },
  darkgoldenrod: {
    r: 0.721569,
    g: 0.52549,
    b: 0.043137
  },
  darkgray: {
    r: 0.662745,
    g: 0.662745,
    b: 0.662745
  },
  darkgreen: {
    r: 0,
    g: 0.392157,
    b: 0
  },
  darkgrey: {
    r: 0.662745,
    g: 0.662745,
    b: 0.662745
  },
  darkkhaki: {
    r: 0.741176,
    g: 0.717647,
    b: 0.419608
  },
  darkmagenta: {
    r: 0.545098,
    g: 0,
    b: 0.545098
  },
  darkolivegreen: {
    r: 0.333333,
    g: 0.419608,
    b: 0.184314
  },
  darkorange: {
    r: 1,
    g: 0.54902,
    b: 0
  },
  darkorchid: {
    r: 0.6,
    g: 0.196078,
    b: 0.8
  },
  darkred: {
    r: 0.545098,
    g: 0,
    b: 0
  },
  darksalmon: {
    r: 0.913725,
    g: 0.588235,
    b: 0.478431
  },
  darkseagreen: {
    r: 0.560784,
    g: 0.737255,
    b: 0.560784
  },
  darkslateblue: {
    r: 0.282353,
    g: 0.239216,
    b: 0.545098
  },
  darkslategray: {
    r: 0.184314,
    g: 0.309804,
    b: 0.309804
  },
  darkslategrey: {
    r: 0.184314,
    g: 0.309804,
    b: 0.309804
  },
  darkturquoise: {
    r: 0,
    g: 0.807843,
    b: 0.819608
  },
  darkviolet: {
    r: 0.580392,
    g: 0,
    b: 0.827451
  },
  deeppink: {
    r: 1,
    g: 0.078431,
    b: 0.576471
  },
  deepskyblue: {
    r: 0,
    g: 0.74902,
    b: 1
  },
  dimgray: {
    r: 0.411765,
    g: 0.411765,
    b: 0.411765
  },
  dimgrey: {
    r: 0.411765,
    g: 0.411765,
    b: 0.411765
  },
  dodgerblue: {
    r: 0.117647,
    g: 0.564706,
    b: 1
  },
  firebrick: {
    r: 0.698039,
    g: 0.133333,
    b: 0.133333
  },
  floralwhite: {
    r: 1,
    g: 0.980392,
    b: 0.941176
  },
  forestgreen: {
    r: 0.133333,
    g: 0.545098,
    b: 0.133333
  },
  fuchsia: {
    r: 1,
    g: 0,
    b: 1
  },
  gainsboro: {
    r: 0.862745,
    g: 0.862745,
    b: 0.862745
  },
  ghostwhite: {
    r: 0.972549,
    g: 0.972549,
    b: 1
  },
  gold: {
    r: 1,
    g: 0.843137,
    b: 0
  },
  goldenrod: {
    r: 0.854902,
    g: 0.647059,
    b: 0.12549
  },
  gray: {
    r: 0.501961,
    g: 0.501961,
    b: 0.501961
  },
  green: {
    r: 0,
    g: 0.501961,
    b: 0
  },
  greenyellow: {
    r: 0.678431,
    g: 1,
    b: 0.184314
  },
  grey: {
    r: 0.501961,
    g: 0.501961,
    b: 0.501961
  },
  honeydew: {
    r: 0.941176,
    g: 1,
    b: 0.941176
  },
  hotpink: {
    r: 1,
    g: 0.411765,
    b: 0.705882
  },
  indianred: {
    r: 0.803922,
    g: 0.360784,
    b: 0.360784
  },
  indigo: {
    r: 0.294118,
    g: 0,
    b: 0.509804
  },
  ivory: {
    r: 1,
    g: 1,
    b: 0.941176
  },
  khaki: {
    r: 0.941176,
    g: 0.901961,
    b: 0.54902
  },
  lavender: {
    r: 0.901961,
    g: 0.901961,
    b: 0.980392
  },
  lavenderblush: {
    r: 1,
    g: 0.941176,
    b: 0.960784
  },
  lawngreen: {
    r: 0.486275,
    g: 0.988235,
    b: 0
  },
  lemonchiffon: {
    r: 1,
    g: 0.980392,
    b: 0.803922
  },
  lightblue: {
    r: 0.678431,
    g: 0.847059,
    b: 0.901961
  },
  lightcoral: {
    r: 0.941176,
    g: 0.501961,
    b: 0.501961
  },
  lightcyan: {
    r: 0.878431,
    g: 1,
    b: 1
  },
  lightgoldenrodyellow: {
    r: 0.980392,
    g: 0.980392,
    b: 0.823529
  },
  lightgray: {
    r: 0.827451,
    g: 0.827451,
    b: 0.827451
  },
  lightgreen: {
    r: 0.564706,
    g: 0.933333,
    b: 0.564706
  },
  lightgrey: {
    r: 0.827451,
    g: 0.827451,
    b: 0.827451
  },
  lightpink: {
    r: 1,
    g: 0.713725,
    b: 0.756863
  },
  lightsalmon: {
    r: 1,
    g: 0.627451,
    b: 0.478431
  },
  lightseagreen: {
    r: 0.12549,
    g: 0.698039,
    b: 0.666667
  },
  lightskyblue: {
    r: 0.529412,
    g: 0.807843,
    b: 0.980392
  },
  lightslategray: {
    r: 0.466667,
    g: 0.533333,
    b: 0.6
  },
  lightslategrey: {
    r: 0.466667,
    g: 0.533333,
    b: 0.6
  },
  lightsteelblue: {
    r: 0.690196,
    g: 0.768627,
    b: 0.870588
  },
  lightyellow: {
    r: 1,
    g: 1,
    b: 0.878431
  },
  lime: {
    r: 0,
    g: 1,
    b: 0
  },
  limegreen: {
    r: 0.196078,
    g: 0.803922,
    b: 0.196078
  },
  linen: {
    r: 0.980392,
    g: 0.941176,
    b: 0.901961
  },
  magenta: {
    r: 1,
    g: 0,
    b: 1
  },
  maroon: {
    r: 0.501961,
    g: 0,
    b: 0
  },
  mediumaquamarine: {
    r: 0.4,
    g: 0.803922,
    b: 0.666667
  },
  mediumblue: {
    r: 0,
    g: 0,
    b: 0.803922
  },
  mediumorchid: {
    r: 0.729412,
    g: 0.333333,
    b: 0.827451
  },
  mediumpurple: {
    r: 0.576471,
    g: 0.439216,
    b: 0.858824
  },
  mediumseagreen: {
    r: 0.235294,
    g: 0.701961,
    b: 0.443137
  },
  mediumslateblue: {
    r: 0.482353,
    g: 0.407843,
    b: 0.933333
  },
  mediumspringgreen: {
    r: 0,
    g: 0.980392,
    b: 0.603922
  },
  mediumturquoise: {
    r: 0.282353,
    g: 0.819608,
    b: 0.8
  },
  mediumvioletred: {
    r: 0.780392,
    g: 0.082353,
    b: 0.521569
  },
  midnightblue: {
    r: 0.098039,
    g: 0.098039,
    b: 0.439216
  },
  mintcream: {
    r: 0.960784,
    g: 1,
    b: 0.980392
  },
  mistyrose: {
    r: 1,
    g: 0.894118,
    b: 0.882353
  },
  moccasin: {
    r: 1,
    g: 0.894118,
    b: 0.709804
  },
  navajowhite: {
    r: 1,
    g: 0.870588,
    b: 0.678431
  },
  navy: {
    r: 0,
    g: 0,
    b: 0.501961
  },
  oldlace: {
    r: 0.992157,
    g: 0.960784,
    b: 0.901961
  },
  olive: {
    r: 0.501961,
    g: 0.501961,
    b: 0
  },
  olivedrab: {
    r: 0.419608,
    g: 0.556863,
    b: 0.137255
  },
  orange: {
    r: 1,
    g: 0.647059,
    b: 0
  },
  orangered: {
    r: 1,
    g: 0.270588,
    b: 0
  },
  orchid: {
    r: 0.854902,
    g: 0.439216,
    b: 0.839216
  },
  palegoldenrod: {
    r: 0.933333,
    g: 0.909804,
    b: 0.666667
  },
  palegreen: {
    r: 0.596078,
    g: 0.984314,
    b: 0.596078
  },
  paleturquoise: {
    r: 0.686275,
    g: 0.933333,
    b: 0.933333
  },
  palevioletred: {
    r: 0.858824,
    g: 0.439216,
    b: 0.576471
  },
  papayawhip: {
    r: 1,
    g: 0.937255,
    b: 0.835294
  },
  peachpuff: {
    r: 1,
    g: 0.854902,
    b: 0.72549
  },
  peru: {
    r: 0.803922,
    g: 0.521569,
    b: 0.247059
  },
  pink: {
    r: 1,
    g: 0.752941,
    b: 0.796078
  },
  plum: {
    r: 0.866667,
    g: 0.627451,
    b: 0.866667
  },
  powderblue: {
    r: 0.690196,
    g: 0.878431,
    b: 0.901961
  },
  purple: {
    r: 0.501961,
    g: 0,
    b: 0.501961
  },
  red: {
    r: 1,
    g: 0,
    b: 0
  },
  rosybrown: {
    r: 0.737255,
    g: 0.560784,
    b: 0.560784
  },
  royalblue: {
    r: 0.254902,
    g: 0.411765,
    b: 0.882353
  },
  saddlebrown: {
    r: 0.545098,
    g: 0.270588,
    b: 0.07451
  },
  salmon: {
    r: 0.980392,
    g: 0.501961,
    b: 0.447059
  },
  sandybrown: {
    r: 0.956863,
    g: 0.643137,
    b: 0.376471
  },
  seagreen: {
    r: 0.180392,
    g: 0.545098,
    b: 0.341176
  },
  seashell: {
    r: 1,
    g: 0.960784,
    b: 0.933333
  },
  sienna: {
    r: 0.627451,
    g: 0.321569,
    b: 0.176471
  },
  silver: {
    r: 0.752941,
    g: 0.752941,
    b: 0.752941
  },
  skyblue: {
    r: 0.529412,
    g: 0.807843,
    b: 0.921569
  },
  slateblue: {
    r: 0.415686,
    g: 0.352941,
    b: 0.803922
  },
  slategray: {
    r: 0.439216,
    g: 0.501961,
    b: 0.564706
  },
  slategrey: {
    r: 0.439216,
    g: 0.501961,
    b: 0.564706
  },
  snow: {
    r: 1,
    g: 0.980392,
    b: 0.980392
  },
  springgreen: {
    r: 0,
    g: 1,
    b: 0.498039
  },
  steelblue: {
    r: 0.27451,
    g: 0.509804,
    b: 0.705882
  },
  tan: {
    r: 0.823529,
    g: 0.705882,
    b: 0.54902
  },
  teal: {
    r: 0,
    g: 0.501961,
    b: 0.501961
  },
  thistle: {
    r: 0.847059,
    g: 0.74902,
    b: 0.847059
  },
  tomato: {
    r: 1,
    g: 0.388235,
    b: 0.278431
  },
  transparent: {
    r: 0,
    g: 0,
    b: 0,
    a: 0
  },
  turquoise: {
    r: 0.25098,
    g: 0.878431,
    b: 0.815686
  },
  violet: {
    r: 0.933333,
    g: 0.509804,
    b: 0.933333
  },
  wheat: {
    r: 0.960784,
    g: 0.870588,
    b: 0.701961
  },
  white: {
    r: 1,
    g: 1,
    b: 1
  },
  whitesmoke: {
    r: 0.960784,
    g: 0.960784,
    b: 0.960784
  },
  yellow: {
    r: 1,
    g: 1,
    b: 0
  },
  yellowgreen: {
    r: 0.603922,
    g: 0.803922,
    b: 0.196078
  }
};
const webRGBRegex = /^rgb\(\s*((?:(?:25[0-5]|2[0-4]\d|1\d\d|\d{1,2})\s*,\s*){2}(?:25[0-5]|2[0-4]\d|1\d\d|\d{1,2})\s*)\)$/i;
const webRGBARegex = /^rgba\(\s*((?:(?:25[0-5]|2[0-4]\d|1\d\d|\d{1,2})\s*,\s*){3}(?:0|1|0?\.\d*)\s*)\)$/i;
const hexRGBRegex = /^#((?:[0-9a-f]{6}|[0-9a-f]{3}))$/i;
const hexRGBARegex = /^#((?:[0-9a-f]{8}|[0-9a-f]{4}))$/i;
function isColorStringHexRGB(raw) {
  return hexRGBRegex.test(raw);
}
function isColorStringHexARGB(raw) {
  return hexRGBARegex.test(raw);
}
function isColorStringHexRGBA(raw) {
  return isColorStringHexARGB(raw);
}
function isColorStringWebRGB(raw) {
  return webRGBRegex.test(raw);
}
function isColorStringWebRGBA(raw) {
  return webRGBARegex.test(raw);
}
function isColorNamed(raw) {
  return namedColorsConfigs.hasOwnProperty(raw);
}
function parseColorHexRGB(raw) {
  const result2 = hexRGBRegex.exec(raw);
  if (result2 === null) {
    return null;
  }
  let digits = result2[1];
  if (digits.length === 3) {
    const r = digits.charAt(0);
    const g = digits.charAt(1);
    const b = digits.charAt(2);
    digits = r.concat(r, g, g, b, b);
  }
  const rawInt = parseInt(digits, 16);
  if (isNaN(rawInt)) {
    return null;
  }
  return new ColorRGBA64(normalize((rawInt & 16711680) >>> 16, 0, 255), normalize((rawInt & 65280) >>> 8, 0, 255), normalize(rawInt & 255, 0, 255), 1);
}
function parseColorHexARGB(raw) {
  const result2 = hexRGBARegex.exec(raw);
  if (result2 === null) {
    return null;
  }
  let digits = result2[1];
  if (digits.length === 4) {
    const a = digits.charAt(0);
    const r = digits.charAt(1);
    const g = digits.charAt(2);
    const b = digits.charAt(3);
    digits = a.concat(a, r, r, g, g, b, b);
  }
  const rawInt = parseInt(digits, 16);
  if (isNaN(rawInt)) {
    return null;
  }
  return new ColorRGBA64(normalize((rawInt & 16711680) >>> 16, 0, 255), normalize((rawInt & 65280) >>> 8, 0, 255), normalize(rawInt & 255, 0, 255), normalize((rawInt & 4278190080) >>> 24, 0, 255));
}
function parseColorWebRGB(raw) {
  const result2 = webRGBRegex.exec(raw);
  if (result2 === null) {
    return null;
  }
  const split = result2[1].split(",");
  return new ColorRGBA64(normalize(Number(split[0]), 0, 255), normalize(Number(split[1]), 0, 255), normalize(Number(split[2]), 0, 255), 1);
}
function parseColorWebRGBA(raw) {
  const result2 = webRGBARegex.exec(raw);
  if (result2 === null) {
    return null;
  }
  const split = result2[1].split(",");
  if (split.length === 4) {
    return new ColorRGBA64(normalize(Number(split[0]), 0, 255), normalize(Number(split[1]), 0, 255), normalize(Number(split[2]), 0, 255), Number(split[3]));
  }
  return null;
}
function parseColorNamed(raw) {
  const config2 = namedColorsConfigs[raw.toLowerCase()];
  return config2 ? new ColorRGBA64(config2.r, config2.g, config2.b, config2.hasOwnProperty("a") ? config2.a : void 0) : null;
}
function parseColor(raw) {
  const rawLower = raw.toLowerCase();
  return isColorStringHexRGB(rawLower) ? parseColorHexRGB(rawLower) : isColorStringHexRGBA(rawLower) ? parseColorHexARGB(rawLower) : isColorStringWebRGB(rawLower) ? parseColorWebRGB(rawLower) : isColorStringWebRGBA(rawLower) ? parseColorWebRGBA(rawLower) : isColorNamed(rawLower) ? parseColorNamed(rawLower) : null;
}
class ColorPalette {
  constructor(config2) {
    this.config = Object.assign({}, ColorPalette.defaultPaletteConfig, config2);
    this.palette = [];
    this.updatePaletteColors();
  }
  updatePaletteGenerationValues(newConfig) {
    let changed = false;
    for (const key2 in newConfig) {
      if (this.config[key2]) {
        if (this.config[key2].equalValue) {
          if (!this.config[key2].equalValue(newConfig[key2])) {
            this.config[key2] = newConfig[key2];
            changed = true;
          }
        } else {
          if (newConfig[key2] !== this.config[key2]) {
            this.config[key2] = newConfig[key2];
            changed = true;
          }
        }
      }
    }
    if (changed) {
      this.updatePaletteColors();
    }
    return changed;
  }
  updatePaletteColors() {
    const scale = this.generatePaletteColorScale();
    for (let i2 = 0; i2 < this.config.steps; i2++) {
      this.palette[i2] = scale.getColor(i2 / (this.config.steps - 1), this.config.interpolationMode);
    }
  }
  generatePaletteColorScale() {
    const baseColorHSL = rgbToHSL(this.config.baseColor);
    const baseScale = new ColorScale([
      { position: 0, color: this.config.scaleColorLight },
      { position: 0.5, color: this.config.baseColor },
      { position: 1, color: this.config.scaleColorDark }
    ]);
    const trimmedScale = baseScale.trim(this.config.clipLight, 1 - this.config.clipDark);
    const trimmedLight = trimmedScale.getColor(0);
    const trimmedDark = trimmedScale.getColor(1);
    let adjustedLight = trimmedLight;
    let adjustedDark = trimmedDark;
    if (baseColorHSL.s >= this.config.saturationAdjustmentCutoff) {
      adjustedLight = saturateViaLCH(adjustedLight, this.config.saturationLight);
      adjustedDark = saturateViaLCH(adjustedDark, this.config.saturationDark);
    }
    if (this.config.multiplyLight !== 0) {
      const multiply = blendMultiply(this.config.baseColor, adjustedLight);
      adjustedLight = interpolateByColorSpace(this.config.multiplyLight, this.config.interpolationMode, adjustedLight, multiply);
    }
    if (this.config.multiplyDark !== 0) {
      const multiply = blendMultiply(this.config.baseColor, adjustedDark);
      adjustedDark = interpolateByColorSpace(this.config.multiplyDark, this.config.interpolationMode, adjustedDark, multiply);
    }
    if (this.config.overlayLight !== 0) {
      const overlay = blendOverlay(this.config.baseColor, adjustedLight);
      adjustedLight = interpolateByColorSpace(this.config.overlayLight, this.config.interpolationMode, adjustedLight, overlay);
    }
    if (this.config.overlayDark !== 0) {
      const overlay = blendOverlay(this.config.baseColor, adjustedDark);
      adjustedDark = interpolateByColorSpace(this.config.overlayDark, this.config.interpolationMode, adjustedDark, overlay);
    }
    if (this.config.baseScalePosition) {
      if (this.config.baseScalePosition <= 0) {
        return new ColorScale([
          { position: 0, color: this.config.baseColor },
          { position: 1, color: adjustedDark.clamp() }
        ]);
      } else if (this.config.baseScalePosition >= 1) {
        return new ColorScale([
          { position: 0, color: adjustedLight.clamp() },
          { position: 1, color: this.config.baseColor }
        ]);
      }
      return new ColorScale([
        { position: 0, color: adjustedLight.clamp() },
        {
          position: this.config.baseScalePosition,
          color: this.config.baseColor
        },
        { position: 1, color: adjustedDark.clamp() }
      ]);
    }
    return new ColorScale([
      { position: 0, color: adjustedLight.clamp() },
      { position: 0.5, color: this.config.baseColor },
      { position: 1, color: adjustedDark.clamp() }
    ]);
  }
}
ColorPalette.defaultPaletteConfig = {
  baseColor: parseColorHexRGB("#808080"),
  steps: 11,
  interpolationMode: ColorInterpolationSpace.RGB,
  scaleColorLight: new ColorRGBA64(1, 1, 1, 1),
  scaleColorDark: new ColorRGBA64(0, 0, 0, 1),
  clipLight: 0.185,
  clipDark: 0.16,
  saturationAdjustmentCutoff: 0.05,
  saturationLight: 0.35,
  saturationDark: 1.25,
  overlayLight: 0,
  overlayDark: 0.25,
  multiplyLight: 0,
  multiplyDark: 0,
  baseScalePosition: 0.5
};
ColorPalette.greyscalePaletteConfig = {
  baseColor: parseColorHexRGB("#808080"),
  steps: 11,
  interpolationMode: ColorInterpolationSpace.RGB,
  scaleColorLight: new ColorRGBA64(1, 1, 1, 1),
  scaleColorDark: new ColorRGBA64(0, 0, 0, 1),
  clipLight: 0,
  clipDark: 0,
  saturationAdjustmentCutoff: 0,
  saturationLight: 0,
  saturationDark: 0,
  overlayLight: 0,
  overlayDark: 0,
  multiplyLight: 0,
  multiplyDark: 0,
  baseScalePosition: 0.5
};
({
  targetSize: 63,
  spacing: 4,
  scaleColorLight: ColorPalette.defaultPaletteConfig.scaleColorLight,
  scaleColorDark: ColorPalette.defaultPaletteConfig.scaleColorDark
});
class ComponentStateColorPalette {
  constructor(config2) {
    this.palette = [];
    this.config = Object.assign({}, ComponentStateColorPalette.defaultPaletteConfig, config2);
    this.regenPalettes();
  }
  regenPalettes() {
    let steps = this.config.steps;
    if (isNaN(steps) || steps < 3) {
      steps = 3;
    }
    const darkLum = 0.14;
    const darkestLum = 0.06;
    const darkLumColor = new ColorRGBA64(darkLum, darkLum, darkLum, 1);
    const stepsForLuminanceRamp = 94;
    const r = new ColorPalette(Object.assign(Object.assign({}, ColorPalette.greyscalePaletteConfig), { baseColor: darkLumColor, baseScalePosition: (1 - darkLum) * 100 / stepsForLuminanceRamp, steps }));
    const referencePalette = r.palette;
    const baseColorLum1 = rgbToLinearLuminance(this.config.baseColor);
    const baseColorLum2 = rgbToHSL(this.config.baseColor).l;
    const baseColorLum = (baseColorLum1 + baseColorLum2) / 2;
    const baseColorRefIndex = this.matchRelativeLuminanceIndex(baseColorLum, referencePalette);
    const baseColorPercent = baseColorRefIndex / (steps - 1);
    const darkRefIndex = this.matchRelativeLuminanceIndex(darkLum, referencePalette);
    const darkPercent = darkRefIndex / (steps - 1);
    const baseColorHSL = rgbToHSL(this.config.baseColor);
    const darkBaseColor = hslToRGB(ColorHSL.fromObject({
      h: baseColorHSL.h,
      s: baseColorHSL.s,
      l: darkLum
    }));
    const darkestBaseColor = hslToRGB(ColorHSL.fromObject({
      h: baseColorHSL.h,
      s: baseColorHSL.s,
      l: darkestLum
    }));
    const fullColorScaleStops = new Array(5);
    fullColorScaleStops[0] = {
      position: 0,
      color: new ColorRGBA64(1, 1, 1, 1)
    };
    fullColorScaleStops[1] = {
      position: baseColorPercent,
      color: this.config.baseColor
    };
    fullColorScaleStops[2] = {
      position: darkPercent,
      color: darkBaseColor
    };
    fullColorScaleStops[3] = {
      position: 0.99,
      color: darkestBaseColor
    };
    fullColorScaleStops[4] = {
      position: 1,
      color: new ColorRGBA64(0, 0, 0, 1)
    };
    const scale = new ColorScale(fullColorScaleStops);
    this.palette = new Array(steps);
    for (let i2 = 0; i2 < steps; i2++) {
      const c = scale.getColor(i2 / (steps - 1), ColorInterpolationSpace.RGB);
      this.palette[i2] = c;
    }
  }
  matchRelativeLuminanceIndex(input2, reference) {
    let bestFitValue = Number.MAX_VALUE;
    let bestFitIndex = 0;
    let i2 = 0;
    const referenceLength = reference.length;
    for (; i2 < referenceLength; i2++) {
      const fitValue = Math.abs(rgbToLinearLuminance(reference[i2]) - input2);
      if (fitValue < bestFitValue) {
        bestFitValue = fitValue;
        bestFitIndex = i2;
      }
    }
    return bestFitIndex;
  }
}
ComponentStateColorPalette.defaultPaletteConfig = {
  baseColor: parseColorHexRGB("#808080"),
  steps: 94
};
function contrast(a, b) {
  const L1 = a.relativeLuminance > b.relativeLuminance ? a : b;
  const L2 = a.relativeLuminance > b.relativeLuminance ? b : a;
  return (L1.relativeLuminance + 0.05) / (L2.relativeLuminance + 0.05);
}
const SwatchRGB = Object.freeze({
  create(r, g, b) {
    return new SwatchRGBImpl(r, g, b);
  },
  from(obj) {
    return new SwatchRGBImpl(obj.r, obj.g, obj.b);
  }
});
function isSwatchRGB(value) {
  const test = {
    r: 0,
    g: 0,
    b: 0,
    toColorString: () => "",
    contrast: () => 0,
    relativeLuminance: 0
  };
  for (const key2 in test) {
    if (typeof test[key2] !== typeof value[key2]) {
      return false;
    }
  }
  return true;
}
class SwatchRGBImpl extends ColorRGBA64 {
  /**
   *
   * @param red - Red channel expressed as a number between 0 and 1
   * @param green - Green channel expressed as a number between 0 and 1
   * @param blue - Blue channel expressed as a number between 0 and 1
   */
  constructor(red, green, blue) {
    super(red, green, blue, 1);
    this.toColorString = this.toStringHexRGB;
    this.contrast = contrast.bind(null, this);
    this.createCSS = this.toColorString;
    this.relativeLuminance = rgbToRelativeLuminance(this);
  }
  static fromObject(obj) {
    return new SwatchRGBImpl(obj.r, obj.g, obj.b);
  }
}
function baseLayerLuminanceSwatch(luminance) {
  return SwatchRGB.create(luminance, luminance, luminance);
}
const StandardLuminance = {
  LightMode: 1,
  DarkMode: 0.23
};
const target = (-0.1 + Math.sqrt(0.21)) / 2;
function isDark(color) {
  return color.relativeLuminance <= target;
}
const $global = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  try {
    return new Function("return this")();
  } catch (_a) {
    return {};
  }
}();
if ($global.trustedTypes === void 0) {
  $global.trustedTypes = { createPolicy: (n, r) => r };
}
const propConfig = {
  configurable: false,
  enumerable: false,
  writable: false
};
if ($global.FAST === void 0) {
  Reflect.defineProperty($global, "FAST", Object.assign({ value: /* @__PURE__ */ Object.create(null) }, propConfig));
}
const FAST = $global.FAST;
if (FAST.getById === void 0) {
  const storage = /* @__PURE__ */ Object.create(null);
  Reflect.defineProperty(FAST, "getById", Object.assign({ value(id, initialize) {
    let found2 = storage[id];
    if (found2 === void 0) {
      found2 = initialize ? storage[id] = initialize() : null;
    }
    return found2;
  } }, propConfig));
}
const emptyArray = Object.freeze([]);
function createMetadataLocator() {
  const metadataLookup = /* @__PURE__ */ new WeakMap();
  return function(target2) {
    let metadata = metadataLookup.get(target2);
    if (metadata === void 0) {
      let currentTarget = Reflect.getPrototypeOf(target2);
      while (metadata === void 0 && currentTarget !== null) {
        metadata = metadataLookup.get(currentTarget);
        currentTarget = Reflect.getPrototypeOf(currentTarget);
      }
      metadata = metadata === void 0 ? [] : metadata.slice(0);
      metadataLookup.set(target2, metadata);
    }
    return metadata;
  };
}
const updateQueue = $global.FAST.getById(1, () => {
  const tasks = [];
  const pendingErrors = [];
  function throwFirstError() {
    if (pendingErrors.length) {
      throw pendingErrors.shift();
    }
  }
  function tryRunTask(task) {
    try {
      task.call();
    } catch (error) {
      pendingErrors.push(error);
      setTimeout(throwFirstError, 0);
    }
  }
  function process2() {
    const capacity = 1024;
    let index = 0;
    while (index < tasks.length) {
      tryRunTask(tasks[index]);
      index++;
      if (index > capacity) {
        for (let scan = 0, newLength = tasks.length - index; scan < newLength; scan++) {
          tasks[scan] = tasks[scan + index];
        }
        tasks.length -= index;
        index = 0;
      }
    }
    tasks.length = 0;
  }
  function enqueue(callable) {
    if (tasks.length < 1) {
      $global.requestAnimationFrame(process2);
    }
    tasks.push(callable);
  }
  return Object.freeze({
    enqueue,
    process: process2
  });
});
const fastHTMLPolicy = $global.trustedTypes.createPolicy("fast-html", {
  createHTML: (html2) => html2
});
let htmlPolicy = fastHTMLPolicy;
const marker = `fast-${Math.random().toString(36).substring(2, 8)}`;
const _interpolationStart = `${marker}{`;
const _interpolationEnd = `}${marker}`;
const DOM = Object.freeze({
  /**
   * Indicates whether the DOM supports the adoptedStyleSheets feature.
   */
  supportsAdoptedStyleSheets: Array.isArray(document.adoptedStyleSheets) && "replace" in CSSStyleSheet.prototype,
  /**
   * Sets the HTML trusted types policy used by the templating engine.
   * @param policy - The policy to set for HTML.
   * @remarks
   * This API can only be called once, for security reasons. It should be
   * called by the application developer at the start of their program.
   */
  setHTMLPolicy(policy) {
    if (htmlPolicy !== fastHTMLPolicy) {
      throw new Error("The HTML policy can only be set once.");
    }
    htmlPolicy = policy;
  },
  /**
   * Turns a string into trusted HTML using the configured trusted types policy.
   * @param html - The string to turn into trusted HTML.
   * @remarks
   * Used internally by the template engine when creating templates
   * and setting innerHTML.
   */
  createHTML(html2) {
    return htmlPolicy.createHTML(html2);
  },
  /**
   * Determines if the provided node is a template marker used by the runtime.
   * @param node - The node to test.
   */
  isMarker(node2) {
    return node2 && node2.nodeType === 8 && node2.data.startsWith(marker);
  },
  /**
   * Given a marker node, extract the {@link HTMLDirective} index from the placeholder.
   * @param node - The marker node to extract the index from.
   */
  extractDirectiveIndexFromMarker(node2) {
    return parseInt(node2.data.replace(`${marker}:`, ""));
  },
  /**
   * Creates a placeholder string suitable for marking out a location *within*
   * an attribute value or HTML content.
   * @param index - The directive index to create the placeholder for.
   * @remarks
   * Used internally by binding directives.
   */
  createInterpolationPlaceholder(index) {
    return `${_interpolationStart}${index}${_interpolationEnd}`;
  },
  /**
   * Creates a placeholder that manifests itself as an attribute on an
   * element.
   * @param attributeName - The name of the custom attribute.
   * @param index - The directive index to create the placeholder for.
   * @remarks
   * Used internally by attribute directives such as `ref`, `slotted`, and `children`.
   */
  createCustomAttributePlaceholder(attributeName, index) {
    return `${attributeName}="${this.createInterpolationPlaceholder(index)}"`;
  },
  /**
   * Creates a placeholder that manifests itself as a marker within the DOM structure.
   * @param index - The directive index to create the placeholder for.
   * @remarks
   * Used internally by structural directives such as `repeat`.
   */
  createBlockPlaceholder(index) {
    return `<!--${marker}:${index}-->`;
  },
  /**
   * Schedules DOM update work in the next async batch.
   * @param callable - The callable function or object to queue.
   */
  queueUpdate: updateQueue.enqueue,
  /**
   * Immediately processes all work previously scheduled
   * through queueUpdate.
   * @remarks
   * This also forces nextUpdate promises
   * to resolve.
   */
  processUpdates: updateQueue.process,
  /**
   * Resolves with the next DOM update.
   */
  nextUpdate() {
    return new Promise(updateQueue.enqueue);
  },
  /**
   * Sets an attribute value on an element.
   * @param element - The element to set the attribute value on.
   * @param attributeName - The attribute name to set.
   * @param value - The value of the attribute to set.
   * @remarks
   * If the value is `null` or `undefined`, the attribute is removed, otherwise
   * it is set to the provided value using the standard `setAttribute` API.
   */
  setAttribute(element, attributeName, value) {
    if (value === null || value === void 0) {
      element.removeAttribute(attributeName);
    } else {
      element.setAttribute(attributeName, value);
    }
  },
  /**
   * Sets a boolean attribute value.
   * @param element - The element to set the boolean attribute value on.
   * @param attributeName - The attribute name to set.
   * @param value - The value of the attribute to set.
   * @remarks
   * If the value is true, the attribute is added; otherwise it is removed.
   */
  setBooleanAttribute(element, attributeName, value) {
    value ? element.setAttribute(attributeName, "") : element.removeAttribute(attributeName);
  },
  /**
   * Removes all the child nodes of the provided parent node.
   * @param parent - The node to remove the children from.
   */
  removeChildNodes(parent) {
    for (let child = parent.firstChild; child !== null; child = parent.firstChild) {
      parent.removeChild(child);
    }
  },
  /**
   * Creates a TreeWalker configured to walk a template fragment.
   * @param fragment - The fragment to walk.
   */
  createTemplateWalker(fragment) {
    return document.createTreeWalker(
      fragment,
      133,
      // element, text, comment
      null,
      false
    );
  }
});
class SubscriberSet {
  /**
   * Creates an instance of SubscriberSet for the specified source.
   * @param source - The object source that subscribers will receive notifications from.
   * @param initialSubscriber - An initial subscriber to changes.
   */
  constructor(source, initialSubscriber) {
    this.sub1 = void 0;
    this.sub2 = void 0;
    this.spillover = void 0;
    this.source = source;
    this.sub1 = initialSubscriber;
  }
  /**
   * Checks whether the provided subscriber has been added to this set.
   * @param subscriber - The subscriber to test for inclusion in this set.
   */
  has(subscriber) {
    return this.spillover === void 0 ? this.sub1 === subscriber || this.sub2 === subscriber : this.spillover.indexOf(subscriber) !== -1;
  }
  /**
   * Subscribes to notification of changes in an object's state.
   * @param subscriber - The object that is subscribing for change notification.
   */
  subscribe(subscriber) {
    const spillover = this.spillover;
    if (spillover === void 0) {
      if (this.has(subscriber)) {
        return;
      }
      if (this.sub1 === void 0) {
        this.sub1 = subscriber;
        return;
      }
      if (this.sub2 === void 0) {
        this.sub2 = subscriber;
        return;
      }
      this.spillover = [this.sub1, this.sub2, subscriber];
      this.sub1 = void 0;
      this.sub2 = void 0;
    } else {
      const index = spillover.indexOf(subscriber);
      if (index === -1) {
        spillover.push(subscriber);
      }
    }
  }
  /**
   * Unsubscribes from notification of changes in an object's state.
   * @param subscriber - The object that is unsubscribing from change notification.
   */
  unsubscribe(subscriber) {
    const spillover = this.spillover;
    if (spillover === void 0) {
      if (this.sub1 === subscriber) {
        this.sub1 = void 0;
      } else if (this.sub2 === subscriber) {
        this.sub2 = void 0;
      }
    } else {
      const index = spillover.indexOf(subscriber);
      if (index !== -1) {
        spillover.splice(index, 1);
      }
    }
  }
  /**
   * Notifies all subscribers.
   * @param args - Data passed along to subscribers during notification.
   */
  notify(args) {
    const spillover = this.spillover;
    const source = this.source;
    if (spillover === void 0) {
      const sub1 = this.sub1;
      const sub2 = this.sub2;
      if (sub1 !== void 0) {
        sub1.handleChange(source, args);
      }
      if (sub2 !== void 0) {
        sub2.handleChange(source, args);
      }
    } else {
      for (let i2 = 0, ii = spillover.length; i2 < ii; ++i2) {
        spillover[i2].handleChange(source, args);
      }
    }
  }
}
class PropertyChangeNotifier {
  /**
   * Creates an instance of PropertyChangeNotifier for the specified source.
   * @param source - The object source that subscribers will receive notifications from.
   */
  constructor(source) {
    this.subscribers = {};
    this.sourceSubscribers = null;
    this.source = source;
  }
  /**
   * Notifies all subscribers, based on the specified property.
   * @param propertyName - The property name, passed along to subscribers during notification.
   */
  notify(propertyName) {
    var _a;
    const subscribers = this.subscribers[propertyName];
    if (subscribers !== void 0) {
      subscribers.notify(propertyName);
    }
    (_a = this.sourceSubscribers) === null || _a === void 0 ? void 0 : _a.notify(propertyName);
  }
  /**
   * Subscribes to notification of changes in an object's state.
   * @param subscriber - The object that is subscribing for change notification.
   * @param propertyToWatch - The name of the property that the subscriber is interested in watching for changes.
   */
  subscribe(subscriber, propertyToWatch) {
    var _a;
    if (propertyToWatch) {
      let subscribers = this.subscribers[propertyToWatch];
      if (subscribers === void 0) {
        this.subscribers[propertyToWatch] = subscribers = new SubscriberSet(this.source);
      }
      subscribers.subscribe(subscriber);
    } else {
      this.sourceSubscribers = (_a = this.sourceSubscribers) !== null && _a !== void 0 ? _a : new SubscriberSet(this.source);
      this.sourceSubscribers.subscribe(subscriber);
    }
  }
  /**
   * Unsubscribes from notification of changes in an object's state.
   * @param subscriber - The object that is unsubscribing from change notification.
   * @param propertyToUnwatch - The name of the property that the subscriber is no longer interested in watching.
   */
  unsubscribe(subscriber, propertyToUnwatch) {
    var _a;
    if (propertyToUnwatch) {
      const subscribers = this.subscribers[propertyToUnwatch];
      if (subscribers !== void 0) {
        subscribers.unsubscribe(subscriber);
      }
    } else {
      (_a = this.sourceSubscribers) === null || _a === void 0 ? void 0 : _a.unsubscribe(subscriber);
    }
  }
}
const Observable$1 = FAST.getById(2, () => {
  const volatileRegex = /(:|&&|\|\||if)/;
  const notifierLookup = /* @__PURE__ */ new WeakMap();
  const queueUpdate = DOM.queueUpdate;
  let watcher = void 0;
  let createArrayObserver = (array) => {
    throw new Error("Must call enableArrayObservation before observing arrays.");
  };
  function getNotifier(source) {
    let found2 = source.$fastController || notifierLookup.get(source);
    if (found2 === void 0) {
      if (Array.isArray(source)) {
        found2 = createArrayObserver(source);
      } else {
        notifierLookup.set(source, found2 = new PropertyChangeNotifier(source));
      }
    }
    return found2;
  }
  const getAccessors = createMetadataLocator();
  class DefaultObservableAccessor {
    constructor(name2) {
      this.name = name2;
      this.field = `_${name2}`;
      this.callback = `${name2}Changed`;
    }
    getValue(source) {
      if (watcher !== void 0) {
        watcher.watch(source, this.name);
      }
      return source[this.field];
    }
    setValue(source, newValue) {
      const field = this.field;
      const oldValue = source[field];
      if (oldValue !== newValue) {
        source[field] = newValue;
        const callback = source[this.callback];
        if (typeof callback === "function") {
          callback.call(source, oldValue, newValue);
        }
        getNotifier(source).notify(this.name);
      }
    }
  }
  class BindingObserverImplementation extends SubscriberSet {
    constructor(binding, initialSubscriber, isVolatileBinding = false) {
      super(binding, initialSubscriber);
      this.binding = binding;
      this.isVolatileBinding = isVolatileBinding;
      this.needsRefresh = true;
      this.needsQueue = true;
      this.first = this;
      this.last = null;
      this.propertySource = void 0;
      this.propertyName = void 0;
      this.notifier = void 0;
      this.next = void 0;
    }
    observe(source, context) {
      if (this.needsRefresh && this.last !== null) {
        this.disconnect();
      }
      const previousWatcher = watcher;
      watcher = this.needsRefresh ? this : void 0;
      this.needsRefresh = this.isVolatileBinding;
      const result2 = this.binding(source, context);
      watcher = previousWatcher;
      return result2;
    }
    disconnect() {
      if (this.last !== null) {
        let current = this.first;
        while (current !== void 0) {
          current.notifier.unsubscribe(this, current.propertyName);
          current = current.next;
        }
        this.last = null;
        this.needsRefresh = this.needsQueue = true;
      }
    }
    watch(propertySource, propertyName) {
      const prev = this.last;
      const notifier = getNotifier(propertySource);
      const current = prev === null ? this.first : {};
      current.propertySource = propertySource;
      current.propertyName = propertyName;
      current.notifier = notifier;
      notifier.subscribe(this, propertyName);
      if (prev !== null) {
        if (!this.needsRefresh) {
          let prevValue;
          watcher = void 0;
          prevValue = prev.propertySource[prev.propertyName];
          watcher = this;
          if (propertySource === prevValue) {
            this.needsRefresh = true;
          }
        }
        prev.next = current;
      }
      this.last = current;
    }
    handleChange() {
      if (this.needsQueue) {
        this.needsQueue = false;
        queueUpdate(this);
      }
    }
    call() {
      if (this.last !== null) {
        this.needsQueue = true;
        this.notify(this);
      }
    }
    records() {
      let next = this.first;
      return {
        next: () => {
          const current = next;
          if (current === void 0) {
            return { value: void 0, done: true };
          } else {
            next = next.next;
            return {
              value: current,
              done: false
            };
          }
        },
        [Symbol.iterator]: function() {
          return this;
        }
      };
    }
  }
  return Object.freeze({
    /**
     * @internal
     * @param factory - The factory used to create array observers.
     */
    setArrayObserverFactory(factory) {
      createArrayObserver = factory;
    },
    /**
     * Gets a notifier for an object or Array.
     * @param source - The object or Array to get the notifier for.
     */
    getNotifier,
    /**
     * Records a property change for a source object.
     * @param source - The object to record the change against.
     * @param propertyName - The property to track as changed.
     */
    track(source, propertyName) {
      if (watcher !== void 0) {
        watcher.watch(source, propertyName);
      }
    },
    /**
     * Notifies watchers that the currently executing property getter or function is volatile
     * with respect to its observable dependencies.
     */
    trackVolatile() {
      if (watcher !== void 0) {
        watcher.needsRefresh = true;
      }
    },
    /**
     * Notifies subscribers of a source object of changes.
     * @param source - the object to notify of changes.
     * @param args - The change args to pass to subscribers.
     */
    notify(source, args) {
      getNotifier(source).notify(args);
    },
    /**
     * Defines an observable property on an object or prototype.
     * @param target - The target object to define the observable on.
     * @param nameOrAccessor - The name of the property to define as observable;
     * or a custom accessor that specifies the property name and accessor implementation.
     */
    defineProperty(target2, nameOrAccessor) {
      if (typeof nameOrAccessor === "string") {
        nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);
      }
      getAccessors(target2).push(nameOrAccessor);
      Reflect.defineProperty(target2, nameOrAccessor.name, {
        enumerable: true,
        get: function() {
          return nameOrAccessor.getValue(this);
        },
        set: function(newValue) {
          nameOrAccessor.setValue(this, newValue);
        }
      });
    },
    /**
     * Finds all the observable accessors defined on the target,
     * including its prototype chain.
     * @param target - The target object to search for accessor on.
     */
    getAccessors,
    /**
     * Creates a {@link BindingObserver} that can watch the
     * provided {@link Binding} for changes.
     * @param binding - The binding to observe.
     * @param initialSubscriber - An initial subscriber to changes in the binding value.
     * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.
     */
    binding(binding, initialSubscriber, isVolatileBinding = this.isVolatileBinding(binding)) {
      return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);
    },
    /**
     * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated
     * on every evaluation of the value.
     * @param binding - The binding to inspect.
     */
    isVolatileBinding(binding) {
      return volatileRegex.test(binding.toString());
    }
  });
});
function observable(target2, nameOrAccessor) {
  Observable$1.defineProperty(target2, nameOrAccessor);
}
const contextEvent = FAST.getById(3, () => {
  let current = null;
  return {
    get() {
      return current;
    },
    set(event2) {
      current = event2;
    }
  };
});
class ExecutionContext {
  constructor() {
    this.index = 0;
    this.length = 0;
    this.parent = null;
    this.parentContext = null;
  }
  /**
   * The current event within an event handler.
   */
  get event() {
    return contextEvent.get();
  }
  /**
   * Indicates whether the current item within a repeat context
   * has an even index.
   */
  get isEven() {
    return this.index % 2 === 0;
  }
  /**
   * Indicates whether the current item within a repeat context
   * has an odd index.
   */
  get isOdd() {
    return this.index % 2 !== 0;
  }
  /**
   * Indicates whether the current item within a repeat context
   * is the first item in the collection.
   */
  get isFirst() {
    return this.index === 0;
  }
  /**
   * Indicates whether the current item within a repeat context
   * is somewhere in the middle of the collection.
   */
  get isInMiddle() {
    return !this.isFirst && !this.isLast;
  }
  /**
   * Indicates whether the current item within a repeat context
   * is the last item in the collection.
   */
  get isLast() {
    return this.index === this.length - 1;
  }
  /**
   * Sets the event for the current execution context.
   * @param event - The event to set.
   * @internal
   */
  static setEvent(event2) {
    contextEvent.set(event2);
  }
}
Observable$1.defineProperty(ExecutionContext.prototype, "index");
Observable$1.defineProperty(ExecutionContext.prototype, "length");
const defaultExecutionContext = Object.seal(new ExecutionContext());
class HTMLDirective {
  constructor() {
    this.targetIndex = 0;
  }
}
class TargetedHTMLDirective extends HTMLDirective {
  constructor() {
    super(...arguments);
    this.createPlaceholder = DOM.createInterpolationPlaceholder;
  }
}
class AttachedBehaviorHTMLDirective extends HTMLDirective {
  /**
   *
   * @param name - The name of the behavior; used as a custom attribute on the element.
   * @param behavior - The behavior to instantiate and attach to the element.
   * @param options - Options to pass to the behavior during creation.
   */
  constructor(name2, behavior, options) {
    super();
    this.name = name2;
    this.behavior = behavior;
    this.options = options;
  }
  /**
   * Creates a placeholder string based on the directive's index within the template.
   * @param index - The index of the directive within the template.
   * @remarks
   * Creates a custom attribute placeholder.
   */
  createPlaceholder(index) {
    return DOM.createCustomAttributePlaceholder(this.name, index);
  }
  /**
   * Creates a behavior for the provided target node.
   * @param target - The node instance to create the behavior for.
   * @remarks
   * Creates an instance of the `behavior` type this directive was constructed with
   * and passes the target and options to that `behavior`'s constructor.
   */
  createBehavior(target2) {
    return new this.behavior(target2, this.options);
  }
}
function normalBind(source, context) {
  this.source = source;
  this.context = context;
  if (this.bindingObserver === null) {
    this.bindingObserver = Observable$1.binding(this.binding, this, this.isBindingVolatile);
  }
  this.updateTarget(this.bindingObserver.observe(source, context));
}
function triggerBind(source, context) {
  this.source = source;
  this.context = context;
  this.target.addEventListener(this.targetName, this);
}
function normalUnbind() {
  this.bindingObserver.disconnect();
  this.source = null;
  this.context = null;
}
function contentUnbind() {
  this.bindingObserver.disconnect();
  this.source = null;
  this.context = null;
  const view = this.target.$fastView;
  if (view !== void 0 && view.isComposed) {
    view.unbind();
    view.needsBindOnly = true;
  }
}
function triggerUnbind() {
  this.target.removeEventListener(this.targetName, this);
  this.source = null;
  this.context = null;
}
function updateAttributeTarget(value) {
  DOM.setAttribute(this.target, this.targetName, value);
}
function updateBooleanAttributeTarget(value) {
  DOM.setBooleanAttribute(this.target, this.targetName, value);
}
function updateContentTarget(value) {
  if (value === null || value === void 0) {
    value = "";
  }
  if (value.create) {
    this.target.textContent = "";
    let view = this.target.$fastView;
    if (view === void 0) {
      view = value.create();
    } else {
      if (this.target.$fastTemplate !== value) {
        if (view.isComposed) {
          view.remove();
          view.unbind();
        }
        view = value.create();
      }
    }
    if (!view.isComposed) {
      view.isComposed = true;
      view.bind(this.source, this.context);
      view.insertBefore(this.target);
      this.target.$fastView = view;
      this.target.$fastTemplate = value;
    } else if (view.needsBindOnly) {
      view.needsBindOnly = false;
      view.bind(this.source, this.context);
    }
  } else {
    const view = this.target.$fastView;
    if (view !== void 0 && view.isComposed) {
      view.isComposed = false;
      view.remove();
      if (view.needsBindOnly) {
        view.needsBindOnly = false;
      } else {
        view.unbind();
      }
    }
    this.target.textContent = value;
  }
}
function updatePropertyTarget(value) {
  this.target[this.targetName] = value;
}
function updateClassTarget(value) {
  const classVersions = this.classVersions || /* @__PURE__ */ Object.create(null);
  const target2 = this.target;
  let version = this.version || 0;
  if (value !== null && value !== void 0 && value.length) {
    const names = value.split(/\s+/);
    for (let i2 = 0, ii = names.length; i2 < ii; ++i2) {
      const currentName = names[i2];
      if (currentName === "") {
        continue;
      }
      classVersions[currentName] = version;
      target2.classList.add(currentName);
    }
  }
  this.classVersions = classVersions;
  this.version = version + 1;
  if (version === 0) {
    return;
  }
  version -= 1;
  for (const name2 in classVersions) {
    if (classVersions[name2] === version) {
      target2.classList.remove(name2);
    }
  }
}
class HTMLBindingDirective extends TargetedHTMLDirective {
  /**
   * Creates an instance of BindingDirective.
   * @param binding - A binding that returns the data used to update the DOM.
   */
  constructor(binding) {
    super();
    this.binding = binding;
    this.bind = normalBind;
    this.unbind = normalUnbind;
    this.updateTarget = updateAttributeTarget;
    this.isBindingVolatile = Observable$1.isVolatileBinding(this.binding);
  }
  /**
   * Gets/sets the name of the attribute or property that this
   * binding is targeting.
   */
  get targetName() {
    return this.originalTargetName;
  }
  set targetName(value) {
    this.originalTargetName = value;
    if (value === void 0) {
      return;
    }
    switch (value[0]) {
      case ":":
        this.cleanedTargetName = value.substr(1);
        this.updateTarget = updatePropertyTarget;
        if (this.cleanedTargetName === "innerHTML") {
          const binding = this.binding;
          this.binding = (s, c) => DOM.createHTML(binding(s, c));
        }
        break;
      case "?":
        this.cleanedTargetName = value.substr(1);
        this.updateTarget = updateBooleanAttributeTarget;
        break;
      case "@":
        this.cleanedTargetName = value.substr(1);
        this.bind = triggerBind;
        this.unbind = triggerUnbind;
        break;
      default:
        this.cleanedTargetName = value;
        if (value === "class") {
          this.updateTarget = updateClassTarget;
        }
        break;
    }
  }
  /**
   * Makes this binding target the content of an element rather than
   * a particular attribute or property.
   */
  targetAtContent() {
    this.updateTarget = updateContentTarget;
    this.unbind = contentUnbind;
  }
  /**
   * Creates the runtime BindingBehavior instance based on the configuration
   * information stored in the BindingDirective.
   * @param target - The target node that the binding behavior should attach to.
   */
  createBehavior(target2) {
    return new BindingBehavior(target2, this.binding, this.isBindingVolatile, this.bind, this.unbind, this.updateTarget, this.cleanedTargetName);
  }
}
class BindingBehavior {
  /**
   * Creates an instance of BindingBehavior.
   * @param target - The target of the data updates.
   * @param binding - The binding that returns the latest value for an update.
   * @param isBindingVolatile - Indicates whether the binding has volatile dependencies.
   * @param bind - The operation to perform during binding.
   * @param unbind - The operation to perform during unbinding.
   * @param updateTarget - The operation to perform when updating.
   * @param targetName - The name of the target attribute or property to update.
   */
  constructor(target2, binding, isBindingVolatile, bind, unbind, updateTarget, targetName) {
    this.source = null;
    this.context = null;
    this.bindingObserver = null;
    this.target = target2;
    this.binding = binding;
    this.isBindingVolatile = isBindingVolatile;
    this.bind = bind;
    this.unbind = unbind;
    this.updateTarget = updateTarget;
    this.targetName = targetName;
  }
  /** @internal */
  handleChange() {
    this.updateTarget(this.bindingObserver.observe(this.source, this.context));
  }
  /** @internal */
  handleEvent(event2) {
    ExecutionContext.setEvent(event2);
    const result2 = this.binding(this.source, this.context);
    ExecutionContext.setEvent(null);
    if (result2 !== true) {
      event2.preventDefault();
    }
  }
}
let sharedContext = null;
class CompilationContext {
  addFactory(factory) {
    factory.targetIndex = this.targetIndex;
    this.behaviorFactories.push(factory);
  }
  captureContentBinding(directive) {
    directive.targetAtContent();
    this.addFactory(directive);
  }
  reset() {
    this.behaviorFactories = [];
    this.targetIndex = -1;
  }
  release() {
    sharedContext = this;
  }
  static borrow(directives) {
    const shareable = sharedContext || new CompilationContext();
    shareable.directives = directives;
    shareable.reset();
    sharedContext = null;
    return shareable;
  }
}
function createAggregateBinding(parts) {
  if (parts.length === 1) {
    return parts[0];
  }
  let targetName;
  const partCount = parts.length;
  const finalParts = parts.map((x2) => {
    if (typeof x2 === "string") {
      return () => x2;
    }
    targetName = x2.targetName || targetName;
    return x2.binding;
  });
  const binding = (scope, context) => {
    let output = "";
    for (let i2 = 0; i2 < partCount; ++i2) {
      output += finalParts[i2](scope, context);
    }
    return output;
  };
  const directive = new HTMLBindingDirective(binding);
  directive.targetName = targetName;
  return directive;
}
const interpolationEndLength = _interpolationEnd.length;
function parseContent(context, value) {
  const valueParts = value.split(_interpolationStart);
  if (valueParts.length === 1) {
    return null;
  }
  const bindingParts = [];
  for (let i2 = 0, ii = valueParts.length; i2 < ii; ++i2) {
    const current = valueParts[i2];
    const index = current.indexOf(_interpolationEnd);
    let literal;
    if (index === -1) {
      literal = current;
    } else {
      const directiveIndex = parseInt(current.substring(0, index));
      bindingParts.push(context.directives[directiveIndex]);
      literal = current.substring(index + interpolationEndLength);
    }
    if (literal !== "") {
      bindingParts.push(literal);
    }
  }
  return bindingParts;
}
function compileAttributes(context, node2, includeBasicValues = false) {
  const attributes = node2.attributes;
  for (let i2 = 0, ii = attributes.length; i2 < ii; ++i2) {
    const attr2 = attributes[i2];
    const attrValue = attr2.value;
    const parseResult = parseContent(context, attrValue);
    let result2 = null;
    if (parseResult === null) {
      if (includeBasicValues) {
        result2 = new HTMLBindingDirective(() => attrValue);
        result2.targetName = attr2.name;
      }
    } else {
      result2 = createAggregateBinding(parseResult);
    }
    if (result2 !== null) {
      node2.removeAttributeNode(attr2);
      i2--;
      ii--;
      context.addFactory(result2);
    }
  }
}
function compileContent(context, node2, walker) {
  const parseResult = parseContent(context, node2.textContent);
  if (parseResult !== null) {
    let lastNode = node2;
    for (let i2 = 0, ii = parseResult.length; i2 < ii; ++i2) {
      const currentPart = parseResult[i2];
      const currentNode = i2 === 0 ? node2 : lastNode.parentNode.insertBefore(document.createTextNode(""), lastNode.nextSibling);
      if (typeof currentPart === "string") {
        currentNode.textContent = currentPart;
      } else {
        currentNode.textContent = " ";
        context.captureContentBinding(currentPart);
      }
      lastNode = currentNode;
      context.targetIndex++;
      if (currentNode !== node2) {
        walker.nextNode();
      }
    }
    context.targetIndex--;
  }
}
function compileTemplate(template, directives) {
  const fragment = template.content;
  document.adoptNode(fragment);
  const context = CompilationContext.borrow(directives);
  compileAttributes(context, template, true);
  const hostBehaviorFactories = context.behaviorFactories;
  context.reset();
  const walker = DOM.createTemplateWalker(fragment);
  let node2;
  while (node2 = walker.nextNode()) {
    context.targetIndex++;
    switch (node2.nodeType) {
      case 1:
        compileAttributes(context, node2);
        break;
      case 3:
        compileContent(context, node2, walker);
        break;
      case 8:
        if (DOM.isMarker(node2)) {
          context.addFactory(directives[DOM.extractDirectiveIndexFromMarker(node2)]);
        }
    }
  }
  let targetOffset = 0;
  if (
    // If the first node in a fragment is a marker, that means it's an unstable first node,
    // because something like a when, repeat, etc. could add nodes before the marker.
    // To mitigate this, we insert a stable first node. However, if we insert a node,
    // that will alter the result of the TreeWalker. So, we also need to offset the target index.
    DOM.isMarker(fragment.firstChild) || // Or if there is only one node and a directive, it means the template's content
    // is *only* the directive. In that case, HTMLView.dispose() misses any nodes inserted by
    // the directive. Inserting a new node ensures proper disposal of nodes added by the directive.
    fragment.childNodes.length === 1 && directives.length
  ) {
    fragment.insertBefore(document.createComment(""), fragment.firstChild);
    targetOffset = -1;
  }
  const viewBehaviorFactories = context.behaviorFactories;
  context.release();
  return {
    fragment,
    viewBehaviorFactories,
    hostBehaviorFactories,
    targetOffset
  };
}
const range = document.createRange();
class HTMLView {
  /**
   * Constructs an instance of HTMLView.
   * @param fragment - The html fragment that contains the nodes for this view.
   * @param behaviors - The behaviors to be applied to this view.
   */
  constructor(fragment, behaviors) {
    this.fragment = fragment;
    this.behaviors = behaviors;
    this.source = null;
    this.context = null;
    this.firstChild = fragment.firstChild;
    this.lastChild = fragment.lastChild;
  }
  /**
   * Appends the view's DOM nodes to the referenced node.
   * @param node - The parent node to append the view's DOM nodes to.
   */
  appendTo(node2) {
    node2.appendChild(this.fragment);
  }
  /**
   * Inserts the view's DOM nodes before the referenced node.
   * @param node - The node to insert the view's DOM before.
   */
  insertBefore(node2) {
    if (this.fragment.hasChildNodes()) {
      node2.parentNode.insertBefore(this.fragment, node2);
    } else {
      const end = this.lastChild;
      if (node2.previousSibling === end)
        return;
      const parentNode = node2.parentNode;
      let current = this.firstChild;
      let next;
      while (current !== end) {
        next = current.nextSibling;
        parentNode.insertBefore(current, node2);
        current = next;
      }
      parentNode.insertBefore(end, node2);
    }
  }
  /**
   * Removes the view's DOM nodes.
   * The nodes are not disposed and the view can later be re-inserted.
   */
  remove() {
    const fragment = this.fragment;
    const end = this.lastChild;
    let current = this.firstChild;
    let next;
    while (current !== end) {
      next = current.nextSibling;
      fragment.appendChild(current);
      current = next;
    }
    fragment.appendChild(end);
  }
  /**
   * Removes the view and unbinds its behaviors, disposing of DOM nodes afterward.
   * Once a view has been disposed, it cannot be inserted or bound again.
   */
  dispose() {
    const parent = this.firstChild.parentNode;
    const end = this.lastChild;
    let current = this.firstChild;
    let next;
    while (current !== end) {
      next = current.nextSibling;
      parent.removeChild(current);
      current = next;
    }
    parent.removeChild(end);
    const behaviors = this.behaviors;
    const oldSource = this.source;
    for (let i2 = 0, ii = behaviors.length; i2 < ii; ++i2) {
      behaviors[i2].unbind(oldSource);
    }
  }
  /**
   * Binds a view's behaviors to its binding source.
   * @param source - The binding source for the view's binding behaviors.
   * @param context - The execution context to run the behaviors within.
   */
  bind(source, context) {
    const behaviors = this.behaviors;
    if (this.source === source) {
      return;
    } else if (this.source !== null) {
      const oldSource = this.source;
      this.source = source;
      this.context = context;
      for (let i2 = 0, ii = behaviors.length; i2 < ii; ++i2) {
        const current = behaviors[i2];
        current.unbind(oldSource);
        current.bind(source, context);
      }
    } else {
      this.source = source;
      this.context = context;
      for (let i2 = 0, ii = behaviors.length; i2 < ii; ++i2) {
        behaviors[i2].bind(source, context);
      }
    }
  }
  /**
   * Unbinds a view's behaviors from its binding source.
   */
  unbind() {
    if (this.source === null) {
      return;
    }
    const behaviors = this.behaviors;
    const oldSource = this.source;
    for (let i2 = 0, ii = behaviors.length; i2 < ii; ++i2) {
      behaviors[i2].unbind(oldSource);
    }
    this.source = null;
  }
  /**
   * Efficiently disposes of a contiguous range of synthetic view instances.
   * @param views - A contiguous range of views to be disposed.
   */
  static disposeContiguousBatch(views) {
    if (views.length === 0) {
      return;
    }
    range.setStartBefore(views[0].firstChild);
    range.setEndAfter(views[views.length - 1].lastChild);
    range.deleteContents();
    for (let i2 = 0, ii = views.length; i2 < ii; ++i2) {
      const view = views[i2];
      const behaviors = view.behaviors;
      const oldSource = view.source;
      for (let j = 0, jj = behaviors.length; j < jj; ++j) {
        behaviors[j].unbind(oldSource);
      }
    }
  }
}
class ViewTemplate {
  /**
   * Creates an instance of ViewTemplate.
   * @param html - The html representing what this template will instantiate, including placeholders for directives.
   * @param directives - The directives that will be connected to placeholders in the html.
   */
  constructor(html2, directives) {
    this.behaviorCount = 0;
    this.hasHostBehaviors = false;
    this.fragment = null;
    this.targetOffset = 0;
    this.viewBehaviorFactories = null;
    this.hostBehaviorFactories = null;
    this.html = html2;
    this.directives = directives;
  }
  /**
   * Creates an HTMLView instance based on this template definition.
   * @param hostBindingTarget - The element that host behaviors will be bound to.
   */
  create(hostBindingTarget) {
    if (this.fragment === null) {
      let template;
      const html2 = this.html;
      if (typeof html2 === "string") {
        template = document.createElement("template");
        template.innerHTML = DOM.createHTML(html2);
        const fec = template.content.firstElementChild;
        if (fec !== null && fec.tagName === "TEMPLATE") {
          template = fec;
        }
      } else {
        template = html2;
      }
      const result2 = compileTemplate(template, this.directives);
      this.fragment = result2.fragment;
      this.viewBehaviorFactories = result2.viewBehaviorFactories;
      this.hostBehaviorFactories = result2.hostBehaviorFactories;
      this.targetOffset = result2.targetOffset;
      this.behaviorCount = this.viewBehaviorFactories.length + this.hostBehaviorFactories.length;
      this.hasHostBehaviors = this.hostBehaviorFactories.length > 0;
    }
    const fragment = this.fragment.cloneNode(true);
    const viewFactories = this.viewBehaviorFactories;
    const behaviors = new Array(this.behaviorCount);
    const walker = DOM.createTemplateWalker(fragment);
    let behaviorIndex = 0;
    let targetIndex = this.targetOffset;
    let node2 = walker.nextNode();
    for (let ii = viewFactories.length; behaviorIndex < ii; ++behaviorIndex) {
      const factory = viewFactories[behaviorIndex];
      const factoryIndex = factory.targetIndex;
      while (node2 !== null) {
        if (targetIndex === factoryIndex) {
          behaviors[behaviorIndex] = factory.createBehavior(node2);
          break;
        } else {
          node2 = walker.nextNode();
          targetIndex++;
        }
      }
    }
    if (this.hasHostBehaviors) {
      const hostFactories = this.hostBehaviorFactories;
      for (let i2 = 0, ii = hostFactories.length; i2 < ii; ++i2, ++behaviorIndex) {
        behaviors[behaviorIndex] = hostFactories[i2].createBehavior(hostBindingTarget);
      }
    }
    return new HTMLView(fragment, behaviors);
  }
  /**
   * Creates an HTMLView from this template, binds it to the source, and then appends it to the host.
   * @param source - The data source to bind the template to.
   * @param host - The Element where the template will be rendered.
   * @param hostBindingTarget - An HTML element to target the host bindings at if different from the
   * host that the template is being attached to.
   */
  render(source, host, hostBindingTarget) {
    if (typeof host === "string") {
      host = document.getElementById(host);
    }
    if (hostBindingTarget === void 0) {
      hostBindingTarget = host;
    }
    const view = this.create(hostBindingTarget);
    view.bind(source, defaultExecutionContext);
    view.appendTo(host);
    return view;
  }
}
const lastAttributeNameRegex = (
  /* eslint-disable-next-line no-control-regex */
  /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/
);
function html(strings, ...values) {
  const directives = [];
  let html2 = "";
  for (let i2 = 0, ii = strings.length - 1; i2 < ii; ++i2) {
    const currentString = strings[i2];
    let value = values[i2];
    html2 += currentString;
    if (value instanceof ViewTemplate) {
      const template = value;
      value = () => template;
    }
    if (typeof value === "function") {
      value = new HTMLBindingDirective(value);
    }
    if (value instanceof TargetedHTMLDirective) {
      const match = lastAttributeNameRegex.exec(currentString);
      if (match !== null) {
        value.targetName = match[2];
      }
    }
    if (value instanceof HTMLDirective) {
      html2 += value.createPlaceholder(directives.length);
      directives.push(value);
    } else {
      html2 += value;
    }
  }
  html2 += strings[strings.length - 1];
  return new ViewTemplate(html2, directives);
}
class ElementStyles {
  constructor() {
    this.targets = /* @__PURE__ */ new WeakSet();
  }
  /** @internal */
  addStylesTo(target2) {
    this.targets.add(target2);
  }
  /** @internal */
  removeStylesFrom(target2) {
    this.targets.delete(target2);
  }
  /** @internal */
  isAttachedTo(target2) {
    return this.targets.has(target2);
  }
  /**
   * Associates behaviors with this set of styles.
   * @param behaviors - The behaviors to associate.
   */
  withBehaviors(...behaviors) {
    this.behaviors = this.behaviors === null ? behaviors : this.behaviors.concat(behaviors);
    return this;
  }
}
ElementStyles.create = (() => {
  if (DOM.supportsAdoptedStyleSheets) {
    const styleSheetCache = /* @__PURE__ */ new Map();
    return (styles) => (
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      new AdoptedStyleSheetsStyles(styles, styleSheetCache)
    );
  }
  return (styles) => new StyleElementStyles(styles);
})();
function reduceStyles(styles) {
  return styles.map((x2) => x2 instanceof ElementStyles ? reduceStyles(x2.styles) : [x2]).reduce((prev, curr) => prev.concat(curr), []);
}
function reduceBehaviors(styles) {
  return styles.map((x2) => x2 instanceof ElementStyles ? x2.behaviors : null).reduce((prev, curr) => {
    if (curr === null) {
      return prev;
    }
    if (prev === null) {
      prev = [];
    }
    return prev.concat(curr);
  }, null);
}
const prependToAdoptedStyleSheetsSymbol = Symbol("prependToAdoptedStyleSheets");
function separateSheetsToPrepend(sheets) {
  const prepend2 = [];
  const append2 = [];
  sheets.forEach((x2) => (x2[prependToAdoptedStyleSheetsSymbol] ? prepend2 : append2).push(x2));
  return { prepend: prepend2, append: append2 };
}
let addAdoptedStyleSheets = (target2, sheets) => {
  const { prepend: prepend2, append: append2 } = separateSheetsToPrepend(sheets);
  target2.adoptedStyleSheets = [...prepend2, ...target2.adoptedStyleSheets, ...append2];
};
let removeAdoptedStyleSheets = (target2, sheets) => {
  target2.adoptedStyleSheets = target2.adoptedStyleSheets.filter((x2) => sheets.indexOf(x2) === -1);
};
if (DOM.supportsAdoptedStyleSheets) {
  try {
    document.adoptedStyleSheets.push();
    document.adoptedStyleSheets.splice();
    addAdoptedStyleSheets = (target2, sheets) => {
      const { prepend: prepend2, append: append2 } = separateSheetsToPrepend(sheets);
      target2.adoptedStyleSheets.splice(0, 0, ...prepend2);
      target2.adoptedStyleSheets.push(...append2);
    };
    removeAdoptedStyleSheets = (target2, sheets) => {
      for (const sheet of sheets) {
        const index = target2.adoptedStyleSheets.indexOf(sheet);
        if (index !== -1) {
          target2.adoptedStyleSheets.splice(index, 1);
        }
      }
    };
  } catch (e) {
  }
}
class AdoptedStyleSheetsStyles extends ElementStyles {
  constructor(styles, styleSheetCache) {
    super();
    this.styles = styles;
    this.styleSheetCache = styleSheetCache;
    this._styleSheets = void 0;
    this.behaviors = reduceBehaviors(styles);
  }
  get styleSheets() {
    if (this._styleSheets === void 0) {
      const styles = this.styles;
      const styleSheetCache = this.styleSheetCache;
      this._styleSheets = reduceStyles(styles).map((x2) => {
        if (x2 instanceof CSSStyleSheet) {
          return x2;
        }
        let sheet = styleSheetCache.get(x2);
        if (sheet === void 0) {
          sheet = new CSSStyleSheet();
          sheet.replaceSync(x2);
          styleSheetCache.set(x2, sheet);
        }
        return sheet;
      });
    }
    return this._styleSheets;
  }
  addStylesTo(target2) {
    addAdoptedStyleSheets(target2, this.styleSheets);
    super.addStylesTo(target2);
  }
  removeStylesFrom(target2) {
    removeAdoptedStyleSheets(target2, this.styleSheets);
    super.removeStylesFrom(target2);
  }
}
let styleClassId = 0;
function getNextStyleClass() {
  return `fast-style-class-${++styleClassId}`;
}
class StyleElementStyles extends ElementStyles {
  constructor(styles) {
    super();
    this.styles = styles;
    this.behaviors = null;
    this.behaviors = reduceBehaviors(styles);
    this.styleSheets = reduceStyles(styles);
    this.styleClass = getNextStyleClass();
  }
  addStylesTo(target2) {
    const styleSheets = this.styleSheets;
    const styleClass = this.styleClass;
    target2 = this.normalizeTarget(target2);
    for (let i2 = 0; i2 < styleSheets.length; i2++) {
      const element = document.createElement("style");
      element.innerHTML = styleSheets[i2];
      element.className = styleClass;
      target2.append(element);
    }
    super.addStylesTo(target2);
  }
  removeStylesFrom(target2) {
    target2 = this.normalizeTarget(target2);
    const styles = target2.querySelectorAll(`.${this.styleClass}`);
    for (let i2 = 0, ii = styles.length; i2 < ii; ++i2) {
      target2.removeChild(styles[i2]);
    }
    super.removeStylesFrom(target2);
  }
  isAttachedTo(target2) {
    return super.isAttachedTo(this.normalizeTarget(target2));
  }
  normalizeTarget(target2) {
    return target2 === document ? document.body : target2;
  }
}
const AttributeConfiguration = Object.freeze({
  /**
   * Locates all attribute configurations associated with a type.
   */
  locate: createMetadataLocator()
});
const booleanConverter = {
  toView(value) {
    return value ? "true" : "false";
  },
  fromView(value) {
    if (value === null || value === void 0 || value === "false" || value === false || value === 0) {
      return false;
    }
    return true;
  }
};
class AttributeDefinition {
  /**
   * Creates an instance of AttributeDefinition.
   * @param Owner - The class constructor that owns this attribute.
   * @param name - The name of the property associated with the attribute.
   * @param attribute - The name of the attribute in HTML.
   * @param mode - The {@link AttributeMode} that describes the behavior of this attribute.
   * @param converter - A {@link ValueConverter} that integrates with the property getter/setter
   * to convert values to and from a DOM string.
   */
  constructor(Owner, name2, attribute = name2.toLowerCase(), mode = "reflect", converter) {
    this.guards = /* @__PURE__ */ new Set();
    this.Owner = Owner;
    this.name = name2;
    this.attribute = attribute;
    this.mode = mode;
    this.converter = converter;
    this.fieldName = `_${name2}`;
    this.callbackName = `${name2}Changed`;
    this.hasCallback = this.callbackName in Owner.prototype;
    if (mode === "boolean" && converter === void 0) {
      this.converter = booleanConverter;
    }
  }
  /**
   * Sets the value of the attribute/property on the source element.
   * @param source - The source element to access.
   * @param value - The value to set the attribute/property to.
   */
  setValue(source, newValue) {
    const oldValue = source[this.fieldName];
    const converter = this.converter;
    if (converter !== void 0) {
      newValue = converter.fromView(newValue);
    }
    if (oldValue !== newValue) {
      source[this.fieldName] = newValue;
      this.tryReflectToAttribute(source);
      if (this.hasCallback) {
        source[this.callbackName](oldValue, newValue);
      }
      source.$fastController.notify(this.name);
    }
  }
  /**
   * Gets the value of the attribute/property on the source element.
   * @param source - The source element to access.
   */
  getValue(source) {
    Observable$1.track(source, this.name);
    return source[this.fieldName];
  }
  /** @internal */
  onAttributeChangedCallback(element, value) {
    if (this.guards.has(element)) {
      return;
    }
    this.guards.add(element);
    this.setValue(element, value);
    this.guards.delete(element);
  }
  tryReflectToAttribute(element) {
    const mode = this.mode;
    const guards = this.guards;
    if (guards.has(element) || mode === "fromView") {
      return;
    }
    DOM.queueUpdate(() => {
      guards.add(element);
      const latestValue = element[this.fieldName];
      switch (mode) {
        case "reflect":
          const converter = this.converter;
          DOM.setAttribute(element, this.attribute, converter !== void 0 ? converter.toView(latestValue) : latestValue);
          break;
        case "boolean":
          DOM.setBooleanAttribute(element, this.attribute, latestValue);
          break;
      }
      guards.delete(element);
    });
  }
  /**
   * Collects all attribute definitions associated with the owner.
   * @param Owner - The class constructor to collect attribute for.
   * @param attributeLists - Any existing attributes to collect and merge with those associated with the owner.
   * @internal
   */
  static collect(Owner, ...attributeLists) {
    const attributes = [];
    attributeLists.push(AttributeConfiguration.locate(Owner));
    for (let i2 = 0, ii = attributeLists.length; i2 < ii; ++i2) {
      const list2 = attributeLists[i2];
      if (list2 === void 0) {
        continue;
      }
      for (let j = 0, jj = list2.length; j < jj; ++j) {
        const config2 = list2[j];
        if (typeof config2 === "string") {
          attributes.push(new AttributeDefinition(Owner, config2));
        } else {
          attributes.push(new AttributeDefinition(Owner, config2.property, config2.attribute, config2.mode, config2.converter));
        }
      }
    }
    return attributes;
  }
}
function attr(configOrTarget, prop) {
  let config2;
  function decorator($target, $prop) {
    if (arguments.length > 1) {
      config2.property = $prop;
    }
    AttributeConfiguration.locate($target.constructor).push(config2);
  }
  if (arguments.length > 1) {
    config2 = {};
    decorator(configOrTarget, prop);
    return;
  }
  config2 = configOrTarget === void 0 ? {} : configOrTarget;
  return decorator;
}
const defaultShadowOptions = { mode: "open" };
const defaultElementOptions = {};
const fastRegistry = FAST.getById(4, () => {
  const typeToDefinition = /* @__PURE__ */ new Map();
  return Object.freeze({
    register(definition) {
      if (typeToDefinition.has(definition.type)) {
        return false;
      }
      typeToDefinition.set(definition.type, definition);
      return true;
    },
    getByType(key2) {
      return typeToDefinition.get(key2);
    }
  });
});
class FASTElementDefinition {
  /**
   * Creates an instance of FASTElementDefinition.
   * @param type - The type this definition is being created for.
   * @param nameOrConfig - The name of the element to define or a config object
   * that describes the element to define.
   */
  constructor(type, nameOrConfig = type.definition) {
    if (typeof nameOrConfig === "string") {
      nameOrConfig = { name: nameOrConfig };
    }
    this.type = type;
    this.name = nameOrConfig.name;
    this.template = nameOrConfig.template;
    const attributes = AttributeDefinition.collect(type, nameOrConfig.attributes);
    const observedAttributes = new Array(attributes.length);
    const propertyLookup = {};
    const attributeLookup = {};
    for (let i2 = 0, ii = attributes.length; i2 < ii; ++i2) {
      const current = attributes[i2];
      observedAttributes[i2] = current.attribute;
      propertyLookup[current.name] = current;
      attributeLookup[current.attribute] = current;
    }
    this.attributes = attributes;
    this.observedAttributes = observedAttributes;
    this.propertyLookup = propertyLookup;
    this.attributeLookup = attributeLookup;
    this.shadowOptions = nameOrConfig.shadowOptions === void 0 ? defaultShadowOptions : nameOrConfig.shadowOptions === null ? void 0 : Object.assign(Object.assign({}, defaultShadowOptions), nameOrConfig.shadowOptions);
    this.elementOptions = nameOrConfig.elementOptions === void 0 ? defaultElementOptions : Object.assign(Object.assign({}, defaultElementOptions), nameOrConfig.elementOptions);
    this.styles = nameOrConfig.styles === void 0 ? void 0 : Array.isArray(nameOrConfig.styles) ? ElementStyles.create(nameOrConfig.styles) : nameOrConfig.styles instanceof ElementStyles ? nameOrConfig.styles : ElementStyles.create([nameOrConfig.styles]);
  }
  /**
   * Indicates if this element has been defined in at least one registry.
   */
  get isDefined() {
    return !!fastRegistry.getByType(this.type);
  }
  /**
   * Defines a custom element based on this definition.
   * @param registry - The element registry to define the element in.
   */
  define(registry = customElements) {
    const type = this.type;
    if (fastRegistry.register(this)) {
      const attributes = this.attributes;
      const proto = type.prototype;
      for (let i2 = 0, ii = attributes.length; i2 < ii; ++i2) {
        Observable$1.defineProperty(proto, attributes[i2]);
      }
      Reflect.defineProperty(type, "observedAttributes", {
        value: this.observedAttributes,
        enumerable: true
      });
    }
    if (!registry.get(this.name)) {
      registry.define(this.name, type, this.elementOptions);
    }
    return this;
  }
}
FASTElementDefinition.forType = fastRegistry.getByType;
const shadowRoots = /* @__PURE__ */ new WeakMap();
const defaultEventOptions = {
  bubbles: true,
  composed: true,
  cancelable: true
};
function getShadowRoot(element) {
  return element.shadowRoot || shadowRoots.get(element) || null;
}
class Controller extends PropertyChangeNotifier {
  /**
   * Creates a Controller to control the specified element.
   * @param element - The element to be controlled by this controller.
   * @param definition - The element definition metadata that instructs this
   * controller in how to handle rendering and other platform integrations.
   * @internal
   */
  constructor(element, definition) {
    super(element);
    this.boundObservables = null;
    this.behaviors = null;
    this.needsInitialization = true;
    this._template = null;
    this._styles = null;
    this._isConnected = false;
    this.$fastController = this;
    this.view = null;
    this.element = element;
    this.definition = definition;
    const shadowOptions = definition.shadowOptions;
    if (shadowOptions !== void 0) {
      const shadowRoot = element.attachShadow(shadowOptions);
      if (shadowOptions.mode === "closed") {
        shadowRoots.set(element, shadowRoot);
      }
    }
    const accessors = Observable$1.getAccessors(element);
    if (accessors.length > 0) {
      const boundObservables = this.boundObservables = /* @__PURE__ */ Object.create(null);
      for (let i2 = 0, ii = accessors.length; i2 < ii; ++i2) {
        const propertyName = accessors[i2].name;
        const value = element[propertyName];
        if (value !== void 0) {
          delete element[propertyName];
          boundObservables[propertyName] = value;
        }
      }
    }
  }
  /**
   * Indicates whether or not the custom element has been
   * connected to the document.
   */
  get isConnected() {
    Observable$1.track(this, "isConnected");
    return this._isConnected;
  }
  setIsConnected(value) {
    this._isConnected = value;
    Observable$1.notify(this, "isConnected");
  }
  /**
   * Gets/sets the template used to render the component.
   * @remarks
   * This value can only be accurately read after connect but can be set at any time.
   */
  get template() {
    return this._template;
  }
  set template(value) {
    if (this._template === value) {
      return;
    }
    this._template = value;
    if (!this.needsInitialization) {
      this.renderTemplate(value);
    }
  }
  /**
   * Gets/sets the primary styles used for the component.
   * @remarks
   * This value can only be accurately read after connect but can be set at any time.
   */
  get styles() {
    return this._styles;
  }
  set styles(value) {
    if (this._styles === value) {
      return;
    }
    if (this._styles !== null) {
      this.removeStyles(this._styles);
    }
    this._styles = value;
    if (!this.needsInitialization && value !== null) {
      this.addStyles(value);
    }
  }
  /**
   * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.
   * @param styles - The styles to add.
   */
  addStyles(styles) {
    const target2 = getShadowRoot(this.element) || this.element.getRootNode();
    if (styles instanceof HTMLStyleElement) {
      target2.append(styles);
    } else if (!styles.isAttachedTo(target2)) {
      const sourceBehaviors = styles.behaviors;
      styles.addStylesTo(target2);
      if (sourceBehaviors !== null) {
        this.addBehaviors(sourceBehaviors);
      }
    }
  }
  /**
   * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.
   * @param styles - the styles to remove.
   */
  removeStyles(styles) {
    const target2 = getShadowRoot(this.element) || this.element.getRootNode();
    if (styles instanceof HTMLStyleElement) {
      target2.removeChild(styles);
    } else if (styles.isAttachedTo(target2)) {
      const sourceBehaviors = styles.behaviors;
      styles.removeStylesFrom(target2);
      if (sourceBehaviors !== null) {
        this.removeBehaviors(sourceBehaviors);
      }
    }
  }
  /**
   * Adds behaviors to this element.
   * @param behaviors - The behaviors to add.
   */
  addBehaviors(behaviors) {
    const targetBehaviors = this.behaviors || (this.behaviors = /* @__PURE__ */ new Map());
    const length2 = behaviors.length;
    const behaviorsToBind = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      const behavior = behaviors[i2];
      if (targetBehaviors.has(behavior)) {
        targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);
      } else {
        targetBehaviors.set(behavior, 1);
        behaviorsToBind.push(behavior);
      }
    }
    if (this._isConnected) {
      const element = this.element;
      for (let i2 = 0; i2 < behaviorsToBind.length; ++i2) {
        behaviorsToBind[i2].bind(element, defaultExecutionContext);
      }
    }
  }
  /**
   * Removes behaviors from this element.
   * @param behaviors - The behaviors to remove.
   * @param force - Forces unbinding of behaviors.
   */
  removeBehaviors(behaviors, force = false) {
    const targetBehaviors = this.behaviors;
    if (targetBehaviors === null) {
      return;
    }
    const length2 = behaviors.length;
    const behaviorsToUnbind = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      const behavior = behaviors[i2];
      if (targetBehaviors.has(behavior)) {
        const count = targetBehaviors.get(behavior) - 1;
        count === 0 || force ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior) : targetBehaviors.set(behavior, count);
      }
    }
    if (this._isConnected) {
      const element = this.element;
      for (let i2 = 0; i2 < behaviorsToUnbind.length; ++i2) {
        behaviorsToUnbind[i2].unbind(element);
      }
    }
  }
  /**
   * Runs connected lifecycle behavior on the associated element.
   */
  onConnectedCallback() {
    if (this._isConnected) {
      return;
    }
    const element = this.element;
    if (this.needsInitialization) {
      this.finishInitialization();
    } else if (this.view !== null) {
      this.view.bind(element, defaultExecutionContext);
    }
    const behaviors = this.behaviors;
    if (behaviors !== null) {
      for (const [behavior] of behaviors) {
        behavior.bind(element, defaultExecutionContext);
      }
    }
    this.setIsConnected(true);
  }
  /**
   * Runs disconnected lifecycle behavior on the associated element.
   */
  onDisconnectedCallback() {
    if (!this._isConnected) {
      return;
    }
    this.setIsConnected(false);
    const view = this.view;
    if (view !== null) {
      view.unbind();
    }
    const behaviors = this.behaviors;
    if (behaviors !== null) {
      const element = this.element;
      for (const [behavior] of behaviors) {
        behavior.unbind(element);
      }
    }
  }
  /**
   * Runs the attribute changed callback for the associated element.
   * @param name - The name of the attribute that changed.
   * @param oldValue - The previous value of the attribute.
   * @param newValue - The new value of the attribute.
   */
  onAttributeChangedCallback(name2, oldValue, newValue) {
    const attrDef = this.definition.attributeLookup[name2];
    if (attrDef !== void 0) {
      attrDef.onAttributeChangedCallback(this.element, newValue);
    }
  }
  /**
   * Emits a custom HTML event.
   * @param type - The type name of the event.
   * @param detail - The event detail object to send with the event.
   * @param options - The event options. By default bubbles and composed.
   * @remarks
   * Only emits events if connected.
   */
  emit(type, detail, options) {
    if (this._isConnected) {
      return this.element.dispatchEvent(new CustomEvent(type, Object.assign(Object.assign({ detail }, defaultEventOptions), options)));
    }
    return false;
  }
  finishInitialization() {
    const element = this.element;
    const boundObservables = this.boundObservables;
    if (boundObservables !== null) {
      const propertyNames = Object.keys(boundObservables);
      for (let i2 = 0, ii = propertyNames.length; i2 < ii; ++i2) {
        const propertyName = propertyNames[i2];
        element[propertyName] = boundObservables[propertyName];
      }
      this.boundObservables = null;
    }
    const definition = this.definition;
    if (this._template === null) {
      if (this.element.resolveTemplate) {
        this._template = this.element.resolveTemplate();
      } else if (definition.template) {
        this._template = definition.template || null;
      }
    }
    if (this._template !== null) {
      this.renderTemplate(this._template);
    }
    if (this._styles === null) {
      if (this.element.resolveStyles) {
        this._styles = this.element.resolveStyles();
      } else if (definition.styles) {
        this._styles = definition.styles || null;
      }
    }
    if (this._styles !== null) {
      this.addStyles(this._styles);
    }
    this.needsInitialization = false;
  }
  renderTemplate(template) {
    const element = this.element;
    const host = getShadowRoot(element) || element;
    if (this.view !== null) {
      this.view.dispose();
      this.view = null;
    } else if (!this.needsInitialization) {
      DOM.removeChildNodes(host);
    }
    if (template) {
      this.view = template.render(element, host, element);
    }
  }
  /**
   * Locates or creates a controller for the specified element.
   * @param element - The element to return the controller for.
   * @remarks
   * The specified element must have a {@link FASTElementDefinition}
   * registered either through the use of the {@link customElement}
   * decorator or a call to `FASTElement.define`.
   */
  static forCustomElement(element) {
    const controller = element.$fastController;
    if (controller !== void 0) {
      return controller;
    }
    const definition = FASTElementDefinition.forType(element.constructor);
    if (definition === void 0) {
      throw new Error("Missing FASTElement definition.");
    }
    return element.$fastController = new Controller(element, definition);
  }
}
function createFASTElement(BaseType) {
  return class extends BaseType {
    constructor() {
      super();
      Controller.forCustomElement(this);
    }
    $emit(type, detail, options) {
      return this.$fastController.emit(type, detail, options);
    }
    connectedCallback() {
      this.$fastController.onConnectedCallback();
    }
    disconnectedCallback() {
      this.$fastController.onDisconnectedCallback();
    }
    attributeChangedCallback(name2, oldValue, newValue) {
      this.$fastController.onAttributeChangedCallback(name2, oldValue, newValue);
    }
  };
}
const FASTElement = Object.assign(createFASTElement(HTMLElement), {
  /**
   * Creates a new FASTElement base class inherited from the
   * provided base type.
   * @param BaseType - The base element type to inherit from.
   */
  from(BaseType) {
    return createFASTElement(BaseType);
  },
  /**
   * Defines a platform custom element based on the provided type and definition.
   * @param type - The custom element type to define.
   * @param nameOrDef - The name of the element to define or a definition object
   * that describes the element to define.
   */
  define(type, nameOrDef) {
    return new FASTElementDefinition(type, nameOrDef).define().type;
  }
});
class CSSDirective {
  /**
   * Creates a CSS fragment to interpolate into the CSS document.
   * @returns - the string to interpolate into CSS
   */
  createCSS() {
    return "";
  }
  /**
   * Creates a behavior to bind to the host element.
   * @returns - the behavior to bind to the host element, or undefined.
   */
  createBehavior() {
    return void 0;
  }
}
function collectStyles(strings, values) {
  const styles = [];
  let cssString = "";
  const behaviors = [];
  for (let i2 = 0, ii = strings.length - 1; i2 < ii; ++i2) {
    cssString += strings[i2];
    let value = values[i2];
    if (value instanceof CSSDirective) {
      const behavior = value.createBehavior();
      value = value.createCSS();
      if (behavior) {
        behaviors.push(behavior);
      }
    }
    if (value instanceof ElementStyles || value instanceof CSSStyleSheet) {
      if (cssString.trim() !== "") {
        styles.push(cssString);
        cssString = "";
      }
      styles.push(value);
    } else {
      cssString += value;
    }
  }
  cssString += strings[strings.length - 1];
  if (cssString.trim() !== "") {
    styles.push(cssString);
  }
  return {
    styles,
    behaviors
  };
}
function css(strings, ...values) {
  const { styles, behaviors } = collectStyles(strings, values);
  const elementStyles = ElementStyles.create(styles);
  if (behaviors.length) {
    elementStyles.withBehaviors(...behaviors);
  }
  return elementStyles;
}
class CSSPartial extends CSSDirective {
  constructor(styles, behaviors) {
    super();
    this.behaviors = behaviors;
    this.css = "";
    const stylesheets = styles.reduce((accumulated, current) => {
      if (typeof current === "string") {
        this.css += current;
      } else {
        accumulated.push(current);
      }
      return accumulated;
    }, []);
    if (stylesheets.length) {
      this.styles = ElementStyles.create(stylesheets);
    }
  }
  createBehavior() {
    return this;
  }
  createCSS() {
    return this.css;
  }
  bind(el) {
    if (this.styles) {
      el.$fastController.addStyles(this.styles);
    }
    if (this.behaviors.length) {
      el.$fastController.addBehaviors(this.behaviors);
    }
  }
  unbind(el) {
    if (this.styles) {
      el.$fastController.removeStyles(this.styles);
    }
    if (this.behaviors.length) {
      el.$fastController.removeBehaviors(this.behaviors);
    }
  }
}
function cssPartial(strings, ...values) {
  const { styles, behaviors } = collectStyles(strings, values);
  return new CSSPartial(styles, behaviors);
}
class RefBehavior {
  /**
   * Creates an instance of RefBehavior.
   * @param target - The element to reference.
   * @param propertyName - The name of the property to assign the reference to.
   */
  constructor(target2, propertyName) {
    this.target = target2;
    this.propertyName = propertyName;
  }
  /**
   * Bind this behavior to the source.
   * @param source - The source to bind to.
   * @param context - The execution context that the binding is operating within.
   */
  bind(source) {
    source[this.propertyName] = this.target;
  }
  /**
   * Unbinds this behavior from the source.
   * @param source - The source to unbind from.
   */
  /* eslint-disable-next-line @typescript-eslint/no-empty-function */
  unbind() {
  }
}
function ref(propertyName) {
  return new AttachedBehaviorHTMLDirective("fast-ref", RefBehavior, propertyName);
}
function elements(selector) {
  return function(value, index, array) {
    return value.nodeType === 1;
  };
}
class NodeObservationBehavior {
  /**
   * Creates an instance of NodeObservationBehavior.
   * @param target - The target to assign the nodes property on.
   * @param options - The options to use in configuring node observation.
   */
  constructor(target2, options) {
    this.target = target2;
    this.options = options;
    this.source = null;
  }
  /**
   * Bind this behavior to the source.
   * @param source - The source to bind to.
   * @param context - The execution context that the binding is operating within.
   */
  bind(source) {
    const name2 = this.options.property;
    this.shouldUpdate = Observable$1.getAccessors(source).some((x2) => x2.name === name2);
    this.source = source;
    this.updateTarget(this.computeNodes());
    if (this.shouldUpdate) {
      this.observe();
    }
  }
  /**
   * Unbinds this behavior from the source.
   * @param source - The source to unbind from.
   */
  unbind() {
    this.updateTarget(emptyArray);
    this.source = null;
    if (this.shouldUpdate) {
      this.disconnect();
    }
  }
  /** @internal */
  handleEvent() {
    this.updateTarget(this.computeNodes());
  }
  computeNodes() {
    let nodes = this.getNodes();
    if (this.options.filter !== void 0) {
      nodes = nodes.filter(this.options.filter);
    }
    return nodes;
  }
  updateTarget(value) {
    this.source[this.options.property] = value;
  }
}
class SlottedBehavior extends NodeObservationBehavior {
  /**
   * Creates an instance of SlottedBehavior.
   * @param target - The slot element target to observe.
   * @param options - The options to use when observing the slot.
   */
  constructor(target2, options) {
    super(target2, options);
  }
  /**
   * Begins observation of the nodes.
   */
  observe() {
    this.target.addEventListener("slotchange", this);
  }
  /**
   * Disconnects observation of the nodes.
   */
  disconnect() {
    this.target.removeEventListener("slotchange", this);
  }
  /**
   * Retrieves the nodes that should be assigned to the target.
   */
  getNodes() {
    return this.target.assignedNodes(this.options);
  }
}
function slotted(propertyOrOptions) {
  if (typeof propertyOrOptions === "string") {
    propertyOrOptions = { property: propertyOrOptions };
  }
  return new AttachedBehaviorHTMLDirective("fast-slotted", SlottedBehavior, propertyOrOptions);
}
class ChildrenBehavior extends NodeObservationBehavior {
  /**
   * Creates an instance of ChildrenBehavior.
   * @param target - The element target to observe children on.
   * @param options - The options to use when observing the element children.
   */
  constructor(target2, options) {
    super(target2, options);
    this.observer = null;
    options.childList = true;
  }
  /**
   * Begins observation of the nodes.
   */
  observe() {
    if (this.observer === null) {
      this.observer = new MutationObserver(this.handleEvent.bind(this));
    }
    this.observer.observe(this.target, this.options);
  }
  /**
   * Disconnects observation of the nodes.
   */
  disconnect() {
    this.observer.disconnect();
  }
  /**
   * Retrieves the nodes that should be assigned to the target.
   */
  getNodes() {
    if ("subtree" in this.options) {
      return Array.from(this.target.querySelectorAll(this.options.selector));
    }
    return Array.from(this.target.childNodes);
  }
}
function children(propertyOrOptions) {
  if (typeof propertyOrOptions === "string") {
    propertyOrOptions = {
      property: propertyOrOptions
    };
  }
  return new AttachedBehaviorHTMLDirective("fast-children", ChildrenBehavior, propertyOrOptions);
}
class StartEnd {
  handleStartContentChange() {
    this.startContainer.classList.toggle("start", this.start.assignedNodes().length > 0);
  }
  handleEndContentChange() {
    this.endContainer.classList.toggle("end", this.end.assignedNodes().length > 0);
  }
}
const endSlotTemplate = (context, definition) => html`
    <span
        part="end"
        ${ref("endContainer")}
        class=${(x2) => definition.end ? "end" : void 0}
    >
        <slot name="end" ${ref("end")} @slotchange="${(x2) => x2.handleEndContentChange()}">
            ${definition.end || ""}
        </slot>
    </span>
`;
const startSlotTemplate = (context, definition) => html`
    <span
        part="start"
        ${ref("startContainer")}
        class="${(x2) => definition.start ? "start" : void 0}"
    >
        <slot
            name="start"
            ${ref("start")}
            @slotchange="${(x2) => x2.handleStartContentChange()}"
        >
            ${definition.start || ""}
        </slot>
    </span>
`;
html`
    <span part="end" ${ref("endContainer")}>
        <slot
            name="end"
            ${ref("end")}
            @slotchange="${(x2) => x2.handleEndContentChange()}"
        ></slot>
    </span>
`;
html`
    <span part="start" ${ref("startContainer")}>
        <slot
            name="start"
            ${ref("start")}
            @slotchange="${(x2) => x2.handleStartContentChange()}"
        ></slot>
    </span>
`;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __decorate(decorators, target2, key2, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target2, key2, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target2, key2, r) : d(target2, key2)) || r;
  return c > 3 && r && Object.defineProperty(target2, key2, r), r;
}
const metadataByTarget = /* @__PURE__ */ new Map();
if (!("metadata" in Reflect)) {
  Reflect.metadata = function(key2, value) {
    return function(target2) {
      Reflect.defineMetadata(key2, value, target2);
    };
  };
  Reflect.defineMetadata = function(key2, value, target2) {
    let metadata = metadataByTarget.get(target2);
    if (metadata === void 0) {
      metadataByTarget.set(target2, metadata = /* @__PURE__ */ new Map());
    }
    metadata.set(key2, value);
  };
  Reflect.getOwnMetadata = function(key2, target2) {
    const metadata = metadataByTarget.get(target2);
    if (metadata !== void 0) {
      return metadata.get(key2);
    }
    return void 0;
  };
}
class ResolverBuilder {
  /**
   *
   * @param container - The container to create resolvers for.
   * @param key - The key to register resolvers under.
   */
  constructor(container2, key2) {
    this.container = container2;
    this.key = key2;
  }
  /**
   * Creates a resolver for an existing object instance.
   * @param value - The instance to resolve.
   * @returns The resolver.
   */
  instance(value) {
    return this.registerResolver(0, value);
  }
  /**
   * Creates a resolver that enforces a singleton lifetime.
   * @param value - The type to create and cache the singleton for.
   * @returns The resolver.
   */
  singleton(value) {
    return this.registerResolver(1, value);
  }
  /**
   * Creates a resolver that creates a new instance for every dependency request.
   * @param value - The type to create instances of.
   * @returns - The resolver.
   */
  transient(value) {
    return this.registerResolver(2, value);
  }
  /**
   * Creates a resolver that invokes a callback function for every dependency resolution
   * request, allowing custom logic to return the dependency.
   * @param value - The callback to call during resolution.
   * @returns The resolver.
   */
  callback(value) {
    return this.registerResolver(3, value);
  }
  /**
   * Creates a resolver that invokes a callback function the first time that a dependency
   * resolution is requested. The returned value is then cached and provided for all
   * subsequent requests.
   * @param value - The callback to call during the first resolution.
   * @returns The resolver.
   */
  cachedCallback(value) {
    return this.registerResolver(3, cacheCallbackResult(value));
  }
  /**
   * Aliases the current key to a different key.
   * @param destinationKey - The key to point the alias to.
   * @returns The resolver.
   */
  aliasTo(destinationKey) {
    return this.registerResolver(5, destinationKey);
  }
  registerResolver(strategy, state) {
    const { container: container2, key: key2 } = this;
    this.container = this.key = void 0;
    return container2.registerResolver(key2, new ResolverImpl(key2, strategy, state));
  }
}
function cloneArrayWithPossibleProps(source) {
  const clone = source.slice();
  const keys2 = Object.keys(source);
  const len = keys2.length;
  let key2;
  for (let i2 = 0; i2 < len; ++i2) {
    key2 = keys2[i2];
    if (!isArrayIndex(key2)) {
      clone[key2] = source[key2];
    }
  }
  return clone;
}
const DefaultResolver = Object.freeze({
  /**
   * Disables auto-registration and throws for all un-registered dependencies.
   * @param key - The key to create the resolver for.
   */
  none(key2) {
    throw Error(`${key2.toString()} not registered, did you forget to add @singleton()?`);
  },
  /**
   * Provides default singleton resolution behavior during auto-registration.
   * @param key - The key to create the resolver for.
   * @returns The resolver.
   */
  singleton(key2) {
    return new ResolverImpl(key2, 1, key2);
  },
  /**
   * Provides default transient resolution behavior during auto-registration.
   * @param key - The key to create the resolver for.
   * @returns The resolver.
   */
  transient(key2) {
    return new ResolverImpl(key2, 2, key2);
  }
});
const ContainerConfiguration = Object.freeze({
  /**
   * The default configuration used when creating a DOM-disconnected container.
   * @remarks
   * The default creates a root container, with no parent container. It does not handle
   * owner requests and it uses singleton resolution behavior for auto-registration.
   */
  default: Object.freeze({
    parentLocator: () => null,
    responsibleForOwnerRequests: false,
    defaultResolver: DefaultResolver.singleton
  })
});
const dependencyLookup = /* @__PURE__ */ new Map();
function getParamTypes(key2) {
  return (Type) => {
    return Reflect.getOwnMetadata(key2, Type);
  };
}
let rootDOMContainer = null;
const DI = Object.freeze({
  /**
   * Creates a new dependency injection container.
   * @param config - The configuration for the container.
   * @returns A newly created dependency injection container.
   */
  createContainer(config2) {
    return new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config2));
  },
  /**
   * Finds the dependency injection container responsible for providing dependencies
   * to the specified node.
   * @param node - The node to find the responsible container for.
   * @returns The container responsible for providing dependencies to the node.
   * @remarks
   * This will be the same as the parent container if the specified node
   * does not itself host a container configured with responsibleForOwnerRequests.
   */
  findResponsibleContainer(node2) {
    const owned = node2.$$container$$;
    if (owned && owned.responsibleForOwnerRequests) {
      return owned;
    }
    return DI.findParentContainer(node2);
  },
  /**
   * Find the dependency injection container up the DOM tree from this node.
   * @param node - The node to find the parent container for.
   * @returns The parent container of this node.
   * @remarks
   * This will be the same as the responsible container if the specified node
   * does not itself host a container configured with responsibleForOwnerRequests.
   */
  findParentContainer(node2) {
    const event2 = new CustomEvent(DILocateParentEventType, {
      bubbles: true,
      composed: true,
      cancelable: true,
      detail: { container: void 0 }
    });
    node2.dispatchEvent(event2);
    return event2.detail.container || DI.getOrCreateDOMContainer();
  },
  /**
   * Returns a dependency injection container if one is explicitly owned by the specified
   * node. If one is not owned, then a new container is created and assigned to the node.
   * @param node - The node to find or create the container for.
   * @param config - The configuration for the container if one needs to be created.
   * @returns The located or created container.
   * @remarks
   * This API does not search for a responsible or parent container. It looks only for a container
   * directly defined on the specified node and creates one at that location if one does not
   * already exist.
   */
  getOrCreateDOMContainer(node2, config2) {
    if (!node2) {
      return rootDOMContainer || (rootDOMContainer = new ContainerImpl(null, Object.assign({}, ContainerConfiguration.default, config2, {
        parentLocator: () => null
      })));
    }
    return node2.$$container$$ || new ContainerImpl(node2, Object.assign({}, ContainerConfiguration.default, config2, {
      parentLocator: DI.findParentContainer
    }));
  },
  /**
   * Gets the "design:paramtypes" metadata for the specified type.
   * @param Type - The type to get the metadata for.
   * @returns The metadata array or undefined if no metadata is found.
   */
  getDesignParamtypes: getParamTypes("design:paramtypes"),
  /**
   * Gets the "di:paramtypes" metadata for the specified type.
   * @param Type - The type to get the metadata for.
   * @returns The metadata array or undefined if no metadata is found.
   */
  getAnnotationParamtypes: getParamTypes("di:paramtypes"),
  /**
   *
   * @param Type - Gets the "di:paramtypes" metadata for the specified type. If none is found,
   * an empty metadata array is created and added.
   * @returns The metadata array.
   */
  getOrCreateAnnotationParamTypes(Type) {
    let annotationParamtypes = this.getAnnotationParamtypes(Type);
    if (annotationParamtypes === void 0) {
      Reflect.defineMetadata("di:paramtypes", annotationParamtypes = [], Type);
    }
    return annotationParamtypes;
  },
  /**
   * Gets the dependency keys representing what is needed to instantiate the specified type.
   * @param Type - The type to get the dependencies for.
   * @returns An array of dependency keys.
   */
  getDependencies(Type) {
    let dependencies = dependencyLookup.get(Type);
    if (dependencies === void 0) {
      const inject = Type.inject;
      if (inject === void 0) {
        const designParamtypes = DI.getDesignParamtypes(Type);
        const annotationParamtypes = DI.getAnnotationParamtypes(Type);
        if (designParamtypes === void 0) {
          if (annotationParamtypes === void 0) {
            const Proto = Object.getPrototypeOf(Type);
            if (typeof Proto === "function" && Proto !== Function.prototype) {
              dependencies = cloneArrayWithPossibleProps(DI.getDependencies(Proto));
            } else {
              dependencies = [];
            }
          } else {
            dependencies = cloneArrayWithPossibleProps(annotationParamtypes);
          }
        } else if (annotationParamtypes === void 0) {
          dependencies = cloneArrayWithPossibleProps(designParamtypes);
        } else {
          dependencies = cloneArrayWithPossibleProps(designParamtypes);
          let len = annotationParamtypes.length;
          let auAnnotationParamtype;
          for (let i2 = 0; i2 < len; ++i2) {
            auAnnotationParamtype = annotationParamtypes[i2];
            if (auAnnotationParamtype !== void 0) {
              dependencies[i2] = auAnnotationParamtype;
            }
          }
          const keys2 = Object.keys(annotationParamtypes);
          len = keys2.length;
          let key2;
          for (let i2 = 0; i2 < len; ++i2) {
            key2 = keys2[i2];
            if (!isArrayIndex(key2)) {
              dependencies[key2] = annotationParamtypes[key2];
            }
          }
        }
      } else {
        dependencies = cloneArrayWithPossibleProps(inject);
      }
      dependencyLookup.set(Type, dependencies);
    }
    return dependencies;
  },
  /**
   * Defines a property on a web component class. The value of this property will
   * be resolved from the dependency injection container responsible for the element
   * instance, based on where it is connected in the DOM.
   * @param target - The target to define the property on.
   * @param propertyName - The name of the property to define.
   * @param key - The dependency injection key.
   * @param respectConnection - Indicates whether or not to update the property value if the
   * hosting component is disconnected and then re-connected at a different location in the DOM.
   * @remarks
   * The respectConnection option is only applicable to elements that descend from FASTElement.
   */
  defineProperty(target2, propertyName, key2, respectConnection = false) {
    const diPropertyKey = `$di_${propertyName}`;
    Reflect.defineProperty(target2, propertyName, {
      get: function() {
        let value = this[diPropertyKey];
        if (value === void 0) {
          const container2 = this instanceof HTMLElement ? DI.findResponsibleContainer(this) : DI.getOrCreateDOMContainer();
          value = container2.get(key2);
          this[diPropertyKey] = value;
          if (respectConnection && this instanceof FASTElement) {
            const notifier = this.$fastController;
            const handleChange = () => {
              const newContainer = DI.findResponsibleContainer(this);
              const newValue = newContainer.get(key2);
              const oldValue = this[diPropertyKey];
              if (newValue !== oldValue) {
                this[diPropertyKey] = value;
                notifier.notify(propertyName);
              }
            };
            notifier.subscribe({ handleChange }, "isConnected");
          }
        }
        return value;
      }
    });
  },
  /**
   * Creates a dependency injection key.
   * @param nameConfigOrCallback - A friendly name for the key or a lambda that configures a
   * default resolution for the dependency.
   * @param configuror - If a friendly name was provided for the first parameter, then an optional
   * lambda that configures a default resolution for the dependency can be provided second.
   * @returns The created key.
   * @remarks
   * The created key can be used as a property decorator or constructor parameter decorator,
   * in addition to its standard use in an inject array or through direct container APIs.
   */
  createInterface(nameConfigOrCallback, configuror) {
    const configure = typeof nameConfigOrCallback === "function" ? nameConfigOrCallback : configuror;
    const friendlyName = typeof nameConfigOrCallback === "string" ? nameConfigOrCallback : nameConfigOrCallback && "friendlyName" in nameConfigOrCallback ? nameConfigOrCallback.friendlyName || defaultFriendlyName : defaultFriendlyName;
    const respectConnection = typeof nameConfigOrCallback === "string" ? false : nameConfigOrCallback && "respectConnection" in nameConfigOrCallback ? nameConfigOrCallback.respectConnection || false : false;
    const Interface = function(target2, property, index) {
      if (target2 == null || new.target !== void 0) {
        throw new Error(`No registration for interface: '${Interface.friendlyName}'`);
      }
      if (property) {
        DI.defineProperty(target2, property, Interface, respectConnection);
      } else {
        const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target2);
        annotationParamtypes[index] = Interface;
      }
    };
    Interface.$isInterface = true;
    Interface.friendlyName = friendlyName == null ? "(anonymous)" : friendlyName;
    if (configure != null) {
      Interface.register = function(container2, key2) {
        return configure(new ResolverBuilder(container2, key2 !== null && key2 !== void 0 ? key2 : Interface));
      };
    }
    Interface.toString = function toString2() {
      return `InterfaceSymbol<${Interface.friendlyName}>`;
    };
    return Interface;
  },
  /**
   * A decorator that specifies what to inject into its target.
   * @param dependencies - The dependencies to inject.
   * @returns The decorator to be applied to the target class.
   * @remarks
   * The decorator can be used to decorate a class, listing all of the classes dependencies.
   * Or it can be used to decorate a constructor paramter, indicating what to inject for that
   * parameter.
   * Or it can be used for a web component property, indicating what that property should resolve to.
   */
  inject(...dependencies) {
    return function(target2, key2, descriptor) {
      if (typeof descriptor === "number") {
        const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target2);
        const dep = dependencies[0];
        if (dep !== void 0) {
          annotationParamtypes[descriptor] = dep;
        }
      } else if (key2) {
        DI.defineProperty(target2, key2, dependencies[0]);
      } else {
        const annotationParamtypes = descriptor ? DI.getOrCreateAnnotationParamTypes(descriptor.value) : DI.getOrCreateAnnotationParamTypes(target2);
        let dep;
        for (let i2 = 0; i2 < dependencies.length; ++i2) {
          dep = dependencies[i2];
          if (dep !== void 0) {
            annotationParamtypes[i2] = dep;
          }
        }
      }
    };
  },
  /**
   * Registers the `target` class as a transient dependency; each time the dependency is resolved
   * a new instance will be created.
   *
   * @param target - The class / constructor function to register as transient.
   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
   *
   * @example
   * On an existing class
   * ```ts
   * class Foo { }
   * DI.transient(Foo);
   * ```
   *
   * @example
   * Inline declaration
   *
   * ```ts
   * const Foo = DI.transient(class { });
   * // Foo is now strongly typed with register
   * Foo.register(container);
   * ```
   *
   * @public
   */
  transient(target2) {
    target2.register = function register(container2) {
      const registration = Registration.transient(target2, target2);
      return registration.register(container2);
    };
    target2.registerInRequestor = false;
    return target2;
  },
  /**
   * Registers the `target` class as a singleton dependency; the class will only be created once. Each
   * consecutive time the dependency is resolved, the same instance will be returned.
   *
   * @param target - The class / constructor function to register as a singleton.
   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
   * @example
   * On an existing class
   * ```ts
   * class Foo { }
   * DI.singleton(Foo);
   * ```
   *
   * @example
   * Inline declaration
   * ```ts
   * const Foo = DI.singleton(class { });
   * // Foo is now strongly typed with register
   * Foo.register(container);
   * ```
   *
   * @public
   */
  singleton(target2, options = defaultSingletonOptions) {
    target2.register = function register(container2) {
      const registration = Registration.singleton(target2, target2);
      return registration.register(container2);
    };
    target2.registerInRequestor = options.scoped;
    return target2;
  }
});
const Container$8 = DI.createInterface("Container");
DI.inject;
const defaultSingletonOptions = { scoped: false };
class ResolverImpl {
  constructor(key2, strategy, state) {
    this.key = key2;
    this.strategy = strategy;
    this.state = state;
    this.resolving = false;
  }
  get $isResolver() {
    return true;
  }
  register(container2) {
    return container2.registerResolver(this.key, this);
  }
  resolve(handler, requestor) {
    switch (this.strategy) {
      case 0:
        return this.state;
      case 1: {
        if (this.resolving) {
          throw new Error(`Cyclic dependency found: ${this.state.name}`);
        }
        this.resolving = true;
        this.state = handler.getFactory(this.state).construct(requestor);
        this.strategy = 0;
        this.resolving = false;
        return this.state;
      }
      case 2: {
        const factory = handler.getFactory(this.state);
        if (factory === null) {
          throw new Error(`Resolver for ${String(this.key)} returned a null factory`);
        }
        return factory.construct(requestor);
      }
      case 3:
        return this.state(handler, requestor, this);
      case 4:
        return this.state[0].resolve(handler, requestor);
      case 5:
        return requestor.get(this.state);
      default:
        throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);
    }
  }
  getFactory(container2) {
    var _a, _b, _c;
    switch (this.strategy) {
      case 1:
      case 2:
        return container2.getFactory(this.state);
      case 5:
        return (_c = (_b = (_a = container2.getResolver(this.state)) === null || _a === void 0 ? void 0 : _a.getFactory) === null || _b === void 0 ? void 0 : _b.call(_a, container2)) !== null && _c !== void 0 ? _c : null;
      default:
        return null;
    }
  }
}
function containerGetKey(d) {
  return this.get(d);
}
function transformInstance(inst, transform) {
  return transform(inst);
}
class FactoryImpl {
  constructor(Type, dependencies) {
    this.Type = Type;
    this.dependencies = dependencies;
    this.transformers = null;
  }
  construct(container2, dynamicDependencies) {
    let instance;
    if (dynamicDependencies === void 0) {
      instance = new this.Type(...this.dependencies.map(containerGetKey, container2));
    } else {
      instance = new this.Type(...this.dependencies.map(containerGetKey, container2), ...dynamicDependencies);
    }
    if (this.transformers == null) {
      return instance;
    }
    return this.transformers.reduce(transformInstance, instance);
  }
  registerTransformer(transformer) {
    (this.transformers || (this.transformers = [])).push(transformer);
  }
}
const containerResolver = {
  $isResolver: true,
  resolve(handler, requestor) {
    return requestor;
  }
};
function isRegistry(obj) {
  return typeof obj.register === "function";
}
function isSelfRegistry(obj) {
  return isRegistry(obj) && typeof obj.registerInRequestor === "boolean";
}
function isRegisterInRequester(obj) {
  return isSelfRegistry(obj) && obj.registerInRequestor;
}
function isClass(obj) {
  return obj.prototype !== void 0;
}
const InstrinsicTypeNames = /* @__PURE__ */ new Set([
  "Array",
  "ArrayBuffer",
  "Boolean",
  "DataView",
  "Date",
  "Error",
  "EvalError",
  "Float32Array",
  "Float64Array",
  "Function",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Map",
  "Number",
  "Object",
  "Promise",
  "RangeError",
  "ReferenceError",
  "RegExp",
  "Set",
  "SharedArrayBuffer",
  "String",
  "SyntaxError",
  "TypeError",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "URIError",
  "WeakMap",
  "WeakSet"
]);
const DILocateParentEventType = "__DI_LOCATE_PARENT__";
const factories = /* @__PURE__ */ new Map();
class ContainerImpl {
  constructor(owner, config2) {
    this.owner = owner;
    this.config = config2;
    this._parent = void 0;
    this.registerDepth = 0;
    this.context = null;
    if (owner !== null) {
      owner.$$container$$ = this;
    }
    this.resolvers = /* @__PURE__ */ new Map();
    this.resolvers.set(Container$8, containerResolver);
    if (owner instanceof Node) {
      owner.addEventListener(DILocateParentEventType, (e) => {
        if (e.composedPath()[0] !== this.owner) {
          e.detail.container = this;
          e.stopImmediatePropagation();
        }
      });
    }
  }
  get parent() {
    if (this._parent === void 0) {
      this._parent = this.config.parentLocator(this.owner);
    }
    return this._parent;
  }
  get depth() {
    return this.parent === null ? 0 : this.parent.depth + 1;
  }
  get responsibleForOwnerRequests() {
    return this.config.responsibleForOwnerRequests;
  }
  registerWithContext(context, ...params2) {
    this.context = context;
    this.register(...params2);
    this.context = null;
    return this;
  }
  register(...params2) {
    if (++this.registerDepth === 100) {
      throw new Error("Unable to autoregister dependency");
    }
    let current;
    let keys2;
    let value;
    let j;
    let jj;
    const context = this.context;
    for (let i2 = 0, ii = params2.length; i2 < ii; ++i2) {
      current = params2[i2];
      if (!isObject$1(current)) {
        continue;
      }
      if (isRegistry(current)) {
        current.register(this, context);
      } else if (isClass(current)) {
        Registration.singleton(current, current).register(this);
      } else {
        keys2 = Object.keys(current);
        j = 0;
        jj = keys2.length;
        for (; j < jj; ++j) {
          value = current[keys2[j]];
          if (!isObject$1(value)) {
            continue;
          }
          if (isRegistry(value)) {
            value.register(this, context);
          } else {
            this.register(value);
          }
        }
      }
    }
    --this.registerDepth;
    return this;
  }
  registerResolver(key2, resolver) {
    validateKey(key2);
    const resolvers = this.resolvers;
    const result2 = resolvers.get(key2);
    if (result2 == null) {
      resolvers.set(key2, resolver);
    } else if (result2 instanceof ResolverImpl && result2.strategy === 4) {
      result2.state.push(resolver);
    } else {
      resolvers.set(key2, new ResolverImpl(key2, 4, [result2, resolver]));
    }
    return resolver;
  }
  registerTransformer(key2, transformer) {
    const resolver = this.getResolver(key2);
    if (resolver == null) {
      return false;
    }
    if (resolver.getFactory) {
      const factory = resolver.getFactory(this);
      if (factory == null) {
        return false;
      }
      factory.registerTransformer(transformer);
      return true;
    }
    return false;
  }
  getResolver(key2, autoRegister = true) {
    validateKey(key2);
    if (key2.resolve !== void 0) {
      return key2;
    }
    let current = this;
    let resolver;
    while (current != null) {
      resolver = current.resolvers.get(key2);
      if (resolver == null) {
        if (current.parent == null) {
          const handler = isRegisterInRequester(key2) ? this : current;
          return autoRegister ? this.jitRegister(key2, handler) : null;
        }
        current = current.parent;
      } else {
        return resolver;
      }
    }
    return null;
  }
  has(key2, searchAncestors = false) {
    return this.resolvers.has(key2) ? true : searchAncestors && this.parent != null ? this.parent.has(key2, true) : false;
  }
  get(key2) {
    validateKey(key2);
    if (key2.$isResolver) {
      return key2.resolve(this, this);
    }
    let current = this;
    let resolver;
    while (current != null) {
      resolver = current.resolvers.get(key2);
      if (resolver == null) {
        if (current.parent == null) {
          const handler = isRegisterInRequester(key2) ? this : current;
          resolver = this.jitRegister(key2, handler);
          return resolver.resolve(current, this);
        }
        current = current.parent;
      } else {
        return resolver.resolve(current, this);
      }
    }
    throw new Error(`Unable to resolve key: ${String(key2)}`);
  }
  getAll(key2, searchAncestors = false) {
    validateKey(key2);
    const requestor = this;
    let current = requestor;
    let resolver;
    if (searchAncestors) {
      let resolutions = emptyArray;
      while (current != null) {
        resolver = current.resolvers.get(key2);
        if (resolver != null) {
          resolutions = resolutions.concat(
            /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
            buildAllResponse(resolver, current, requestor)
          );
        }
        current = current.parent;
      }
      return resolutions;
    } else {
      while (current != null) {
        resolver = current.resolvers.get(key2);
        if (resolver == null) {
          current = current.parent;
          if (current == null) {
            return emptyArray;
          }
        } else {
          return buildAllResponse(resolver, current, requestor);
        }
      }
    }
    return emptyArray;
  }
  getFactory(Type) {
    let factory = factories.get(Type);
    if (factory === void 0) {
      if (isNativeFunction(Type)) {
        throw new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);
      }
      factories.set(Type, factory = new FactoryImpl(Type, DI.getDependencies(Type)));
    }
    return factory;
  }
  registerFactory(key2, factory) {
    factories.set(key2, factory);
  }
  createChild(config2) {
    return new ContainerImpl(null, Object.assign({}, this.config, config2, { parentLocator: () => this }));
  }
  jitRegister(keyAsValue, handler) {
    if (typeof keyAsValue !== "function") {
      throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this dependency?`);
    }
    if (InstrinsicTypeNames.has(keyAsValue.name)) {
      throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);
    }
    if (isRegistry(keyAsValue)) {
      const registrationResolver = keyAsValue.register(handler);
      if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {
        const newResolver = handler.resolvers.get(keyAsValue);
        if (newResolver != void 0) {
          return newResolver;
        }
        throw new Error("A valid resolver was not returned from the static register method");
      }
      return registrationResolver;
    } else if (keyAsValue.$isInterface) {
      throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);
    } else {
      const resolver = this.config.defaultResolver(keyAsValue, handler);
      handler.resolvers.set(keyAsValue, resolver);
      return resolver;
    }
  }
}
const cache = /* @__PURE__ */ new WeakMap();
function cacheCallbackResult(fun) {
  return function(handler, requestor, resolver) {
    if (cache.has(resolver)) {
      return cache.get(resolver);
    }
    const t = fun(handler, requestor, resolver);
    cache.set(resolver, t);
    return t;
  };
}
const Registration = Object.freeze({
  /**
   * Allows you to pass an instance.
   * Every time you request this {@link Key} you will get this instance back.
   *
   * @example
   * ```
   * Registration.instance(Foo, new Foo()));
   * ```
   *
   * @param key - The key to register the instance under.
   * @param value - The instance to return when the key is requested.
   */
  instance(key2, value) {
    return new ResolverImpl(key2, 0, value);
  },
  /**
   * Creates an instance from the class.
   * Every time you request this {@link Key} you will get the same one back.
   *
   * @example
   * ```
   * Registration.singleton(Foo, Foo);
   * ```
   *
   * @param key - The key to register the singleton under.
   * @param value - The class to instantiate as a singleton when first requested.
   */
  singleton(key2, value) {
    return new ResolverImpl(key2, 1, value);
  },
  /**
   * Creates an instance from a class.
   * Every time you request this {@link Key} you will get a new instance.
   *
   * @example
   * ```
   * Registration.instance(Foo, Foo);
   * ```
   *
   * @param key - The key to register the instance type under.
   * @param value - The class to instantiate each time the key is requested.
   */
  transient(key2, value) {
    return new ResolverImpl(key2, 2, value);
  },
  /**
   * Delegates to a callback function to provide the dependency.
   * Every time you request this {@link Key} the callback will be invoked to provide
   * the dependency.
   *
   * @example
   * ```
   * Registration.callback(Foo, () => new Foo());
   * Registration.callback(Bar, (c: Container) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key - The key to register the callback for.
   * @param callback - The function that is expected to return the dependency.
   */
  callback(key2, callback) {
    return new ResolverImpl(key2, 3, callback);
  },
  /**
   * Delegates to a callback function to provide the dependency and then caches the
   * dependency for future requests.
   *
   * @example
   * ```
   * Registration.cachedCallback(Foo, () => new Foo());
   * Registration.cachedCallback(Bar, (c: Container) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key - The key to register the callback for.
   * @param callback - The function that is expected to return the dependency.
   * @remarks
   * If you pass the same Registration to another container, the same cached value will be used.
   * Should all references to the resolver returned be removed, the cache will expire.
   */
  cachedCallback(key2, callback) {
    return new ResolverImpl(key2, 3, cacheCallbackResult(callback));
  },
  /**
   * Creates an alternate {@link Key} to retrieve an instance by.
   *
   * @example
   * ```
   * Register.singleton(Foo, Foo)
   * Register.aliasTo(Foo, MyFoos);
   *
   * container.getAll(MyFoos) // contains an instance of Foo
   * ```
   *
   * @param originalKey - The original key that has been registered.
   * @param aliasKey - The alias to the original key.
   */
  aliasTo(originalKey, aliasKey) {
    return new ResolverImpl(aliasKey, 5, originalKey);
  }
});
function validateKey(key2) {
  if (key2 === null || key2 === void 0) {
    throw new Error("key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?");
  }
}
function buildAllResponse(resolver, handler, requestor) {
  if (resolver instanceof ResolverImpl && resolver.strategy === 4) {
    const state = resolver.state;
    let i2 = state.length;
    const results = new Array(i2);
    while (i2--) {
      results[i2] = state[i2].resolve(handler, requestor);
    }
    return results;
  }
  return [resolver.resolve(handler, requestor)];
}
const defaultFriendlyName = "(anonymous)";
function isObject$1(value) {
  return typeof value === "object" && value !== null || typeof value === "function";
}
const isNativeFunction = /* @__PURE__ */ function() {
  const lookup = /* @__PURE__ */ new WeakMap();
  let isNative = false;
  let sourceText = "";
  let i2 = 0;
  return function(fn) {
    isNative = lookup.get(fn);
    if (isNative === void 0) {
      sourceText = fn.toString();
      i2 = sourceText.length;
      isNative = // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string
      i2 >= 29 && // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.
      i2 <= 100 && // This whole heuristic *could* be tricked by a comment. Do we need to care about that?
      sourceText.charCodeAt(i2 - 1) === 125 && // }
      // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.
      sourceText.charCodeAt(i2 - 2) <= 32 && // whitespace
      sourceText.charCodeAt(i2 - 3) === 93 && // ]
      sourceText.charCodeAt(i2 - 4) === 101 && // e
      sourceText.charCodeAt(i2 - 5) === 100 && // d
      sourceText.charCodeAt(i2 - 6) === 111 && // o
      sourceText.charCodeAt(i2 - 7) === 99 && // c
      sourceText.charCodeAt(i2 - 8) === 32 && //
      sourceText.charCodeAt(i2 - 9) === 101 && // e
      sourceText.charCodeAt(i2 - 10) === 118 && // v
      sourceText.charCodeAt(i2 - 11) === 105 && // i
      sourceText.charCodeAt(i2 - 12) === 116 && // t
      sourceText.charCodeAt(i2 - 13) === 97 && // a
      sourceText.charCodeAt(i2 - 14) === 110 && // n
      sourceText.charCodeAt(i2 - 15) === 88;
      lookup.set(fn, isNative);
    }
    return isNative;
  };
}();
const isNumericLookup = {};
function isArrayIndex(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result2 = isNumericLookup[value];
      if (result2 !== void 0) {
        return result2;
      }
      const length2 = value.length;
      if (length2 === 0) {
        return isNumericLookup[value] = false;
      }
      let ch = 0;
      for (let i2 = 0; i2 < length2; ++i2) {
        ch = value.charCodeAt(i2);
        if (i2 === 0 && ch === 48 && length2 > 1 || ch < 48 || ch > 57) {
          return isNumericLookup[value] = false;
        }
      }
      return isNumericLookup[value] = true;
    }
    default:
      return false;
  }
}
function presentationKeyFromTag(tagName) {
  return `${tagName.toLowerCase()}:presentation`;
}
const presentationRegistry = /* @__PURE__ */ new Map();
const ComponentPresentation = Object.freeze({
  /**
   * Defines a component presentation for an element.
   * @param tagName - The element name to define the presentation for.
   * @param presentation - The presentation that will be applied to matching elements.
   * @param container - The dependency injection container to register the configuration in.
   * @public
   */
  define(tagName, presentation, container2) {
    const key2 = presentationKeyFromTag(tagName);
    const existing = presentationRegistry.get(key2);
    if (existing === void 0) {
      presentationRegistry.set(key2, presentation);
    } else {
      presentationRegistry.set(key2, false);
    }
    container2.register(Registration.instance(key2, presentation));
  },
  /**
   * Finds a component presentation for the specified element name,
   * searching the DOM hierarchy starting from the provided element.
   * @param tagName - The name of the element to locate the presentation for.
   * @param element - The element to begin the search from.
   * @returns The component presentation or null if none is found.
   * @public
   */
  forTag(tagName, element) {
    const key2 = presentationKeyFromTag(tagName);
    const existing = presentationRegistry.get(key2);
    if (existing === false) {
      const container2 = DI.findResponsibleContainer(element);
      return container2.get(key2);
    }
    return existing || null;
  }
});
class DefaultComponentPresentation {
  /**
   * Creates an instance of DefaultComponentPresentation.
   * @param template - The template to apply to the element.
   * @param styles - The styles to apply to the element.
   * @public
   */
  constructor(template, styles) {
    this.template = template || null;
    this.styles = styles === void 0 ? null : Array.isArray(styles) ? ElementStyles.create(styles) : styles instanceof ElementStyles ? styles : ElementStyles.create([styles]);
  }
  /**
   * Applies the presentation details to the specified element.
   * @param element - The element to apply the presentation details to.
   * @public
   */
  applyTo(element) {
    const controller = element.$fastController;
    if (controller.template === null) {
      controller.template = this.template;
    }
    if (controller.styles === null) {
      controller.styles = this.styles;
    }
  }
}
class FoundationElement extends FASTElement {
  constructor() {
    super(...arguments);
    this._presentation = void 0;
  }
  /**
   * A property which resolves the ComponentPresentation instance
   * for the current component.
   * @public
   */
  get $presentation() {
    if (this._presentation === void 0) {
      this._presentation = ComponentPresentation.forTag(this.tagName, this);
    }
    return this._presentation;
  }
  templateChanged() {
    if (this.template !== void 0) {
      this.$fastController.template = this.template;
    }
  }
  stylesChanged() {
    if (this.styles !== void 0) {
      this.$fastController.styles = this.styles;
    }
  }
  /**
   * The connected callback for this FASTElement.
   * @remarks
   * This method is invoked by the platform whenever this FoundationElement
   * becomes connected to the document.
   * @public
   */
  connectedCallback() {
    if (this.$presentation !== null) {
      this.$presentation.applyTo(this);
    }
    super.connectedCallback();
  }
  /**
   * Defines an element registry function with a set of element definition defaults.
   * @param elementDefinition - The definition of the element to create the registry
   * function for.
   * @public
   */
  static compose(elementDefinition) {
    return (overrideDefinition = {}) => new FoundationElementRegistry(this === FoundationElement ? class extends FoundationElement {
    } : this, elementDefinition, overrideDefinition);
  }
}
__decorate([
  observable
], FoundationElement.prototype, "template", void 0);
__decorate([
  observable
], FoundationElement.prototype, "styles", void 0);
function resolveOption(option, context, definition) {
  if (typeof option === "function") {
    return option(context, definition);
  }
  return option;
}
class FoundationElementRegistry {
  constructor(type, elementDefinition, overrideDefinition) {
    this.type = type;
    this.elementDefinition = elementDefinition;
    this.overrideDefinition = overrideDefinition;
    this.definition = Object.assign(Object.assign({}, this.elementDefinition), this.overrideDefinition);
  }
  register(container2, context) {
    const definition = this.definition;
    const overrideDefinition = this.overrideDefinition;
    const prefix = definition.prefix || context.elementPrefix;
    const name2 = `${prefix}-${definition.baseName}`;
    context.tryDefineElement({
      name: name2,
      type: this.type,
      baseClass: this.elementDefinition.baseClass,
      callback: (x2) => {
        const presentation = new DefaultComponentPresentation(resolveOption(definition.template, x2, definition), resolveOption(definition.styles, x2, definition));
        x2.definePresentation(presentation);
        let shadowOptions = resolveOption(definition.shadowOptions, x2, definition);
        if (x2.shadowRootMode) {
          if (shadowOptions) {
            if (!overrideDefinition.shadowOptions) {
              shadowOptions.mode = x2.shadowRootMode;
            }
          } else if (shadowOptions !== null) {
            shadowOptions = { mode: x2.shadowRootMode };
          }
        }
        x2.defineElement({
          elementOptions: resolveOption(definition.elementOptions, x2, definition),
          shadowOptions,
          attributes: resolveOption(definition.attributes, x2, definition)
        });
      }
    });
  }
}
function applyMixins(derivedCtor, ...baseCtors) {
  const derivedAttributes = AttributeConfiguration.locate(derivedCtor);
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name2) => {
      if (name2 !== "constructor") {
        Object.defineProperty(
          derivedCtor.prototype,
          name2,
          /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
          Object.getOwnPropertyDescriptor(baseCtor.prototype, name2)
        );
      }
    });
    const baseAttributes = AttributeConfiguration.locate(baseCtor);
    baseAttributes.forEach((x2) => derivedAttributes.push(x2));
  });
}
const Orientation = {
  horizontal: "horizontal",
  vertical: "vertical"
};
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function getNonce() {
  const node2 = document.querySelector('meta[property="csp-nonce"]');
  if (node2) {
    return node2.getAttribute("content");
  } else {
    return null;
  }
}
let _canUseFocusVisible;
function canUseFocusVisible() {
  if (typeof _canUseFocusVisible === "boolean") {
    return _canUseFocusVisible;
  }
  if (!canUseDOM()) {
    _canUseFocusVisible = false;
    return _canUseFocusVisible;
  }
  const styleElement = document.createElement("style");
  const styleNonce = getNonce();
  if (styleNonce !== null) {
    styleElement.setAttribute("nonce", styleNonce);
  }
  document.head.appendChild(styleElement);
  try {
    styleElement.sheet.insertRule("foo:focus-visible {color:inherit}", 0);
    _canUseFocusVisible = true;
  } catch (e) {
    _canUseFocusVisible = false;
  } finally {
    document.head.removeChild(styleElement);
  }
  return _canUseFocusVisible;
}
var KeyCodes;
(function(KeyCodes2) {
  KeyCodes2[KeyCodes2["alt"] = 18] = "alt";
  KeyCodes2[KeyCodes2["arrowDown"] = 40] = "arrowDown";
  KeyCodes2[KeyCodes2["arrowLeft"] = 37] = "arrowLeft";
  KeyCodes2[KeyCodes2["arrowRight"] = 39] = "arrowRight";
  KeyCodes2[KeyCodes2["arrowUp"] = 38] = "arrowUp";
  KeyCodes2[KeyCodes2["back"] = 8] = "back";
  KeyCodes2[KeyCodes2["backSlash"] = 220] = "backSlash";
  KeyCodes2[KeyCodes2["break"] = 19] = "break";
  KeyCodes2[KeyCodes2["capsLock"] = 20] = "capsLock";
  KeyCodes2[KeyCodes2["closeBracket"] = 221] = "closeBracket";
  KeyCodes2[KeyCodes2["colon"] = 186] = "colon";
  KeyCodes2[KeyCodes2["colon2"] = 59] = "colon2";
  KeyCodes2[KeyCodes2["comma"] = 188] = "comma";
  KeyCodes2[KeyCodes2["ctrl"] = 17] = "ctrl";
  KeyCodes2[KeyCodes2["delete"] = 46] = "delete";
  KeyCodes2[KeyCodes2["end"] = 35] = "end";
  KeyCodes2[KeyCodes2["enter"] = 13] = "enter";
  KeyCodes2[KeyCodes2["equals"] = 187] = "equals";
  KeyCodes2[KeyCodes2["equals2"] = 61] = "equals2";
  KeyCodes2[KeyCodes2["equals3"] = 107] = "equals3";
  KeyCodes2[KeyCodes2["escape"] = 27] = "escape";
  KeyCodes2[KeyCodes2["forwardSlash"] = 191] = "forwardSlash";
  KeyCodes2[KeyCodes2["function1"] = 112] = "function1";
  KeyCodes2[KeyCodes2["function10"] = 121] = "function10";
  KeyCodes2[KeyCodes2["function11"] = 122] = "function11";
  KeyCodes2[KeyCodes2["function12"] = 123] = "function12";
  KeyCodes2[KeyCodes2["function2"] = 113] = "function2";
  KeyCodes2[KeyCodes2["function3"] = 114] = "function3";
  KeyCodes2[KeyCodes2["function4"] = 115] = "function4";
  KeyCodes2[KeyCodes2["function5"] = 116] = "function5";
  KeyCodes2[KeyCodes2["function6"] = 117] = "function6";
  KeyCodes2[KeyCodes2["function7"] = 118] = "function7";
  KeyCodes2[KeyCodes2["function8"] = 119] = "function8";
  KeyCodes2[KeyCodes2["function9"] = 120] = "function9";
  KeyCodes2[KeyCodes2["home"] = 36] = "home";
  KeyCodes2[KeyCodes2["insert"] = 45] = "insert";
  KeyCodes2[KeyCodes2["menu"] = 93] = "menu";
  KeyCodes2[KeyCodes2["minus"] = 189] = "minus";
  KeyCodes2[KeyCodes2["minus2"] = 109] = "minus2";
  KeyCodes2[KeyCodes2["numLock"] = 144] = "numLock";
  KeyCodes2[KeyCodes2["numPad0"] = 96] = "numPad0";
  KeyCodes2[KeyCodes2["numPad1"] = 97] = "numPad1";
  KeyCodes2[KeyCodes2["numPad2"] = 98] = "numPad2";
  KeyCodes2[KeyCodes2["numPad3"] = 99] = "numPad3";
  KeyCodes2[KeyCodes2["numPad4"] = 100] = "numPad4";
  KeyCodes2[KeyCodes2["numPad5"] = 101] = "numPad5";
  KeyCodes2[KeyCodes2["numPad6"] = 102] = "numPad6";
  KeyCodes2[KeyCodes2["numPad7"] = 103] = "numPad7";
  KeyCodes2[KeyCodes2["numPad8"] = 104] = "numPad8";
  KeyCodes2[KeyCodes2["numPad9"] = 105] = "numPad9";
  KeyCodes2[KeyCodes2["numPadDivide"] = 111] = "numPadDivide";
  KeyCodes2[KeyCodes2["numPadDot"] = 110] = "numPadDot";
  KeyCodes2[KeyCodes2["numPadMinus"] = 109] = "numPadMinus";
  KeyCodes2[KeyCodes2["numPadMultiply"] = 106] = "numPadMultiply";
  KeyCodes2[KeyCodes2["numPadPlus"] = 107] = "numPadPlus";
  KeyCodes2[KeyCodes2["openBracket"] = 219] = "openBracket";
  KeyCodes2[KeyCodes2["pageDown"] = 34] = "pageDown";
  KeyCodes2[KeyCodes2["pageUp"] = 33] = "pageUp";
  KeyCodes2[KeyCodes2["period"] = 190] = "period";
  KeyCodes2[KeyCodes2["print"] = 44] = "print";
  KeyCodes2[KeyCodes2["quote"] = 222] = "quote";
  KeyCodes2[KeyCodes2["scrollLock"] = 145] = "scrollLock";
  KeyCodes2[KeyCodes2["shift"] = 16] = "shift";
  KeyCodes2[KeyCodes2["space"] = 32] = "space";
  KeyCodes2[KeyCodes2["tab"] = 9] = "tab";
  KeyCodes2[KeyCodes2["tilde"] = 192] = "tilde";
  KeyCodes2[KeyCodes2["windowsLeft"] = 91] = "windowsLeft";
  KeyCodes2[KeyCodes2["windowsOpera"] = 219] = "windowsOpera";
  KeyCodes2[KeyCodes2["windowsRight"] = 92] = "windowsRight";
})(KeyCodes || (KeyCodes = {}));
const keyArrowDown = "ArrowDown";
const keyArrowLeft = "ArrowLeft";
const keyArrowRight = "ArrowRight";
const keyArrowUp = "ArrowUp";
const keyEnter = "Enter";
const ArrowKeys = {
  ArrowDown: keyArrowDown,
  ArrowLeft: keyArrowLeft,
  ArrowRight: keyArrowRight,
  ArrowUp: keyArrowUp
};
var Direction$1;
(function(Direction2) {
  Direction2["ltr"] = "ltr";
  Direction2["rtl"] = "rtl";
})(Direction$1 || (Direction$1 = {}));
function limit(min2, max2, value) {
  return Math.min(Math.max(value, min2), max2);
}
var SystemColors;
(function(SystemColors2) {
  SystemColors2["Canvas"] = "Canvas";
  SystemColors2["CanvasText"] = "CanvasText";
  SystemColors2["LinkText"] = "LinkText";
  SystemColors2["VisitedText"] = "VisitedText";
  SystemColors2["ActiveText"] = "ActiveText";
  SystemColors2["ButtonFace"] = "ButtonFace";
  SystemColors2["ButtonText"] = "ButtonText";
  SystemColors2["Field"] = "Field";
  SystemColors2["FieldText"] = "FieldText";
  SystemColors2["Highlight"] = "Highlight";
  SystemColors2["HighlightText"] = "HighlightText";
  SystemColors2["GrayText"] = "GrayText";
})(SystemColors || (SystemColors = {}));
class ARIAGlobalStatesAndProperties {
}
__decorate([
  attr({ attribute: "aria-atomic" })
], ARIAGlobalStatesAndProperties.prototype, "ariaAtomic", void 0);
__decorate([
  attr({ attribute: "aria-busy" })
], ARIAGlobalStatesAndProperties.prototype, "ariaBusy", void 0);
__decorate([
  attr({ attribute: "aria-controls" })
], ARIAGlobalStatesAndProperties.prototype, "ariaControls", void 0);
__decorate([
  attr({ attribute: "aria-current" })
], ARIAGlobalStatesAndProperties.prototype, "ariaCurrent", void 0);
__decorate([
  attr({ attribute: "aria-describedby" })
], ARIAGlobalStatesAndProperties.prototype, "ariaDescribedby", void 0);
__decorate([
  attr({ attribute: "aria-details" })
], ARIAGlobalStatesAndProperties.prototype, "ariaDetails", void 0);
__decorate([
  attr({ attribute: "aria-disabled" })
], ARIAGlobalStatesAndProperties.prototype, "ariaDisabled", void 0);
__decorate([
  attr({ attribute: "aria-errormessage" })
], ARIAGlobalStatesAndProperties.prototype, "ariaErrormessage", void 0);
__decorate([
  attr({ attribute: "aria-flowto" })
], ARIAGlobalStatesAndProperties.prototype, "ariaFlowto", void 0);
__decorate([
  attr({ attribute: "aria-haspopup" })
], ARIAGlobalStatesAndProperties.prototype, "ariaHaspopup", void 0);
__decorate([
  attr({ attribute: "aria-hidden" })
], ARIAGlobalStatesAndProperties.prototype, "ariaHidden", void 0);
__decorate([
  attr({ attribute: "aria-invalid" })
], ARIAGlobalStatesAndProperties.prototype, "ariaInvalid", void 0);
__decorate([
  attr({ attribute: "aria-keyshortcuts" })
], ARIAGlobalStatesAndProperties.prototype, "ariaKeyshortcuts", void 0);
__decorate([
  attr({ attribute: "aria-label" })
], ARIAGlobalStatesAndProperties.prototype, "ariaLabel", void 0);
__decorate([
  attr({ attribute: "aria-labelledby" })
], ARIAGlobalStatesAndProperties.prototype, "ariaLabelledby", void 0);
__decorate([
  attr({ attribute: "aria-live" })
], ARIAGlobalStatesAndProperties.prototype, "ariaLive", void 0);
__decorate([
  attr({ attribute: "aria-owns" })
], ARIAGlobalStatesAndProperties.prototype, "ariaOwns", void 0);
__decorate([
  attr({ attribute: "aria-relevant" })
], ARIAGlobalStatesAndProperties.prototype, "ariaRelevant", void 0);
__decorate([
  attr({ attribute: "aria-roledescription" })
], ARIAGlobalStatesAndProperties.prototype, "ariaRoledescription", void 0);
const getDirection = (rootNode) => {
  const dirNode = rootNode.closest("[dir]");
  return dirNode !== null && dirNode.dir === "rtl" ? Direction$1.rtl : Direction$1.ltr;
};
const buttonTemplate = (context, definition) => html`
    <button
        class="control"
        part="control"
        ?autofocus="${(x2) => x2.autofocus}"
        ?disabled="${(x2) => x2.disabled}"
        form="${(x2) => x2.formId}"
        formaction="${(x2) => x2.formaction}"
        formenctype="${(x2) => x2.formenctype}"
        formmethod="${(x2) => x2.formmethod}"
        formnovalidate="${(x2) => x2.formnovalidate}"
        formtarget="${(x2) => x2.formtarget}"
        name="${(x2) => x2.name}"
        type="${(x2) => x2.type}"
        value="${(x2) => x2.value}"
        aria-atomic="${(x2) => x2.ariaAtomic}"
        aria-busy="${(x2) => x2.ariaBusy}"
        aria-controls="${(x2) => x2.ariaControls}"
        aria-current="${(x2) => x2.ariaCurrent}"
        aria-describedby="${(x2) => x2.ariaDescribedby}"
        aria-details="${(x2) => x2.ariaDetails}"
        aria-disabled="${(x2) => x2.ariaDisabled}"
        aria-errormessage="${(x2) => x2.ariaErrormessage}"
        aria-expanded="${(x2) => x2.ariaExpanded}"
        aria-flowto="${(x2) => x2.ariaFlowto}"
        aria-haspopup="${(x2) => x2.ariaHaspopup}"
        aria-hidden="${(x2) => x2.ariaHidden}"
        aria-invalid="${(x2) => x2.ariaInvalid}"
        aria-keyshortcuts="${(x2) => x2.ariaKeyshortcuts}"
        aria-label="${(x2) => x2.ariaLabel}"
        aria-labelledby="${(x2) => x2.ariaLabelledby}"
        aria-live="${(x2) => x2.ariaLive}"
        aria-owns="${(x2) => x2.ariaOwns}"
        aria-pressed="${(x2) => x2.ariaPressed}"
        aria-relevant="${(x2) => x2.ariaRelevant}"
        aria-roledescription="${(x2) => x2.ariaRoledescription}"
        ${ref("control")}
    >
        ${startSlotTemplate(context, definition)}
        <span class="content" part="content">
            <slot ${slotted("defaultSlottedContent")}></slot>
        </span>
        ${endSlotTemplate(context, definition)}
    </button>
`;
const proxySlotName = "form-associated-proxy";
const ElementInternalsKey = "ElementInternals";
const supportsElementInternals = ElementInternalsKey in window && "setFormValue" in window[ElementInternalsKey].prototype;
const InternalsMap = /* @__PURE__ */ new WeakMap();
function FormAssociated(BaseCtor) {
  const C2 = class extends BaseCtor {
    constructor(...args) {
      super(...args);
      this.dirtyValue = false;
      this.disabled = false;
      this.proxyEventsToBlock = ["change", "click"];
      this.proxyInitialized = false;
      this.required = false;
      this.initialValue = this.initialValue || "";
      if (!this.elementInternals) {
        this.formResetCallback = this.formResetCallback.bind(this);
      }
    }
    /**
     * Must evaluate to true to enable elementInternals.
     * Feature detects API support and resolve respectively
     *
     * @internal
     */
    static get formAssociated() {
      return supportsElementInternals;
    }
    /**
     * Returns the validity state of the element
     *
     * @alpha
     */
    get validity() {
      return this.elementInternals ? this.elementInternals.validity : this.proxy.validity;
    }
    /**
     * Retrieve a reference to the associated form.
     * Returns null if not associated to any form.
     *
     * @alpha
     */
    get form() {
      return this.elementInternals ? this.elementInternals.form : this.proxy.form;
    }
    /**
     * Retrieve the localized validation message,
     * or custom validation message if set.
     *
     * @alpha
     */
    get validationMessage() {
      return this.elementInternals ? this.elementInternals.validationMessage : this.proxy.validationMessage;
    }
    /**
     * Whether the element will be validated when the
     * form is submitted
     */
    get willValidate() {
      return this.elementInternals ? this.elementInternals.willValidate : this.proxy.willValidate;
    }
    /**
     * A reference to all associated label elements
     */
    get labels() {
      if (this.elementInternals) {
        return Object.freeze(Array.from(this.elementInternals.labels));
      } else if (this.proxy instanceof HTMLElement && this.proxy.ownerDocument && this.id) {
        const parentLabels = this.proxy.labels;
        const forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`));
        const labels = parentLabels ? forLabels.concat(Array.from(parentLabels)) : forLabels;
        return Object.freeze(labels);
      } else {
        return emptyArray;
      }
    }
    /**
     * Invoked when the `value` property changes
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `valueChanged` method
     * They must be sure to invoke `super.valueChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    valueChanged(previous, next) {
      this.dirtyValue = true;
      if (this.proxy instanceof HTMLElement) {
        this.proxy.value = this.value;
      }
      this.currentValue = this.value;
      this.setFormValue(this.value);
      this.validate();
    }
    currentValueChanged() {
      this.value = this.currentValue;
    }
    /**
     * Invoked when the `initialValue` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `initialValueChanged` method
     * They must be sure to invoke `super.initialValueChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    initialValueChanged(previous, next) {
      if (!this.dirtyValue) {
        this.value = this.initialValue;
        this.dirtyValue = false;
      }
    }
    /**
     * Invoked when the `disabled` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `disabledChanged` method
     * They must be sure to invoke `super.disabledChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    disabledChanged(previous, next) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.disabled = this.disabled;
      }
      DOM.queueUpdate(() => this.classList.toggle("disabled", this.disabled));
    }
    /**
     * Invoked when the `name` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `nameChanged` method
     * They must be sure to invoke `super.nameChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    nameChanged(previous, next) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.name = this.name;
      }
    }
    /**
     * Invoked when the `required` property changes
     *
     * @param previous - the previous value
     * @param next - the new value
     *
     * @remarks
     * If elements extending `FormAssociated` implement a `requiredChanged` method
     * They must be sure to invoke `super.requiredChanged(previous, next)` to ensure
     * proper functioning of `FormAssociated`
     */
    requiredChanged(prev, next) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.required = this.required;
      }
      DOM.queueUpdate(() => this.classList.toggle("required", this.required));
      this.validate();
    }
    /**
     * The element internals object. Will only exist
     * in browsers supporting the attachInternals API
     */
    get elementInternals() {
      if (!supportsElementInternals) {
        return null;
      }
      let internals = InternalsMap.get(this);
      if (!internals) {
        internals = this.attachInternals();
        InternalsMap.set(this, internals);
      }
      return internals;
    }
    /**
     * @internal
     */
    connectedCallback() {
      super.connectedCallback();
      this.addEventListener("keypress", this._keypressHandler);
      if (!this.value) {
        this.value = this.initialValue;
        this.dirtyValue = false;
      }
      if (!this.elementInternals) {
        this.attachProxy();
        if (this.form) {
          this.form.addEventListener("reset", this.formResetCallback);
        }
      }
    }
    /**
     * @internal
     */
    disconnectedCallback() {
      super.disconnectedCallback();
      this.proxyEventsToBlock.forEach((name2) => this.proxy.removeEventListener(name2, this.stopPropagation));
      if (!this.elementInternals && this.form) {
        this.form.removeEventListener("reset", this.formResetCallback);
      }
    }
    /**
     * Return the current validity of the element.
     */
    checkValidity() {
      return this.elementInternals ? this.elementInternals.checkValidity() : this.proxy.checkValidity();
    }
    /**
     * Return the current validity of the element.
     * If false, fires an invalid event at the element.
     */
    reportValidity() {
      return this.elementInternals ? this.elementInternals.reportValidity() : this.proxy.reportValidity();
    }
    /**
     * Set the validity of the control. In cases when the elementInternals object is not
     * available (and the proxy element is used to report validity), this function will
     * do nothing unless a message is provided, at which point the setCustomValidity method
     * of the proxy element will be invoked with the provided message.
     * @param flags - Validity flags
     * @param message - Optional message to supply
     * @param anchor - Optional element used by UA to display an interactive validation UI
     */
    setValidity(flags, message, anchor) {
      if (this.elementInternals) {
        this.elementInternals.setValidity(flags, message, anchor);
      } else if (typeof message === "string") {
        this.proxy.setCustomValidity(message);
      }
    }
    /**
     * Invoked when a connected component's form or fieldset has its disabled
     * state changed.
     * @param disabled - the disabled value of the form / fieldset
     */
    formDisabledCallback(disabled) {
      this.disabled = disabled;
    }
    formResetCallback() {
      this.value = this.initialValue;
      this.dirtyValue = false;
    }
    /**
     * Attach the proxy element to the DOM
     */
    attachProxy() {
      var _a;
      if (!this.proxyInitialized) {
        this.proxyInitialized = true;
        this.proxy.style.display = "none";
        this.proxyEventsToBlock.forEach((name2) => this.proxy.addEventListener(name2, this.stopPropagation));
        this.proxy.disabled = this.disabled;
        this.proxy.required = this.required;
        if (typeof this.name === "string") {
          this.proxy.name = this.name;
        }
        if (typeof this.value === "string") {
          this.proxy.value = this.value;
        }
        this.proxy.setAttribute("slot", proxySlotName);
        this.proxySlot = document.createElement("slot");
        this.proxySlot.setAttribute("name", proxySlotName);
      }
      (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.appendChild(this.proxySlot);
      this.appendChild(this.proxy);
    }
    /**
     * Detach the proxy element from the DOM
     */
    detachProxy() {
      var _a;
      this.removeChild(this.proxy);
      (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.removeChild(this.proxySlot);
    }
    /** {@inheritDoc (FormAssociated:interface).validate} */
    validate(anchor) {
      if (this.proxy instanceof HTMLElement) {
        this.setValidity(this.proxy.validity, this.proxy.validationMessage, anchor);
      }
    }
    /**
     * Associates the provided value (and optional state) with the parent form.
     * @param value - The value to set
     * @param state - The state object provided to during session restores and when autofilling.
     */
    setFormValue(value, state) {
      if (this.elementInternals) {
        this.elementInternals.setFormValue(value, state || value);
      }
    }
    _keypressHandler(e) {
      switch (e.key) {
        case keyEnter:
          if (this.form instanceof HTMLFormElement) {
            const defaultButton = this.form.querySelector("[type=submit]");
            defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();
          }
          break;
      }
    }
    /**
     * Used to stop propagation of proxy element events
     * @param e - Event object
     */
    stopPropagation(e) {
      e.stopPropagation();
    }
  };
  attr({ mode: "boolean" })(C2.prototype, "disabled");
  attr({ mode: "fromView", attribute: "value" })(C2.prototype, "initialValue");
  attr({ attribute: "current-value" })(C2.prototype, "currentValue");
  attr(C2.prototype, "name");
  attr({ mode: "boolean" })(C2.prototype, "required");
  observable(C2.prototype, "value");
  return C2;
}
class _Button extends FoundationElement {
}
class FormAssociatedButton extends FormAssociated(_Button) {
  constructor() {
    super(...arguments);
    this.proxy = document.createElement("input");
  }
}
let Button$1 = class Button2 extends FormAssociatedButton {
  constructor() {
    super(...arguments);
    this.handleClick = (e) => {
      var _a;
      if (this.disabled && ((_a = this.defaultSlottedContent) === null || _a === void 0 ? void 0 : _a.length) <= 1) {
        e.stopPropagation();
      }
    };
    this.handleSubmission = () => {
      if (!this.form) {
        return;
      }
      const attached = this.proxy.isConnected;
      if (!attached) {
        this.attachProxy();
      }
      typeof this.form.requestSubmit === "function" ? this.form.requestSubmit(this.proxy) : this.proxy.click();
      if (!attached) {
        this.detachProxy();
      }
    };
    this.handleFormReset = () => {
      var _a;
      (_a = this.form) === null || _a === void 0 ? void 0 : _a.reset();
    };
    this.handleUnsupportedDelegatesFocus = () => {
      var _a;
      if (window.ShadowRoot && !window.ShadowRoot.prototype.hasOwnProperty("delegatesFocus") && ((_a = this.$fastController.definition.shadowOptions) === null || _a === void 0 ? void 0 : _a.delegatesFocus)) {
        this.focus = () => {
          this.control.focus();
        };
      }
    };
  }
  formactionChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.formAction = this.formaction;
    }
  }
  formenctypeChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.formEnctype = this.formenctype;
    }
  }
  formmethodChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.formMethod = this.formmethod;
    }
  }
  formnovalidateChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.formNoValidate = this.formnovalidate;
    }
  }
  formtargetChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.formTarget = this.formtarget;
    }
  }
  typeChanged(previous, next) {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.type = this.type;
    }
    next === "submit" && this.addEventListener("click", this.handleSubmission);
    previous === "submit" && this.removeEventListener("click", this.handleSubmission);
    next === "reset" && this.addEventListener("click", this.handleFormReset);
    previous === "reset" && this.removeEventListener("click", this.handleFormReset);
  }
  /** {@inheritDoc (FormAssociated:interface).validate} */
  validate() {
    super.validate(this.control);
  }
  /**
   * @internal
   */
  connectedCallback() {
    var _a;
    super.connectedCallback();
    this.proxy.setAttribute("type", this.type);
    this.handleUnsupportedDelegatesFocus();
    const elements2 = Array.from((_a = this.control) === null || _a === void 0 ? void 0 : _a.children);
    if (elements2) {
      elements2.forEach((span) => {
        span.addEventListener("click", this.handleClick);
      });
    }
  }
  /**
   * @internal
   */
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    const elements2 = Array.from((_a = this.control) === null || _a === void 0 ? void 0 : _a.children);
    if (elements2) {
      elements2.forEach((span) => {
        span.removeEventListener("click", this.handleClick);
      });
    }
  }
};
__decorate([
  attr({ mode: "boolean" })
], Button$1.prototype, "autofocus", void 0);
__decorate([
  attr({ attribute: "form" })
], Button$1.prototype, "formId", void 0);
__decorate([
  attr
], Button$1.prototype, "formaction", void 0);
__decorate([
  attr
], Button$1.prototype, "formenctype", void 0);
__decorate([
  attr
], Button$1.prototype, "formmethod", void 0);
__decorate([
  attr({ mode: "boolean" })
], Button$1.prototype, "formnovalidate", void 0);
__decorate([
  attr
], Button$1.prototype, "formtarget", void 0);
__decorate([
  attr
], Button$1.prototype, "type", void 0);
__decorate([
  observable
], Button$1.prototype, "defaultSlottedContent", void 0);
class DelegatesARIAButton {
}
__decorate([
  attr({ attribute: "aria-expanded" })
], DelegatesARIAButton.prototype, "ariaExpanded", void 0);
__decorate([
  attr({ attribute: "aria-pressed" })
], DelegatesARIAButton.prototype, "ariaPressed", void 0);
applyMixins(DelegatesARIAButton, ARIAGlobalStatesAndProperties);
applyMixins(Button$1, StartEnd, DelegatesARIAButton);
function composedParent(element) {
  const parentNode = element.parentElement;
  if (parentNode) {
    return parentNode;
  } else {
    const rootNode = element.getRootNode();
    if (rootNode.host instanceof HTMLElement) {
      return rootNode.host;
    }
  }
  return null;
}
function composedContains(reference, test) {
  let current = test;
  while (current !== null) {
    if (current === reference) {
      return true;
    }
    current = composedParent(current);
  }
  return false;
}
const defaultElement = document.createElement("div");
function isFastElement(element) {
  return element instanceof FASTElement;
}
class QueuedStyleSheetTarget {
  setProperty(name2, value) {
    DOM.queueUpdate(() => this.target.setProperty(name2, value));
  }
  removeProperty(name2) {
    DOM.queueUpdate(() => this.target.removeProperty(name2));
  }
}
class ConstructableStyleSheetTarget extends QueuedStyleSheetTarget {
  constructor(source) {
    super();
    const sheet = new CSSStyleSheet();
    sheet[prependToAdoptedStyleSheetsSymbol] = true;
    this.target = sheet.cssRules[sheet.insertRule(":host{}")].style;
    source.$fastController.addStyles(ElementStyles.create([sheet]));
  }
}
class DocumentStyleSheetTarget extends QueuedStyleSheetTarget {
  constructor() {
    super();
    const sheet = new CSSStyleSheet();
    this.target = sheet.cssRules[sheet.insertRule(":root{}")].style;
    document.adoptedStyleSheets = [
      ...document.adoptedStyleSheets,
      sheet
    ];
  }
}
class HeadStyleElementStyleSheetTarget extends QueuedStyleSheetTarget {
  constructor() {
    super();
    this.style = document.createElement("style");
    document.head.appendChild(this.style);
    const { sheet } = this.style;
    if (sheet) {
      const index = sheet.insertRule(":root{}", sheet.cssRules.length);
      this.target = sheet.cssRules[index].style;
    }
  }
}
class StyleElementStyleSheetTarget {
  constructor(target2) {
    this.store = /* @__PURE__ */ new Map();
    this.target = null;
    const controller = target2.$fastController;
    this.style = document.createElement("style");
    controller.addStyles(this.style);
    Observable$1.getNotifier(controller).subscribe(this, "isConnected");
    this.handleChange(controller, "isConnected");
  }
  targetChanged() {
    if (this.target !== null) {
      for (const [key2, value] of this.store.entries()) {
        this.target.setProperty(key2, value);
      }
    }
  }
  setProperty(name2, value) {
    this.store.set(name2, value);
    DOM.queueUpdate(() => {
      if (this.target !== null) {
        this.target.setProperty(name2, value);
      }
    });
  }
  removeProperty(name2) {
    this.store.delete(name2);
    DOM.queueUpdate(() => {
      if (this.target !== null) {
        this.target.removeProperty(name2);
      }
    });
  }
  handleChange(source, key2) {
    const { sheet } = this.style;
    if (sheet) {
      const index = sheet.insertRule(":host{}", sheet.cssRules.length);
      this.target = sheet.cssRules[index].style;
    } else {
      this.target = null;
    }
  }
}
__decorate([
  observable
], StyleElementStyleSheetTarget.prototype, "target", void 0);
class ElementStyleSheetTarget {
  constructor(source) {
    this.target = source.style;
  }
  setProperty(name2, value) {
    DOM.queueUpdate(() => this.target.setProperty(name2, value));
  }
  removeProperty(name2) {
    DOM.queueUpdate(() => this.target.removeProperty(name2));
  }
}
class RootStyleSheetTarget {
  setProperty(name2, value) {
    RootStyleSheetTarget.properties[name2] = value;
    for (const target2 of RootStyleSheetTarget.roots.values()) {
      PropertyTargetManager.getOrCreate(RootStyleSheetTarget.normalizeRoot(target2)).setProperty(name2, value);
    }
  }
  removeProperty(name2) {
    delete RootStyleSheetTarget.properties[name2];
    for (const target2 of RootStyleSheetTarget.roots.values()) {
      PropertyTargetManager.getOrCreate(RootStyleSheetTarget.normalizeRoot(target2)).removeProperty(name2);
    }
  }
  static registerRoot(root2) {
    const { roots } = RootStyleSheetTarget;
    if (!roots.has(root2)) {
      roots.add(root2);
      const target2 = PropertyTargetManager.getOrCreate(this.normalizeRoot(root2));
      for (const key2 in RootStyleSheetTarget.properties) {
        target2.setProperty(key2, RootStyleSheetTarget.properties[key2]);
      }
    }
  }
  static unregisterRoot(root2) {
    const { roots } = RootStyleSheetTarget;
    if (roots.has(root2)) {
      roots.delete(root2);
      const target2 = PropertyTargetManager.getOrCreate(RootStyleSheetTarget.normalizeRoot(root2));
      for (const key2 in RootStyleSheetTarget.properties) {
        target2.removeProperty(key2);
      }
    }
  }
  /**
   * Returns the document when provided the default element,
   * otherwise is a no-op
   * @param root - the root to normalize
   */
  static normalizeRoot(root2) {
    return root2 === defaultElement ? document : root2;
  }
}
RootStyleSheetTarget.roots = /* @__PURE__ */ new Set();
RootStyleSheetTarget.properties = {};
const propertyTargetCache = /* @__PURE__ */ new WeakMap();
const propertyTargetCtor = DOM.supportsAdoptedStyleSheets ? ConstructableStyleSheetTarget : StyleElementStyleSheetTarget;
const PropertyTargetManager = Object.freeze({
  getOrCreate(source) {
    if (propertyTargetCache.has(source)) {
      return propertyTargetCache.get(source);
    }
    let target2;
    if (source === defaultElement) {
      target2 = new RootStyleSheetTarget();
    } else if (source instanceof Document) {
      target2 = DOM.supportsAdoptedStyleSheets ? new DocumentStyleSheetTarget() : new HeadStyleElementStyleSheetTarget();
    } else if (isFastElement(source)) {
      target2 = new propertyTargetCtor(source);
    } else {
      target2 = new ElementStyleSheetTarget(source);
    }
    propertyTargetCache.set(source, target2);
    return target2;
  }
});
class DesignTokenImpl extends CSSDirective {
  constructor(configuration) {
    super();
    this.subscribers = /* @__PURE__ */ new WeakMap();
    this._appliedTo = /* @__PURE__ */ new Set();
    this.name = configuration.name;
    if (configuration.cssCustomPropertyName !== null) {
      this.cssCustomProperty = `--${configuration.cssCustomPropertyName}`;
      this.cssVar = `var(${this.cssCustomProperty})`;
    }
    this.id = DesignTokenImpl.uniqueId();
    DesignTokenImpl.tokensById.set(this.id, this);
  }
  get appliedTo() {
    return [...this._appliedTo];
  }
  static from(nameOrConfig) {
    return new DesignTokenImpl({
      name: typeof nameOrConfig === "string" ? nameOrConfig : nameOrConfig.name,
      cssCustomPropertyName: typeof nameOrConfig === "string" ? nameOrConfig : nameOrConfig.cssCustomPropertyName === void 0 ? nameOrConfig.name : nameOrConfig.cssCustomPropertyName
    });
  }
  static isCSSDesignToken(token) {
    return typeof token.cssCustomProperty === "string";
  }
  static isDerivedDesignTokenValue(value) {
    return typeof value === "function";
  }
  /**
   * Gets a token by ID. Returns undefined if the token was not found.
   * @param id - The ID of the token
   * @returns
   */
  static getTokenById(id) {
    return DesignTokenImpl.tokensById.get(id);
  }
  getOrCreateSubscriberSet(target2 = this) {
    return this.subscribers.get(target2) || this.subscribers.set(target2, /* @__PURE__ */ new Set()) && this.subscribers.get(target2);
  }
  createCSS() {
    return this.cssVar || "";
  }
  getValueFor(element) {
    const value = DesignTokenNode.getOrCreate(element).get(this);
    if (value !== void 0) {
      return value;
    }
    throw new Error(`Value could not be retrieved for token named "${this.name}". Ensure the value is set for ${element} or an ancestor of ${element}.`);
  }
  setValueFor(element, value) {
    this._appliedTo.add(element);
    if (value instanceof DesignTokenImpl) {
      value = this.alias(value);
    }
    DesignTokenNode.getOrCreate(element).set(this, value);
    return this;
  }
  deleteValueFor(element) {
    this._appliedTo.delete(element);
    if (DesignTokenNode.existsFor(element)) {
      DesignTokenNode.getOrCreate(element).delete(this);
    }
    return this;
  }
  withDefault(value) {
    this.setValueFor(defaultElement, value);
    return this;
  }
  subscribe(subscriber, target2) {
    const subscriberSet = this.getOrCreateSubscriberSet(target2);
    if (target2 && !DesignTokenNode.existsFor(target2)) {
      DesignTokenNode.getOrCreate(target2);
    }
    if (!subscriberSet.has(subscriber)) {
      subscriberSet.add(subscriber);
    }
  }
  unsubscribe(subscriber, target2) {
    const list2 = this.subscribers.get(target2 || this);
    if (list2 && list2.has(subscriber)) {
      list2.delete(subscriber);
    }
  }
  /**
   * Notifies subscribers that the value for an element has changed.
   * @param element - The element to emit a notification for
   */
  notify(element) {
    const record = Object.freeze({ token: this, target: element });
    if (this.subscribers.has(this)) {
      this.subscribers.get(this).forEach((sub) => sub.handleChange(record));
    }
    if (this.subscribers.has(element)) {
      this.subscribers.get(element).forEach((sub) => sub.handleChange(record));
    }
  }
  /**
   * Alias the token to the provided token.
   * @param token - the token to alias to
   */
  alias(token) {
    return (target2) => token.getValueFor(target2);
  }
}
DesignTokenImpl.uniqueId = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(16);
  };
})();
DesignTokenImpl.tokensById = /* @__PURE__ */ new Map();
class CustomPropertyReflector {
  startReflection(token, target2) {
    token.subscribe(this, target2);
    this.handleChange({ token, target: target2 });
  }
  stopReflection(token, target2) {
    token.unsubscribe(this, target2);
    this.remove(token, target2);
  }
  handleChange(record) {
    const { token, target: target2 } = record;
    this.add(token, target2);
  }
  add(token, target2) {
    PropertyTargetManager.getOrCreate(target2).setProperty(token.cssCustomProperty, this.resolveCSSValue(DesignTokenNode.getOrCreate(target2).get(token)));
  }
  remove(token, target2) {
    PropertyTargetManager.getOrCreate(target2).removeProperty(token.cssCustomProperty);
  }
  resolveCSSValue(value) {
    return value && typeof value.createCSS === "function" ? value.createCSS() : value;
  }
}
class DesignTokenBindingObserver {
  constructor(source, token, node2) {
    this.source = source;
    this.token = token;
    this.node = node2;
    this.dependencies = /* @__PURE__ */ new Set();
    this.observer = Observable$1.binding(source, this, false);
    this.observer.handleChange = this.observer.call;
    this.handleChange();
  }
  disconnect() {
    this.observer.disconnect();
  }
  /**
   * @internal
   */
  handleChange() {
    try {
      this.node.store.set(this.token, this.observer.observe(this.node.target, defaultExecutionContext));
    } catch (e) {
      console.error(e);
    }
  }
}
class Store {
  constructor() {
    this.values = /* @__PURE__ */ new Map();
  }
  set(token, value) {
    if (this.values.get(token) !== value) {
      this.values.set(token, value);
      Observable$1.getNotifier(this).notify(token.id);
    }
  }
  get(token) {
    Observable$1.track(this, token.id);
    return this.values.get(token);
  }
  delete(token) {
    this.values.delete(token);
    Observable$1.getNotifier(this).notify(token.id);
  }
  all() {
    return this.values.entries();
  }
}
const nodeCache = /* @__PURE__ */ new WeakMap();
const childToParent = /* @__PURE__ */ new WeakMap();
class DesignTokenNode {
  constructor(target2) {
    this.target = target2;
    this.store = new Store();
    this.children = [];
    this.assignedValues = /* @__PURE__ */ new Map();
    this.reflecting = /* @__PURE__ */ new Set();
    this.bindingObservers = /* @__PURE__ */ new Map();
    this.tokenValueChangeHandler = {
      handleChange: (source, arg) => {
        const token = DesignTokenImpl.getTokenById(arg);
        if (token) {
          token.notify(this.target);
          this.updateCSSTokenReflection(source, token);
        }
      }
    };
    nodeCache.set(target2, this);
    Observable$1.getNotifier(this.store).subscribe(this.tokenValueChangeHandler);
    if (target2 instanceof FASTElement) {
      target2.$fastController.addBehaviors([this]);
    } else if (target2.isConnected) {
      this.bind();
    }
  }
  /**
   * Returns a DesignTokenNode for an element.
   * Creates a new instance if one does not already exist for a node,
   * otherwise returns the cached instance
   *
   * @param target - The HTML element to retrieve a DesignTokenNode for
   */
  static getOrCreate(target2) {
    return nodeCache.get(target2) || new DesignTokenNode(target2);
  }
  /**
   * Determines if a DesignTokenNode has been created for a target
   * @param target - The element to test
   */
  static existsFor(target2) {
    return nodeCache.has(target2);
  }
  /**
   * Searches for and return the nearest parent DesignTokenNode.
   * Null is returned if no node is found or the node provided is for a default element.
   */
  static findParent(node2) {
    if (!(defaultElement === node2.target)) {
      let parent = composedParent(node2.target);
      while (parent !== null) {
        if (nodeCache.has(parent)) {
          return nodeCache.get(parent);
        }
        parent = composedParent(parent);
      }
      return DesignTokenNode.getOrCreate(defaultElement);
    }
    return null;
  }
  /**
   * Finds the closest node with a value explicitly assigned for a token, otherwise null.
   * @param token - The token to look for
   * @param start - The node to start looking for value assignment
   * @returns
   */
  static findClosestAssignedNode(token, start) {
    let current = start;
    do {
      if (current.has(token)) {
        return current;
      }
      current = current.parent ? current.parent : current.target !== defaultElement ? DesignTokenNode.getOrCreate(defaultElement) : null;
    } while (current !== null);
    return null;
  }
  /**
   * The parent DesignTokenNode, or null.
   */
  get parent() {
    return childToParent.get(this) || null;
  }
  updateCSSTokenReflection(source, token) {
    if (DesignTokenImpl.isCSSDesignToken(token)) {
      const parent = this.parent;
      const reflecting = this.isReflecting(token);
      if (parent) {
        const parentValue = parent.get(token);
        const sourceValue = source.get(token);
        if (parentValue !== sourceValue && !reflecting) {
          this.reflectToCSS(token);
        } else if (parentValue === sourceValue && reflecting) {
          this.stopReflectToCSS(token);
        }
      } else if (!reflecting) {
        this.reflectToCSS(token);
      }
    }
  }
  /**
   * Checks if a token has been assigned an explicit value the node.
   * @param token - the token to check.
   */
  has(token) {
    return this.assignedValues.has(token);
  }
  /**
   * Gets the value of a token for a node
   * @param token - The token to retrieve the value for
   * @returns
   */
  get(token) {
    const value = this.store.get(token);
    if (value !== void 0) {
      return value;
    }
    const raw = this.getRaw(token);
    if (raw !== void 0) {
      this.hydrate(token, raw);
      return this.get(token);
    }
  }
  /**
   * Retrieves the raw assigned value of a token from the nearest assigned node.
   * @param token - The token to retrieve a raw value for
   * @returns
   */
  getRaw(token) {
    var _a;
    if (this.assignedValues.has(token)) {
      return this.assignedValues.get(token);
    }
    return (_a = DesignTokenNode.findClosestAssignedNode(token, this)) === null || _a === void 0 ? void 0 : _a.getRaw(token);
  }
  /**
   * Sets a token to a value for a node
   * @param token - The token to set
   * @param value - The value to set the token to
   */
  set(token, value) {
    if (DesignTokenImpl.isDerivedDesignTokenValue(this.assignedValues.get(token))) {
      this.tearDownBindingObserver(token);
    }
    this.assignedValues.set(token, value);
    if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {
      this.setupBindingObserver(token, value);
    } else {
      this.store.set(token, value);
    }
  }
  /**
   * Deletes a token value for the node.
   * @param token - The token to delete the value for
   */
  delete(token) {
    this.assignedValues.delete(token);
    this.tearDownBindingObserver(token);
    const upstream = this.getRaw(token);
    if (upstream) {
      this.hydrate(token, upstream);
    } else {
      this.store.delete(token);
    }
  }
  /**
   * Invoked when the DesignTokenNode.target is attached to the document
   */
  bind() {
    const parent = DesignTokenNode.findParent(this);
    if (parent) {
      parent.appendChild(this);
    }
    for (const key2 of this.assignedValues.keys()) {
      key2.notify(this.target);
    }
  }
  /**
   * Invoked when the DesignTokenNode.target is detached from the document
   */
  unbind() {
    if (this.parent) {
      const parent = childToParent.get(this);
      parent.removeChild(this);
    }
    for (const token of this.bindingObservers.keys()) {
      this.tearDownBindingObserver(token);
    }
  }
  /**
   * Appends a child to a parent DesignTokenNode.
   * @param child - The child to append to the node
   */
  appendChild(child) {
    if (child.parent) {
      childToParent.get(child).removeChild(child);
    }
    const reParent = this.children.filter((x2) => child.contains(x2));
    childToParent.set(child, this);
    this.children.push(child);
    reParent.forEach((x2) => child.appendChild(x2));
    Observable$1.getNotifier(this.store).subscribe(child);
    for (const [token, value] of this.store.all()) {
      child.hydrate(token, this.bindingObservers.has(token) ? this.getRaw(token) : value);
      child.updateCSSTokenReflection(child.store, token);
    }
  }
  /**
   * Removes a child from a node.
   * @param child - The child to remove.
   */
  removeChild(child) {
    const childIndex = this.children.indexOf(child);
    if (childIndex !== -1) {
      this.children.splice(childIndex, 1);
    }
    Observable$1.getNotifier(this.store).unsubscribe(child);
    if (child.parent !== this) {
      return false;
    }
    const deleted = childToParent.delete(child);
    for (const [token] of this.store.all()) {
      child.hydrate(token, child.getRaw(token));
      child.updateCSSTokenReflection(child.store, token);
    }
    return deleted;
  }
  /**
   * Tests whether a provided node is contained by
   * the calling node.
   * @param test - The node to test
   */
  contains(test) {
    return composedContains(this.target, test.target);
  }
  /**
   * Instructs the node to reflect a design token for the provided token.
   * @param token - The design token to reflect
   */
  reflectToCSS(token) {
    if (!this.isReflecting(token)) {
      this.reflecting.add(token);
      DesignTokenNode.cssCustomPropertyReflector.startReflection(token, this.target);
    }
  }
  /**
   * Stops reflecting a DesignToken to CSS
   * @param token - The design token to stop reflecting
   */
  stopReflectToCSS(token) {
    if (this.isReflecting(token)) {
      this.reflecting.delete(token);
      DesignTokenNode.cssCustomPropertyReflector.stopReflection(token, this.target);
    }
  }
  /**
   * Determines if a token is being reflected to CSS for a node.
   * @param token - The token to check for reflection
   * @returns
   */
  isReflecting(token) {
    return this.reflecting.has(token);
  }
  /**
   * Handle changes to upstream tokens
   * @param source - The parent DesignTokenNode
   * @param property - The token ID that changed
   */
  handleChange(source, property) {
    const token = DesignTokenImpl.getTokenById(property);
    if (!token) {
      return;
    }
    this.hydrate(token, this.getRaw(token));
    this.updateCSSTokenReflection(this.store, token);
  }
  /**
   * Hydrates a token with a DesignTokenValue, making retrieval available.
   * @param token - The token to hydrate
   * @param value - The value to hydrate
   */
  hydrate(token, value) {
    if (!this.has(token)) {
      const observer = this.bindingObservers.get(token);
      if (DesignTokenImpl.isDerivedDesignTokenValue(value)) {
        if (observer) {
          if (observer.source !== value) {
            this.tearDownBindingObserver(token);
            this.setupBindingObserver(token, value);
          }
        } else {
          this.setupBindingObserver(token, value);
        }
      } else {
        if (observer) {
          this.tearDownBindingObserver(token);
        }
        this.store.set(token, value);
      }
    }
  }
  /**
   * Sets up a binding observer for a derived token value that notifies token
   * subscribers on change.
   *
   * @param token - The token to notify when the binding updates
   * @param source - The binding source
   */
  setupBindingObserver(token, source) {
    const binding = new DesignTokenBindingObserver(source, token, this);
    this.bindingObservers.set(token, binding);
    return binding;
  }
  /**
   * Tear down a binding observer for a token.
   */
  tearDownBindingObserver(token) {
    if (this.bindingObservers.has(token)) {
      this.bindingObservers.get(token).disconnect();
      this.bindingObservers.delete(token);
      return true;
    }
    return false;
  }
}
DesignTokenNode.cssCustomPropertyReflector = new CustomPropertyReflector();
__decorate([
  observable
], DesignTokenNode.prototype, "children", void 0);
function create$9(nameOrConfig) {
  return DesignTokenImpl.from(nameOrConfig);
}
const DesignToken = Object.freeze({
  create: create$9,
  /**
   * Informs DesignToken that an HTMLElement for which tokens have
   * been set has been connected to the document.
   *
   * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness
   * in all scenarios, so invoking this method manually is necessary when:
   *
   * 1. Token values are set for an HTMLElement.
   * 2. The HTMLElement does not inherit from FASTElement.
   * 3. The HTMLElement is not connected to the document when token values are set.
   *
   * @param element - The element to notify
   * @returns - true if notification was successful, otherwise false.
   */
  notifyConnection(element) {
    if (!element.isConnected || !DesignTokenNode.existsFor(element)) {
      return false;
    }
    DesignTokenNode.getOrCreate(element).bind();
    return true;
  },
  /**
   * Informs DesignToken that an HTMLElement for which tokens have
   * been set has been disconnected to the document.
   *
   * The browser does not provide a reliable mechanism to observe an HTMLElement's connectedness
   * in all scenarios, so invoking this method manually is necessary when:
   *
   * 1. Token values are set for an HTMLElement.
   * 2. The HTMLElement does not inherit from FASTElement.
   *
   * @param element - The element to notify
   * @returns - true if notification was successful, otherwise false.
   */
  notifyDisconnection(element) {
    if (element.isConnected || !DesignTokenNode.existsFor(element)) {
      return false;
    }
    DesignTokenNode.getOrCreate(element).unbind();
    return true;
  },
  /**
   * Registers and element or document as a DesignToken root.
   * {@link CSSDesignToken | CSSDesignTokens} with default values assigned via
   * {@link (DesignToken:interface).withDefault} will emit CSS custom properties to all
   * registered roots.
   * @param target - The root to register
   */
  registerRoot(target2 = defaultElement) {
    RootStyleSheetTarget.registerRoot(target2);
  },
  /**
   * Unregister an element or document as a DesignToken root.
   * @param target - The root to deregister
   */
  unregisterRoot(target2 = defaultElement) {
    RootStyleSheetTarget.unregisterRoot(target2);
  }
});
const ElementDisambiguation = Object.freeze({
  /**
   * Skip defining the element but still call the provided callback passed
   * to DesignSystemRegistrationContext.tryDefineElement
   */
  definitionCallbackOnly: null,
  /**
   * Ignore the duplicate element entirely.
   */
  ignoreDuplicate: Symbol()
});
const elementTypesByTag = /* @__PURE__ */ new Map();
const elementTagsByType = /* @__PURE__ */ new Map();
let rootDesignSystem = null;
const designSystemKey = DI.createInterface((x2) => x2.cachedCallback((handler) => {
  if (rootDesignSystem === null) {
    rootDesignSystem = new DefaultDesignSystem(null, handler);
  }
  return rootDesignSystem;
}));
const DesignSystem = Object.freeze({
  /**
   * Returns the HTML element name that the type is defined as.
   * @param type - The type to lookup.
   * @public
   */
  tagFor(type) {
    return elementTagsByType.get(type);
  },
  /**
   * Searches the DOM hierarchy for the design system that is responsible
   * for the provided element.
   * @param element - The element to locate the design system for.
   * @returns The located design system.
   * @public
   */
  responsibleFor(element) {
    const owned = element.$$designSystem$$;
    if (owned) {
      return owned;
    }
    const container2 = DI.findResponsibleContainer(element);
    return container2.get(designSystemKey);
  },
  /**
   * Gets the DesignSystem if one is explicitly defined on the provided element;
   * otherwise creates a design system defined directly on the element.
   * @param element - The element to get or create a design system for.
   * @returns The design system.
   * @public
   */
  getOrCreate(node2) {
    if (!node2) {
      if (rootDesignSystem === null) {
        rootDesignSystem = DI.getOrCreateDOMContainer().get(designSystemKey);
      }
      return rootDesignSystem;
    }
    const owned = node2.$$designSystem$$;
    if (owned) {
      return owned;
    }
    const container2 = DI.getOrCreateDOMContainer(node2);
    if (container2.has(designSystemKey, false)) {
      return container2.get(designSystemKey);
    } else {
      const system = new DefaultDesignSystem(node2, container2);
      container2.register(Registration.instance(designSystemKey, system));
      return system;
    }
  }
});
function extractTryDefineElementParams(params2, elementDefinitionType, elementDefinitionCallback) {
  if (typeof params2 === "string") {
    return {
      name: params2,
      type: elementDefinitionType,
      callback: elementDefinitionCallback
    };
  } else {
    return params2;
  }
}
class DefaultDesignSystem {
  constructor(owner, container2) {
    this.owner = owner;
    this.container = container2;
    this.designTokensInitialized = false;
    this.prefix = "fast";
    this.shadowRootMode = void 0;
    this.disambiguate = () => ElementDisambiguation.definitionCallbackOnly;
    if (owner !== null) {
      owner.$$designSystem$$ = this;
    }
  }
  withPrefix(prefix) {
    this.prefix = prefix;
    return this;
  }
  withShadowRootMode(mode) {
    this.shadowRootMode = mode;
    return this;
  }
  withElementDisambiguation(callback) {
    this.disambiguate = callback;
    return this;
  }
  withDesignTokenRoot(root2) {
    this.designTokenRoot = root2;
    return this;
  }
  register(...registrations) {
    const container2 = this.container;
    const elementDefinitionEntries = [];
    const disambiguate = this.disambiguate;
    const shadowRootMode = this.shadowRootMode;
    const context = {
      elementPrefix: this.prefix,
      tryDefineElement(params2, elementDefinitionType, elementDefinitionCallback) {
        const extractedParams = extractTryDefineElementParams(params2, elementDefinitionType, elementDefinitionCallback);
        const { name: name2, callback, baseClass } = extractedParams;
        let { type } = extractedParams;
        let elementName = name2;
        let typeFoundByName = elementTypesByTag.get(elementName);
        let needsDefine = true;
        while (typeFoundByName) {
          const result2 = disambiguate(elementName, type, typeFoundByName);
          switch (result2) {
            case ElementDisambiguation.ignoreDuplicate:
              return;
            case ElementDisambiguation.definitionCallbackOnly:
              needsDefine = false;
              typeFoundByName = void 0;
              break;
            default:
              elementName = result2;
              typeFoundByName = elementTypesByTag.get(elementName);
              break;
          }
        }
        if (needsDefine) {
          if (elementTagsByType.has(type) || type === FoundationElement) {
            type = class extends type {
            };
          }
          elementTypesByTag.set(elementName, type);
          elementTagsByType.set(type, elementName);
          if (baseClass) {
            elementTagsByType.set(baseClass, elementName);
          }
        }
        elementDefinitionEntries.push(new ElementDefinitionEntry(container2, elementName, type, shadowRootMode, callback, needsDefine));
      }
    };
    if (!this.designTokensInitialized) {
      this.designTokensInitialized = true;
      if (this.designTokenRoot !== null) {
        DesignToken.registerRoot(this.designTokenRoot);
      }
    }
    container2.registerWithContext(context, ...registrations);
    for (const entry of elementDefinitionEntries) {
      entry.callback(entry);
      if (entry.willDefine && entry.definition !== null) {
        entry.definition.define();
      }
    }
    return this;
  }
}
class ElementDefinitionEntry {
  constructor(container2, name2, type, shadowRootMode, callback, willDefine) {
    this.container = container2;
    this.name = name2;
    this.type = type;
    this.shadowRootMode = shadowRootMode;
    this.callback = callback;
    this.willDefine = willDefine;
    this.definition = null;
  }
  definePresentation(presentation) {
    ComponentPresentation.define(this.name, presentation, this.container);
  }
  defineElement(definition) {
    this.definition = new FASTElementDefinition(this.type, Object.assign(Object.assign({}, definition), { name: this.name }));
  }
  tagFor(type) {
    return DesignSystem.tagFor(type);
  }
}
/*!
* tabbable 5.3.3
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var isInput = function isInput2(node2) {
  return node2.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node2) {
  return isInput(node2) && node2.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node2) {
  var r = node2.tagName === "DETAILS" && Array.prototype.slice.apply(node2.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var isZeroArea = function isZeroArea2(node2) {
  var _node$getBoundingClie = node2.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node2, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot2 = _ref.getShadowRoot;
  if (getComputedStyle(node2).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node2, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node2.parentElement : node2;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  var nodeRootHost = getRootNode(node2).host;
  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node2.ownerDocument.contains(node2);
  if (!displayCheck || displayCheck === "full") {
    if (typeof getShadowRoot2 === "function") {
      var originalNode = node2;
      while (node2) {
        var parentElement = node2.parentElement;
        var rootNode = getRootNode(node2);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot2(parentElement) === true) {
          return isZeroArea(node2);
        } else if (node2.assignedSlot) {
          node2 = node2.assignedSlot;
        } else if (!parentElement && rootNode !== node2.ownerDocument) {
          node2 = rootNode.host;
        } else {
          node2 = parentElement;
        }
      }
      node2 = originalNode;
    }
    if (nodeIsAttached) {
      return !node2.getClientRects().length;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node2);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node2) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node2.tagName)) {
    var parentNode = node2.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node2);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node2) {
  if (node2.disabled || isHiddenInput(node2) || isHidden(node2, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node2) || isDisabledFromFieldset(node2)) {
    return false;
  }
  return true;
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node2, options) {
  options = options || {};
  if (!node2) {
    throw new Error("No node provided");
  }
  if (matches.call(node2, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node2);
};
const toolbarTemplate = (context, definition) => html`
    <template
        aria-label="${(x2) => x2.ariaLabel}"
        aria-labelledby="${(x2) => x2.ariaLabelledby}"
        aria-orientation="${(x2) => x2.orientation}"
        orientation="${(x2) => x2.orientation}"
        role="toolbar"
        @mousedown="${(x2, c) => x2.mouseDownHandler(c.event)}"
        @focusin="${(x2, c) => x2.focusinHandler(c.event)}"
        @keydown="${(x2, c) => x2.keydownHandler(c.event)}"
        ${children({
  property: "childItems",
  attributeFilter: ["disabled", "hidden"],
  filter: elements(),
  subtree: true
})}
    >
        <slot name="label"></slot>
        <div class="positioning-region" part="positioning-region">
            ${startSlotTemplate(context, definition)}
            <slot
                ${slotted({
  filter: elements(),
  property: "slottedItems"
})}
            ></slot>
            ${endSlotTemplate(context, definition)}
        </div>
    </template>
`;
class MatchMediaBehavior {
  /**
   *
   * @param query - The media query to operate from.
   */
  constructor(query) {
    this.listenerCache = /* @__PURE__ */ new WeakMap();
    this.query = query;
  }
  /**
   * Binds the behavior to the element.
   * @param source - The element for which the behavior is bound.
   */
  bind(source) {
    const { query } = this;
    const listener = this.constructListener(source);
    listener.bind(query)();
    query.addListener(listener);
    this.listenerCache.set(source, listener);
  }
  /**
   * Unbinds the behavior from the element.
   * @param source - The element for which the behavior is unbinding.
   */
  unbind(source) {
    const listener = this.listenerCache.get(source);
    if (listener) {
      this.query.removeListener(listener);
      this.listenerCache.delete(source);
    }
  }
}
class MatchMediaStyleSheetBehavior extends MatchMediaBehavior {
  /**
   * Constructs a {@link MatchMediaStyleSheetBehavior} instance.
   * @param query - The media query to operate from.
   * @param styles - The styles to coordinate with the query.
   */
  constructor(query, styles) {
    super(query);
    this.styles = styles;
  }
  /**
   * Defines a function to construct {@link MatchMediaStyleSheetBehavior | MatchMediaStyleSheetBehaviors} for
   * a provided query.
   * @param query - The media query to operate from.
   *
   * @public
   * @example
   *
   * ```ts
   * import { css } from "@microsoft/fast-element";
   * import { MatchMediaStyleSheetBehavior } from "@microsoft/fast-foundation";
   *
   * const landscapeBehavior = MatchMediaStyleSheetBehavior.with(
   *   window.matchMedia("(orientation: landscape)")
   * );
   * const styles = css`
   *   :host {
   *     width: 200px;
   *     height: 400px;
   *   }
   * `
   * .withBehaviors(landscapeBehavior(css`
   *   :host {
   *     width: 400px;
   *     height: 200px;
   *   }
   * `))
   * ```
   */
  static with(query) {
    return (styles) => {
      return new MatchMediaStyleSheetBehavior(query, styles);
    };
  }
  /**
   * Constructs a match-media listener for a provided element.
   * @param source - the element for which to attach or detach styles.
   * @internal
   */
  constructListener(source) {
    let attached = false;
    const styles = this.styles;
    return function listener() {
      const { matches: matches2 } = this;
      if (matches2 && !attached) {
        source.$fastController.addStyles(styles);
        attached = matches2;
      } else if (!matches2 && attached) {
        source.$fastController.removeStyles(styles);
        attached = matches2;
      }
    };
  }
  /**
   * Unbinds the behavior from the element.
   * @param source - The element for which the behavior is unbinding.
   * @internal
   */
  unbind(source) {
    super.unbind(source);
    source.$fastController.removeStyles(this.styles);
  }
}
const forcedColorsStylesheetBehavior = MatchMediaStyleSheetBehavior.with(window.matchMedia("(forced-colors)"));
MatchMediaStyleSheetBehavior.with(window.matchMedia("(prefers-color-scheme: dark)"));
MatchMediaStyleSheetBehavior.with(window.matchMedia("(prefers-color-scheme: light)"));
class PropertyStyleSheetBehavior {
  /**
   * Constructs a {@link PropertyStyleSheetBehavior} instance.
   * @param propertyName - The property name to operate from.
   * @param value - The property value to operate from.
   * @param styles - The styles to coordinate with the property.
   */
  constructor(propertyName, value, styles) {
    this.propertyName = propertyName;
    this.value = value;
    this.styles = styles;
  }
  /**
   * Binds the behavior to the element.
   * @param elementInstance - The element for which the property is applied.
   */
  bind(elementInstance) {
    Observable$1.getNotifier(elementInstance).subscribe(this, this.propertyName);
    this.handleChange(elementInstance, this.propertyName);
  }
  /**
   * Unbinds the behavior from the element.
   * @param source - The element for which the behavior is unbinding.
   * @internal
   */
  unbind(source) {
    Observable$1.getNotifier(source).unsubscribe(this, this.propertyName);
    source.$fastController.removeStyles(this.styles);
  }
  /**
   * Change event for the provided element.
   * @param source - the element for which to attach or detach styles.
   * @param key - the key to lookup to know if the element already has the styles
   * @internal
   */
  handleChange(source, key2) {
    if (source[key2] === this.value) {
      source.$fastController.addStyles(this.styles);
    } else {
      source.$fastController.removeStyles(this.styles);
    }
  }
}
const disabledCursor = "not-allowed";
const hidden = `:host([hidden]){display:none}`;
function display(displayValue) {
  return `${hidden}:host{display:${displayValue}}`;
}
const focusVisible = canUseFocusVisible() ? "focus-visible" : "focus";
function binarySearch(valuesToSearch, searchCondition, startIndex = 0, endIndex = valuesToSearch.length - 1) {
  if (endIndex === startIndex) {
    return valuesToSearch[startIndex];
  }
  const middleIndex = Math.floor((endIndex - startIndex) / 2) + startIndex;
  return searchCondition(valuesToSearch[middleIndex]) ? binarySearch(
    valuesToSearch,
    searchCondition,
    startIndex,
    middleIndex
    // include this index because it passed the search condition
  ) : binarySearch(
    valuesToSearch,
    searchCondition,
    middleIndex + 1,
    // exclude this index because it failed the search condition
    endIndex
  );
}
function directionByIsDark(color) {
  return isDark(color) ? -1 : 1;
}
function create$8(rOrSource, g, b) {
  if (typeof rOrSource === "number") {
    return PaletteRGB.from(SwatchRGB.create(rOrSource, g, b));
  } else {
    return PaletteRGB.from(rOrSource);
  }
}
function from$1(source) {
  return isSwatchRGB(source) ? PaletteRGBImpl.from(source) : PaletteRGBImpl.from(SwatchRGB.create(source.r, source.g, source.b));
}
const PaletteRGB = Object.freeze({
  create: create$8,
  from: from$1
});
class PaletteRGBImpl {
  /**
   *
   * @param source - The source color for the palette
   * @param swatches - All swatches in the palette
   */
  constructor(source, swatches) {
    this.closestIndexCache = /* @__PURE__ */ new Map();
    this.source = source;
    this.swatches = swatches;
    this.reversedSwatches = Object.freeze([...this.swatches].reverse());
    this.lastIndex = this.swatches.length - 1;
  }
  /**
   * {@inheritdoc Palette.colorContrast}
   */
  colorContrast(reference, contrastTarget, initialSearchIndex, direction) {
    if (initialSearchIndex === void 0) {
      initialSearchIndex = this.closestIndexOf(reference);
    }
    let source = this.swatches;
    const endSearchIndex = this.lastIndex;
    let startSearchIndex = initialSearchIndex;
    if (direction === void 0) {
      direction = directionByIsDark(reference);
    }
    const condition = (value) => contrast(reference, value) >= contrastTarget;
    if (direction === -1) {
      source = this.reversedSwatches;
      startSearchIndex = endSearchIndex - startSearchIndex;
    }
    return binarySearch(source, condition, startSearchIndex, endSearchIndex);
  }
  /**
   * {@inheritdoc Palette.get}
   */
  get(index) {
    return this.swatches[index] || this.swatches[clamp(index, 0, this.lastIndex)];
  }
  /**
   * {@inheritdoc Palette.closestIndexOf}
   */
  closestIndexOf(reference) {
    if (this.closestIndexCache.has(reference.relativeLuminance)) {
      return this.closestIndexCache.get(reference.relativeLuminance);
    }
    let index = this.swatches.indexOf(reference);
    if (index !== -1) {
      this.closestIndexCache.set(reference.relativeLuminance, index);
      return index;
    }
    const closest = this.swatches.reduce((previous, next) => Math.abs(next.relativeLuminance - reference.relativeLuminance) < Math.abs(previous.relativeLuminance - reference.relativeLuminance) ? next : previous);
    index = this.swatches.indexOf(closest);
    this.closestIndexCache.set(reference.relativeLuminance, index);
    return index;
  }
  /**
   * Create a color palette from a provided swatch
   * @param source - The source swatch to create a palette from
   * @returns
   */
  static from(source) {
    return new PaletteRGBImpl(source, Object.freeze(new ComponentStateColorPalette({
      /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
      baseColor: ColorRGBA64.fromObject(source)
    }).palette.map((x2) => {
      const _x = parseColorHexRGB(x2.toStringHexRGB());
      return SwatchRGB.create(_x.r, _x.g, _x.b);
    })));
  }
}
function accentFill(palette, neutralPalette2, reference, hoverDelta, activeDelta, focusDelta, neutralFillRestDelta2, neutralFillHoverDelta2, neutralFillActiveDelta2) {
  const accent = palette.source;
  const referenceIndex = neutralPalette2.closestIndexOf(reference);
  const swapThreshold = Math.max(neutralFillRestDelta2, neutralFillHoverDelta2, neutralFillActiveDelta2);
  const direction = referenceIndex >= swapThreshold ? -1 : 1;
  const accentIndex = palette.closestIndexOf(accent);
  const hoverIndex = accentIndex;
  const restIndex = hoverIndex + direction * -1 * hoverDelta;
  const activeIndex = restIndex + direction * activeDelta;
  const focusIndex = restIndex + direction * focusDelta;
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(activeIndex),
    focus: palette.get(focusIndex)
  };
}
function accentForeground(palette, reference, contrastTarget, restDelta, hoverDelta, activeDelta, focusDelta) {
  const accent = palette.source;
  const accentIndex = palette.closestIndexOf(accent);
  const direction = directionByIsDark(reference);
  const startIndex = accentIndex + (direction === 1 ? Math.min(restDelta, hoverDelta) : Math.max(direction * restDelta, direction * hoverDelta));
  const accessibleSwatch = palette.colorContrast(reference, contrastTarget, startIndex, direction);
  const accessibleIndex1 = palette.closestIndexOf(accessibleSwatch);
  const accessibleIndex2 = accessibleIndex1 + direction * Math.abs(restDelta - hoverDelta);
  const indexOneIsRestState = direction === 1 ? restDelta < hoverDelta : direction * restDelta > direction * hoverDelta;
  let restIndex;
  let hoverIndex;
  if (indexOneIsRestState) {
    restIndex = accessibleIndex1;
    hoverIndex = accessibleIndex2;
  } else {
    restIndex = accessibleIndex2;
    hoverIndex = accessibleIndex1;
  }
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(restIndex + direction * activeDelta),
    focus: palette.get(restIndex + direction * focusDelta)
  };
}
const white = SwatchRGB.create(1, 1, 1);
const black = SwatchRGB.create(0, 0, 0);
const middleGrey = SwatchRGB.from(parseColorHexRGB("#808080"));
const accentBase = SwatchRGB.from(parseColorHexRGB("#DA1A5F"));
const errorBase = SwatchRGB.from(parseColorHexRGB("#D32F2F"));
function foregroundOnAccent(reference, contrastTarget) {
  return reference.contrast(white) >= contrastTarget ? white : black;
}
function neutralFill(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta) {
  const referenceIndex = palette.closestIndexOf(reference);
  const threshold = Math.max(restDelta, hoverDelta, activeDelta, focusDelta);
  const direction = referenceIndex >= threshold ? -1 : 1;
  return {
    rest: palette.get(referenceIndex + direction * restDelta),
    hover: palette.get(referenceIndex + direction * hoverDelta),
    active: palette.get(referenceIndex + direction * activeDelta),
    focus: palette.get(referenceIndex + direction * focusDelta)
  };
}
function neutralFillInput(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta) {
  const direction = directionByIsDark(reference);
  const referenceIndex = palette.closestIndexOf(reference);
  return {
    rest: palette.get(referenceIndex - direction * restDelta),
    hover: palette.get(referenceIndex - direction * hoverDelta),
    active: palette.get(referenceIndex - direction * activeDelta),
    focus: palette.get(referenceIndex - direction * focusDelta)
  };
}
function neutralFillLayer(palette, reference, delta) {
  const referenceIndex = palette.closestIndexOf(reference);
  return palette.get(referenceIndex - (referenceIndex < delta ? delta * -1 : delta));
}
function neutralFillStealth(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta, fillRestDelta, fillHoverDelta, fillActiveDelta, fillFocusDelta) {
  const swapThreshold = Math.max(restDelta, hoverDelta, activeDelta, focusDelta, fillRestDelta, fillHoverDelta, fillActiveDelta, fillFocusDelta);
  const referenceIndex = palette.closestIndexOf(reference);
  const direction = referenceIndex >= swapThreshold ? -1 : 1;
  return {
    rest: palette.get(referenceIndex + direction * restDelta),
    hover: palette.get(referenceIndex + direction * hoverDelta),
    active: palette.get(referenceIndex + direction * activeDelta),
    focus: palette.get(referenceIndex + direction * focusDelta)
  };
}
function neutralFillContrast(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta) {
  const direction = directionByIsDark(reference);
  const accessibleIndex = palette.closestIndexOf(palette.colorContrast(reference, 4.5));
  const accessibleIndex2 = accessibleIndex + direction * Math.abs(restDelta - hoverDelta);
  const indexOneIsRest = direction === 1 ? restDelta < hoverDelta : direction * restDelta > direction * hoverDelta;
  let restIndex;
  let hoverIndex;
  if (indexOneIsRest) {
    restIndex = accessibleIndex;
    hoverIndex = accessibleIndex2;
  } else {
    restIndex = accessibleIndex2;
    hoverIndex = accessibleIndex;
  }
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(restIndex + direction * activeDelta),
    focus: palette.get(restIndex + direction * focusDelta)
  };
}
function focusStrokeOuter$1(palette, reference) {
  return palette.colorContrast(reference, 3.5);
}
function focusStrokeInner(palette, reference, focusColor) {
  return palette.colorContrast(focusColor, 3.5, palette.closestIndexOf(palette.source), directionByIsDark(reference) * -1);
}
function neutralForeground(palette, reference) {
  return palette.colorContrast(reference, 14);
}
function neutralForegroundHint(palette, reference) {
  return palette.colorContrast(reference, 4.5);
}
function neutralLayerCardContainer(palette, relativeLuminance, layerDelta) {
  return palette.get(palette.closestIndexOf(baseLayerLuminanceSwatch(relativeLuminance)) + layerDelta);
}
function neutralLayerFloating(palette, relativeLuminance, layerDelta) {
  const cardIndex = palette.closestIndexOf(baseLayerLuminanceSwatch(relativeLuminance)) - layerDelta;
  return palette.get(cardIndex - layerDelta);
}
function neutralLayer1$1(palette, baseLayerLuminance2) {
  return palette.get(palette.closestIndexOf(baseLayerLuminanceSwatch(baseLayerLuminance2)));
}
function neutralLayer2Index(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) {
  return Math.max(palette.closestIndexOf(baseLayerLuminanceSwatch(luminance)) + layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta);
}
function neutralLayer2(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) {
  return palette.get(neutralLayer2Index(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta));
}
function neutralLayer3(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) {
  return palette.get(neutralLayer2Index(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) + layerDelta);
}
function neutralLayer4(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) {
  return palette.get(neutralLayer2Index(palette, luminance, layerDelta, fillRestDelta, fillHoverDelta, fillActiveDelta) + layerDelta * 2);
}
function neutralStroke(palette, reference, restDelta, hoverDelta, activeDelta, focusDelta) {
  const referenceIndex = palette.closestIndexOf(reference);
  const direction = directionByIsDark(reference);
  const restIndex = referenceIndex + direction * restDelta;
  const hoverIndex = restIndex + direction * (hoverDelta - restDelta);
  const activeIndex = restIndex + direction * (activeDelta - restDelta);
  const focusIndex = restIndex + direction * (focusDelta - restDelta);
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(activeIndex),
    focus: palette.get(focusIndex)
  };
}
function neutralStrokeDivider(palette, reference, delta) {
  return palette.get(palette.closestIndexOf(reference) + directionByIsDark(reference) * delta);
}
function errorFillAlgorithm(palette, neutralPalette2, reference, hoverDelta, activeDelta, focusDelta, neutralFillRestDelta2, neutralFillHoverDelta2, neutralFillActiveDelta2) {
  const error = palette.source;
  const referenceIndex = neutralPalette2.closestIndexOf(reference);
  const swapThreshold = Math.max(neutralFillRestDelta2, neutralFillHoverDelta2, neutralFillActiveDelta2);
  const direction = referenceIndex >= swapThreshold ? -1 : 1;
  const errorIndex = palette.closestIndexOf(error);
  const hoverIndex = errorIndex;
  const restIndex = hoverIndex + direction * -1 * hoverDelta;
  const activeIndex = restIndex + direction * activeDelta;
  const focusIndex = restIndex + direction * focusDelta;
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(activeIndex),
    focus: palette.get(focusIndex)
  };
}
function errorForegroundAlgorithm(palette, reference, contrastTarget, restDelta, hoverDelta, activeDelta, focusDelta) {
  const error = palette.source;
  const errorIndex = palette.closestIndexOf(error);
  const direction = isDark(reference) ? -1 : 1;
  const startIndex = errorIndex + (direction === 1 ? Math.min(restDelta, hoverDelta) : Math.max(direction * restDelta, direction * hoverDelta));
  const accessibleSwatch = palette.colorContrast(reference, contrastTarget, startIndex, direction);
  const accessibleIndex1 = palette.closestIndexOf(accessibleSwatch);
  const accessibleIndex2 = accessibleIndex1 + direction * Math.abs(restDelta - hoverDelta);
  const indexOneIsRestState = direction === 1 ? restDelta < hoverDelta : direction * restDelta > direction * hoverDelta;
  let restIndex;
  let hoverIndex;
  if (indexOneIsRestState) {
    restIndex = accessibleIndex1;
    hoverIndex = accessibleIndex2;
  } else {
    restIndex = accessibleIndex2;
    hoverIndex = accessibleIndex1;
  }
  return {
    rest: palette.get(restIndex),
    hover: palette.get(hoverIndex),
    active: palette.get(restIndex + direction * activeDelta),
    focus: palette.get(restIndex + direction * focusDelta)
  };
}
function foregroundOnErrorAlgorithm(reference, contrastTarget) {
  return reference.contrast(white) >= contrastTarget ? white : black;
}
const { create: create$7 } = DesignToken;
function createNonCss(name2) {
  return DesignToken.create({ name: name2, cssCustomPropertyName: null });
}
const bodyFont = create$7("body-font").withDefault('aktiv-grotesk, "Segoe UI", Arial, Helvetica, sans-serif');
const baseHeightMultiplier = create$7("base-height-multiplier").withDefault(10);
create$7("base-horizontal-spacing-multiplier").withDefault(3);
const baseLayerLuminance = create$7("base-layer-luminance").withDefault(StandardLuminance.DarkMode);
const controlCornerRadius = create$7("control-corner-radius").withDefault(4);
const density = create$7("density").withDefault(0);
const designUnit = create$7("design-unit").withDefault(4);
const elementScale = create$7("element-scale").withDefault(0);
create$7("direction").withDefault(Direction$1.ltr);
const disabledOpacity = create$7("disabled-opacity").withDefault(0.4);
const strokeWidth = create$7("stroke-width").withDefault(1);
const focusStrokeWidth = create$7("focus-stroke-width").withDefault(2);
const typeRampBaseFontSize = create$7("type-ramp-base-font-size").withDefault("14px");
const typeRampBaseLineHeight = create$7("type-ramp-base-line-height").withDefault("20px");
create$7("type-ramp-minus-1-font-size").withDefault("12px");
create$7("type-ramp-minus-1-line-height").withDefault("16px");
create$7("type-ramp-minus-2-font-size").withDefault("10px");
create$7("type-ramp-minus-2-line-height").withDefault("16px");
create$7("type-ramp-plus-1-font-size").withDefault("16px");
create$7("type-ramp-plus-1-line-height").withDefault("24px");
create$7("type-ramp-plus-2-font-size").withDefault("20px");
create$7("type-ramp-plus-2-line-height").withDefault("28px");
create$7("type-ramp-plus-3-font-size").withDefault("28px");
create$7("type-ramp-plus-3-line-height").withDefault("36px");
create$7("type-ramp-plus-4-font-size").withDefault("34px");
create$7("type-ramp-plus-4-line-height").withDefault("44px");
create$7("type-ramp-plus-5-font-size").withDefault("46px");
create$7("type-ramp-plus-5-line-height").withDefault("56px");
create$7("type-ramp-plus-6-font-size").withDefault("60px");
create$7("type-ramp-plus-6-line-height").withDefault("72px");
createNonCss("accent-fill-rest-delta").withDefault(0);
const accentFillHoverDelta = createNonCss("accent-fill-hover-delta").withDefault(4);
const accentFillActiveDelta = createNonCss("accent-fill-active-delta").withDefault(-5);
const accentFillFocusDelta = createNonCss("accent-fill-focus-delta").withDefault(0);
const accentForegroundRestDelta = createNonCss("accent-foreground-rest-delta").withDefault(0);
const accentForegroundHoverDelta = createNonCss("accent-foreground-hover-delta").withDefault(6);
const accentForegroundActiveDelta = createNonCss("accent-foreground-active-delta").withDefault(-4);
const accentForegroundFocusDelta = createNonCss("accent-foreground-focus-delta").withDefault(0);
const neutralFillRestDelta = createNonCss("neutral-fill-rest-delta").withDefault(7);
const neutralFillHoverDelta = createNonCss("neutral-fill-hover-delta").withDefault(10);
const neutralFillActiveDelta = createNonCss("neutral-fill-active-delta").withDefault(5);
const neutralFillFocusDelta = createNonCss("neutral-fill-focus-delta").withDefault(0);
const neutralFillInputRestDelta = createNonCss("neutral-fill-input-rest-delta").withDefault(0);
const neutralFillInputHoverDelta = createNonCss("neutral-fill-input-hover-delta").withDefault(0);
const neutralFillInputActiveDelta = createNonCss("neutral-fill-input-active-delta").withDefault(0);
const neutralFillInputFocusDelta = createNonCss("neutral-fill-input-focus-delta").withDefault(0);
const neutralFillStealthRestDelta = createNonCss("neutral-fill-stealth-rest-delta").withDefault(0);
const neutralFillStealthHoverDelta = createNonCss("neutral-fill-stealth-hover-delta").withDefault(5);
const neutralFillStealthActiveDelta = createNonCss("neutral-fill-stealth-active-delta").withDefault(3);
const neutralFillStealthFocusDelta = createNonCss("neutral-fill-stealth-focus-delta").withDefault(0);
const neutralFillStrongRestDelta = createNonCss("neutral-fill-strong-rest-delta").withDefault(0);
const neutralFillStrongHoverDelta = createNonCss("neutral-fill-strong-hover-delta").withDefault(8);
const neutralFillStrongActiveDelta = createNonCss("neutral-fill-strong-active-delta").withDefault(-5);
const neutralFillStrongFocusDelta = createNonCss("neutral-fill-strong-focus-delta").withDefault(0);
const neutralFillLayerRestDelta = createNonCss("neutral-fill-layer-rest-delta").withDefault(3);
const neutralStrokeRestDelta = createNonCss("neutral-stroke-rest-delta").withDefault(25);
const neutralStrokeHoverDelta = createNonCss("neutral-stroke-hover-delta").withDefault(40);
const neutralStrokeActiveDelta = createNonCss("neutral-stroke-active-delta").withDefault(16);
const neutralStrokeFocusDelta = createNonCss("neutral-stroke-focus-delta").withDefault(25);
const neutralStrokeDividerRestDelta = createNonCss("neutral-stroke-divider-rest-delta").withDefault(8);
const neutralColor = create$7("neutral-color").withDefault(middleGrey);
const neutralPalette = createNonCss("neutral-palette").withDefault((element) => PaletteRGB.from(neutralColor.getValueFor(element)));
const accentColor = create$7("accent-color").withDefault(accentBase);
const accentPalette = createNonCss("accent-palette").withDefault((element) => PaletteRGB.from(accentColor.getValueFor(element)));
const neutralLayerCardContainerRecipe = createNonCss("neutral-layer-card-container-recipe").withDefault({
  evaluate: (element) => neutralLayerCardContainer(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
});
create$7("neutral-layer-card-container").withDefault((element) => neutralLayerCardContainerRecipe.getValueFor(element).evaluate(element));
const neutralLayerFloatingRecipe = createNonCss("neutral-layer-floating-recipe").withDefault({
  evaluate: (element) => neutralLayerFloating(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
});
create$7("neutral-layer-floating").withDefault((element) => neutralLayerFloatingRecipe.getValueFor(element).evaluate(element));
const neutralLayer1Recipe = createNonCss("neutral-layer-1-recipe").withDefault({
  evaluate: (element) => neutralLayer1$1(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element))
});
const neutralLayer1 = create$7("neutral-layer-1").withDefault((element) => neutralLayer1Recipe.getValueFor(element).evaluate(element));
const neutralLayer2Recipe = createNonCss("neutral-layer-2-recipe").withDefault({
  evaluate: (element) => neutralLayer2(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element))
});
create$7("neutral-layer-2").withDefault((element) => neutralLayer2Recipe.getValueFor(element).evaluate(element));
const neutralLayer3Recipe = createNonCss("neutral-layer-3-recipe").withDefault({
  evaluate: (element) => neutralLayer3(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element))
});
create$7("neutral-layer-3").withDefault((element) => neutralLayer3Recipe.getValueFor(element).evaluate(element));
const neutralLayer4Recipe = createNonCss("neutral-layer-4-recipe").withDefault({
  evaluate: (element) => neutralLayer4(neutralPalette.getValueFor(element), baseLayerLuminance.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element))
});
create$7("neutral-layer-4").withDefault((element) => neutralLayer4Recipe.getValueFor(element).evaluate(element));
const fillColor = create$7("fill-color").withDefault((element) => neutralLayer1.getValueFor(element));
var ContrastTarget;
(function(ContrastTarget2) {
  ContrastTarget2[ContrastTarget2["normal"] = 4.5] = "normal";
  ContrastTarget2[ContrastTarget2["large"] = 7] = "large";
})(ContrastTarget || (ContrastTarget = {}));
const accentFillRecipe = create$7({
  name: "accent-fill-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element, reference) => accentFill(accentPalette.getValueFor(element), neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), accentFillHoverDelta.getValueFor(element), accentFillActiveDelta.getValueFor(element), accentFillFocusDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element))
});
const accentFillRest = create$7("accent-fill-rest").withDefault((element) => {
  return accentFillRecipe.getValueFor(element).evaluate(element).rest;
});
const accentFillHover = create$7("accent-fill-hover").withDefault((element) => {
  return accentFillRecipe.getValueFor(element).evaluate(element).hover;
});
const accentFillActive = create$7("accent-fill-active").withDefault((element) => {
  return accentFillRecipe.getValueFor(element).evaluate(element).active;
});
const accentFillFocus = create$7("accent-fill-focus").withDefault((element) => {
  return accentFillRecipe.getValueFor(element).evaluate(element).focus;
});
const foregroundOnAccentByContrast = (contrast2) => (element, reference) => {
  return foregroundOnAccent(reference || accentFillRest.getValueFor(element), contrast2);
};
const foregroundOnAccentRecipe = createNonCss("foreground-on-accent-recipe").withDefault({
  evaluate: (element, reference) => foregroundOnAccentByContrast(ContrastTarget.normal)(element, reference)
});
const foregroundOnAccentRest = create$7("foreground-on-accent-rest").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element, accentFillRest.getValueFor(element)));
const foregroundOnAccentHover = create$7("foreground-on-accent-hover").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element, accentFillHover.getValueFor(element)));
const foregroundOnAccentActive = create$7("foreground-on-accent-active").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element, accentFillActive.getValueFor(element)));
create$7("foreground-on-accent-focus").withDefault((element) => foregroundOnAccentRecipe.getValueFor(element).evaluate(element, accentFillFocus.getValueFor(element)));
const foregroundOnAccentLargeRecipe = createNonCss("foreground-on-accent-large-recipe").withDefault({
  evaluate: (element, reference) => foregroundOnAccentByContrast(ContrastTarget.large)(element, reference)
});
create$7("foreground-on-accent-rest-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillRest.getValueFor(element)));
create$7("foreground-on-accent-hover-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillHover.getValueFor(element)));
create$7("foreground-on-accent-active-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillActive.getValueFor(element)));
create$7("foreground-on-accent-focus-large").withDefault((element) => foregroundOnAccentLargeRecipe.getValueFor(element).evaluate(element, accentFillFocus.getValueFor(element)));
const accentForegroundByContrast = (contrast2) => (element, reference) => accentForeground(accentPalette.getValueFor(element), reference || fillColor.getValueFor(element), contrast2, accentForegroundRestDelta.getValueFor(element), accentForegroundHoverDelta.getValueFor(element), accentForegroundActiveDelta.getValueFor(element), accentForegroundFocusDelta.getValueFor(element));
const accentForegroundRecipe = create$7({
  name: "accent-foreground-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element, reference) => accentForegroundByContrast(ContrastTarget.normal)(element, reference)
});
const accentForegroundRest = create$7("accent-foreground-rest").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).rest);
const accentForegroundHover = create$7("accent-foreground-hover").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).hover);
const accentForegroundActive = create$7("accent-foreground-active").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).active);
create$7("accent-foreground-focus").withDefault((element) => accentForegroundRecipe.getValueFor(element).evaluate(element).focus);
const neutralFillRecipe = create$7({
  name: "neutral-fill-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element, reference) => neutralFill(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element), neutralFillFocusDelta.getValueFor(element))
});
const neutralFillRest = create$7("neutral-fill-rest").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).rest);
const neutralFillHover = create$7("neutral-fill-hover").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).hover);
const neutralFillActive = create$7("neutral-fill-active").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).active);
create$7("neutral-fill-focus").withDefault((element) => neutralFillRecipe.getValueFor(element).evaluate(element).focus);
const neutralFillInputRecipe = create$7({
  name: "neutral-fill-input-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element, reference) => neutralFillInput(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillInputRestDelta.getValueFor(element), neutralFillInputHoverDelta.getValueFor(element), neutralFillInputActiveDelta.getValueFor(element), neutralFillInputFocusDelta.getValueFor(element))
});
create$7("neutral-fill-input-rest").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).rest);
create$7("neutral-fill-input-hover").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).hover);
create$7("neutral-fill-input-active").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).active);
create$7("neutral-fill-input-focus").withDefault((element) => neutralFillInputRecipe.getValueFor(element).evaluate(element).focus);
const neutralFillStealthRecipe = create$7({
  name: "neutral-fill-stealth-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element, reference) => neutralFillStealth(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillStealthRestDelta.getValueFor(element), neutralFillStealthHoverDelta.getValueFor(element), neutralFillStealthActiveDelta.getValueFor(element), neutralFillStealthFocusDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element), neutralFillFocusDelta.getValueFor(element))
});
create$7("neutral-fill-stealth-rest").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).rest);
const neutralFillStealthHover = create$7("neutral-fill-stealth-hover").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).hover);
const neutralFillStealthActive = create$7("neutral-fill-stealth-active").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).active);
create$7("neutral-fill-stealth-focus").withDefault((element) => neutralFillStealthRecipe.getValueFor(element).evaluate(element).focus);
const neutralFillStrongRecipe = create$7({
  name: "neutral-fill-strong-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element, reference) => neutralFillContrast(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillStrongRestDelta.getValueFor(element), neutralFillStrongHoverDelta.getValueFor(element), neutralFillStrongActiveDelta.getValueFor(element), neutralFillStrongFocusDelta.getValueFor(element))
});
create$7("neutral-fill-strong-rest").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).rest);
create$7("neutral-fill-strong-hover").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).hover);
const neutralFillStrongActive = create$7("neutral-fill-strong-active").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).active);
const neutralFillStrongFocus = create$7("neutral-fill-strong-focus").withDefault((element) => neutralFillStrongRecipe.getValueFor(element).evaluate(element).focus);
const neutralFillLayerRecipe = createNonCss("neutral-fill-layer-recipe").withDefault({
  evaluate: (element, reference) => neutralFillLayer(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralFillLayerRestDelta.getValueFor(element))
});
create$7("neutral-fill-layer-rest").withDefault((element) => neutralFillLayerRecipe.getValueFor(element).evaluate(element));
const focusStrokeOuterRecipe = createNonCss("focus-stroke-outer-recipe").withDefault({
  evaluate: (element) => focusStrokeOuter$1(neutralPalette.getValueFor(element), fillColor.getValueFor(element))
});
const focusStrokeOuter = create$7("focus-stroke-outer").withDefault((element) => focusStrokeOuterRecipe.getValueFor(element).evaluate(element));
const focusStrokeInnerRecipe = createNonCss("focus-stroke-inner-recipe").withDefault({
  evaluate: (element) => focusStrokeInner(accentPalette.getValueFor(element), fillColor.getValueFor(element), focusStrokeOuter.getValueFor(element))
});
create$7("focus-stroke-inner").withDefault((element) => focusStrokeInnerRecipe.getValueFor(element).evaluate(element));
const neutralForegroundHintRecipe = createNonCss("neutral-foreground-hint-recipe").withDefault({
  evaluate: (element) => neutralForegroundHint(neutralPalette.getValueFor(element), fillColor.getValueFor(element))
});
create$7("neutral-foreground-hint").withDefault((element) => neutralForegroundHintRecipe.getValueFor(element).evaluate(element));
const neutralForegroundRecipe = createNonCss("neutral-foreground-recipe").withDefault({
  evaluate: (element) => neutralForeground(neutralPalette.getValueFor(element), fillColor.getValueFor(element))
});
const neutralForegroundRest = create$7("neutral-foreground-rest").withDefault((element) => neutralForegroundRecipe.getValueFor(element).evaluate(element));
const neutralStrokeRecipe = create$7({
  name: "neutral-stroke-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element) => {
    return neutralStroke(neutralPalette.getValueFor(element), fillColor.getValueFor(element), neutralStrokeRestDelta.getValueFor(element), neutralStrokeHoverDelta.getValueFor(element), neutralStrokeActiveDelta.getValueFor(element), neutralStrokeFocusDelta.getValueFor(element));
  }
});
create$7("neutral-stroke-rest").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).rest);
create$7("neutral-stroke-hover").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).hover);
create$7("neutral-stroke-active").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).active);
create$7("neutral-stroke-focus").withDefault((element) => neutralStrokeRecipe.getValueFor(element).evaluate(element).focus);
const neutralStrokeDividerRecipe = createNonCss("neutral-stroke-divider-recipe").withDefault({
  evaluate: (element, reference) => neutralStrokeDivider(neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), neutralStrokeDividerRestDelta.getValueFor(element))
});
create$7("neutral-stroke-divider-rest").withDefault((element) => neutralStrokeDividerRecipe.getValueFor(element).evaluate(element));
DesignToken.create({
  name: "height-number",
  cssCustomPropertyName: null
}).withDefault((target2) => (baseHeightMultiplier.getValueFor(target2) + density.getValueFor(target2)) * designUnit.getValueFor(target2));
const errorColor = create$7("error-color").withDefault(errorBase);
const errorPalette = createNonCss("error-palette").withDefault((element) => PaletteRGB.from(errorColor.getValueFor(element)));
const errorFillRecipe = create$7({
  name: "error-fill-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element, reference) => errorFillAlgorithm(errorPalette.getValueFor(element), neutralPalette.getValueFor(element), reference || fillColor.getValueFor(element), accentFillHoverDelta.getValueFor(element), accentFillActiveDelta.getValueFor(element), accentFillFocusDelta.getValueFor(element), neutralFillRestDelta.getValueFor(element), neutralFillHoverDelta.getValueFor(element), neutralFillActiveDelta.getValueFor(element))
});
const errorFillRest = create$7("error-fill-rest").withDefault((element) => {
  return errorFillRecipe.getValueFor(element).evaluate(element).rest;
});
const errorFillHover = create$7("error-fill-hover").withDefault((element) => {
  return errorFillRecipe.getValueFor(element).evaluate(element).hover;
});
const errorFillActive = create$7("error-fill-active").withDefault((element) => {
  return errorFillRecipe.getValueFor(element).evaluate(element).active;
});
const errorFillFocus = create$7("error-fill-focus").withDefault((element) => {
  return errorFillRecipe.getValueFor(element).evaluate(element).focus;
});
const foregroundOnErrorByContrast = (contrast2) => (element, reference) => {
  return foregroundOnErrorAlgorithm(reference || errorFillRest.getValueFor(element), contrast2);
};
const foregroundOnErrorRecipe = create$7({
  name: "foreground-on-error-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element, reference) => foregroundOnErrorByContrast(ContrastTarget.normal)(element, reference)
});
create$7("foreground-on-error-rest").withDefault((element) => foregroundOnErrorRecipe.getValueFor(element).evaluate(element, errorFillRest.getValueFor(element)));
create$7("foreground-on-error-hover").withDefault((element) => foregroundOnErrorRecipe.getValueFor(element).evaluate(element, errorFillHover.getValueFor(element)));
create$7("foreground-on-error-active").withDefault((element) => foregroundOnErrorRecipe.getValueFor(element).evaluate(element, errorFillActive.getValueFor(element)));
create$7("foreground-on-error-focus").withDefault((element) => foregroundOnErrorRecipe.getValueFor(element).evaluate(element, errorFillFocus.getValueFor(element)));
const foregroundOnErrorLargeRecipe = create$7({
  name: "foreground-on-error-large-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element, reference) => foregroundOnErrorByContrast(ContrastTarget.large)(element, reference)
});
create$7("foreground-on-error-rest-large").withDefault((element) => foregroundOnErrorLargeRecipe.getValueFor(element).evaluate(element, errorFillRest.getValueFor(element)));
create$7("foreground-on-error-hover-large").withDefault((element) => foregroundOnErrorLargeRecipe.getValueFor(element).evaluate(element, errorFillHover.getValueFor(element)));
create$7("foreground-on-error-active-large").withDefault((element) => foregroundOnErrorLargeRecipe.getValueFor(element).evaluate(element, errorFillActive.getValueFor(element)));
create$7("foreground-on-error-focus-large").withDefault((element) => foregroundOnErrorLargeRecipe.getValueFor(element).evaluate(element, errorFillFocus.getValueFor(element)));
const errorForegroundByContrast = (contrast2) => (element, reference) => errorForegroundAlgorithm(errorPalette.getValueFor(element), reference || fillColor.getValueFor(element), contrast2, accentForegroundRestDelta.getValueFor(element), accentForegroundHoverDelta.getValueFor(element), accentForegroundActiveDelta.getValueFor(element), accentForegroundFocusDelta.getValueFor(element));
const errorForegroundRecipe = create$7({
  name: "error-foreground-recipe",
  cssCustomPropertyName: null
}).withDefault({
  evaluate: (element, reference) => errorForegroundByContrast(ContrastTarget.normal)(element, reference)
});
create$7("error-foreground-rest").withDefault((element) => errorForegroundRecipe.getValueFor(element).evaluate(element).rest);
create$7("error-foreground-hover").withDefault((element) => errorForegroundRecipe.getValueFor(element).evaluate(element).hover);
const errorForegroundActive = create$7("error-foreground-active").withDefault((element) => errorForegroundRecipe.getValueFor(element).evaluate(element).active);
create$7("error-foreground-focus").withDefault((element) => errorForegroundRecipe.getValueFor(element).evaluate(element).focus);
const THEME_NAME_BODY_ATTRIBUTE = "data-jp-theme-name";
const THEME_MODE_BODY_ATTRIBUTE = "data-jp-theme-light";
const BASE_LAYOUT_COLOR = "--jp-layout-color1";
let isThemeChangeInitialized = false;
function addJupyterLabThemeChangeListener() {
  if (!isThemeChangeInitialized) {
    isThemeChangeInitialized = true;
    initThemeChangeListener();
  }
}
function initThemeChangeListener() {
  const addObserver = () => {
    const observer = new MutationObserver(() => {
      applyJupyterTheme();
    });
    observer.observe(document.body, {
      attributes: true,
      attributeFilter: [THEME_NAME_BODY_ATTRIBUTE],
      childList: false,
      characterData: false
    });
    applyJupyterTheme();
  };
  if (document.readyState === "complete") {
    addObserver();
  } else {
    window.addEventListener("load", addObserver);
  }
}
const intConverter = (value) => {
  const parsedValue = parseInt(value, 10);
  return isNaN(parsedValue) ? null : parsedValue;
};
const tokenMappings = {
  "--jp-border-width": {
    converter: intConverter,
    token: strokeWidth
  },
  "--jp-border-radius": {
    converter: intConverter,
    token: controlCornerRadius
  },
  [BASE_LAYOUT_COLOR]: {
    converter: (value, isDark2) => {
      const parsedColor = parseColor(value);
      if (parsedColor) {
        const hsl = rgbToHSL(parsedColor);
        const correctedHSL = ColorHSL.fromObject({
          h: hsl.h,
          s: hsl.s,
          l: 0.5
        });
        const correctedRGB = hslToRGB(correctedHSL);
        return SwatchRGB.create(correctedRGB.r, correctedRGB.g, correctedRGB.b);
      } else {
        return null;
      }
    },
    token: neutralColor
  },
  "--jp-brand-color1": {
    converter: (value, isDark2) => {
      const parsedColor = parseColor(value);
      if (parsedColor) {
        const hsl = rgbToHSL(parsedColor);
        const direction = isDark2 ? 1 : -1;
        const correctedHSL = ColorHSL.fromObject({
          h: hsl.h,
          s: hsl.s,
          l: hsl.l + direction * accentFillHoverDelta.getValueFor(document.body) / 94
        });
        const correctedRGB = hslToRGB(correctedHSL);
        return SwatchRGB.create(correctedRGB.r, correctedRGB.g, correctedRGB.b);
      } else {
        return null;
      }
    },
    token: accentColor
  },
  "--jp-error-color1": {
    converter: (value, isDark2) => {
      const parsedColor = parseColor(value);
      if (parsedColor) {
        const hsl = rgbToHSL(parsedColor);
        const direction = isDark2 ? 1 : -1;
        const correctedHSL = ColorHSL.fromObject({
          h: hsl.h,
          s: hsl.s,
          l: hsl.l + direction * accentFillHoverDelta.getValueFor(document.body) / 94
        });
        const correctedRGB = hslToRGB(correctedHSL);
        return SwatchRGB.create(correctedRGB.r, correctedRGB.g, correctedRGB.b);
      } else {
        return null;
      }
    },
    token: errorColor
  },
  "--jp-ui-font-family": {
    token: bodyFont
  },
  "--jp-ui-font-size1": {
    token: typeRampBaseFontSize
  }
};
function applyJupyterTheme() {
  var _a;
  const styles = getComputedStyle(document.body);
  const themeMode = document.body.getAttribute(THEME_MODE_BODY_ATTRIBUTE);
  let isDark_ = false;
  if (themeMode) {
    isDark_ = themeMode === "false";
  } else {
    const layoutColor = styles.getPropertyValue(BASE_LAYOUT_COLOR).toString();
    if (layoutColor) {
      const parsedColor = parseColor(layoutColor);
      if (parsedColor) {
        isDark_ = isDark(SwatchRGB.create(parsedColor.r, parsedColor.g, parsedColor.b));
        console.debug(`Theme is ${isDark_ ? "dark" : "light"} based on '${BASE_LAYOUT_COLOR}' value: ${layoutColor}.`);
      }
    }
  }
  baseLayerLuminance.setValueFor(document.body, isDark_ ? StandardLuminance.DarkMode : StandardLuminance.LightMode);
  for (const jpTokenName in tokenMappings) {
    const toolkitTokenName = tokenMappings[jpTokenName];
    const value = styles.getPropertyValue(jpTokenName).toString();
    if (document.body && value !== "") {
      const parsedValue = ((_a = toolkitTokenName.converter) !== null && _a !== void 0 ? _a : (v) => v)(value.trim(), isDark_);
      if (parsedValue !== null) {
        toolkitTokenName.token.setValueFor(document.body, parsedValue);
      } else {
        console.error(`Fail to parse value '${value}' for '${jpTokenName}' as FAST design token.`);
      }
    }
  }
}
const heightNumber = cssPartial`(${baseHeightMultiplier} + ${density} + ${elementScale}) * ${designUnit}`;
const BaseButtonStyles = css`
  ${display("inline-flex")} :host {
    font-family: ${bodyFont};
    outline: none;
    font-size: ${typeRampBaseFontSize};
    line-height: ${typeRampBaseLineHeight};
    height: calc(${heightNumber} * 1px);
    min-width: calc(${heightNumber} * 1px);
    background-color: ${neutralFillRest};
    color: ${neutralForegroundRest};
    border-radius: calc(${controlCornerRadius} * 1px);
    fill: currentcolor;
    cursor: pointer;
    margin: calc((${focusStrokeWidth} + 2) * 1px);
  }

  .control {
    background: transparent;
    height: inherit;
    flex-grow: 1;
    box-sizing: border-box;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    padding: 0
      max(
        1px,
        calc((10 + (${designUnit} * 2 * (${density} + ${elementScale})))) * 1px
      );
    white-space: nowrap;
    outline: none;
    text-decoration: none;
    border: calc(${strokeWidth} * 1px) solid transparent;
    color: inherit;
    border-radius: inherit;
    fill: inherit;
    cursor: inherit;
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
  }

  :host(:hover) {
    background-color: ${neutralFillHover};
  }

  :host(:active) {
    background-color: ${neutralFillActive};
  }

  :host([aria-pressed='true']) {
    box-shadow: inset 0px 0px 2px 2px ${neutralFillStrongActive};
  }

  :host([minimal]),
  :host([scale='xsmall']) {
    --element-scale: -4;
  }

  :host([scale='small']) {
    --element-scale: -2;
  }

  :host([scale='medium']) {
    --element-scale: 0;
  }

  :host([scale='large']) {
    --element-scale: 2;
  }

  :host([scale='xlarge']) {
    --element-scale: 4;
  }

  /* prettier-ignore */
  .control:${focusVisible} {
      outline: calc(${focusStrokeWidth} * 1px) solid ${neutralFillStrongFocus};
      outline-offset: 2px;
      -moz-outline-radius: 0px;
    }

  .control::-moz-focus-inner {
    border: 0;
  }

  .start,
  .end {
    display: flex;
  }

  .control.icon-only {
    padding: 0;
    line-height: 0;
  }

  ::slotted(svg) {
    ${/* Glyph size and margin-left is temporary -
     replace when adaptive typography is figured out */
""} width: 16px;
    height: 16px;
    pointer-events: none;
  }

  .start {
    margin-inline-end: 11px;
  }

  .end {
    margin-inline-start: 11px;
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host .control {
      background-color: ${SystemColors.ButtonFace};
      border-color: ${SystemColors.ButtonText};
      color: ${SystemColors.ButtonText};
      fill: currentColor;
    }

    :host(:hover) .control {
      forced-color-adjust: none;
      background-color: ${SystemColors.Highlight};
      color: ${SystemColors.HighlightText};
    }

    /* prettier-ignore */
    .control:${focusVisible} {
          forced-color-adjust: none;
          background-color: ${SystemColors.Highlight};
          outline-color: ${SystemColors.ButtonText};
          color: ${SystemColors.HighlightText};
        }

    .control:hover,
    :host([appearance='outline']) .control:hover {
      border-color: ${SystemColors.ButtonText};
    }

    :host([href]) .control {
      border-color: ${SystemColors.LinkText};
      color: ${SystemColors.LinkText};
    }

    :host([href]) .control:hover,
        :host([href]) .control:${focusVisible} {
      forced-color-adjust: none;
      background: ${SystemColors.ButtonFace};
      outline-color: ${SystemColors.LinkText};
      color: ${SystemColors.LinkText};
      fill: currentColor;
    }
  `));
const AccentButtonStyles = css`
  :host([appearance='accent']) {
    background: ${accentFillRest};
    color: ${foregroundOnAccentRest};
  }

  :host([appearance='accent']:hover) {
    background: ${accentFillHover};
    color: ${foregroundOnAccentHover};
  }

  :host([appearance='accent'][aria-pressed='true']) {
    box-shadow: inset 0px 0px 2px 2px ${accentForegroundActive};
  }

  :host([appearance='accent']:active) .control:active {
    background: ${accentFillActive};
    color: ${foregroundOnAccentActive};
  }

  :host([appearance="accent"]) .control:${focusVisible} {
    outline-color: ${accentFillFocus};
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance='accent']) .control {
      forced-color-adjust: none;
      background: ${SystemColors.Highlight};
      color: ${SystemColors.HighlightText};
    }

    :host([appearance='accent']) .control:hover,
    :host([appearance='accent']:active) .control:active {
      background: ${SystemColors.HighlightText};
      border-color: ${SystemColors.Highlight};
      color: ${SystemColors.Highlight};
    }

    :host([appearance="accent"]) .control:${focusVisible} {
      outline-color: ${SystemColors.Highlight};
    }

    :host([appearance='accent'][href]) .control {
      background: ${SystemColors.LinkText};
      color: ${SystemColors.HighlightText};
    }

    :host([appearance='accent'][href]) .control:hover {
      background: ${SystemColors.ButtonFace};
      border-color: ${SystemColors.LinkText};
      box-shadow: none;
      color: ${SystemColors.LinkText};
      fill: currentColor;
    }

    :host([appearance="accent"][href]) .control:${focusVisible} {
      outline-color: ${SystemColors.HighlightText};
    }
  `));
const ErrorButtonStyles = css`
  :host([appearance='error']) {
    background: ${errorFillRest};
    color: ${foregroundOnAccentRest};
  }

  :host([appearance='error']:hover) {
    background: ${errorFillHover};
    color: ${foregroundOnAccentHover};
  }

  :host([appearance='error'][aria-pressed='true']) {
    box-shadow: inset 0px 0px 2px 2px ${errorForegroundActive};
  }

  :host([appearance='error']:active) .control:active {
    background: ${errorFillActive};
    color: ${foregroundOnAccentActive};
  }

  :host([appearance="error"]) .control:${focusVisible} {
    outline-color: ${errorFillFocus};
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance='error']) .control {
      forced-color-adjust: none;
      background: ${SystemColors.Highlight};
      color: ${SystemColors.HighlightText};
    }

    :host([appearance='error']) .control:hover,
    :host([appearance='error']:active) .control:active {
      background: ${SystemColors.HighlightText};
      border-color: ${SystemColors.Highlight};
      color: ${SystemColors.Highlight};
    }

    :host([appearance="error"]) .control:${focusVisible} {
      outline-color: ${SystemColors.Highlight};
    }

    :host([appearance='error'][href]) .control {
      background: ${SystemColors.LinkText};
      color: ${SystemColors.HighlightText};
    }

    :host([appearance='error'][href]) .control:hover {
      background: ${SystemColors.ButtonFace};
      border-color: ${SystemColors.LinkText};
      box-shadow: none;
      color: ${SystemColors.LinkText};
      fill: currentColor;
    }

    :host([appearance="error"][href]) .control:${focusVisible} {
      outline-color: ${SystemColors.HighlightText};
    }
  `));
css`
  :host([appearance='hypertext']) {
    font-size: inherit;
    line-height: inherit;
    height: auto;
    min-width: 0;
    background: transparent;
  }

  :host([appearance='hypertext']) .control {
    display: inline;
    padding: 0;
    border: none;
    box-shadow: none;
    border-radius: 0;
    line-height: 1;
  }

  :host a.control:not(:link) {
    background-color: transparent;
    cursor: default;
  }
  :host([appearance='hypertext']) .control:link,
  :host([appearance='hypertext']) .control:visited {
    background: transparent;
    color: ${accentForegroundRest};
    border-bottom: calc(${strokeWidth} * 1px) solid ${accentForegroundRest};
  }

  :host([appearance='hypertext']:hover),
  :host([appearance='hypertext']) .control:hover {
    background: transparent;
    border-bottom-color: ${accentForegroundHover};
  }

  :host([appearance='hypertext']:active),
  :host([appearance='hypertext']) .control:active {
    background: transparent;
    border-bottom-color: ${accentForegroundActive};
  }

  :host([appearance="hypertext"]) .control:${focusVisible} {
    outline-color: transparent;
    border-bottom: calc(${focusStrokeWidth} * 1px) solid ${focusStrokeOuter};
    margin-bottom: calc(calc(${strokeWidth} - ${focusStrokeWidth}) * 1px);
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance='hypertext']:hover) {
      background-color: ${SystemColors.ButtonFace};
      color: ${SystemColors.ButtonText};
    }
    :host([appearance="hypertext"][href]) .control:hover,
        :host([appearance="hypertext"][href]) .control:active,
        :host([appearance="hypertext"][href]) .control:${focusVisible} {
      color: ${SystemColors.LinkText};
      border-bottom-color: ${SystemColors.LinkText};
      box-shadow: none;
    }
  `));
const LightweightButtonStyles = css`
  :host([appearance='lightweight']) {
    background: transparent;
    color: ${accentForegroundRest};
  }

  :host([appearance='lightweight']) .control {
    padding: 0;
    height: initial;
    border: none;
    box-shadow: none;
    border-radius: 0;
  }

  :host([appearance='lightweight']:hover) {
    background: transparent;
    color: ${accentForegroundHover};
  }

  :host([appearance='lightweight']:active) {
    background: transparent;
    color: ${accentForegroundActive};
  }

  :host([appearance='lightweight']) .content {
    position: relative;
  }

  :host([appearance='lightweight']) .content::before {
    content: '';
    display: block;
    height: calc(${strokeWidth} * 1px);
    position: absolute;
    top: calc(1em + 4px);
    width: 100%;
  }

  :host([appearance='lightweight']:hover) .content::before {
    background: ${accentForegroundHover};
  }

  :host([appearance='lightweight']:active) .content::before {
    background: ${accentForegroundActive};
  }

  :host([appearance="lightweight"]) .control:${focusVisible} {
    outline-color: transparent;
  }

  :host([appearance="lightweight"]) .control:${focusVisible} .content::before {
    background: ${neutralForegroundRest};
    height: calc(${focusStrokeWidth} * 1px);
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance="lightweight"]) .control:hover,
        :host([appearance="lightweight"]) .control:${focusVisible} {
      forced-color-adjust: none;
      background: ${SystemColors.ButtonFace};
      color: ${SystemColors.Highlight};
    }
    :host([appearance="lightweight"]) .control:hover .content::before,
        :host([appearance="lightweight"]) .control:${focusVisible} .content::before {
      background: ${SystemColors.Highlight};
    }

    :host([appearance="lightweight"][href]) .control:hover,
        :host([appearance="lightweight"][href]) .control:${focusVisible} {
      background: ${SystemColors.ButtonFace};
      box-shadow: none;
      color: ${SystemColors.LinkText};
    }

    :host([appearance="lightweight"][href]) .control:hover .content::before,
        :host([appearance="lightweight"][href]) .control:${focusVisible} .content::before {
      background: ${SystemColors.LinkText};
    }
  `));
const OutlineButtonStyles = css`
  :host([appearance='outline']) {
    background: transparent;
    border-color: ${accentFillRest};
  }

  :host([appearance='outline']:hover) {
    border-color: ${accentFillHover};
  }

  :host([appearance='outline']:active) {
    border-color: ${accentFillActive};
  }

  :host([appearance='outline']) .control {
    border-color: inherit;
  }

  :host([appearance="outline"]) .control:${focusVisible} {
    outline-color: ${accentFillFocus};
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance='outline']) .control {
      border-color: ${SystemColors.ButtonText};
    }
    :host([appearance="outline"]) .control:${focusVisible} {
      forced-color-adjust: none;
      background-color: ${SystemColors.Highlight};
      outline-color: ${SystemColors.ButtonText};
      color: ${SystemColors.HighlightText};
      fill: currentColor;
    }
    :host([appearance='outline'][href]) .control {
      background: ${SystemColors.ButtonFace};
      border-color: ${SystemColors.LinkText};
      color: ${SystemColors.LinkText};
      fill: currentColor;
    }
    :host([appearance="outline"][href]) .control:hover,
        :host([appearance="outline"][href]) .control:${focusVisible} {
      forced-color-adjust: none;
      outline-color: ${SystemColors.LinkText};
    }
  `));
const StealthButtonStyles = css`
  :host([appearance='stealth']),
  :host([appearance='stealth'][disabled]:active),
  :host([appearance='stealth'][disabled]:hover) {
    background: transparent;
  }

  :host([appearance='stealth']:hover) {
    background: ${neutralFillStealthHover};
  }

  :host([appearance='stealth']:active) {
    background: ${neutralFillStealthActive};
  }

  :host([appearance='stealth']) .control:${focusVisible} {
    outline-color: ${accentFillFocus};
  }

  /* Make the focus outline displayed within the button if
     it is in a start or end slot; e.g. in a tree item
     This will make the focus outline bounded within the container.
   */
  :host([appearance='stealth'][slot="end"]) .control:${focusVisible},
  :host([appearance='stealth'][slot="start"]) .control:${focusVisible} {
    outline-offset: -2px;
  }
`.withBehaviors(forcedColorsStylesheetBehavior(css`
    :host([appearance='stealth']),
    :host([appearance='stealth']) .control {
      forced-color-adjust: none;
      background: ${SystemColors.ButtonFace};
      border-color: transparent;
      color: ${SystemColors.ButtonText};
      fill: currentColor;
    }

    :host([appearance='stealth']:hover) .control {
      background: ${SystemColors.Highlight};
      border-color: ${SystemColors.Highlight};
      color: ${SystemColors.HighlightText};
      fill: currentColor;
    }

    :host([appearance="stealth"]:${focusVisible}) .control {
      outline-color: ${SystemColors.Highlight};
      color: ${SystemColors.HighlightText};
      fill: currentColor;
    }

    :host([appearance='stealth'][href]) .control {
      color: ${SystemColors.LinkText};
    }

    :host([appearance="stealth"][href]:hover) .control,
        :host([appearance="stealth"][href]:${focusVisible}) .control {
      background: ${SystemColors.LinkText};
      border-color: ${SystemColors.LinkText};
      color: ${SystemColors.HighlightText};
      fill: currentColor;
    }

    :host([appearance="stealth"][href]:${focusVisible}) .control {
      forced-color-adjust: none;
      box-shadow: 0 0 0 1px ${SystemColors.LinkText};
    }
  `));
function appearanceBehavior(value, styles) {
  return new PropertyStyleSheetBehavior("appearance", value, styles);
}
const buttonStyles = (context, definition) => css`
    :host([disabled]),
    :host([disabled]:hover),
    :host([disabled]:active) {
      opacity: ${disabledOpacity};
      background-color: ${neutralFillRest};
      cursor: ${disabledCursor};
    }

    ${BaseButtonStyles}
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host([disabled]),
      :host([disabled]) .control,
      :host([disabled]:hover),
      :host([disabled]:active) {
        forced-color-adjust: none;
        background-color: ${SystemColors.ButtonFace};
        outline-color: ${SystemColors.GrayText};
        color: ${SystemColors.GrayText};
        cursor: ${disabledCursor};
        opacity: 1;
      }
    `), appearanceBehavior("accent", css`
        :host([appearance='accent'][disabled]),
        :host([appearance='accent'][disabled]:hover),
        :host([appearance='accent'][disabled]:active) {
          background: ${accentFillRest};
        }

        ${AccentButtonStyles}
      `.withBehaviors(forcedColorsStylesheetBehavior(css`
          :host([appearance='accent'][disabled]) .control,
          :host([appearance='accent'][disabled]) .control:hover {
            background: ${SystemColors.ButtonFace};
            border-color: ${SystemColors.GrayText};
            color: ${SystemColors.GrayText};
          }
        `))), appearanceBehavior("error", css`
        :host([appearance='error'][disabled]),
        :host([appearance='error'][disabled]:hover),
        :host([appearance='error'][disabled]:active) {
          background: ${errorFillRest};
        }

        ${ErrorButtonStyles}
      `.withBehaviors(forcedColorsStylesheetBehavior(css`
          :host([appearance='error'][disabled]) .control,
          :host([appearance='error'][disabled]) .control:hover {
            background: ${SystemColors.ButtonFace};
            border-color: ${SystemColors.GrayText};
            color: ${SystemColors.GrayText};
          }
        `))), appearanceBehavior("lightweight", css`
        :host([appearance='lightweight'][disabled]:hover),
        :host([appearance='lightweight'][disabled]:active) {
          background-color: transparent;
          color: ${accentForegroundRest};
        }

        :host([appearance='lightweight'][disabled]) .content::before,
        :host([appearance='lightweight'][disabled]:hover) .content::before,
        :host([appearance='lightweight'][disabled]:active) .content::before {
          background: transparent;
        }

        ${LightweightButtonStyles}
      `.withBehaviors(forcedColorsStylesheetBehavior(css`
          :host([appearance='lightweight'].disabled) .control {
            forced-color-adjust: none;
            color: ${SystemColors.GrayText};
          }

          :host([appearance='lightweight'].disabled)
            .control:hover
            .content::before {
            background: none;
          }
        `))), appearanceBehavior("outline", css`
        :host([appearance='outline'][disabled]),
        :host([appearance='outline'][disabled]:hover),
        :host([appearance='outline'][disabled]:active) {
          background: transparent;
          border-color: ${accentFillRest};
        }

        ${OutlineButtonStyles}
      `.withBehaviors(forcedColorsStylesheetBehavior(css`
          :host([appearance='outline'][disabled]) .control {
            border-color: ${SystemColors.GrayText};
          }
        `))), appearanceBehavior("stealth", css`
        ${StealthButtonStyles}
      `.withBehaviors(forcedColorsStylesheetBehavior(css`
          :host([appearance='stealth'][disabled]) {
            background: ${SystemColors.ButtonFace};
          }

          :host([appearance='stealth'][disabled]) .control {
            background: ${SystemColors.ButtonFace};
            border-color: transparent;
            color: ${SystemColors.GrayText};
          }
        `))));
class JupyterButton extends Button$1 {
  constructor() {
    super(...arguments);
    this.appearance = "neutral";
  }
  /**
   * Applies 'icon-only' class when there is only an SVG in the default slot
   *
   * @public
   * @remarks
   */
  defaultSlottedContentChanged(oldValue, newValue) {
    const slottedElements = this.defaultSlottedContent.filter((x2) => x2.nodeType === Node.ELEMENT_NODE);
    if (slottedElements.length === 1 && (slottedElements[0] instanceof SVGElement || slottedElements[0].classList.contains("fa") || slottedElements[0].classList.contains("fas"))) {
      this.control.classList.add("icon-only");
    } else {
      this.control.classList.remove("icon-only");
    }
  }
}
__decorate([
  attr
], JupyterButton.prototype, "appearance", void 0);
__decorate([
  attr({ attribute: "minimal", mode: "boolean" })
], JupyterButton.prototype, "minimal", void 0);
__decorate([
  attr
], JupyterButton.prototype, "scale", void 0);
const jpButton = JupyterButton.compose({
  baseName: "button",
  baseClass: Button$1,
  template: buttonTemplate,
  styles: buttonStyles,
  shadowOptions: {
    delegatesFocus: true
  }
});
const toolbarStyles = (context, definition) => css`
    ${display("inline-flex")} :host {
      --toolbar-item-gap: calc(
        (var(--design-unit) + calc(var(--density) + 2)) * 1px
      );
      background-color: ${fillColor};
      border-radius: calc(${controlCornerRadius} * 1px);
      fill: currentcolor;
      padding: var(--toolbar-item-gap);
    }

    :host(${focusVisible}) {
      outline: calc(${strokeWidth} * 1px) solid ${accentFillFocus};
    }

    .positioning-region {
      align-items: flex-start;
      display: inline-flex;
      flex-flow: row wrap;
      justify-content: flex-start;
      width: 100%;
      height: 100%;
    }

    :host([orientation='vertical']) .positioning-region {
      flex-direction: column;
    }

    ::slotted(:not([slot])) {
      flex: 0 0 auto;
      margin: 0 var(--toolbar-item-gap);
    }

    :host([orientation='vertical']) ::slotted(:not([slot])) {
      margin: var(--toolbar-item-gap) 0;
    }

    .start,
    .end {
      display: flex;
      margin: auto;
      margin-inline: 0;
    }

    ::slotted(svg) {
      /* TODO: adaptive typography https://github.com/microsoft/fast/issues/2432 */
      width: 16px;
      height: 16px;
    }
  `.withBehaviors(forcedColorsStylesheetBehavior(css`
      :host(:${focusVisible}) {
        box-shadow: 0 0 0 calc(${focusStrokeWidth} * 1px)
          ${SystemColors.Highlight};
        color: ${SystemColors.ButtonText};
        forced-color-adjust: none;
      }
    `));
const ToolbarArrowKeyMap = Object.freeze({
  [ArrowKeys.ArrowUp]: {
    [Orientation.vertical]: -1
  },
  [ArrowKeys.ArrowDown]: {
    [Orientation.vertical]: 1
  },
  [ArrowKeys.ArrowLeft]: {
    [Orientation.horizontal]: {
      [Direction$1.ltr]: -1,
      [Direction$1.rtl]: 1
    }
  },
  [ArrowKeys.ArrowRight]: {
    [Orientation.horizontal]: {
      [Direction$1.ltr]: 1,
      [Direction$1.rtl]: -1
    }
  }
});
class FoundationToolbar extends FoundationElement {
  constructor() {
    super(...arguments);
    this._activeIndex = 0;
    this.direction = Direction$1.ltr;
    this.orientation = Orientation.horizontal;
  }
  /**
   * The index of the currently focused element, clamped between 0 and the last element.
   *
   * @internal
   */
  get activeIndex() {
    Observable$1.track(this, "activeIndex");
    return this._activeIndex;
  }
  set activeIndex(value) {
    if (this.$fastController.isConnected) {
      this._activeIndex = limit(0, this.focusableElements.length - 1, value);
      Observable$1.notify(this, "activeIndex");
    }
  }
  slottedItemsChanged() {
    if (this.$fastController.isConnected) {
      this.reduceFocusableElements();
    }
  }
  /**
   * Set the activeIndex when a focusable element in the toolbar is clicked.
   *
   * @internal
   */
  mouseDownHandler(e) {
    var _a;
    const activeIndex = (_a = this.focusableElements) === null || _a === void 0 ? void 0 : _a.findIndex((x2) => x2.contains(e.target));
    if (activeIndex > -1 && this.activeIndex !== activeIndex) {
      this.setFocusedElement(activeIndex);
    }
    return true;
  }
  childItemsChanged(prev, next) {
    if (this.$fastController.isConnected) {
      this.reduceFocusableElements();
    }
  }
  /**
   * @internal
   */
  connectedCallback() {
    super.connectedCallback();
    this.direction = getDirection(this);
  }
  /**
   * When the toolbar receives focus, set the currently active element as focused.
   *
   * @internal
   */
  focusinHandler(e) {
    const relatedTarget = e.relatedTarget;
    if (!relatedTarget || this.contains(relatedTarget)) {
      return;
    }
    this.setFocusedElement();
  }
  /**
   * Determines a value that can be used to iterate a list with the arrow keys.
   *
   * @param this - An element with an orientation and direction
   * @param key - The event key value
   * @internal
   */
  getDirectionalIncrementer(key2) {
    var _a, _b, _c, _d, _e;
    return (
      // @ts-expect-error ToolbarArrowKeyMap has not index
      (_e = (_c = (_b = (_a = ToolbarArrowKeyMap[key2]) === null || _a === void 0 ? void 0 : _a[this.orientation]) === null || _b === void 0 ? void 0 : _b[this.direction]) !== null && _c !== void 0 ? _c : (
        // @ts-expect-error ToolbarArrowKeyMap has not index
        (_d = ToolbarArrowKeyMap[key2]) === null || _d === void 0 ? void 0 : _d[this.orientation]
      )) !== null && _e !== void 0 ? _e : 0
    );
  }
  /**
   * Handle keyboard events for the toolbar.
   *
   * @internal
   */
  keydownHandler(e) {
    const key2 = e.key;
    if (!(key2 in ArrowKeys) || e.defaultPrevented || e.shiftKey) {
      return true;
    }
    const incrementer = this.getDirectionalIncrementer(key2);
    if (!incrementer) {
      return !e.target.closest("[role=radiogroup]");
    }
    const nextIndex = this.activeIndex + incrementer;
    if (this.focusableElements[nextIndex]) {
      e.preventDefault();
    }
    this.setFocusedElement(nextIndex);
    return true;
  }
  /**
   * get all the slotted elements
   * @internal
   */
  get allSlottedItems() {
    return [
      ...this.start.assignedElements(),
      ...this.slottedItems,
      ...this.end.assignedElements()
    ];
  }
  /**
   * Prepare the slotted elements which can be focusable.
   *
   * @internal
   */
  reduceFocusableElements() {
    var _a;
    const previousFocusedElement = (_a = this.focusableElements) === null || _a === void 0 ? void 0 : _a[this.activeIndex];
    this.focusableElements = this.allSlottedItems.reduce(FoundationToolbar.reduceFocusableItems, []);
    const adjustedActiveIndex = this.focusableElements.indexOf(previousFocusedElement);
    this.activeIndex = Math.max(0, adjustedActiveIndex);
    this.setFocusableElements();
  }
  /**
   * Set the activeIndex and focus the corresponding control.
   *
   * @param activeIndex - The new index to set
   * @internal
   */
  setFocusedElement(activeIndex = this.activeIndex) {
    this.activeIndex = activeIndex;
    this.setFocusableElements();
    if (this.focusableElements[this.activeIndex] && // Don't focus the toolbar element if some event handlers moved
    // the focus on another element in the page.
    this.contains(document.activeElement)) {
      this.focusableElements[this.activeIndex].focus();
    }
  }
  /**
   * Reduce a collection to only its focusable elements.
   *
   * @param elements - Collection of elements to reduce
   * @param element - The current element
   *
   * @internal
   */
  static reduceFocusableItems(elements2, element) {
    var _a, _b, _c, _d;
    const isRoleRadio = element.getAttribute("role") === "radio";
    const isFocusableFastElement = (_b = (_a = element.$fastController) === null || _a === void 0 ? void 0 : _a.definition.shadowOptions) === null || _b === void 0 ? void 0 : _b.delegatesFocus;
    const hasFocusableShadow = Array.from((_d = (_c = element.shadowRoot) === null || _c === void 0 ? void 0 : _c.querySelectorAll("*")) !== null && _d !== void 0 ? _d : []).some((x2) => isFocusable(x2));
    if (!element.hasAttribute("disabled") && !element.hasAttribute("hidden") && (isFocusable(element) || isRoleRadio || isFocusableFastElement || hasFocusableShadow)) {
      elements2.push(element);
      return elements2;
    }
    if (element.childElementCount) {
      return elements2.concat(Array.from(element.children).reduce(FoundationToolbar.reduceFocusableItems, []));
    }
    return elements2;
  }
  /**
   * @internal
   */
  setFocusableElements() {
    if (this.$fastController.isConnected && this.focusableElements.length > 0) {
      this.focusableElements.forEach((element, index) => {
        element.tabIndex = this.activeIndex === index ? 0 : -1;
      });
    }
  }
}
__decorate([
  observable
], FoundationToolbar.prototype, "direction", void 0);
__decorate([
  attr
], FoundationToolbar.prototype, "orientation", void 0);
__decorate([
  observable
], FoundationToolbar.prototype, "slottedItems", void 0);
__decorate([
  observable
], FoundationToolbar.prototype, "slottedLabel", void 0);
__decorate([
  observable
], FoundationToolbar.prototype, "childItems", void 0);
class DelegatesARIAToolbar {
}
__decorate([
  attr({ attribute: "aria-labelledby" })
], DelegatesARIAToolbar.prototype, "ariaLabelledby", void 0);
__decorate([
  attr({ attribute: "aria-label" })
], DelegatesARIAToolbar.prototype, "ariaLabel", void 0);
applyMixins(DelegatesARIAToolbar, ARIAGlobalStatesAndProperties);
applyMixins(FoundationToolbar, StartEnd, DelegatesARIAToolbar);
let Toolbar$1 = class Toolbar2 extends FoundationToolbar {
  connectedCallback() {
    super.connectedCallback();
    const parent = composedParent(this);
    if (parent) {
      fillColor.setValueFor(this, (target2) => neutralFillLayerRecipe.getValueFor(target2).evaluate(target2, fillColor.getValueFor(parent)));
    }
  }
};
const jpToolbar = Toolbar$1.compose({
  baseName: "toolbar",
  baseClass: FoundationToolbar,
  template: toolbarTemplate,
  styles: toolbarStyles,
  shadowOptions: {
    delegatesFocus: true
  }
});
function provideJupyterDesignSystem(element) {
  return DesignSystem.getOrCreate(element).withPrefix("jp");
}
function useProperties(targetElement, propName, value) {
  reactExports.useEffect(() => {
    if (value !== void 0 && targetElement.current && targetElement.current[propName] !== value) {
      try {
        targetElement.current[propName] = value;
      } catch (e) {
        console.warn(e);
      }
    }
  }, [value, targetElement.current]);
}
provideJupyterDesignSystem().register(jpButton());
const Button = reactExports.forwardRef((props, forwardedRef) => {
  const ref2 = reactExports.useRef(null);
  const {
    className,
    minimal,
    appearance,
    form,
    formaction,
    formenctype,
    formmethod,
    formtarget,
    type,
    autofocus,
    formnovalidate,
    defaultSlottedContent,
    disabled,
    required: required3,
    ...filteredProps
  } = props;
  useProperties(ref2, "autofocus", props.autofocus);
  useProperties(ref2, "formnovalidate", props.formnovalidate);
  useProperties(ref2, "defaultSlottedContent", props.defaultSlottedContent);
  useProperties(ref2, "disabled", props.disabled);
  useProperties(ref2, "required", props.required);
  reactExports.useImperativeHandle(forwardedRef, () => ref2.current, [ref2.current]);
  return React.createElement(
    "jp-button",
    {
      ref: ref2,
      ...filteredProps,
      appearance: props.appearance,
      form: props.form,
      formaction: props.formaction,
      formenctype: props.formenctype,
      formmethod: props.formmethod,
      formtarget: props.formtarget,
      type: props.type,
      class: props.className,
      exportparts: props.exportparts,
      for: props.htmlFor,
      part: props.part,
      tabindex: props.tabIndex,
      minimal: props.minimal ? "" : void 0,
      style: { ...props.style }
    },
    props.children
  );
});
class ReactWidget extends Widget {
  constructor() {
    super();
    this._rootDOM = null;
  }
  /**
   * Creates a new `ReactWidget` that renders a constant element.
   * @param element React element to render.
   */
  static create(element) {
    return new class extends ReactWidget {
      render() {
        return element;
      }
    }();
  }
  /**
   * Called to update the state of the widget.
   *
   * The default implementation of this method triggers
   * VDOM based rendering by calling the `renderDOM` method.
   */
  onUpdateRequest(msg) {
    this.renderPromise = this.renderDOM();
  }
  /**
   * Called after the widget is attached to the DOM
   */
  onAfterAttach(msg) {
    MessageLoop.sendMessage(this, Widget.Msg.UpdateRequest);
  }
  /**
   * Called before the widget is detached from the DOM.
   */
  onBeforeDetach(msg) {
    if (this._rootDOM !== null) {
      this._rootDOM.unmount();
      this._rootDOM = null;
    }
  }
  /**
   * Render the React nodes to the DOM.
   *
   * @returns a promise that resolves when the rendering is done.
   */
  renderDOM() {
    return new Promise((resolve3) => {
      const vnode = this.render();
      if (this._rootDOM === null) {
        this._rootDOM = createRoot(this.node);
      }
      if (Array.isArray(vnode)) {
        this._rootDOM.render(vnode);
        requestIdleCallback(() => resolve3());
      } else if (vnode) {
        this._rootDOM.render(vnode);
        requestIdleCallback(() => resolve3());
      } else {
        this._rootDOM.unmount();
        this._rootDOM = null;
        requestIdleCallback(() => resolve3());
      }
    });
  }
}
provideJupyterDesignSystem().register([jpButton(), jpToolbar()]);
addJupyterLabThemeChangeListener();
const TOOLBAR_CLASS = "jp-Toolbar";
const TOOLBAR_ITEM_CLASS = "jp-Toolbar-item";
const TOOLBAR_OPENER_NAME = "toolbar-popup-opener";
const TOOLBAR_SPACER_CLASS = "jp-Toolbar-spacer";
class ToolbarLayout extends PanelLayout {
  constructor() {
    super(...arguments);
    this._dirty = false;
  }
  /**
   * A message handler invoked on a `'fit-request'` message.
   *
   * If any child widget is visible, expand the toolbar height to the normal
   * toolbar height.
   */
  onFitRequest(msg) {
    super.onFitRequest(msg);
    if (this.parent.isAttached) {
      if (some$1(this.widgets, (w) => !w.isHidden)) {
        this.parent.node.style.minHeight = "var(--jp-private-toolbar-height)";
        this.parent.removeClass("jp-Toolbar-micro");
      } else {
        this.parent.node.style.minHeight = "";
        this.parent.addClass("jp-Toolbar-micro");
      }
    }
    this._dirty = true;
    if (this.parent.parent) {
      MessageLoop.sendMessage(this.parent.parent, Widget.Msg.FitRequest);
    }
    if (this._dirty) {
      MessageLoop.sendMessage(this.parent, Widget.Msg.UpdateRequest);
    }
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   */
  onUpdateRequest(msg) {
    super.onUpdateRequest(msg);
    if (this.parent.isVisible) {
      this._dirty = false;
    }
  }
  /**
   * A message handler invoked on a `'child-shown'` message.
   */
  onChildShown(msg) {
    super.onChildShown(msg);
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'child-hidden'` message.
   */
  onChildHidden(msg) {
    super.onChildHidden(msg);
    this.parent.fit();
  }
  /**
   * A message handler invoked on a `'before-attach'` message.
   */
  onBeforeAttach(msg) {
    super.onBeforeAttach(msg);
    this.parent.fit();
  }
  /**
   * Attach a widget to the parent's DOM node.
   *
   * @param index - The current index of the widget in the layout.
   *
   * @param widget - The widget to attach to the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  attachWidget(index, widget) {
    super.attachWidget(index, widget);
    this.parent.fit();
  }
  /**
   * Detach a widget from the parent's DOM node.
   *
   * @param index - The previous index of the widget in the layout.
   *
   * @param widget - The widget to detach from the parent.
   *
   * #### Notes
   * This is a reimplementation of the superclass method.
   */
  detachWidget(index, widget) {
    super.detachWidget(index, widget);
    this.parent.fit();
  }
}
class Toolbar extends Widget {
  /**
   * Construct a new toolbar widget.
   */
  constructor(options = {}) {
    var _a, _b;
    super({ node: document.createElement("jp-toolbar") });
    this.addClass(TOOLBAR_CLASS);
    this.layout = (_a = options.layout) !== null && _a !== void 0 ? _a : new ToolbarLayout();
    this.noFocusOnClick = (_b = options.noFocusOnClick) !== null && _b !== void 0 ? _b : false;
  }
  /**
   * Get an iterator over the ordered toolbar item names.
   *
   * @returns An iterator over the toolbar item names.
   */
  names() {
    const layout = this.layout;
    return map$1(layout.widgets, (widget) => {
      return Private$h.nameProperty.get(widget);
    });
  }
  /**
   * Add an item to the end of the toolbar.
   *
   * @param name - The name of the widget to add to the toolbar.
   *
   * @param widget - The widget to add to the toolbar.
   *
   * @returns Whether the item was added to toolbar. Returns false if
   *   an item of the same name is already in the toolbar.
   *
   * #### Notes
   * The item can be removed from the toolbar by setting its parent to `null`.
   */
  addItem(name2, widget) {
    const layout = this.layout;
    return this.insertItem(layout.widgets.length, name2, widget);
  }
  /**
   * Insert an item into the toolbar at the specified index.
   *
   * @param index - The index at which to insert the item.
   *
   * @param name - The name of the item.
   *
   * @param widget - The widget to add.
   *
   * @returns Whether the item was added to the toolbar. Returns false if
   *   an item of the same name is already in the toolbar.
   *
   * #### Notes
   * The index will be clamped to the bounds of the items.
   * The item can be removed from the toolbar by setting its parent to `null`.
   */
  insertItem(index, name2, widget) {
    const existing = find$3(this.names(), (value) => value === name2);
    if (existing) {
      return false;
    }
    widget.addClass(TOOLBAR_ITEM_CLASS);
    const layout = this.layout;
    const j = Math.max(0, Math.min(index, layout.widgets.length));
    layout.insertWidget(j, widget);
    Private$h.nameProperty.set(widget, name2);
    widget.node.dataset["jpItemName"] = name2;
    if (this.noFocusOnClick) {
      widget.node.dataset["noFocusOnClick"] = "true";
    }
    return true;
  }
  /**
   * Insert an item into the toolbar at the after a target item.
   *
   * @param at - The target item to insert after.
   *
   * @param name - The name of the item.
   *
   * @param widget - The widget to add.
   *
   * @returns Whether the item was added to the toolbar. Returns false if
   *   an item of the same name is already in the toolbar.
   *
   * #### Notes
   * The index will be clamped to the bounds of the items.
   * The item can be removed from the toolbar by setting its parent to `null`.
   */
  insertAfter(at, name2, widget) {
    return this.insertRelative(at, 1, name2, widget);
  }
  /**
   * Insert an item into the toolbar at the before a target item.
   *
   * @param at - The target item to insert before.
   *
   * @param name - The name of the item.
   *
   * @param widget - The widget to add.
   *
   * @returns Whether the item was added to the toolbar. Returns false if
   *   an item of the same name is already in the toolbar.
   *
   * #### Notes
   * The index will be clamped to the bounds of the items.
   * The item can be removed from the toolbar by setting its parent to `null`.
   */
  insertBefore(at, name2, widget) {
    return this.insertRelative(at, 0, name2, widget);
  }
  /**
   * Insert an item relatively to an other item.
   */
  insertRelative(at, offset, name2, widget) {
    const nameWithIndex = map$1(this.names(), (name3, i2) => {
      return { name: name3, index: i2 };
    });
    const target2 = find$3(nameWithIndex, (x2) => x2.name === at);
    if (target2) {
      return this.insertItem(target2.index + offset, name2, widget);
    }
    return false;
  }
  /**
   * Handle the DOM events for the widget.
   *
   * @param event - The DOM event sent to the widget.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the dock panel's node. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "click":
        this.handleClick(event2);
        break;
    }
  }
  /**
   * Handle a DOM click event.
   */
  handleClick(event2) {
    event2.stopPropagation();
    if (event2.target instanceof HTMLLabelElement) {
      const forId = event2.target.getAttribute("for");
      if (forId && this.node.querySelector(`#${forId}`)) {
        return;
      }
    }
    if (this.node.contains(document.activeElement)) {
      return;
    }
    if (this.parent) {
      this.parent.activate();
    }
  }
  /**
   * Handle `after-attach` messages for the widget.
   */
  onAfterAttach(msg) {
    this.node.addEventListener("click", this);
  }
  /**
   * Handle `before-detach` messages for the widget.
   */
  onBeforeDetach(msg) {
    this.node.removeEventListener("click", this);
  }
}
class ReactiveToolbar extends Toolbar {
  /**
   * Construct a new toolbar widget.
   */
  constructor(options = {}) {
    super(options);
    this.popupOpener = new ToolbarPopupOpener();
    this._widgetWidths = /* @__PURE__ */ new Map();
    this._widgetPositions = /* @__PURE__ */ new Map();
    this._zoomChanged = true;
    this.insertItem(0, TOOLBAR_OPENER_NAME, this.popupOpener);
    this.popupOpener.hide();
    this._resizer = new Throttler(async (callTwice = false) => {
      await this._onResize(callTwice);
    }, 500);
  }
  /**
   * Dispose of the widget and its descendant widgets.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    if (this._resizer) {
      this._resizer.dispose();
    }
    super.dispose();
  }
  /**
   * Insert an item into the toolbar at the after a target item.
   *
   * @param at - The target item to insert after.
   *
   * @param name - The name of the item.
   *
   * @param widget - The widget to add.
   *
   * @returns Whether the item was added to the toolbar. Returns false if
   *   an item of the same name is already in the toolbar or if the target
   *   is the toolbar pop-up opener.
   *
   * #### Notes
   * The index will be clamped to the bounds of the items.
   * The item can be removed from the toolbar by setting its parent to `null`.
   */
  insertAfter(at, name2, widget) {
    if (at === TOOLBAR_OPENER_NAME) {
      return false;
    }
    return super.insertAfter(at, name2, widget);
  }
  /**
   * Insert an item relatively to an other item.
   */
  insertRelative(at, offset, name2, widget) {
    const targetPosition = this._widgetPositions.get(at);
    const position = (targetPosition !== null && targetPosition !== void 0 ? targetPosition : 0) + offset;
    return this.insertItem(position, name2, widget);
  }
  /**
   * Insert an item into the toolbar at the specified index.
   *
   * @param index - The index at which to insert the item.
   *
   * @param name - The name of the item.
   *
   * @param widget - The widget to add.
   *
   * @returns Whether the item was added to the toolbar. Returns false if
   *   an item of the same name is already in the toolbar.
   *
   * #### Notes
   * The index will be clamped to the bounds of the items.
   * The item can be removed from the toolbar by setting its parent to `null`.
   */
  insertItem(index, name2, widget) {
    var _a;
    let status;
    if (widget instanceof ToolbarPopupOpener) {
      status = super.insertItem(index, name2, widget);
    } else {
      const j = Math.max(0, Math.min(index, this.layout.widgets.length - 1));
      status = super.insertItem(j, name2, widget);
      if (j !== index) {
        index = Math.max(0, Math.min(index, this._widgetPositions.size));
      }
    }
    if (name2 !== TOOLBAR_OPENER_NAME && this._widgetPositions.get(name2) !== index) {
      const currentPosition = (_a = this._widgetPositions.get(name2)) !== null && _a !== void 0 ? _a : this._widgetPositions.size;
      this._widgetPositions.forEach((value, key2) => {
        if (key2 !== TOOLBAR_OPENER_NAME) {
          if (value >= index && value < currentPosition) {
            this._widgetPositions.set(key2, value + 1);
          } else if (value <= index && value > currentPosition) {
            this._widgetPositions.set(key2, value - 1);
          }
        }
      });
      this._widgetPositions.set(name2, index);
      if (this.isVisible) {
        void this._resizer.invoke();
      }
    }
    return status;
  }
  /**
   * A message handler invoked on an `'after-show'` message.
   *
   * Invokes resizing to ensure correct display of items.
   */
  onAfterShow(msg) {
    void this._resizer.invoke(true);
  }
  /**
   * A message handler invoked on a `'before-hide'` message.
   *
   * It will hide the pop-up panel
   */
  onBeforeHide(msg) {
    this.popupOpener.hidePopup();
    super.onBeforeHide(msg);
  }
  onResize(msg) {
    super.onResize(msg);
    const zoom = Math.round(window.outerWidth / window.innerWidth * 100);
    if (zoom !== this._zoom) {
      this._zoomChanged = true;
      this._zoom = zoom;
    }
    if (msg.width > 0 && this._resizer) {
      void this._resizer.invoke();
    }
  }
  /**
   * Move the toolbar items between the reactive toolbar and the popup toolbar,
   * depending on the width of the toolbar and the width of each item.
   *
   * @param callTwice - whether to call the function twice.
   *
   * **NOTES**
   * The `callTwice` parameter is useful when the toolbar is displayed the first time,
   * because the size of the items is unknown before their first rendering. The first
   * call will usually add all the items in the main toolbar, and the second call will
   * reorganize the items between the main toolbar and the popup toolbar.
   */
  async _onResize(callTwice = false) {
    if (!(this.parent && this.parent.isAttached)) {
      return;
    }
    const toolbarWidth = this.node.clientWidth;
    const opener = this.popupOpener;
    const openerWidth = 32;
    const toolbarPadding = 2 + 5;
    let width = opener.isHidden ? toolbarPadding : toolbarPadding + openerWidth;
    return this._getWidgetsToRemove(width, toolbarWidth, openerWidth).then(async (values) => {
      var _a, _b;
      let { width: width2, widgetsToRemove } = values;
      while (widgetsToRemove.length > 0) {
        const widget = widgetsToRemove.pop();
        const name2 = Private$h.nameProperty.get(widget);
        width2 -= this._widgetWidths.get(name2) || 0;
        const position = (_a = this._widgetPositions.get(name2)) !== null && _a !== void 0 ? _a : 0;
        let openerFirstIndex = this._widgetPositions.size;
        const openerFirst = opener.widgetAt(0);
        if (openerFirst) {
          const openerFirstName = Private$h.nameProperty.get(openerFirst);
          openerFirstIndex = (_b = this._widgetPositions.get(openerFirstName)) !== null && _b !== void 0 ? _b : openerFirstIndex;
        }
        const index = position - openerFirstIndex;
        opener.insertWidget(index, widget);
      }
      if (opener.widgetCount() > 0) {
        const widgetsToAdd = [];
        let index = 0;
        const widgetCount = opener.widgetCount();
        while (index < widgetCount) {
          let widget = opener.widgetAt(index);
          if (widget) {
            width2 += this._getWidgetWidth(widget);
            if (widgetCount - widgetsToAdd.length === 1) {
              width2 -= openerWidth;
            }
          } else {
            break;
          }
          if (width2 < toolbarWidth) {
            widgetsToAdd.push(widget);
          } else {
            break;
          }
          index++;
        }
        while (widgetsToAdd.length > 0) {
          const widget = widgetsToAdd.shift();
          const name2 = Private$h.nameProperty.get(widget);
          if (this._widgetPositions.has(name2)) {
            this.insertItem(this._widgetPositions.get(name2), name2, widget);
          } else {
            this.addItem(name2, widget);
          }
        }
      }
      if (opener.widgetCount() > 0) {
        opener.updatePopup();
        opener.show();
      } else {
        opener.hide();
      }
      if (callTwice) {
        await this._onResize();
      }
    }).catch((msg) => {
      console.error("Error while computing the ReactiveToolbar", msg);
    });
  }
  async _getWidgetsToRemove(width, toolbarWidth, openerWidth) {
    var _a;
    const opener = this.popupOpener;
    const widgets = [...this.layout.widgets];
    const toIndex = widgets.length - 1;
    const widgetsToRemove = [];
    let index = 0;
    while (index < toIndex) {
      const widget = widgets[index];
      const name2 = Private$h.nameProperty.get(widget);
      let widgetWidth;
      if (this._zoomChanged) {
        widgetWidth = await this._saveWidgetWidth(name2, widget);
      } else {
        widgetWidth = this._getWidgetWidth(widget) || await this._saveWidgetWidth(name2, widget);
      }
      width += widgetWidth;
      if (widgetsToRemove.length === 0 && opener.isHidden && width + openerWidth > toolbarWidth) {
        width += openerWidth;
      }
      if (width > toolbarWidth || ((_a = this._widgetPositions.get(name2)) !== null && _a !== void 0 ? _a : 0) > index) {
        widgetsToRemove.push(widget);
      }
      index++;
    }
    this._zoomChanged = false;
    return {
      width,
      widgetsToRemove
    };
  }
  async _saveWidgetWidth(name2, widget) {
    if (widget instanceof ReactWidget) {
      await widget.renderPromise;
    }
    const widgetWidth = widget.hasClass(TOOLBAR_SPACER_CLASS) ? 2 : widget.node.clientWidth;
    this._widgetWidths.set(name2, widgetWidth);
    return widgetWidth;
  }
  _getWidgetWidth(widget) {
    const widgetName = Private$h.nameProperty.get(widget);
    return this._widgetWidths.get(widgetName) || 0;
  }
}
(function(Toolbar3) {
  function createSpacerItem() {
    return new Private$h.Spacer();
  }
  Toolbar3.createSpacerItem = createSpacerItem;
})(Toolbar || (Toolbar = {}));
function ToolbarButtonComponent(props) {
  var _a, _b, _c;
  const handleClick = ((_a = props.noFocusOnClick) !== null && _a !== void 0 ? _a : false) ? void 0 : (event2) => {
    var _a2;
    if (event2.button === 0) {
      (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props);
      event2.target.focus();
    }
  };
  const handleMouseDown = ((_b = props.noFocusOnClick) !== null && _b !== void 0 ? _b : false) ? (event2) => {
    var _a2;
    if (event2.button === 0) {
      event2.preventDefault();
      (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
  } : void 0;
  const handleKeyDown = (event2) => {
    var _a2;
    const { key: key2 } = event2;
    if (key2 === "Enter" || key2 === " ") {
      (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props);
    }
  };
  const getTooltip = () => {
    if (props.enabled === false && props.disabledTooltip) {
      return props.disabledTooltip;
    } else if (props.pressed && props.pressedTooltip) {
      return props.pressedTooltip;
    } else {
      return props.tooltip || props.iconLabel;
    }
  };
  const title = getTooltip();
  const disabled = props.enabled === false;
  return reactExports.createElement(
    Button,
    { appearance: "stealth", className: props.className ? props.className + " jp-ToolbarButtonComponent" : "jp-ToolbarButtonComponent", "aria-disabled": disabled, "aria-label": props.label || title, "aria-pressed": props.pressed, ...props.dataset, disabled, onClick: handleClick, onMouseDown: handleMouseDown, onKeyDown: handleKeyDown, title },
    (props.icon || props.iconClass) && reactExports.createElement(LabIcon.resolveReact, { icon: props.pressed ? (_c = props.pressedIcon) !== null && _c !== void 0 ? _c : props.icon : props.icon, iconClass: (
      // add some extra classes for proper support of icons-as-css-background
      classes$1(props.iconClass, "jp-Icon")
    ), tag: null }),
    props.label && reactExports.createElement("span", { className: "jp-ToolbarButtonComponent-label" }, props.label)
  );
}
function addToolbarButtonClass(w) {
  w.addClass("jp-ToolbarButton");
  return w;
}
class ToolbarButton extends ReactWidget {
  /**
   * Creates a toolbar button
   * @param props props for underlying `ToolbarButton` component
   */
  constructor(props = {}) {
    var _a, _b;
    super();
    this.props = props;
    addToolbarButtonClass(this);
    this._enabled = (_a = props.enabled) !== null && _a !== void 0 ? _a : true;
    this._pressed = this._enabled && ((_b = props.pressed) !== null && _b !== void 0 ? _b : false);
    this._onClick = props.onClick;
  }
  /**
   * Sets the pressed state for the button
   * @param value true if button is pressed, false otherwise
   */
  set pressed(value) {
    if (this.enabled && value !== this._pressed) {
      this._pressed = value;
      this.update();
    }
  }
  /**
   * Returns true if button is pressed, false otherwise
   */
  get pressed() {
    return this._pressed;
  }
  /**
   * Sets the enabled state for the button
   * @param value true to enable the button, false otherwise
   */
  set enabled(value) {
    if (value != this._enabled) {
      this._enabled = value;
      if (!this._enabled) {
        this._pressed = false;
      }
      this.update();
    }
  }
  /**
   * Returns true if button is enabled, false otherwise
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the click handler for the button
   * @param value click handler
   */
  set onClick(value) {
    if (value !== this._onClick) {
      this._onClick = value;
      this.update();
    }
  }
  /**
   * Returns the click handler for the button
   */
  get onClick() {
    return this._onClick;
  }
  render() {
    return reactExports.createElement(ToolbarButtonComponent, { ...this.props, noFocusOnClick: this.props.noFocusOnClick, pressed: this.pressed, enabled: this.enabled, onClick: this.onClick });
  }
}
class ToolbarPopup extends Widget {
  /**
   *  Construct a new ToolbarPopup
   */
  constructor() {
    super({ node: document.createElement("jp-toolbar") });
    this.width = 0;
    this.addClass("jp-Toolbar");
    this.addClass("jp-Toolbar-responsive-popup");
    this.addClass("jp-ThemedContainer");
    this.layout = new PanelLayout();
    Widget.attach(this, document.body);
    this.hide();
  }
  /**
   * Updates the width of the popup, this
   * should match with the toolbar width
   *
   * @param width - The width to resize to
   * @protected
   */
  updateWidth(width) {
    if (width > 0) {
      this.width = width;
      this.node.style.width = `${width}px`;
    }
  }
  /**
   * Aligns the popup to left bottom of widget
   *
   * @param widget the widget to align to
   * @private
   */
  alignTo(widget) {
    const { height: widgetHeight, width: widgetWidth, x: widgetX, y: widgetY } = widget.node.getBoundingClientRect();
    const width = this.width;
    this.node.style.left = `${widgetX + widgetWidth - width + 1}px`;
    this.node.style.top = `${widgetY + widgetHeight + 1}px`;
  }
  /**
   * Inserts the widget at specified index
   * @param index the index
   * @param widget widget to add
   */
  insertWidget(index, widget) {
    this.layout.insertWidget(index, widget);
  }
  /**
   *  Total number of widgets in the popup
   */
  widgetCount() {
    return this.layout.widgets.length;
  }
  /**
   * Returns the widget at index
   * @param index the index
   */
  widgetAt(index) {
    return this.layout.widgets[index];
  }
}
class ToolbarPopupOpener extends ToolbarButton {
  /**
   *  Create a new popup opener
   */
  constructor(props = {}) {
    const trans = (props.translator || nullTranslator).load("jupyterlab");
    super({
      icon: ellipsesIcon,
      onClick: () => {
        this.handleClick();
      },
      tooltip: trans.__("More commands")
    });
    this.addClass("jp-Toolbar-responsive-opener");
    this.popup = new ToolbarPopup();
  }
  /**
   * Add widget to the popup, prepends widgets
   * @param widget the widget to add
   */
  addWidget(widget) {
    this.popup.insertWidget(0, widget);
  }
  /**
   * Insert widget to the popup.
   * @param widget the widget to add
   */
  insertWidget(index, widget) {
    this.popup.insertWidget(index, widget);
  }
  /**
   * Dispose of the widget and its descendant widgets.
   *
   * #### Notes
   * It is unsafe to use the widget after it has been disposed.
   *
   * All calls made to this method after the first are a no-op.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.popup.dispose();
    super.dispose();
  }
  /**
   * Hides the opener and the popup
   */
  hide() {
    super.hide();
    this.hidePopup();
  }
  /**
   * Hides the popup
   */
  hidePopup() {
    this.popup.hide();
  }
  /**
   *  Updates width and position of the popup
   *  to align with the toolbar
   */
  updatePopup() {
    this.popup.updateWidth(this.parent.node.clientWidth);
    this.popup.alignTo(this.parent);
  }
  /**
   * Returns widget at index in the popup
   * @param index
   */
  widgetAt(index) {
    return this.popup.widgetAt(index);
  }
  /**
   * Returns total number of widgets in the popup
   *
   * @returns Number of widgets
   */
  widgetCount() {
    return this.popup.widgetCount();
  }
  handleClick() {
    this.updatePopup();
    this.popup.setHidden(!this.popup.isHidden);
  }
}
var Private$h;
(function(Private2) {
  function propsFromCommand(options) {
    var _a, _b;
    const { commands, id, args } = options;
    const iconClass = commands.iconClass(id, args);
    const iconLabel = commands.iconLabel(id, args);
    const icon = (_a = options.icon) !== null && _a !== void 0 ? _a : commands.icon(id, args);
    const label = commands.label(id, args);
    let className = commands.className(id, args);
    let pressed;
    if (commands.isToggleable(id, args)) {
      pressed = commands.isToggled(id, args);
      if (pressed) {
        className += " lm-mod-toggled";
      }
    }
    if (!commands.isVisible(id, args)) {
      className += " lm-mod-hidden";
    }
    const labelOverride = typeof options.label === "function" ? options.label(args !== null && args !== void 0 ? args : {}) : options.label;
    let tooltip = commands.caption(id, args) || labelOverride || label || iconLabel;
    const binding = commands.keyBindings.find((b) => b.command === id);
    if (binding) {
      const ks = binding.keys.map(CommandRegistry.formatKeystroke).join(", ");
      tooltip = `${tooltip} (${ks})`;
    }
    const onClick = () => {
      void commands.execute(id, args);
    };
    const enabled = commands.isEnabled(id, args);
    return {
      className,
      dataset: { "data-command": options.id },
      noFocusOnClick: options.noFocusOnClick,
      icon,
      iconClass,
      tooltip: (_b = options.caption) !== null && _b !== void 0 ? _b : tooltip,
      onClick,
      enabled,
      label: labelOverride !== null && labelOverride !== void 0 ? labelOverride : label,
      pressed
    };
  }
  Private2.propsFromCommand = propsFromCommand;
  Private2.nameProperty = new AttachedProperty({
    name: "name",
    create: () => ""
  });
  class Spacer extends Widget {
    /**
     * Construct a new spacer widget.
     */
    constructor() {
      super();
      this.addClass(TOOLBAR_SPACER_CLASS);
    }
  }
  Private2.Spacer = Spacer;
})(Private$h || (Private$h = {}));
class Spinner extends Widget {
  /**
   * Construct a spinner widget.
   */
  constructor() {
    super();
    this.addClass("jp-Spinner");
    this.node.tabIndex = -1;
    const content = document.createElement("div");
    content.className = "jp-SpinnerContent";
    this.node.appendChild(content);
  }
  /**
   * Handle `'activate-request'` messages.
   */
  onActivateRequest(msg) {
    this.node.focus();
  }
}
var Styling;
(function(Styling2) {
  function styleNode(node2, className = "") {
    styleNodeByTag(node2, "select", className);
    styleNodeByTag(node2, "textarea", className);
    styleNodeByTag(node2, "input", className);
    styleNodeByTag(node2, "button", className);
  }
  Styling2.styleNode = styleNode;
  function styleNodeByTag(node2, tagName, className = "") {
    if (node2.localName === tagName) {
      node2.classList.add("jp-mod-styled");
    }
    if (node2.localName === "select") {
      const multiple = node2.hasAttribute("multiple");
      wrapSelect(node2, multiple);
    }
    const nodes = node2.getElementsByTagName(tagName);
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const child = nodes[i2];
      child.classList.add("jp-mod-styled");
      if (className) {
        child.classList.add(className);
      }
      if (tagName === "select") {
        const multiple = child.hasAttribute("multiple");
        wrapSelect(child, multiple);
      }
    }
  }
  Styling2.styleNodeByTag = styleNodeByTag;
  function wrapSelect(node2, multiple) {
    const wrapper = document.createElement("div");
    wrapper.classList.add("jp-select-wrapper");
    node2.addEventListener("focus", Private$g.onFocus);
    node2.addEventListener("blur", Private$g.onFocus);
    node2.classList.add("jp-mod-styled");
    if (node2.parentElement) {
      node2.parentElement.replaceChild(wrapper, node2);
    }
    wrapper.appendChild(node2);
    if (multiple) {
      wrapper.classList.add("multiple");
    } else {
      wrapper.appendChild(caretDownEmptyIcon.element({
        tag: "span",
        stylesheet: "select",
        right: "8px",
        top: "5px",
        width: "18px"
      }));
    }
    return wrapper;
  }
  Styling2.wrapSelect = wrapSelect;
})(Styling || (Styling = {}));
var Private$g;
(function(Private2) {
  function onFocus(event2) {
    const target2 = event2.target;
    const parent = target2.parentElement;
    if (!parent) {
      return;
    }
    if (event2.type === "focus") {
      parent.classList.add("jp-mod-focused");
    } else {
      parent.classList.remove("jp-mod-focused");
    }
  }
  Private2.onFocus = onFocus;
})(Private$g || (Private$g = {}));
const MAXIMUM_TIME_REMAINING$1 = 100;
let passiveIfSupported = false;
try {
  window.addEventListener("test", null, Object.defineProperty({}, "passive", {
    get: function() {
      passiveIfSupported = { passive: true };
    }
  }));
} catch (err) {
}
class WindowedListModel {
  /**
   * Constructor
   *
   * @param options Constructor options
   */
  constructor(options = {}) {
    var _a, _b, _c, _d, _e, _f;
    this.scrollDownThreshold = 1;
    this.scrollUpThreshold = 0;
    this.paddingTop = 0;
    this._estimatedWidgetSize = WindowedList.DEFAULT_WIDGET_SIZE;
    this._stateChanged = new Signal(this);
    this._currentWindow = [-1, -1, -1, -1];
    this._height = 0;
    this._isDisposed = false;
    this._itemsList = null;
    this._measuredAllUntilIndex = -1;
    this._overscanCount = 1;
    this._scrollOffset = 0;
    this._widgetCount = 0;
    this._widgetSizers = [];
    this._windowingActive = true;
    this._widgetCount = (_c = (_b = (_a = options.itemsList) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : options.count) !== null && _c !== void 0 ? _c : 0;
    this._overscanCount = (_d = options.overscanCount) !== null && _d !== void 0 ? _d : 1;
    this._windowingActive = (_e = options.windowingActive) !== null && _e !== void 0 ? _e : true;
    this.itemsList = (_f = options.itemsList) !== null && _f !== void 0 ? _f : null;
  }
  /**
   * List widget height
   */
  get height() {
    return this._height;
  }
  set height(h2) {
    this._height = h2;
  }
  /**
   * Test whether the model is disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Items list to be rendered
   */
  get itemsList() {
    return this._itemsList;
  }
  set itemsList(v) {
    var _a, _b, _c;
    if (this._itemsList !== v) {
      if (this._itemsList) {
        this._itemsList.changed.disconnect(this.onListChanged, this);
      }
      const oldValue = this._itemsList;
      this._itemsList = v;
      if (this._itemsList) {
        this._itemsList.changed.connect(this.onListChanged, this);
      } else {
        this._widgetCount = 0;
      }
      this._stateChanged.emit({
        name: "list",
        newValue: this._itemsList,
        oldValue
      });
      this._stateChanged.emit({
        name: "count",
        newValue: (_b = (_a = this._itemsList) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,
        oldValue: (_c = oldValue === null || oldValue === void 0 ? void 0 : oldValue.length) !== null && _c !== void 0 ? _c : 0
      });
    }
  }
  /**
   * Number of widgets to render in addition to those
   * visible in the viewport.
   */
  get overscanCount() {
    return this._overscanCount;
  }
  set overscanCount(newValue) {
    if (newValue >= 1) {
      if (this._overscanCount !== newValue) {
        const oldValue = this._overscanCount;
        this._overscanCount = newValue;
        this._stateChanged.emit({ name: "overscanCount", newValue, oldValue });
      }
    } else {
      console.error(`Forbidden non-positive overscan count: got ${newValue}`);
    }
  }
  /**
   * Viewport scroll offset.
   */
  get scrollOffset() {
    return this._scrollOffset;
  }
  set scrollOffset(offset) {
    this._scrollOffset = offset;
  }
  /**
   * Total number of widgets in the list
   */
  get widgetCount() {
    return this._itemsList ? this._itemsList.length : this._widgetCount;
  }
  set widgetCount(newValue) {
    if (this.itemsList) {
      console.error("It is not allow to change the widgets count of a windowed list if a items list is used.");
      return;
    }
    if (newValue >= 0) {
      if (this._widgetCount !== newValue) {
        const oldValue = this._widgetCount;
        this._widgetCount = newValue;
        this._stateChanged.emit({ name: "count", newValue, oldValue });
      }
    } else {
      console.error(`Forbidden negative widget count: got ${newValue}`);
    }
  }
  /**
   * Whether windowing is active or not.
   *
   * This is true by default.
   */
  get windowingActive() {
    return this._windowingActive;
  }
  set windowingActive(newValue) {
    if (newValue !== this._windowingActive) {
      const oldValue = this._windowingActive;
      this._windowingActive = newValue;
      this._currentWindow = [-1, -1, -1, -1];
      this._measuredAllUntilIndex = -1;
      this._widgetSizers = [];
      this._stateChanged.emit({ name: "windowingActive", newValue, oldValue });
    }
  }
  /**
   * A signal emitted when any model state changes.
   */
  get stateChanged() {
    return this._stateChanged;
  }
  /**
   * Dispose the model.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._isDisposed = true;
    Signal.clearData(this);
  }
  /**
   * Get the total list size.
   *
   * @returns Total estimated size
   */
  getEstimatedTotalSize() {
    let totalSizeOfInitialItems = 0;
    if (this._measuredAllUntilIndex >= this.widgetCount) {
      this._measuredAllUntilIndex = this.widgetCount - 1;
    }
    if (this._measuredAllUntilIndex >= 0) {
      const itemMetadata = this._widgetSizers[this._measuredAllUntilIndex];
      totalSizeOfInitialItems = itemMetadata.offset + itemMetadata.size;
    }
    let totalSizeOfRemainingItems = 0;
    for (let i2 = this._measuredAllUntilIndex + 1; i2 < this.widgetCount; i2++) {
      const sizer = this._widgetSizers[i2];
      totalSizeOfRemainingItems += (sizer === null || sizer === void 0 ? void 0 : sizer.measured) ? sizer.size : this.estimateWidgetSize(i2);
    }
    return totalSizeOfInitialItems + totalSizeOfRemainingItems;
  }
  /**
   * Get the scroll offset to display an item in the viewport.
   *
   * By default, the list will scroll as little as possible to ensure the item is fully visible (`auto`).
   * You can control the alignment of the item though by specifying a second alignment parameter.
   * Acceptable values are:
   *
   *   auto - Automatically align with the top or bottom minimising the amount scrolled,
   *          If `alignPreference` is given, follow such preferred alignment.
   *          If item is smaller than the viewport and fully visible, do not scroll at all.
   *   smart - If the item is significantly visible, don't scroll at all (regardless of whether it fits in the viewport).
   *           If the item is less than one viewport away, scroll so that it becomes fully visible (following the `auto` heuristics).
   *           If the item is more than one viewport away, scroll so that it is centered within the viewport (`center` if smaller than viewport, `top-center` otherwise).
   *   center - Align the middle of the item with the middle of the viewport (it only works well for items smaller than the viewport).
   *   top-center - Align the top of the item with the middle of the viewport (works well for items larger than the viewport).
   *   end - Align the bottom of the item to the bottom of the list.
   *   start - Align the top of item to the top of the list.
   *
   * An item is considered significantly visible if:
   *  - it overlaps with the viewport by the amount specified by `scrollDownThreshold` when below the viewport
   *  - it exceeds the viewport by the amount less than specified by `scrollUpThreshold` when above the viewport.
   *
   * @param index Item index
   * @param align Where to align the item in the viewport
   * @param margin The proportion of viewport to add when aligning with the top/bottom of the list.
   * @param precomputed Precomputed values to use when windowing is disabled.
   * @param alignPreference Allows to override the alignment of item when the `auto` heuristic decides that the item needs to be scrolled into view.
   * @returns The needed scroll offset
   */
  getOffsetForIndexAndAlignment(index, align = "auto", margin = 0, precomputed, alignPreference) {
    const boundedMargin = Math.min(Math.max(0, margin), 1);
    const size2 = this._height;
    const itemMetadata = precomputed ? precomputed.itemMetadata : this._getItemMetadata(index);
    const scrollDownThreshold = this.scrollDownThreshold <= 1 ? itemMetadata.size * this.scrollDownThreshold : this.scrollDownThreshold;
    const scrollUpThreshold = this.scrollUpThreshold <= 1 ? itemMetadata.size * this.scrollUpThreshold : this.scrollUpThreshold;
    const estimatedTotalSize = precomputed ? precomputed.totalSize : this.getEstimatedTotalSize();
    const topOffset = Math.max(0, Math.min(estimatedTotalSize - size2, itemMetadata.offset));
    const bottomOffset = Math.max(0, itemMetadata.offset - size2 + itemMetadata.size);
    const currentOffset = precomputed ? precomputed.currentOffset : this._scrollOffset;
    const viewportPadding = this._windowingActive ? this.paddingTop : 0;
    const itemTop = itemMetadata.offset;
    const itemBottom = itemMetadata.offset + itemMetadata.size;
    const bottomEdge = currentOffset - viewportPadding + size2;
    const topEdge = currentOffset - viewportPadding;
    const crossingBottomEdge = bottomEdge > itemTop && bottomEdge < itemBottom;
    const crossingTopEdge = topEdge > itemTop && topEdge < itemBottom;
    const isFullyWithinViewport = bottomEdge > itemBottom && topEdge < itemTop;
    if (align === "smart") {
      const edgeLessThanOneViewportAway = currentOffset >= bottomOffset - size2 && currentOffset <= topOffset + size2;
      const visiblePartBottom = bottomEdge - itemTop;
      const hiddenPartTop = topEdge - itemTop;
      if (isFullyWithinViewport || crossingBottomEdge && visiblePartBottom >= scrollDownThreshold || crossingTopEdge && hiddenPartTop < scrollUpThreshold) {
        return currentOffset;
      } else if (edgeLessThanOneViewportAway) {
        align = "auto";
      } else {
        if (itemMetadata.size > size2) {
          align = "top-center";
        } else {
          align = "center";
        }
      }
    }
    if (align === "auto") {
      if (isFullyWithinViewport) {
        return currentOffset;
      } else if (alignPreference !== void 0) {
        align = alignPreference;
      } else if (crossingBottomEdge || bottomEdge <= itemBottom) {
        align = "end";
      } else {
        align = "start";
      }
    }
    switch (align) {
      case "start":
        return Math.max(0, topOffset - boundedMargin * size2) + viewportPadding;
      case "end":
        return bottomOffset + boundedMargin * size2 + viewportPadding;
      case "center":
        return bottomOffset + (topOffset - bottomOffset) / 2;
      case "top-center":
        return topOffset - size2 / 2;
    }
  }
  /**
   * Compute the items range to display.
   *
   * It returns ``null`` if the range does not need to be updated.
   *
   * @returns The current items range to display
   */
  getRangeToRender() {
    let newWindowIndex = [
      0,
      Math.max(this.widgetCount - 1, -1),
      0,
      Math.max(this.widgetCount - 1, -1)
    ];
    const previousLastMeasuredIndex = this._measuredAllUntilIndex;
    if (this.windowingActive) {
      newWindowIndex = this._getRangeToRender();
    }
    const [startIndex, stopIndex] = newWindowIndex;
    if (previousLastMeasuredIndex <= stopIndex || this._currentWindow[0] !== startIndex || this._currentWindow[1] !== stopIndex) {
      this._currentWindow = newWindowIndex;
      return newWindowIndex;
    }
    return null;
  }
  /**
   * Return the viewport top position and height for range spanning from
   * ``startIndex`` to ``stopIndex``.
   *
   * @param startIndex First item in viewport index
   * @param stopIndex Last item in viewport index
   * @returns The viewport top position and its height
   */
  getSpan(startIndex, stopIndex) {
    const startSizer = this._getItemMetadata(startIndex);
    const top2 = startSizer.offset;
    const stopSizer = this._getItemMetadata(stopIndex);
    const height = stopSizer.offset - startSizer.offset + stopSizer.size;
    return [top2, height];
  }
  /**
   * WindowedListModel caches offsets and measurements for each index for performance purposes.
   * This method clears that cached data for all items after (and including) the specified index.
   *
   * The list will automatically re-render after the index is reset.
   *
   * @param index
   */
  resetAfterIndex(index) {
    const oldValue = this._measuredAllUntilIndex;
    this._measuredAllUntilIndex = Math.min(index, this._measuredAllUntilIndex);
    for (const [i2, sizer] of this._widgetSizers.entries()) {
      if (i2 === 0) {
        continue;
      }
      const previous = this._widgetSizers[i2 - 1];
      sizer.offset = previous.offset + previous.size;
    }
    if (this._measuredAllUntilIndex !== oldValue) {
      this._stateChanged.emit({ name: "index", newValue: index, oldValue });
    }
  }
  /**
   * Update item sizes.
   *
   * This should be called when the real item sizes has been
   * measured.
   *
   * @param sizes New sizes per item index
   * @returns Whether some sizes changed or not
   */
  setWidgetSize(sizes) {
    if (this._windowingActive || this._currentWindow[0] >= 0) {
      let minIndex = Infinity;
      let measuredAllItemsUntil = -1;
      let offsetDelta = 0;
      let allPreviousMeasured = true;
      const sizesMap = new Map(sizes.map((i2) => [i2.index, i2.size]));
      const highestIndex = Math.max(...sizesMap.keys());
      const entries = [
        ...this._widgetSizers.entries()
      ];
      for (let i2 = this._widgetSizers.length; i2 <= highestIndex; i2++) {
        entries.push([i2, null]);
      }
      for (let [index, sizer] of entries) {
        const measuredSize = sizesMap.get(index);
        let itemDelta = 0;
        const hadSizer = !!sizer;
        if (!sizer) {
          const previous = this._widgetSizers[index - 1];
          const newSizer = {
            offset: previous ? previous.offset + previous.size : 0,
            size: measuredSize !== void 0 ? measuredSize : this.estimateWidgetSize(index),
            measured: measuredSize !== void 0
          };
          this._widgetSizers[index] = newSizer;
          sizer = newSizer;
        }
        if (measuredSize !== void 0) {
          if (sizer.size != measuredSize) {
            itemDelta = measuredSize - sizer.size;
            sizer.size = measuredSize;
            minIndex = Math.min(minIndex, index);
          }
          sizer.measured = true;
        }
        if (allPreviousMeasured) {
          if (sizer.measured) {
            measuredAllItemsUntil = index;
          } else {
            allPreviousMeasured = false;
          }
        }
        if (hadSizer && offsetDelta !== 0) {
          sizer.offset += offsetDelta;
        }
        offsetDelta += itemDelta;
      }
      if (measuredAllItemsUntil !== -1) {
        this._measuredAllUntilIndex = measuredAllItemsUntil;
      }
      if (minIndex !== Infinity) {
        return true;
      }
    }
    return false;
  }
  /**
   * Callback on list changes
   *
   * @param list List items
   * @param changes List change
   */
  onListChanged(list2, changes) {
    switch (changes.type) {
      case "add":
        this._widgetSizers.splice(changes.newIndex, 0, ...new Array(changes.newValues.length).fill(void 0).map((_, i2) => {
          return { offset: 0, size: this.estimateWidgetSize(i2) };
        }));
        this.resetAfterIndex(changes.newIndex - 1);
        break;
      case "move":
        ArrayExt.move(this._widgetSizers, changes.oldIndex, changes.newIndex);
        this.resetAfterIndex(Math.min(changes.newIndex, changes.oldIndex) - 1);
        break;
      case "remove":
        this._widgetSizers.splice(changes.oldIndex, changes.oldValues.length);
        this.resetAfterIndex(changes.oldIndex - 1);
        break;
      case "set":
        this.resetAfterIndex(changes.newIndex - 1);
        break;
    }
  }
  _getItemMetadata(index) {
    var _a, _b;
    if (index > this._measuredAllUntilIndex) {
      let offset = 0;
      if (this._measuredAllUntilIndex >= 0) {
        const itemMetadata = this._widgetSizers[this._measuredAllUntilIndex];
        offset = itemMetadata.offset + itemMetadata.size;
      }
      for (let i2 = this._measuredAllUntilIndex + 1; i2 <= index; i2++) {
        let size2 = ((_a = this._widgetSizers[i2]) === null || _a === void 0 ? void 0 : _a.measured) ? this._widgetSizers[i2].size : this.estimateWidgetSize(i2);
        this._widgetSizers[i2] = {
          offset,
          size: size2,
          measured: (_b = this._widgetSizers[i2]) === null || _b === void 0 ? void 0 : _b.measured
        };
        offset += size2;
      }
      this._measuredAllUntilIndex = index;
    }
    for (let i2 = 0; i2 <= this._measuredAllUntilIndex; i2++) {
      const sizer = this._widgetSizers[i2];
      if (i2 === 0) {
        if (sizer.offset !== 0) {
          throw new Error("First offset is not null");
        }
      } else {
        const previous = this._widgetSizers[i2 - 1];
        if (sizer.offset !== previous.offset + previous.size) {
          throw new Error(`Sizer ${i2} has incorrect offset.`);
        }
      }
    }
    return this._widgetSizers[index];
  }
  _findNearestItem(offset) {
    const lastContinouslyMeasuredItemOffset = this._measuredAllUntilIndex > 0 ? this._widgetSizers[this._measuredAllUntilIndex].offset : 0;
    if (lastContinouslyMeasuredItemOffset >= offset) {
      return this._findNearestItemBinarySearch(this._measuredAllUntilIndex, 0, offset);
    } else {
      return this._findNearestItemExponentialSearch(Math.max(0, this._measuredAllUntilIndex), offset);
    }
  }
  _findNearestItemBinarySearch(high, low, offset) {
    while (low <= high) {
      const middle = low + Math.floor((high - low) / 2);
      const currentOffset = this._getItemMetadata(middle).offset;
      if (currentOffset === offset) {
        return middle;
      } else if (currentOffset < offset) {
        low = middle + 1;
      } else if (currentOffset > offset) {
        high = middle - 1;
      }
    }
    if (low > 0) {
      return low - 1;
    } else {
      return 0;
    }
  }
  _findNearestItemExponentialSearch(index, offset) {
    let interval = 1;
    while (index < this.widgetCount && this._getItemMetadata(index).offset < offset) {
      index += interval;
      interval *= 2;
    }
    return this._findNearestItemBinarySearch(Math.min(index, this.widgetCount - 1), Math.floor(index / 2), offset);
  }
  _getRangeToRender() {
    const widgetCount = this.widgetCount;
    if (widgetCount === 0) {
      return [-1, -1, -1, -1];
    }
    const startIndex = this._getStartIndexForOffset(this._scrollOffset);
    const stopIndex = this._getStopIndexForStartIndex(startIndex, this._scrollOffset);
    const overscanBackward = Math.max(1, this.overscanCount);
    const overscanForward = Math.max(1, this.overscanCount);
    return [
      Math.max(0, startIndex - overscanBackward),
      Math.max(0, Math.min(widgetCount - 1, stopIndex + overscanForward)),
      startIndex,
      stopIndex
    ];
  }
  _getStartIndexForOffset(offset) {
    return this._findNearestItem(offset);
  }
  _getStopIndexForStartIndex(startIndex, scrollOffset) {
    const size2 = this._height;
    const itemMetadata = this._getItemMetadata(startIndex);
    const maxOffset2 = scrollOffset + size2;
    let offset = itemMetadata.offset + itemMetadata.size;
    let stopIndex = startIndex;
    while (stopIndex < this.widgetCount - 1 && offset < maxOffset2) {
      stopIndex++;
      offset += this._getItemMetadata(stopIndex).size;
    }
    return stopIndex;
  }
}
class WindowedList extends Widget {
  /**
   * Constructor
   *
   * @param options Constructor options
   */
  constructor(options) {
    var _a, _b;
    const renderer = (_a = options.renderer) !== null && _a !== void 0 ? _a : WindowedList.defaultRenderer;
    const node2 = document.createElement("div");
    node2.className = "jp-WindowedPanel";
    const scrollbarElement = node2.appendChild(document.createElement("div"));
    scrollbarElement.classList.add("jp-WindowedPanel-scrollbar");
    const indicator = scrollbarElement.appendChild(renderer.createScrollbarViewportIndicator ? renderer.createScrollbarViewportIndicator() : WindowedList.defaultRenderer.createScrollbarViewportIndicator());
    indicator.classList.add("jp-WindowedPanel-scrollbar-viewportIndicator");
    const list2 = scrollbarElement.appendChild(renderer.createScrollbar());
    list2.classList.add("jp-WindowedPanel-scrollbar-content");
    const outerElement = node2.appendChild(renderer.createOuter());
    outerElement.classList.add("jp-WindowedPanel-outer");
    const innerElement = outerElement.appendChild(document.createElement("div"));
    innerElement.className = "jp-WindowedPanel-inner";
    const viewport = innerElement.appendChild(renderer.createViewport());
    viewport.classList.add("jp-WindowedPanel-viewport");
    super({ node: node2 });
    this.jumped = new Signal(this);
    this._scrollbarItems = {};
    this._viewportPaddingTop = 0;
    this._viewportPaddingBottom = 0;
    this._needsUpdate = false;
    super.layout = (_b = options.layout) !== null && _b !== void 0 ? _b : new WindowedLayout();
    this.renderer = renderer;
    this._viewportIndicator = indicator;
    this._innerElement = innerElement;
    this._isScrolling = null;
    this._outerElement = outerElement;
    this._itemsResizeObserver = null;
    this._scrollbarElement = scrollbarElement;
    this._scrollToItem = null;
    this._scrollRepaint = null;
    this._scrollUpdateWasRequested = false;
    this._updater = new Throttler(() => this.update(), 50);
    this._viewModel = options.model;
    this._viewport = viewport;
    if (options.scrollbar) {
      node2.classList.add("jp-mod-virtual-scrollbar");
    }
    this.viewModel.stateChanged.connect(this.onStateChanged, this);
  }
  /**
   * Whether the parent is hidden or not.
   *
   * This should be set externally if a container is hidden to
   * stop updating the widget size when hidden.
   */
  get isParentHidden() {
    return this._isParentHidden;
  }
  set isParentHidden(v) {
    this._isParentHidden = v;
  }
  /**
   * Widget layout
   */
  get layout() {
    return super.layout;
  }
  /**
   * The outer container of the windowed list.
   */
  get outerNode() {
    return this._outerElement;
  }
  /**
   * Viewport
   */
  get viewportNode() {
    return this._viewport;
  }
  /**
   * Flag to enable virtual scrollbar.
   */
  get scrollbar() {
    return this.node.classList.contains("jp-mod-virtual-scrollbar");
  }
  set scrollbar(enabled) {
    if (enabled) {
      this.node.classList.add("jp-mod-virtual-scrollbar");
    } else {
      this.node.classList.remove("jp-mod-virtual-scrollbar");
    }
    this._adjustDimensionsForScrollbar();
    this.update();
  }
  /**
   * Windowed list view model
   */
  get viewModel() {
    return this._viewModel;
  }
  /**
   * Dispose the windowed list.
   */
  dispose() {
    this._updater.dispose();
    super.dispose();
  }
  /**
   * Callback on event.
   *
   * @param event Event
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "pointerdown":
        event2.preventDefault();
        event2.stopPropagation();
        this._evtPointerDown(event2);
        break;
      case "scroll":
        this.onScroll(event2);
        break;
    }
  }
  /**
   * Scroll to the specified offset `scrollTop`.
   *
   * @param scrollOffset Offset to scroll
   *
   * @deprecated since v4 This is an internal helper. Prefer calling `scrollToItem`.
   */
  scrollTo(scrollOffset) {
    if (!this.viewModel.windowingActive) {
      this._outerElement.scrollTo({ top: scrollOffset });
      return;
    }
    scrollOffset = Math.max(0, scrollOffset);
    if (scrollOffset !== this.viewModel.scrollOffset) {
      this.viewModel.scrollOffset = scrollOffset;
      this._scrollUpdateWasRequested = true;
      this.update();
    }
  }
  /**
   * Scroll to the specified item.
   *
   * By default, the list will scroll as little as possible to ensure the item is fully visible (`auto`).
   * You can control the alignment of the item though by specifying a second alignment parameter.
   * Acceptable values are:
   *
   *   auto - Automatically align with the top or bottom minimising the amount scrolled,
   *          If `alignPreference` is given, follow such preferred alignment.
   *          If item is smaller than the viewport and fully visible, do not scroll at all.
   *   smart - If the item is significantly visible, don't scroll at all (regardless of whether it fits in the viewport).
   *           If the item is less than one viewport away, scroll so that it becomes fully visible (following the `auto` heuristics).
   *           If the item is more than one viewport away, scroll so that it is centered within the viewport (`center` if smaller than viewport, `top-center` otherwise).
   *   center - Align the middle of the item with the middle of the viewport (it only works well for items smaller than the viewport).
   *   top-center - Align the top of the item with the middle of the viewport (works well for items larger than the viewport).
   *   end - Align the bottom of the item to the bottom of the list.
   *   start - Align the top of item to the top of the list.
   *
   * @param index Item index to scroll to
   * @param align Type of alignment
   * @param margin In 'smart' mode the viewport proportion to add
   * @param alignPreference Allows to override the alignment of item when the `auto` heuristic decides that the item needs to be scrolled into view.
   */
  scrollToItem(index, align = "auto", margin = 0.25, alignPreference) {
    if (!this._isScrolling || this._scrollToItem === null || this._scrollToItem[0] !== index || this._scrollToItem[1] !== align) {
      if (this._isScrolling) {
        this._isScrolling.reject("Scrolling to a new item is requested.");
      }
      this._isScrolling = new PromiseDelegate();
      this._isScrolling.promise.catch(console.debug);
    }
    this._scrollToItem = [index, align, margin, alignPreference];
    this._resetScrollToItem();
    let precomputed = void 0;
    if (!this.viewModel.windowingActive) {
      const item = this._innerElement.querySelector(`[data-windowed-list-index="${index}"]`);
      if (!item || !(item instanceof HTMLElement)) {
        console.debug(`Element with index ${index} not found`);
        return Promise.resolve();
      }
      precomputed = {
        totalSize: this._outerElement.scrollHeight,
        itemMetadata: {
          offset: item.offsetTop,
          size: item.clientHeight
        },
        currentOffset: this._outerElement.scrollTop
      };
    }
    this.scrollTo(this.viewModel.getOffsetForIndexAndAlignment(Math.max(0, Math.min(index, this.viewModel.widgetCount - 1)), align, margin, precomputed, alignPreference));
    return this._isScrolling.promise;
  }
  /**
   * A message handler invoked on an `'after-attach'` message.
   */
  onAfterAttach(msg) {
    super.onAfterAttach(msg);
    if (this.viewModel.windowingActive) {
      this._applyWindowingStyles();
    } else {
      this._applyNoWindowingStyles();
    }
    this._addListeners();
    this.viewModel.height = this.node.getBoundingClientRect().height;
    const viewportStyle = window.getComputedStyle(this._viewport);
    this.viewModel.paddingTop = parseFloat(viewportStyle.paddingTop);
    this._viewportPaddingTop = this.viewModel.paddingTop;
    this._viewportPaddingBottom = parseFloat(viewportStyle.paddingBottom);
    this._scrollbarElement.addEventListener("pointerdown", this);
  }
  /**
   * A message handler invoked on an `'before-detach'` message.
   */
  onBeforeDetach(msg) {
    this._removeListeners();
    this._scrollbarElement.removeEventListener("pointerdown", this);
    super.onBeforeDetach(msg);
  }
  /**
   * Callback on scroll event
   *
   * @param event Scroll event
   */
  onScroll(event2) {
    const { clientHeight, scrollHeight, scrollTop } = event2.currentTarget;
    if (!this._scrollUpdateWasRequested && Math.abs(this.viewModel.scrollOffset - scrollTop) > 1) {
      const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
      this.viewModel.scrollOffset = scrollOffset;
      this._scrollUpdateWasRequested = false;
      this.update();
    }
  }
  /**
   * A message handler invoked on an `'resize-request'` message.
   */
  onResize(msg) {
    const previousHeight = this.viewModel.height;
    this.viewModel.height = msg.height >= 0 ? msg.height : this.node.getBoundingClientRect().height;
    if (this.viewModel.height !== previousHeight) {
      void this._updater.invoke();
    }
    super.onResize(msg);
    void this._updater.invoke();
  }
  /**
   * Callback on view model change
   *
   * @param model Windowed list model
   * @param changes Change
   */
  onStateChanged(model, changes) {
    switch (changes.name) {
      case "windowingActive":
        this._removeListeners();
        if (this.viewModel.windowingActive) {
          this._applyWindowingStyles();
          this.onScroll({ currentTarget: this.node });
          this._addListeners();
          return;
        } else {
          this._applyNoWindowingStyles();
          this._addListeners();
        }
        break;
      case "estimatedWidgetSize":
        this._updateTotalSize();
        return;
    }
    this.update();
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onUpdateRequest(msg) {
    if (this.viewModel.windowingActive) {
      if (this._scrollRepaint === null) {
        this._needsUpdate = false;
        this._scrollRepaint = window.requestAnimationFrame(() => {
          this._scrollRepaint = null;
          this._update();
          if (this._needsUpdate) {
            this.update();
          }
        });
      } else {
        this._needsUpdate = true;
      }
    } else {
      this._update();
    }
  }
  /*
   * Hide the native scrollbar if necessary and update dimensions
   */
  _adjustDimensionsForScrollbar() {
    const outer = this._outerElement;
    const scrollbar = this._scrollbarElement;
    if (this.scrollbar) {
      let outerScrollbarWidth = outer.offsetWidth - outer.clientWidth;
      if (outerScrollbarWidth == 0) {
        outerScrollbarWidth = 1e3;
        outer.style.paddingRight = `${outerScrollbarWidth}px`;
        outer.style.boxSizing = "border-box";
      } else {
        outer.style.paddingRight = "0";
      }
      outer.style.width = `calc(100% + ${outerScrollbarWidth}px)`;
      this._innerElement.style.marginRight = `${scrollbar.offsetWidth}px`;
    } else {
      outer.style.width = "100%";
      this._innerElement.style.marginRight = "";
      outer.style.paddingRight = "0";
      outer.style.boxSizing = "";
    }
  }
  /**
   * Add listeners for viewport, contents and the virtual scrollbar.
   */
  _addListeners() {
    if (this.viewModel.windowingActive) {
      if (!this._itemsResizeObserver) {
        this._itemsResizeObserver = new ResizeObserver(this._onItemResize.bind(this));
      }
      for (const widget of this.layout.widgets) {
        this._itemsResizeObserver.observe(widget.node);
        widget.disposed.connect(() => {
          var _a;
          return (_a = this._itemsResizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(widget.node);
        });
      }
      this._outerElement.addEventListener("scroll", this, passiveIfSupported);
      this._scrollbarResizeObserver = new ResizeObserver(this._adjustDimensionsForScrollbar.bind(this));
      this._scrollbarResizeObserver.observe(this._outerElement);
      this._scrollbarResizeObserver.observe(this._scrollbarElement);
    } else {
      if (!this._areaResizeObserver) {
        this._areaResizeObserver = new ResizeObserver(this._onAreaResize.bind(this));
        this._areaResizeObserver.observe(this._innerElement);
      }
    }
  }
  /**
   * Turn off windowing related styles in the viewport.
   */
  _applyNoWindowingStyles() {
    this._viewport.style.position = "relative";
    this._viewport.style.top = "0px";
    this._innerElement.style.height = "";
  }
  /**
   * Turn on windowing related styles in the viewport.
   */
  _applyWindowingStyles() {
    this._viewport.style.position = "absolute";
  }
  /**
   * Remove listeners for viewport and contents (but not the virtual scrollbar).
   */
  _removeListeners() {
    var _a, _b, _c;
    this._outerElement.removeEventListener("scroll", this);
    (_a = this._areaResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
    this._areaResizeObserver = null;
    (_b = this._itemsResizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    this._itemsResizeObserver = null;
    (_c = this._scrollbarResizeObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
    this._scrollbarResizeObserver = null;
  }
  /**
   * Update viewport and DOM state.
   */
  _update() {
    var _a;
    if (this.isDisposed || !this.layout) {
      return;
    }
    const newWindowIndex = this.viewModel.getRangeToRender();
    if (newWindowIndex !== null) {
      const [startIndex, stopIndex, firstVisibleIndex, lastVisibleIndex] = newWindowIndex;
      if (this.scrollbar) {
        const scrollbarItems = this._renderScrollbar();
        const first = scrollbarItems[firstVisibleIndex];
        const last2 = scrollbarItems[lastVisibleIndex];
        this._viewportIndicator.style.top = first.offsetTop - 1 + "px";
        this._viewportIndicator.style.height = last2.offsetTop - first.offsetTop + last2.offsetHeight + "px";
      }
      const toAdd = [];
      if (stopIndex >= 0) {
        for (let index = startIndex; index <= stopIndex; index++) {
          const widget = this.viewModel.widgetRenderer(index);
          widget.dataset.windowedListIndex = `${index}`;
          toAdd.push(widget);
        }
      }
      const nWidgets = this.layout.widgets.length;
      for (let itemIdx = nWidgets - 1; itemIdx >= 0; itemIdx--) {
        if (!toAdd.includes(this.layout.widgets[itemIdx])) {
          (_a = this._itemsResizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(this.layout.widgets[itemIdx].node);
          this.layout.removeWidget(this.layout.widgets[itemIdx]);
        }
      }
      for (let index = 0; index < toAdd.length; index++) {
        const item = toAdd[index];
        if (this._itemsResizeObserver && !this.layout.widgets.includes(item)) {
          this._itemsResizeObserver.observe(item.node);
          item.disposed.connect(() => {
            var _a2;
            return (_a2 = this._itemsResizeObserver) === null || _a2 === void 0 ? void 0 : _a2.unobserve(item.node);
          });
        }
        this.layout.insertWidget(index, item);
      }
      if (this.viewModel.windowingActive) {
        if (stopIndex >= 0) {
          this._updateTotalSize();
          const [top2, minHeight] = this.viewModel.getSpan(startIndex, stopIndex);
          this._viewport.style.top = `${top2}px`;
          this._viewport.style.minHeight = `${minHeight}px`;
        } else {
          this._innerElement.style.height = `0px`;
          this._viewport.style.top = `0px`;
          this._viewport.style.minHeight = `0px`;
        }
        if (this._scrollUpdateWasRequested) {
          this._outerElement.scrollTop = this.viewModel.scrollOffset;
          this._scrollUpdateWasRequested = false;
        }
      }
    }
    let index2 = -1;
    for (const w of this._viewport.children) {
      const currentIdx = parseInt(w.dataset.windowedListIndex, 10);
      if (currentIdx < index2) {
        throw new Error("Inconsistent dataset index");
      } else {
        index2 = currentIdx;
      }
    }
  }
  /**
   * Handle viewport area resize.
   */
  _onAreaResize(_entries) {
    this._scrollBackToItemOnResize();
  }
  /**
   * Handle viewport content (i.e. items) resize.
   */
  _onItemResize(entries) {
    this._resetScrollToItem();
    if (this.isHidden || this.isParentHidden) {
      return;
    }
    const newSizes = [];
    for (let entry of entries) {
      if (entry.target.isConnected) {
        newSizes.push({
          index: parseInt(entry.target.dataset.windowedListIndex, 10),
          size: entry.borderBoxSize[0].blockSize
        });
      }
    }
    if (this.viewModel.setWidgetSize(newSizes)) {
      this._scrollBackToItemOnResize();
      this.update();
    }
  }
  /**
   * Scroll to the item which was most recently requested.
   *
   * This method ensures that the app scrolls to the item even if a resize event
   * occurs shortly after the scroll. Consider the following sequence of events:
   *
   * 1. User is at the nth cell, presses Shift+Enter (run current cell and
   *    advance to next)
   * 2. App scrolls to the next (n+1) cell
   * 3. The nth cell finishes running and renders the output, pushing the
   *    (n+1) cell down out of view
   * 4. This triggers the resize observer, which calls this method and scrolls
   *    the (n+1) cell back into view
   *
   * On implementation level, this is ensured by scrolling to `this._scrollToItem`
   * which is cleared after a short timeout once the scrolling settles
   * (see `this._resetScrollToItem()`).
   */
  _scrollBackToItemOnResize() {
    if (!this._scrollToItem) {
      return;
    }
    this.scrollToItem(...this._scrollToItem).catch((reason) => {
      console.log(reason);
    });
  }
  /**
   * Clear any outstanding timeout and enqueue scrolling to a new item.
   */
  _resetScrollToItem() {
    if (this._resetScrollToItemTimeout) {
      clearTimeout(this._resetScrollToItemTimeout);
    }
    if (this._scrollToItem) {
      this._resetScrollToItemTimeout = window.setTimeout(() => {
        this._scrollToItem = null;
        if (this._isScrolling) {
          this._isScrolling.resolve();
          this._isScrolling = null;
        }
      }, MAXIMUM_TIME_REMAINING$1);
    }
  }
  /**
   * Render virtual scrollbar.
   */
  _renderScrollbar() {
    var _a, _b;
    const { node: node2, renderer, viewModel } = this;
    const content = node2.querySelector(".jp-WindowedPanel-scrollbar-content");
    const elements2 = [];
    const getElement = (item, index) => {
      if (item instanceof HTMLElement) {
        return item;
      } else {
        visitedKeys.add(item.key);
        const props = { index };
        const cachedItem = this._scrollbarItems[item.key];
        if (cachedItem && !cachedItem.isDisposed) {
          return cachedItem.render(props);
        } else {
          this._scrollbarItems[item.key] = item;
          const element = item.render(props);
          return element;
        }
      }
    };
    const list2 = viewModel.itemsList;
    const count = (_a = list2 === null || list2 === void 0 ? void 0 : list2.length) !== null && _a !== void 0 ? _a : viewModel.widgetCount;
    const visitedKeys = /* @__PURE__ */ new Set();
    for (let index = 0; index < count; index += 1) {
      const model = (_b = list2 === null || list2 === void 0 ? void 0 : list2.get) === null || _b === void 0 ? void 0 : _b.call(list2, index);
      const item = renderer.createScrollbarItem(this, index, model);
      const element = getElement(item, index);
      element.classList.add("jp-WindowedPanel-scrollbar-item");
      element.dataset.index = `${index}`;
      elements2.push(element);
    }
    const keysNotSeen = Object.keys(this._scrollbarItems).filter((key2) => !visitedKeys.has(key2));
    for (const key2 of keysNotSeen) {
      this._scrollbarItems[key2].dispose();
      delete this._scrollbarItems[key2];
    }
    const oldNodes = [...content.childNodes];
    if (oldNodes.length !== elements2.length || !oldNodes.every((node3, index) => elements2[index] === node3)) {
      content.replaceChildren(...elements2);
    }
    return elements2;
  }
  /**
   * Handle `pointerdown` events on the virtual scrollbar.
   */
  _evtPointerDown(event2) {
    let target2 = event2.target;
    while (target2 && target2.parentElement) {
      if (target2.hasAttribute("data-index")) {
        const index = parseInt(target2.getAttribute("data-index"), 10);
        return void (async () => {
          await this.scrollToItem(index);
          this.jumped.emit(index);
        })();
      }
      target2 = target2.parentElement;
    }
  }
  /**
   * Update the total size
   */
  _updateTotalSize() {
    if (this.viewModel.windowingActive) {
      const estimatedTotalHeight = this.viewModel.getEstimatedTotalSize();
      const heightWithPadding = estimatedTotalHeight + this._viewportPaddingTop + this._viewportPaddingBottom;
      this._innerElement.style.height = `${heightWithPadding}px`;
    }
  }
}
WindowedList.DEFAULT_WIDGET_SIZE = 50;
class WindowedLayout extends PanelLayout {
  /**
   * Constructor
   */
  constructor() {
    super({ fitPolicy: "set-no-constraint" });
  }
  /**
   * Specialized parent type definition
   */
  get parent() {
    return super.parent;
  }
  set parent(value) {
    super.parent = value;
  }
  /**
   * Attach a widget to the parent's DOM node.
   *
   * @param index - The current index of the widget in the layout.
   *
   * @param widget - The widget to attach to the parent.
   *
   * #### Notes
   * This method is called automatically by the panel layout at the
   * appropriate time. It should not be called directly by user code.
   *
   * The default implementation adds the widgets's node to the parent's
   * node at the proper location, and sends the appropriate attach
   * messages to the widget if the parent is attached to the DOM.
   *
   * Subclasses may reimplement this method to control how the widget's
   * node is added to the parent's node.
   */
  attachWidget(index, widget) {
    let ref2 = this.parent.viewportNode.children[index];
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
    }
    this.parent.viewportNode.insertBefore(widget.node, ref2);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
    }
  }
  /**
   * Detach a widget from the parent's DOM node.
   *
   * @param index - The previous index of the widget in the layout.
   *
   * @param widget - The widget to detach from the parent.
   *
   * #### Notes
   * This method is called automatically by the panel layout at the
   * appropriate time. It should not be called directly by user code.
   *
   * The default implementation removes the widget's node from the
   * parent's node, and sends the appropriate detach messages to the
   * widget if the parent is attached to the DOM.
   *
   * Subclasses may reimplement this method to control how the widget's
   * node is removed from the parent's node.
   */
  detachWidget(index, widget) {
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
    }
    this.parent.viewportNode.removeChild(widget.node);
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
    }
  }
  /**
   * Move a widget in the parent's DOM node.
   *
   * @param fromIndex - The previous index of the widget in the layout.
   *
   * @param toIndex - The current index of the widget in the layout.
   *
   * @param widget - The widget to move in the parent.
   *
   * #### Notes
   * This method is called automatically by the panel layout at the
   * appropriate time. It should not be called directly by user code.
   *
   * The default implementation moves the widget's node to the proper
   * location in the parent's node and sends the appropriate attach and
   * detach messages to the widget if the parent is attached to the DOM.
   *
   * Subclasses may reimplement this method to control how the widget's
   * node is moved in the parent's node.
   */
  moveWidget(fromIndex, toIndex, widget) {
    let ref2 = this.parent.viewportNode.children[toIndex];
    if (fromIndex < toIndex) {
      ref2.insertAdjacentElement("afterend", widget.node);
    } else {
      ref2.insertAdjacentElement("beforebegin", widget.node);
    }
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   *
   * #### Notes
   * This is a reimplementation of the base class method,
   * and is a no-op.
   */
  onUpdateRequest(msg) {
  }
}
(function(WindowedList2) {
  class Renderer {
    /**
     * Create the outer, root element of the windowed list.
     */
    createOuter() {
      return document.createElement("div");
    }
    /**
     * Create the virtual scrollbar element.
     */
    createScrollbar() {
      return document.createElement("ol");
    }
    /**
     * Create the virtual scrollbar viewport indicator.
     */
    createScrollbarViewportIndicator() {
      return document.createElement("div");
    }
    /**
     * Create an individual item rendered in the scrollbar.
     */
    createScrollbarItem(_, index) {
      const li = document.createElement("li");
      li.appendChild(document.createTextNode(`${index}`));
      return li;
    }
    /**
     * Create the viewport element into which virtualized children are added.
     */
    createViewport() {
      return document.createElement("div");
    }
  }
  WindowedList2.Renderer = Renderer;
  WindowedList2.defaultRenderer = new Renderer();
})(WindowedList || (WindowedList = {}));
class ObservableMap {
  /**
   * Construct a new observable map.
   */
  constructor(options = {}) {
    this._map = /* @__PURE__ */ new Map();
    this._changed = new Signal(this);
    this._isDisposed = false;
    this._itemCmp = options.itemCmp || Private$f.itemCmp;
    if (options.values) {
      for (const key2 in options.values) {
        this._map.set(key2, options.values[key2]);
      }
    }
  }
  /**
   * The type of the Observable.
   */
  get type() {
    return "Map";
  }
  /**
   * A signal emitted when the map has changed.
   */
  get changed() {
    return this._changed;
  }
  /**
   * Whether this map has been disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * The number of key-value pairs in the map.
   */
  get size() {
    return this._map.size;
  }
  /**
   * Set a key-value pair in the map
   *
   * @param key - The key to set.
   *
   * @param value - The value for the key.
   *
   * @returns the old value for the key, or undefined
   *   if that did not exist.
   *
   * @throws if the new value is undefined.
   *
   * #### Notes
   * This is a no-op if the value does not change.
   */
  set(key2, value) {
    const oldVal = this._map.get(key2);
    if (value === void 0) {
      throw Error("Cannot set an undefined value, use remove");
    }
    const itemCmp = this._itemCmp;
    if (oldVal !== void 0 && itemCmp(oldVal, value)) {
      return oldVal;
    }
    this._map.set(key2, value);
    this._changed.emit({
      type: oldVal ? "change" : "add",
      key: key2,
      oldValue: oldVal,
      newValue: value
    });
    return oldVal;
  }
  /**
   * Get a value for a given key.
   *
   * @param key - the key.
   *
   * @returns the value for that key.
   */
  get(key2) {
    return this._map.get(key2);
  }
  /**
   * Check whether the map has a key.
   *
   * @param key - the key to check.
   *
   * @returns `true` if the map has the key, `false` otherwise.
   */
  has(key2) {
    return this._map.has(key2);
  }
  /**
   * Get a list of the keys in the map.
   *
   * @returns - a list of keys.
   */
  keys() {
    const keyList = [];
    this._map.forEach((v, k) => {
      keyList.push(k);
    });
    return keyList;
  }
  /**
   * Get a list of the values in the map.
   *
   * @returns - a list of values.
   */
  values() {
    const valList = [];
    this._map.forEach((v, k) => {
      valList.push(v);
    });
    return valList;
  }
  /**
   * Remove a key from the map
   *
   * @param key - the key to remove.
   *
   * @returns the value of the given key,
   *   or undefined if that does not exist.
   *
   * #### Notes
   * This is a no-op if the value does not change.
   */
  delete(key2) {
    const oldVal = this._map.get(key2);
    const removed = this._map.delete(key2);
    if (removed) {
      this._changed.emit({
        type: "remove",
        key: key2,
        oldValue: oldVal,
        newValue: void 0
      });
    }
    return oldVal;
  }
  /**
   * Set the ObservableMap to an empty map.
   */
  clear() {
    const keyList = this.keys();
    for (let i2 = 0; i2 < keyList.length; i2++) {
      this.delete(keyList[i2]);
    }
  }
  /**
   * Dispose of the resources held by the map.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._isDisposed = true;
    Signal.clearData(this);
    this._map.clear();
  }
}
var Private$f;
(function(Private2) {
  function itemCmp(first, second) {
    return first === second;
  }
  Private2.itemCmp = itemCmp;
})(Private$f || (Private$f = {}));
class ObservableJSON extends ObservableMap {
  /**
   * Construct a new observable JSON object.
   */
  constructor(options = {}) {
    super({
      itemCmp: JSONExt.deepEqual,
      values: options.values
    });
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    const out = /* @__PURE__ */ Object.create(null);
    const keys2 = this.keys();
    for (const key2 of keys2) {
      const value = this.get(key2);
      if (value !== void 0) {
        out[key2] = JSONExt.deepCopy(value);
      }
    }
    return out;
  }
}
(function(ObservableJSON2) {
  class ChangeMessage extends Message {
    /**
     * Create a new metadata changed message.
     */
    constructor(type, args) {
      super(type);
      this.args = args;
    }
  }
  ObservableJSON2.ChangeMessage = ChangeMessage;
})(ObservableJSON || (ObservableJSON = {}));
class ObservableString {
  /**
   * Construct a new observable string.
   */
  constructor(initialText = "") {
    this._text = "";
    this._isDisposed = false;
    this._changed = new Signal(this);
    this._text = initialText;
  }
  /**
   * The type of the Observable.
   */
  get type() {
    return "String";
  }
  /**
   * A signal emitted when the string has changed.
   */
  get changed() {
    return this._changed;
  }
  /**
   * Set the value of the string.
   */
  set text(value) {
    if (value.length === this._text.length && value === this._text) {
      return;
    }
    this._text = value;
    this._changed.emit({
      type: "set",
      start: 0,
      end: value.length,
      value
    });
  }
  /**
   * Get the value of the string.
   */
  get text() {
    return this._text;
  }
  /**
   * Insert a substring.
   *
   * @param index - The starting index.
   *
   * @param text - The substring to insert.
   */
  insert(index, text2, options) {
    this._text = this._text.slice(0, index) + text2 + this._text.slice(index);
    this._changed.emit({
      type: "insert",
      start: index,
      end: index + text2.length,
      value: text2,
      options
    });
  }
  /**
   * Remove a substring.
   *
   * @param start - The starting index.
   *
   * @param end - The ending index.
   */
  remove(start, end, options) {
    const oldValue = this._text.slice(start, end);
    this._text = this._text.slice(0, start) + this._text.slice(end);
    this._changed.emit({
      type: "remove",
      start,
      end,
      value: oldValue,
      options
    });
  }
  /**
   * Set the ObservableString to an empty string.
   */
  clear() {
    this.text = "";
  }
  /**
   * Test whether the string has been disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of the resources held by the string.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    Signal.clearData(this);
    this.clear();
  }
}
class ObservableList {
  /**
   * Construct a new observable map.
   */
  constructor(options = {}) {
    this._array = [];
    this._isDisposed = false;
    this._changed = new Signal(this);
    if (options.values) {
      for (const value of options.values) {
        this._array.push(value);
      }
    }
    this._itemCmp = options.itemCmp || Private$e.itemCmp;
  }
  /**
   * The type of this object.
   */
  get type() {
    return "List";
  }
  /**
   * A signal emitted when the list has changed.
   */
  get changed() {
    return this._changed;
  }
  /**
   * The length of the list.
   */
  get length() {
    return this._array.length;
  }
  /**
   * Test whether the list has been disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of the resources held by the list.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    Signal.clearData(this);
    this.clear();
  }
  /**
   * Create an iterator over the values in the list.
   *
   * @returns A new iterator starting at the front of the list.
   *
   * #### Complexity
   * Constant.
   *
   * #### Iterator Validity
   * No changes.
   */
  [Symbol.iterator]() {
    return this._array[Symbol.iterator]();
  }
  /**
   * Get the value at the specified index.
   *
   * @param index - The positive integer index of interest.
   *
   * @returns The value at the specified index.
   *
   * #### Undefined Behavior
   * An `index` which is non-integral or out of range.
   */
  get(index) {
    return this._array[index];
  }
  /**
   * Set the value at the specified index.
   *
   * @param index - The positive integer index of interest.
   *
   * @param value - The value to set at the specified index.
   *
   * #### Complexity
   * Constant.
   *
   * #### Iterator Validity
   * No changes.
   *
   * #### Undefined Behavior
   * An `index` which is non-integral or out of range.
   */
  set(index, value) {
    const oldValue = this._array[index];
    if (value === void 0) {
      throw new Error("Cannot set an undefined item");
    }
    const itemCmp = this._itemCmp;
    if (itemCmp(oldValue, value)) {
      return;
    }
    this._array[index] = value;
    this._changed.emit({
      type: "set",
      oldIndex: index,
      newIndex: index,
      oldValues: [oldValue],
      newValues: [value]
    });
  }
  /**
   * Add a value to the end of the list.
   *
   * @param value - The value to add to the end of the list.
   *
   * @returns The new length of the list.
   *
   * #### Complexity
   * Constant.
   *
   * #### Notes
   * By convention, the oldIndex is set to -1 to indicate
   * an push operation.
   *
   * #### Iterator Validity
   * No changes.
   */
  push(value) {
    const num = this._array.push(value);
    this._changed.emit({
      type: "add",
      oldIndex: -1,
      newIndex: this.length - 1,
      oldValues: [],
      newValues: [value]
    });
    return num;
  }
  /**
   * Insert a value into the list at a specific index.
   *
   * @param index - The index at which to insert the value.
   *
   * @param value - The value to set at the specified index.
   *
   * #### Complexity
   * Linear.
   *
   * #### Iterator Validity
   * No changes.
   *
   * #### Notes
   * The `index` will be clamped to the bounds of the list.
   *
   * By convention, the oldIndex is set to -2 to indicate
   * an insert operation.
   *
   * The value -2 as oldIndex can be used to distinguish from the push
   * method which will use a value -1.
   *
   * #### Undefined Behavior
   * An `index` which is non-integral.
   */
  insert(index, value) {
    if (index === this._array.length) {
      this._array.push(value);
    } else {
      ArrayExt.insert(this._array, index, value);
    }
    this._changed.emit({
      type: "add",
      oldIndex: -2,
      newIndex: index,
      oldValues: [],
      newValues: [value]
    });
  }
  /**
   * Remove the first occurrence of a value from the list.
   *
   * @param value - The value of interest.
   *
   * @returns The index of the removed value, or `-1` if the value
   *   is not contained in the list.
   *
   * #### Complexity
   * Linear.
   *
   * #### Iterator Validity
   * Iterators pointing at the removed value and beyond are invalidated.
   */
  removeValue(value) {
    const itemCmp = this._itemCmp;
    const index = ArrayExt.findFirstIndex(this._array, (item) => {
      return itemCmp(item, value);
    });
    this.remove(index);
    return index;
  }
  /**
   * Remove and return the value at a specific index.
   *
   * @param index - The index of the value of interest.
   *
   * @returns The value at the specified index, or `undefined` if the
   *   index is out of range.
   *
   * #### Complexity
   * Constant.
   *
   * #### Iterator Validity
   * Iterators pointing at the removed value and beyond are invalidated.
   *
   * #### Undefined Behavior
   * An `index` which is non-integral.
   */
  remove(index) {
    const value = ArrayExt.removeAt(this._array, index);
    if (value === void 0) {
      return;
    }
    this._changed.emit({
      type: "remove",
      oldIndex: index,
      newIndex: -1,
      newValues: [],
      oldValues: [value]
    });
    return value;
  }
  /**
   * Remove all values from the list.
   *
   * #### Complexity
   * Linear.
   *
   * #### Iterator Validity
   * All current iterators are invalidated.
   */
  clear() {
    const copy2 = this._array.slice();
    this._array.length = 0;
    this._changed.emit({
      type: "remove",
      oldIndex: 0,
      newIndex: 0,
      newValues: [],
      oldValues: copy2
    });
  }
  /**
   * Move a value from one index to another.
   *
   * @param fromIndex - The index of the element to move.
   *
   * @param toIndex - The index to move the element to.
   *
   * #### Complexity
   * Constant.
   *
   * #### Iterator Validity
   * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`
   * and beyond are invalidated.
   *
   * #### Undefined Behavior
   * A `fromIndex` or a `toIndex` which is non-integral.
   */
  move(fromIndex, toIndex) {
    if (this.length <= 1 || fromIndex === toIndex) {
      return;
    }
    const values = [this._array[fromIndex]];
    ArrayExt.move(this._array, fromIndex, toIndex);
    this._changed.emit({
      type: "move",
      oldIndex: fromIndex,
      newIndex: toIndex,
      oldValues: values,
      newValues: values
    });
  }
  /**
   * Push a set of values to the back of the list.
   *
   * @param values - An iterable set of values to add.
   *
   * @returns The new length of the list.
   *
   * #### Complexity
   * Linear.
   *
   * #### Notes
   * By convention, the oldIndex is set to -1 to indicate
   * an push operation.
   *
   * #### Iterator Validity
   * No changes.
   */
  pushAll(values) {
    const newIndex = this.length;
    for (const value of values) {
      this._array.push(value);
    }
    this._changed.emit({
      type: "add",
      oldIndex: -1,
      newIndex,
      oldValues: [],
      newValues: Array.from(values)
    });
    return this.length;
  }
  /**
   * Insert a set of items into the list at the specified index.
   *
   * @param index - The index at which to insert the values.
   *
   * @param values - The values to insert at the specified index.
   *
   * #### Complexity.
   * Linear.
   *
   * #### Iterator Validity
   * No changes.
   *
   * #### Notes
   * The `index` will be clamped to the bounds of the list.
   * By convention, the oldIndex is set to -2 to indicate
   * an insert operation.
   *
   * #### Undefined Behavior.
   * An `index` which is non-integral.
   */
  insertAll(index, values) {
    const newIndex = index;
    for (const value of values) {
      ArrayExt.insert(this._array, index++, value);
    }
    this._changed.emit({
      type: "add",
      oldIndex: -2,
      newIndex,
      oldValues: [],
      newValues: Array.from(values)
    });
  }
  /**
   * Remove a range of items from the list.
   *
   * @param startIndex - The start index of the range to remove (inclusive).
   *
   * @param endIndex - The end index of the range to remove (exclusive).
   *
   * @returns The new length of the list.
   *
   * #### Complexity
   * Linear.
   *
   * #### Iterator Validity
   * Iterators pointing to the first removed value and beyond are invalid.
   *
   * #### Undefined Behavior
   * A `startIndex` or `endIndex` which is non-integral.
   */
  removeRange(startIndex, endIndex) {
    const oldValues = this._array.slice(startIndex, endIndex);
    for (let i2 = startIndex; i2 < endIndex; i2++) {
      ArrayExt.removeAt(this._array, startIndex);
    }
    this._changed.emit({
      type: "remove",
      oldIndex: startIndex,
      newIndex: -1,
      oldValues,
      newValues: []
    });
    return this.length;
  }
}
var Private$e;
(function(Private2) {
  function itemCmp(first, second) {
    return first === second;
  }
  Private2.itemCmp = itemCmp;
})(Private$e || (Private$e = {}));
class WidgetTracker {
  /**
   * Create a new widget tracker.
   *
   * @param options - The instantiation options for a widget tracker.
   */
  constructor(options) {
    this._currentChanged = new Signal(this);
    this._deferred = null;
    this._isDisposed = false;
    this._widgetAdded = new Signal(this);
    this._widgetUpdated = new Signal(this);
    const focus = this._focusTracker = new FocusTracker();
    const pool = this._pool = new lib$7.RestorablePool(options);
    this.namespace = options.namespace;
    focus.currentChanged.connect((_, current) => {
      if (current.newValue !== this.currentWidget) {
        pool.current = current.newValue;
      }
    }, this);
    pool.added.connect((_, widget) => {
      this._widgetAdded.emit(widget);
    }, this);
    pool.currentChanged.connect((_, widget) => {
      if (widget === null && focus.currentWidget) {
        pool.current = focus.currentWidget;
        return;
      }
      this.onCurrentChanged(widget);
      this._currentChanged.emit(widget);
    }, this);
    pool.updated.connect((_, widget) => {
      this._widgetUpdated.emit(widget);
    }, this);
  }
  /**
   * A signal emitted when the current widget changes.
   */
  get currentChanged() {
    return this._currentChanged;
  }
  /**
   * The current widget is the most recently focused or added widget.
   *
   * #### Notes
   * It is the most recently focused widget, or the most recently added
   * widget if no widget has taken focus.
   */
  get currentWidget() {
    return this._pool.current || null;
  }
  /**
   * A promise resolved when the tracker has been restored.
   */
  get restored() {
    if (this._deferred) {
      return Promise.resolve();
    } else {
      return this._pool.restored;
    }
  }
  /**
   * The number of widgets held by the tracker.
   */
  get size() {
    return this._pool.size;
  }
  /**
   * A signal emitted when a widget is added.
   *
   * #### Notes
   * This signal will only fire when a widget is added to the tracker. It will
   * not fire if a widget is injected into the tracker.
   */
  get widgetAdded() {
    return this._widgetAdded;
  }
  /**
   * A signal emitted when a widget is updated.
   */
  get widgetUpdated() {
    return this._widgetUpdated;
  }
  /**
   * Add a new widget to the tracker.
   *
   * @param widget - The widget being added.
   *
   * #### Notes
   * The widget passed into the tracker is added synchronously; its existence in
   * the tracker can be checked with the `has()` method. The promise this method
   * returns resolves after the widget has been added and saved to an underlying
   * restoration connector, if one is available.
   *
   * The newly added widget becomes the current widget unless the focus tracker
   * already had a focused widget.
   */
  async add(widget) {
    this._focusTracker.add(widget);
    await this._pool.add(widget);
    if (!this._focusTracker.activeWidget) {
      this._pool.current = widget;
    }
  }
  /**
   * Test whether the tracker is disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of the resources held by the tracker.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._isDisposed = true;
    this._pool.dispose();
    this._focusTracker.dispose();
    Signal.clearData(this);
  }
  /**
   * Find the first widget in the tracker that satisfies a filter function.
   *
   * @param fn The filter function to call on each widget.
   *
   * #### Notes
   * If no widget is found, the value returned is `undefined`.
   */
  find(fn) {
    return this._pool.find(fn);
  }
  /**
   * Iterate through each widget in the tracker.
   *
   * @param fn - The function to call on each widget.
   */
  forEach(fn) {
    return this._pool.forEach(fn);
  }
  /**
   * Filter the widgets in the tracker based on a predicate.
   *
   * @param fn - The function by which to filter.
   */
  filter(fn) {
    return this._pool.filter(fn);
  }
  /**
   * Inject a foreign widget into the widget tracker.
   *
   * @param widget - The widget to inject into the tracker.
   *
   * #### Notes
   * Injected widgets will not have their state saved by the tracker.
   *
   * The primary use case for widget injection is for a plugin that offers a
   * sub-class of an extant plugin to have its instances share the same commands
   * as the parent plugin (since most relevant commands will use the
   * `currentWidget` of the parent plugin's widget tracker). In this situation,
   * the sub-class plugin may well have its own widget tracker for layout and
   * state restoration in addition to injecting its widgets into the parent
   * plugin's widget tracker.
   */
  inject(widget) {
    return this._pool.inject(widget);
  }
  /**
   * Check if this tracker has the specified widget.
   *
   * @param widget - The widget whose existence is being checked.
   */
  has(widget) {
    return this._pool.has(widget);
  }
  /**
   * Restore the widgets in this tracker's namespace.
   *
   * @param options - The configuration options that describe restoration.
   *
   * @returns A promise that resolves when restoration has completed.
   *
   * #### Notes
   * This function should not typically be invoked by client code.
   * Its primary use case is to be invoked by a restorer.
   */
  async restore(options) {
    const deferred = this._deferred;
    if (deferred) {
      this._deferred = null;
      return this._pool.restore(deferred);
    }
    if (options) {
      return this._pool.restore(options);
    }
    console.warn("No options provided to restore the tracker.");
  }
  /**
   * Save the restore options for this tracker, but do not restore yet.
   *
   * @param options - The configuration options that describe restoration.
   *
   * ### Notes
   * This function is useful when starting the shell in 'single-document' mode,
   * to avoid restoring all useless widgets. It should not ordinarily be called
   * by client code.
   */
  defer(options) {
    this._deferred = options;
  }
  /**
   * Save the restore data for a given widget.
   *
   * @param widget - The widget being saved.
   */
  async save(widget) {
    return this._pool.save(widget);
  }
  /**
   * Handle the current change event.
   *
   * #### Notes
   * The default implementation is a no-op.
   */
  onCurrentChanged(value) {
  }
}
function showDialog(options = {}) {
  const dialog = new Dialog(options);
  return dialog.launch();
}
function showErrorMessage(title, error, buttons) {
  const trans = Dialog.translator.load("jupyterlab");
  buttons = buttons !== null && buttons !== void 0 ? buttons : [Dialog.cancelButton({ label: trans.__("Close") })];
  console.warn("Showing error:", error);
  const body = typeof error === "string" ? error : error.message;
  const key2 = title + "----" + body;
  const promise = Private$d.errorMessagePromiseCache.get(key2);
  if (promise) {
    return promise;
  } else {
    const dialogPromise = showDialog({
      title,
      body,
      buttons
    }).then(() => {
      Private$d.errorMessagePromiseCache.delete(key2);
    }, (error2) => {
      Private$d.errorMessagePromiseCache.delete(key2);
      throw error2;
    });
    Private$d.errorMessagePromiseCache.set(key2, dialogPromise);
    return dialogPromise;
  }
}
class Dialog extends Widget {
  /**
   * Create a dialog panel instance.
   *
   * @param options - The dialog setup options.
   */
  constructor(options = {}) {
    const dialogNode = document.createElement("dialog");
    dialogNode.ariaModal = "true";
    super({ node: dialogNode });
    this._hasValidationErrors = false;
    this._ready = new PromiseDelegate();
    this._focusNodeSelector = "";
    this.addClass("jp-Dialog");
    this.addClass("jp-ThemedContainer");
    const normalized = Private$d.handleOptions(options);
    const renderer = normalized.renderer;
    this._host = normalized.host;
    this._defaultButton = normalized.defaultButton;
    this._buttons = normalized.buttons;
    this._hasClose = normalized.hasClose;
    this._buttonNodes = this._buttons.map((b) => renderer.createButtonNode(b));
    this._checkboxNode = null;
    this._lastMouseDownInDialog = false;
    if (normalized.checkbox) {
      const { label = "", caption = "", checked = false, className = "" } = normalized.checkbox;
      this._checkboxNode = renderer.createCheckboxNode({
        label,
        caption: caption !== null && caption !== void 0 ? caption : label,
        checked,
        className
      });
    }
    const layout = this.layout = new PanelLayout();
    const content = new Panel();
    content.addClass("jp-Dialog-content");
    if (typeof options.body === "string") {
      content.addClass("jp-Dialog-content-small");
      dialogNode.ariaLabel = [normalized.title, options.body].join(" ");
    }
    layout.addWidget(content);
    this._body = normalized.body;
    const header = renderer.createHeader(normalized.title, () => this.reject(), options);
    const body = renderer.createBody(normalized.body);
    const footer = renderer.createFooter(this._buttonNodes, this._checkboxNode);
    content.addWidget(header);
    content.addWidget(body);
    content.addWidget(footer);
    this._bodyWidget = body;
    this._primary = this._buttonNodes[this._defaultButton];
    this._focusNodeSelector = options.focusNodeSelector;
    void Dialog.tracker.add(this);
  }
  /**
   * A promise that resolves when the Dialog first rendering is done.
   */
  get ready() {
    return this._ready.promise;
  }
  /**
   * Dispose of the resources used by the dialog.
   */
  dispose() {
    const promise = this._promise;
    if (promise) {
      this._promise = null;
      promise.reject(void 0);
      ArrayExt.removeFirstOf(Private$d.launchQueue, promise.promise);
    }
    super.dispose();
  }
  /**
   * Launch the dialog as a modal window.
   *
   * @returns a promise that resolves with the result of the dialog.
   */
  launch() {
    if (this._promise) {
      return this._promise.promise;
    }
    const promise = this._promise = new PromiseDelegate();
    const promises = Promise.all(Private$d.launchQueue);
    Private$d.launchQueue.push(this._promise.promise);
    return promises.then(() => {
      if (!this._promise) {
        return Promise.resolve({
          button: Dialog.cancelButton(),
          isChecked: null,
          value: null
        });
      }
      Widget.attach(this, this._host);
      return promise.promise;
    });
  }
  /**
   * Resolve the current dialog.
   *
   * @param index - An optional index to the button to resolve.
   *
   * #### Notes
   * Will default to the defaultIndex.
   * Will resolve the current `show()` with the button value.
   * Will be a no-op if the dialog is not shown.
   */
  resolve(index) {
    if (!this._promise) {
      return;
    }
    if (index === void 0) {
      index = this._defaultButton;
    }
    this._resolve(this._buttons[index]);
  }
  /**
   * Reject the current dialog with a default reject value.
   *
   * #### Notes
   * Will be a no-op if the dialog is not shown.
   */
  reject() {
    if (!this._promise) {
      return;
    }
    this._resolve(Dialog.cancelButton());
  }
  /**
   * Handle the DOM events for the directory listing.
   *
   * @param event - The DOM event sent to the widget.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the panel's DOM node. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "keydown":
        this._evtKeydown(event2);
        break;
      case "mousedown":
        this._evtMouseDown(event2);
        break;
      case "click":
        this._evtClick(event2);
        break;
      case "input":
        this._evtInput(event2);
        break;
      case "focus":
        this._evtFocus(event2);
        break;
      case "contextmenu":
        event2.preventDefault();
        event2.stopPropagation();
        break;
    }
  }
  /**
   *  A message handler invoked on an `'after-attach'` message.
   */
  onAfterAttach(msg) {
    const node2 = this.node;
    node2.addEventListener("keydown", this, true);
    node2.addEventListener("contextmenu", this, true);
    node2.addEventListener("click", this, true);
    document.addEventListener("mousedown", this, true);
    document.addEventListener("focus", this, true);
    document.addEventListener("input", this, true);
    this._first = Private$d.findFirstFocusable(this.node);
    this._original = document.activeElement;
    const setFocus = () => {
      var _a;
      if (this._focusNodeSelector) {
        const body = this.node.querySelector(".jp-Dialog-body");
        const el = body === null || body === void 0 ? void 0 : body.querySelector(this._focusNodeSelector);
        if (el) {
          this._primary = el;
        }
      }
      (_a = this._primary) === null || _a === void 0 ? void 0 : _a.focus();
      this._ready.resolve();
    };
    if (this._bodyWidget instanceof ReactWidget && this._bodyWidget.renderPromise !== void 0) {
      this._bodyWidget.renderPromise.then(() => {
        setFocus();
      }).catch(() => {
        console.error("Error while loading Dialog's body");
      });
    } else {
      setFocus();
    }
  }
  /**
   *  A message handler invoked on an `'after-detach'` message.
   */
  onAfterDetach(msg) {
    const node2 = this.node;
    node2.removeEventListener("keydown", this, true);
    node2.removeEventListener("contextmenu", this, true);
    node2.removeEventListener("click", this, true);
    document.removeEventListener("focus", this, true);
    document.removeEventListener("mousedown", this, true);
    document.removeEventListener("input", this, true);
    this._original.focus();
  }
  /**
   * A message handler invoked on a `'close-request'` message.
   */
  onCloseRequest(msg) {
    if (this._promise) {
      this.reject();
    }
    super.onCloseRequest(msg);
  }
  /**
   * Handle the `'input'` event for dialog's children.
   *
   * @param event - The DOM event sent to the widget
   */
  _evtInput(_event) {
    this._hasValidationErrors = !!this.node.querySelector(":invalid");
    for (let i2 = 0; i2 < this._buttons.length; i2++) {
      if (this._buttons[i2].accept) {
        this._buttonNodes[i2].disabled = this._hasValidationErrors;
      }
    }
  }
  /**
   * Handle the `'click'` event for a dialog button.
   *
   * @param event - The DOM event sent to the widget
   */
  _evtClick(event2) {
    const content = this.node.getElementsByClassName("jp-Dialog-content")[0];
    if (!content.contains(event2.target)) {
      event2.stopPropagation();
      event2.preventDefault();
      if (this._hasClose && !this._lastMouseDownInDialog) {
        this.reject();
      }
      return;
    }
    for (const buttonNode of this._buttonNodes) {
      if (buttonNode.contains(event2.target)) {
        const index = this._buttonNodes.indexOf(buttonNode);
        this.resolve(index);
      }
    }
  }
  /**
   * Handle the `'keydown'` event for the widget.
   *
   * @param event - The DOM event sent to the widget
   */
  _evtKeydown(event2) {
    switch (event2.keyCode) {
      case 27:
        event2.stopPropagation();
        event2.preventDefault();
        if (this._hasClose) {
          this.reject();
        }
        break;
      case 37: {
        const activeEl = document.activeElement;
        if (activeEl instanceof HTMLButtonElement) {
          let idx = this._buttonNodes.indexOf(activeEl) - 1;
          if (idx < 0) {
            idx = this._buttonNodes.length - 1;
          }
          const node2 = this._buttonNodes[idx];
          event2.stopPropagation();
          event2.preventDefault();
          node2.focus();
        }
        break;
      }
      case 39: {
        const activeEl = document.activeElement;
        if (activeEl instanceof HTMLButtonElement) {
          let idx = this._buttonNodes.indexOf(activeEl) + 1;
          if (idx == this._buttons.length) {
            idx = 0;
          }
          const node2 = this._buttonNodes[idx];
          event2.stopPropagation();
          event2.preventDefault();
          node2.focus();
        }
        break;
      }
      case 9: {
        const node2 = this._buttonNodes[this._buttons.length - 1];
        if (document.activeElement === node2 && !event2.shiftKey) {
          event2.stopPropagation();
          event2.preventDefault();
          this._first.focus();
        }
        break;
      }
      case 13: {
        event2.stopPropagation();
        event2.preventDefault();
        const activeEl = document.activeElement;
        let index;
        if (activeEl instanceof HTMLButtonElement) {
          index = this._buttonNodes.indexOf(activeEl);
        }
        this.resolve(index);
        break;
      }
    }
  }
  /**
   * Handle the `'focus'` event for the widget.
   *
   * @param event - The DOM event sent to the widget
   */
  _evtFocus(event2) {
    var _a;
    const target2 = event2.target;
    if (!this.node.contains(target2)) {
      event2.stopPropagation();
      (_a = this._buttonNodes[this._defaultButton]) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }
  /**
   * Handle the `'mousedown'` event for the widget.
   *
   * @param event - The DOM event sent to the widget
   */
  _evtMouseDown(event2) {
    const content = this.node.getElementsByClassName("jp-Dialog-content")[0];
    const target2 = event2.target;
    this._lastMouseDownInDialog = content.contains(target2);
  }
  /**
   * Resolve a button item.
   */
  _resolve(button) {
    var _a, _b, _c;
    if (this._hasValidationErrors && button.accept) {
      return;
    }
    const promise = this._promise;
    if (!promise) {
      this.dispose();
      return;
    }
    this._promise = null;
    ArrayExt.removeFirstOf(Private$d.launchQueue, promise.promise);
    const body = this._body;
    let value = null;
    if (button.accept && body instanceof Widget && typeof body.getValue === "function") {
      value = body.getValue();
    }
    this.dispose();
    promise.resolve({
      button,
      isChecked: (_c = (_b = (_a = this._checkboxNode) === null || _a === void 0 ? void 0 : _a.querySelector("input")) === null || _b === void 0 ? void 0 : _b.checked) !== null && _c !== void 0 ? _c : null,
      value
    });
  }
}
(function(Dialog2) {
  Dialog2.translator = nullTranslator;
  function createButton(value) {
    value.accept = value.accept !== false;
    const trans = Dialog2.translator.load("jupyterlab");
    const defaultLabel = value.accept ? trans.__("Ok") : trans.__("Cancel");
    return {
      ariaLabel: value.ariaLabel || value.label || defaultLabel,
      label: value.label || defaultLabel,
      iconClass: value.iconClass || "",
      iconLabel: value.iconLabel || "",
      caption: value.caption || "",
      className: value.className || "",
      accept: value.accept,
      actions: value.actions || [],
      displayType: value.displayType || "default"
    };
  }
  Dialog2.createButton = createButton;
  function cancelButton(options = {}) {
    options.accept = false;
    return createButton(options);
  }
  Dialog2.cancelButton = cancelButton;
  function okButton(options = {}) {
    options.accept = true;
    return createButton(options);
  }
  Dialog2.okButton = okButton;
  function warnButton(options = {}) {
    options.displayType = "warn";
    return createButton(options);
  }
  Dialog2.warnButton = warnButton;
  function flush() {
    Dialog2.tracker.forEach((dialog) => {
      dialog.dispose();
    });
  }
  Dialog2.flush = flush;
  class Renderer {
    /**
     * Create the header of the dialog.
     *
     * @param title - The title of the dialog.
     *
     * @returns A widget for the dialog header.
     */
    createHeader(title, reject = () => {
    }, options = {}) {
      let header;
      const handleMouseDown = (event2) => {
        if (event2.button === 0) {
          event2.preventDefault();
          reject();
        }
      };
      const handleKeyDown = (event2) => {
        const { key: key2 } = event2;
        if (key2 === "Enter" || key2 === " ") {
          reject();
        }
      };
      if (typeof title === "string") {
        const trans = Dialog2.translator.load("jupyterlab");
        header = ReactWidget.create(reactExports.createElement(
          reactExports.Fragment,
          null,
          title,
          options.hasClose && reactExports.createElement(
            Button$2,
            { className: "jp-Dialog-close-button", onMouseDown: handleMouseDown, onKeyDown: handleKeyDown, title: trans.__("Cancel"), minimal: true },
            reactExports.createElement(LabIcon.resolveReact, { icon: closeIcon, tag: "span" })
          )
        ));
      } else {
        header = ReactWidget.create(title);
      }
      header.addClass("jp-Dialog-header");
      Styling.styleNode(header.node);
      return header;
    }
    /**
     * Create the body of the dialog.
     *
     * @param value - The input value for the body.
     *
     * @returns A widget for the body.
     */
    createBody(value) {
      const styleReactWidget = (widget) => {
        if (widget.renderPromise !== void 0) {
          widget.renderPromise.then(() => {
            Styling.styleNode(widget.node);
          }).catch(() => {
            console.error("Error while loading Dialog's body");
          });
        } else {
          Styling.styleNode(widget.node);
        }
      };
      let body;
      if (typeof value === "string") {
        body = new Widget({ node: document.createElement("span") });
        body.node.textContent = value;
      } else if (value instanceof Widget) {
        body = value;
        if (body instanceof ReactWidget) {
          styleReactWidget(body);
        } else {
          Styling.styleNode(body.node);
        }
      } else {
        body = ReactWidget.create(value);
        MessageLoop.sendMessage(body, Widget.Msg.UpdateRequest);
        styleReactWidget(body);
      }
      body.addClass("jp-Dialog-body");
      return body;
    }
    /**
     * Create the footer of the dialog.
     *
     * @param buttons - The buttons nodes to add to the footer.
     * @param checkbox - The checkbox node to add to the footer.
     *
     * @returns A widget for the footer.
     */
    createFooter(buttons, checkbox) {
      const footer = new Widget();
      footer.addClass("jp-Dialog-footer");
      if (checkbox) {
        footer.node.appendChild(checkbox);
        footer.node.insertAdjacentHTML("beforeend", '<div class="jp-Dialog-spacer"></div>');
      }
      for (const button of buttons) {
        footer.node.appendChild(button);
      }
      Styling.styleNode(footer.node);
      return footer;
    }
    /**
     * Create a button node for the dialog.
     *
     * @param button - The button data.
     *
     * @returns A node for the button.
     */
    createButtonNode(button) {
      const e = document.createElement("button");
      e.className = this.createItemClass(button);
      e.appendChild(this.renderIcon(button));
      e.appendChild(this.renderLabel(button));
      return e;
    }
    /**
     * Create a checkbox node for the dialog.
     *
     * @param checkbox - The checkbox data.
     *
     * @returns A node for the checkbox.
     */
    createCheckboxNode(checkbox) {
      const e = document.createElement("label");
      e.className = "jp-Dialog-checkbox";
      if (checkbox.className) {
        e.classList.add(checkbox.className);
      }
      e.title = checkbox.caption;
      e.textContent = checkbox.label;
      const input2 = document.createElement("input");
      input2.type = "checkbox";
      input2.checked = !!checkbox.checked;
      e.insertAdjacentElement("afterbegin", input2);
      return e;
    }
    /**
     * Create the class name for the button.
     *
     * @param data - The data to use for the class name.
     *
     * @returns The full class name for the button.
     */
    createItemClass(data) {
      let name2 = "jp-Dialog-button";
      if (data.accept) {
        name2 += " jp-mod-accept";
      } else {
        name2 += " jp-mod-reject";
      }
      if (data.displayType === "warn") {
        name2 += " jp-mod-warn";
      }
      const extra = data.className;
      if (extra) {
        name2 += ` ${extra}`;
      }
      return name2;
    }
    /**
     * Render an icon element for a dialog item.
     *
     * @param data - The data to use for rendering the icon.
     *
     * @returns An HTML element representing the icon.
     */
    renderIcon(data) {
      const e = document.createElement("div");
      e.className = this.createIconClass(data);
      e.appendChild(document.createTextNode(data.iconLabel));
      return e;
    }
    /**
     * Create the class name for the button icon.
     *
     * @param data - The data to use for the class name.
     *
     * @returns The full class name for the item icon.
     */
    createIconClass(data) {
      const name2 = "jp-Dialog-buttonIcon";
      const extra = data.iconClass;
      return extra ? `${name2} ${extra}` : name2;
    }
    /**
     * Render the label element for a button.
     *
     * @param data - The data to use for rendering the label.
     *
     * @returns An HTML element representing the item label.
     */
    renderLabel(data) {
      const e = document.createElement("div");
      e.className = "jp-Dialog-buttonLabel";
      e.title = data.caption;
      e.ariaLabel = data.ariaLabel;
      e.appendChild(document.createTextNode(data.label));
      return e;
    }
  }
  Dialog2.Renderer = Renderer;
  Dialog2.defaultRenderer = new Renderer();
  Dialog2.tracker = new WidgetTracker({
    namespace: "@jupyterlab/apputils:Dialog"
  });
})(Dialog || (Dialog = {}));
var Private$d;
(function(Private2) {
  Private2.launchQueue = [];
  Private2.errorMessagePromiseCache = /* @__PURE__ */ new Map();
  function handleOptions(options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const buttons = (_a = options.buttons) !== null && _a !== void 0 ? _a : [
      Dialog.cancelButton(),
      Dialog.okButton()
    ];
    return {
      title: (_b = options.title) !== null && _b !== void 0 ? _b : "",
      body: (_c = options.body) !== null && _c !== void 0 ? _c : "",
      host: (_d = options.host) !== null && _d !== void 0 ? _d : document.body,
      checkbox: (_e = options.checkbox) !== null && _e !== void 0 ? _e : null,
      buttons,
      defaultButton: (_f = options.defaultButton) !== null && _f !== void 0 ? _f : buttons.length - 1,
      renderer: (_g = options.renderer) !== null && _g !== void 0 ? _g : Dialog.defaultRenderer,
      focusNodeSelector: (_h = options.focusNodeSelector) !== null && _h !== void 0 ? _h : "",
      hasClose: (_j = options.hasClose) !== null && _j !== void 0 ? _j : true
    };
  }
  Private2.handleOptions = handleOptions;
  function findFirstFocusable(node2) {
    const candidateSelectors2 = [
      "input",
      "select",
      "a[href]",
      "textarea",
      "button",
      "[tabindex]"
    ].join(",");
    return node2.querySelectorAll(candidateSelectors2)[0];
  }
  Private2.findFirstFocusable = findFirstFocusable;
})(Private$d || (Private$d = {}));
class SessionContext {
  /**
   * Construct a new session context.
   */
  constructor(options) {
    var _a, _b, _c, _d;
    this._path = "";
    this._name = "";
    this._type = "";
    this._prevKernelName = "";
    this._isDisposed = false;
    this._disposed = new Signal(this);
    this._session = null;
    this._ready = new PromiseDelegate();
    this._initializing = false;
    this._initStarted = new PromiseDelegate();
    this._initPromise = new PromiseDelegate();
    this._isReady = false;
    this._isTerminating = false;
    this._isRestarting = false;
    this._kernelChanged = new Signal(this);
    this._preferenceChanged = new Signal(this);
    this._sessionChanged = new Signal(this);
    this._statusChanged = new Signal(this);
    this._connectionStatusChanged = new Signal(this);
    this._pendingInput = false;
    this._iopubMessage = new Signal(this);
    this._unhandledMessage = new Signal(this);
    this._propertyChanged = new Signal(this);
    this._dialog = null;
    this._busyDisposable = null;
    this._pendingKernelName = "";
    this._pendingSessionRequest = "";
    this.kernelManager = options.kernelManager;
    this.sessionManager = options.sessionManager;
    this.specsManager = options.specsManager;
    this.translator = options.translator || nullTranslator;
    this._trans = this.translator.load("jupyterlab");
    this._path = (_a = options.path) !== null && _a !== void 0 ? _a : UUID.uuid4();
    this._type = (_b = options.type) !== null && _b !== void 0 ? _b : "";
    this._name = (_c = options.name) !== null && _c !== void 0 ? _c : "";
    this._setBusy = options.setBusy;
    this._kernelPreference = (_d = options.kernelPreference) !== null && _d !== void 0 ? _d : {};
  }
  /**
   * The current session connection.
   */
  get session() {
    var _a;
    return (_a = this._session) !== null && _a !== void 0 ? _a : null;
  }
  /**
   * The session path.
   *
   * #### Notes
   * Typically `.session.path` should be used. This attribute is useful if
   * there is no current session.
   */
  get path() {
    return this._path;
  }
  /**
   * The session type.
   *
   * #### Notes
   * Typically `.session.type` should be used. This attribute is useful if
   * there is no current session.
   */
  get type() {
    return this._type;
  }
  /**
   * The session name.
   *
   * #### Notes
   * Typically `.session.name` should be used. This attribute is useful if
   * there is no current session.
   */
  get name() {
    return this._name;
  }
  /**
   * A signal emitted when the kernel connection changes, proxied from the session connection.
   */
  get kernelChanged() {
    return this._kernelChanged;
  }
  /**
   * A signal emitted when the session connection changes.
   */
  get sessionChanged() {
    return this._sessionChanged;
  }
  /**
   * A signal emitted when the kernel status changes, proxied from the kernel.
   */
  get statusChanged() {
    return this._statusChanged;
  }
  /**
   * A flag indicating if the session has pending input, proxied from the kernel.
   */
  get pendingInput() {
    return this._pendingInput;
  }
  /**
   * A signal emitted when the kernel status changes, proxied from the kernel.
   */
  get connectionStatusChanged() {
    return this._connectionStatusChanged;
  }
  /**
   * A signal emitted for iopub kernel messages, proxied from the kernel.
   */
  get iopubMessage() {
    return this._iopubMessage;
  }
  /**
   * A signal emitted for an unhandled kernel message, proxied from the kernel.
   */
  get unhandledMessage() {
    return this._unhandledMessage;
  }
  /**
   * A signal emitted when a session property changes, proxied from the current session.
   */
  get propertyChanged() {
    return this._propertyChanged;
  }
  /**
   * The kernel preference of this client session.
   *
   * This is used when selecting a new kernel, and should reflect the sort of
   * kernel the activity prefers.
   */
  get kernelPreference() {
    return this._kernelPreference;
  }
  set kernelPreference(value) {
    if (!JSONExt.deepEqual(value, this._kernelPreference)) {
      const oldValue = this._kernelPreference;
      this._kernelPreference = value;
      this._preferenceChanged.emit({
        name: "kernelPreference",
        oldValue,
        newValue: JSONExt.deepCopy(value)
      });
    }
  }
  /**
   * Signal emitted if the kernel preference changes.
   */
  get kernelPreferenceChanged() {
    return this._preferenceChanged;
  }
  /**
   * Whether the context is ready.
   */
  get isReady() {
    return this._isReady;
  }
  /**
   * A promise that is fulfilled when the context is ready.
   */
  get ready() {
    return this._ready.promise;
  }
  /**
   * Whether the context is terminating.
   */
  get isTerminating() {
    return this._isTerminating;
  }
  /**
   * Whether the context is restarting.
   */
  get isRestarting() {
    return this._isRestarting;
  }
  /**
   * Whether the kernel is "No Kernel" or not.
   *
   * #### Notes
   * As the displayed name is translated, this can be used directly.
   */
  get hasNoKernel() {
    return this.kernelDisplayName === this.noKernelName;
  }
  /**
   * The display name of the current kernel, or a sensible alternative.
   *
   * #### Notes
   * This is a convenience function to have a consistent sensible name for the
   * kernel.
   */
  get kernelDisplayName() {
    var _a, _b, _c, _d, _e, _f, _g;
    const kernel2 = (_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel;
    if (this._pendingKernelName === this.noKernelName) {
      return this.noKernelName;
    }
    if (this._pendingKernelName) {
      return (_d = (_c = (_b = this.specsManager.specs) === null || _b === void 0 ? void 0 : _b.kernelspecs[this._pendingKernelName]) === null || _c === void 0 ? void 0 : _c.display_name) !== null && _d !== void 0 ? _d : this._pendingKernelName;
    }
    if (!kernel2) {
      return this.noKernelName;
    }
    return (_g = (_f = (_e = this.specsManager.specs) === null || _e === void 0 ? void 0 : _e.kernelspecs[kernel2.name]) === null || _f === void 0 ? void 0 : _f.display_name) !== null && _g !== void 0 ? _g : kernel2.name;
  }
  /**
   * A sensible status to display
   *
   * #### Notes
   * This combines the status and connection status into a single status for
   * the user.
   */
  get kernelDisplayStatus() {
    var _a, _b;
    const kernel2 = (_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel;
    if (this._isTerminating) {
      return "terminating";
    }
    if (this._isRestarting) {
      return "restarting";
    }
    if (this._pendingKernelName === this.noKernelName) {
      return "unknown";
    }
    if (!kernel2 && this._pendingKernelName) {
      return "initializing";
    }
    if (!kernel2 && !this.isReady && this.kernelPreference.canStart !== false && this.kernelPreference.shouldStart !== false) {
      return "initializing";
    }
    return (_b = (kernel2 === null || kernel2 === void 0 ? void 0 : kernel2.connectionStatus) === "connected" ? kernel2 === null || kernel2 === void 0 ? void 0 : kernel2.status : kernel2 === null || kernel2 === void 0 ? void 0 : kernel2.connectionStatus) !== null && _b !== void 0 ? _b : "unknown";
  }
  /**
   * The name of the previously started kernel.
   */
  get prevKernelName() {
    return this._prevKernelName;
  }
  /**
   * Test whether the context is disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * A signal emitted when the poll is disposed.
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * Get the constant displayed name for "No Kernel"
   */
  get noKernelName() {
    return this._trans.__("No Kernel");
  }
  /**
   * Dispose of the resources held by the context.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    this._disposed.emit();
    if (this._session) {
      if (this.kernelPreference.shutdownOnDispose) {
        this.sessionManager.shutdown(this._session.id).catch((reason) => {
          console.error(`Kernel not shut down ${reason}`);
        });
      }
      this._session.dispose();
      this._session = null;
    }
    if (this._dialog) {
      this._dialog.dispose();
    }
    if (this._busyDisposable) {
      this._busyDisposable.dispose();
      this._busyDisposable = null;
    }
    Signal.clearData(this);
  }
  /**
   * Starts new Kernel.
   *
   * @returns Whether to ask the user to pick a kernel.
   */
  async startKernel() {
    const preference = this.kernelPreference;
    if (!preference.autoStartDefault && preference.shouldStart === false) {
      return true;
    }
    let options;
    if (preference.id) {
      options = { id: preference.id };
    } else {
      const name2 = Private$c.getDefaultKernel({
        specs: this.specsManager.specs,
        sessions: this.sessionManager.running(),
        preference
      });
      if (name2) {
        options = { name: name2 };
      }
    }
    if (options) {
      try {
        await this._changeKernel(options);
        return false;
      } catch (err) {
      }
    }
    return true;
  }
  /**
   * Restart the current Kernel.
   *
   * @returns A promise that resolves when the kernel is restarted.
   */
  async restartKernel() {
    var _a, _b, _c, _d, _e, _f;
    const kernel2 = ((_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel) || null;
    if (this._isRestarting) {
      return;
    }
    this._isRestarting = true;
    this._isReady = false;
    this._statusChanged.emit("restarting");
    try {
      await ((_c = (_b = this.session) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.restart());
      this._isReady = true;
    } catch (e) {
      console.error(e);
    }
    this._isRestarting = false;
    this._statusChanged.emit(((_e = (_d = this.session) === null || _d === void 0 ? void 0 : _d.kernel) === null || _e === void 0 ? void 0 : _e.status) || "unknown");
    this._kernelChanged.emit({
      name: "kernel",
      oldValue: kernel2,
      newValue: ((_f = this.session) === null || _f === void 0 ? void 0 : _f.kernel) || null
    });
  }
  /**
   * Change the current kernel associated with the session.
   */
  async changeKernel(options = {}) {
    if (this.isDisposed) {
      throw new Error("Disposed");
    }
    await this._initStarted.promise;
    return this._changeKernel(options);
  }
  /**
   * Kill the kernel and shutdown the session.
   *
   * @returns A promise that resolves when the session is shut down.
   */
  async shutdown() {
    if (this.isDisposed || !this._initializing) {
      return;
    }
    await this._initStarted.promise;
    this._pendingSessionRequest = "";
    this._pendingKernelName = this.noKernelName;
    return this._shutdownSession();
  }
  /**
   * Initialize the session context
   *
   * @returns A promise that resolves with whether to ask the user to select a kernel.
   *
   * #### Notes
   * If a server session exists on the current path, we will connect to it.
   * If preferences include disabling `canStart` or `shouldStart`, no
   * server session will be started.
   * If a kernel id is given, we attempt to start a session with that id.
   * If a default kernel is available, we connect to it.
   * Otherwise we ask the user to select a kernel.
   */
  async initialize() {
    if (this._initializing) {
      return this._initPromise.promise;
    }
    this._initializing = true;
    const needsSelection = await this._initialize();
    if (!needsSelection) {
      this._isReady = true;
      this._ready.resolve(void 0);
    }
    if (!this._pendingSessionRequest) {
      this._initStarted.resolve(void 0);
    }
    this._initPromise.resolve(needsSelection);
    return needsSelection;
  }
  /**
   * Inner initialize function that doesn't handle promises.
   * This makes it easier to consolidate promise handling logic.
   */
  async _initialize() {
    const manager2 = this.sessionManager;
    await manager2.ready;
    await manager2.refreshRunning();
    const model = find$3(manager2.running(), (item) => {
      return item.path === this._path;
    });
    if (model) {
      try {
        const session2 = manager2.connectTo({ model });
        this._handleNewSession(session2);
      } catch (err) {
        void this._handleSessionError(err);
        return Promise.reject(err);
      }
    }
    return await this._startIfNecessary();
  }
  /**
   * Shut down the current session.
   */
  async _shutdownSession() {
    var _a;
    const session2 = this._session;
    const isTerminating = this._isTerminating;
    const isReady = this._isReady;
    this._isTerminating = true;
    this._isReady = false;
    this._statusChanged.emit("terminating");
    try {
      await (session2 === null || session2 === void 0 ? void 0 : session2.shutdown());
      this._isTerminating = false;
      session2 === null || session2 === void 0 ? void 0 : session2.dispose();
      this._session = null;
      const kernel2 = (session2 === null || session2 === void 0 ? void 0 : session2.kernel) || null;
      this._statusChanged.emit("unknown");
      this._kernelChanged.emit({
        name: "kernel",
        oldValue: kernel2,
        newValue: null
      });
      this._sessionChanged.emit({
        name: "session",
        oldValue: session2,
        newValue: null
      });
    } catch (err) {
      this._isTerminating = isTerminating;
      this._isReady = isReady;
      const status = (_a = session2 === null || session2 === void 0 ? void 0 : session2.kernel) === null || _a === void 0 ? void 0 : _a.status;
      if (status === void 0) {
        this._statusChanged.emit("unknown");
      } else {
        this._statusChanged.emit(status);
      }
      throw err;
    }
    return;
  }
  /**
   * Start the session if necessary.
   *
   * @returns Whether to ask the user to pick a kernel.
   */
  async _startIfNecessary() {
    var _a;
    const preference = this.kernelPreference;
    if (this.isDisposed || ((_a = this.session) === null || _a === void 0 ? void 0 : _a.kernel) || preference.shouldStart === false || preference.canStart === false) {
      return false;
    }
    return this.startKernel();
  }
  /**
   * Change the kernel.
   */
  async _changeKernel(model = {}) {
    if (model.name) {
      this._pendingKernelName = model.name;
    }
    if (!this._session) {
      this._kernelChanged.emit({
        name: "kernel",
        oldValue: null,
        newValue: null
      });
    }
    if (!this._pendingSessionRequest) {
      this._initStarted.resolve(void 0);
    }
    if (this._session && !this._isTerminating) {
      try {
        await this._session.changeKernel(model);
        return this._session.kernel;
      } catch (err) {
        void this._handleSessionError(err);
        throw err;
      }
    }
    const dirName = lib$9.PathExt.dirname(this._path);
    const requestId = this._pendingSessionRequest = lib$9.PathExt.join(dirName, UUID.uuid4());
    try {
      this._statusChanged.emit("starting");
      const session2 = await this.sessionManager.startNew({
        path: requestId,
        type: this._type,
        name: this._name,
        kernel: model
      });
      if (this._pendingSessionRequest !== session2.path) {
        await session2.shutdown();
        session2.dispose();
        return null;
      }
      await session2.setPath(this._path);
      await session2.setName(this._name);
      if (this._session && !this._isTerminating) {
        await this._shutdownSession();
      }
      return this._handleNewSession(session2);
    } catch (err) {
      void this._handleSessionError(err);
      throw err;
    }
  }
  /**
   * Handle a new session object.
   */
  _handleNewSession(session2) {
    var _a, _b, _c;
    if (this.isDisposed) {
      throw Error("Disposed");
    }
    if (!this._isReady) {
      this._isReady = true;
      this._ready.resolve(void 0);
    }
    if (this._session) {
      this._session.dispose();
    }
    this._session = session2;
    this._pendingKernelName = "";
    if (session2) {
      this._prevKernelName = (_b = (_a = session2.kernel) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "";
      session2.disposed.connect(this._onSessionDisposed, this);
      session2.propertyChanged.connect(this._onPropertyChanged, this);
      session2.kernelChanged.connect(this._onKernelChanged, this);
      session2.statusChanged.connect(this._onStatusChanged, this);
      session2.connectionStatusChanged.connect(this._onConnectionStatusChanged, this);
      session2.pendingInput.connect(this._onPendingInput, this);
      session2.iopubMessage.connect(this._onIopubMessage, this);
      session2.unhandledMessage.connect(this._onUnhandledMessage, this);
      if (session2.path !== this._path) {
        this._onPropertyChanged(session2, "path");
      }
      if (session2.name !== this._name) {
        this._onPropertyChanged(session2, "name");
      }
      if (session2.type !== this._type) {
        this._onPropertyChanged(session2, "type");
      }
    }
    this._sessionChanged.emit({
      name: "session",
      oldValue: null,
      newValue: session2
    });
    this._kernelChanged.emit({
      oldValue: null,
      newValue: (session2 === null || session2 === void 0 ? void 0 : session2.kernel) || null,
      name: "kernel"
    });
    this._statusChanged.emit(((_c = session2 === null || session2 === void 0 ? void 0 : session2.kernel) === null || _c === void 0 ? void 0 : _c.status) || "unknown");
    return (session2 === null || session2 === void 0 ? void 0 : session2.kernel) || null;
  }
  /**
   * Handle an error in session startup.
   */
  async _handleSessionError(err) {
    this._handleNewSession(null);
    let traceback = "";
    let message = "";
    try {
      traceback = err.traceback;
      message = err.message;
    } catch (err2) {
    }
    await this._displayKernelError(message, traceback);
  }
  /**
   * Display kernel error
   */
  async _displayKernelError(message, traceback) {
    const body = reactExports.createElement(
      "div",
      null,
      message && reactExports.createElement("pre", null, message),
      traceback && reactExports.createElement(
        "details",
        { className: "jp-mod-wide" },
        reactExports.createElement("pre", null, traceback)
      )
    );
    const dialog = this._dialog = new Dialog({
      title: this._trans.__("Error Starting Kernel"),
      body,
      buttons: [Dialog.okButton()]
    });
    await dialog.launch();
    this._dialog = null;
  }
  /**
   * Handle a session termination.
   */
  _onSessionDisposed() {
    if (this._session) {
      const oldValue = this._session;
      this._session = null;
      const newValue = this._session;
      this._sessionChanged.emit({ name: "session", oldValue, newValue });
    }
  }
  /**
   * Handle a change to a session property.
   */
  _onPropertyChanged(sender, property) {
    switch (property) {
      case "path":
        this._path = sender.path;
        break;
      case "name":
        this._name = sender.name;
        break;
      case "type":
        this._type = sender.type;
        break;
      default:
        throw new Error(`unrecognized property ${property}`);
    }
    this._propertyChanged.emit(property);
  }
  /**
   * Handle a change to the kernel.
   */
  _onKernelChanged(sender, args) {
    this._kernelChanged.emit(args);
  }
  /**
   * Handle a change to the session status.
   */
  _onStatusChanged(sender, status) {
    var _a;
    if (status === "dead") {
      const model = (_a = sender.kernel) === null || _a === void 0 ? void 0 : _a.model;
      if (model === null || model === void 0 ? void 0 : model.reason) {
        const traceback = model.traceback || "";
        void this._displayKernelError(model.reason, traceback);
      }
    }
    if (this._setBusy) {
      if (status === "busy") {
        if (!this._busyDisposable) {
          this._busyDisposable = this._setBusy();
        }
      } else {
        if (this._busyDisposable) {
          this._busyDisposable.dispose();
          this._busyDisposable = null;
        }
      }
    }
    this._statusChanged.emit(status);
  }
  /**
   * Handle a change to the session status.
   */
  _onConnectionStatusChanged(sender, status) {
    this._connectionStatusChanged.emit(status);
  }
  /**
   * Handle a change to the pending input.
   */
  _onPendingInput(sender, value) {
    this._pendingInput = value;
  }
  /**
   * Handle an iopub message.
   */
  _onIopubMessage(sender, message) {
    if (message.header.msg_type === "shutdown_reply") {
      this.session.kernel.removeInputGuard();
    }
    this._iopubMessage.emit(message);
  }
  /**
   * Handle an unhandled message.
   */
  _onUnhandledMessage(sender, message) {
    this._unhandledMessage.emit(message);
  }
}
(function(SessionContext2) {
  function getDefaultKernel(options) {
    const { preference } = options;
    const { shouldStart } = preference;
    if (shouldStart === false) {
      return null;
    }
    return Private$c.getDefaultKernel(options);
  }
  SessionContext2.getDefaultKernel = getDefaultKernel;
})(SessionContext || (SessionContext = {}));
class SessionContextDialogs {
  constructor(options = {}) {
    var _a;
    this._translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
    this._settingRegistry = options.settingRegistry || null;
  }
  /**
   * Select a kernel for the session.
   */
  async selectKernel(sessionContext) {
    if (sessionContext.isDisposed) {
      return Promise.resolve();
    }
    const translator = this._translator;
    const trans = translator.load("jupyterlab");
    let label = trans.__("Cancel");
    if (sessionContext.hasNoKernel) {
      label = sessionContext.kernelDisplayName;
    }
    const buttons = [
      Dialog.cancelButton({ label }),
      Dialog.okButton({
        label: trans.__("Select"),
        ariaLabel: trans.__("Select Kernel")
      })
    ];
    const autoStartDefault = sessionContext.kernelPreference.autoStartDefault;
    const hasCheckbox = typeof autoStartDefault === "boolean";
    const dialog = new Dialog({
      title: trans.__("Select Kernel"),
      body: Private$c.createKernelSelector(sessionContext, translator),
      buttons,
      checkbox: hasCheckbox ? {
        label: trans.__("Always start the preferred kernel"),
        caption: trans.__("Remember my choice and always start the preferred kernel"),
        checked: autoStartDefault
      } : null
    });
    const result2 = await dialog.launch();
    if (sessionContext.isDisposed || !result2.button.accept) {
      return;
    }
    if (hasCheckbox && result2.isChecked !== null) {
      sessionContext.kernelPreference = {
        ...sessionContext.kernelPreference,
        autoStartDefault: result2.isChecked
      };
    }
    const model = result2.value;
    if (model === null && !sessionContext.hasNoKernel) {
      return sessionContext.shutdown();
    }
    if (model) {
      await sessionContext.changeKernel(model);
    }
  }
  /**
   * Restart the session.
   *
   * @returns A promise that resolves with whether the kernel has restarted.
   *
   * #### Notes
   * If there is a running kernel, present a dialog.
   * If there is no kernel, we start a kernel with the last run
   * kernel name and resolves with `true`.
   */
  async restart(sessionContext) {
    var _a, _b, _c, _d, _e;
    const trans = this._translator.load("jupyterlab");
    await sessionContext.initialize();
    if (sessionContext.isDisposed) {
      throw new Error("session already disposed");
    }
    const kernel2 = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
    if (!kernel2 && sessionContext.prevKernelName) {
      await sessionContext.changeKernel({
        name: sessionContext.prevKernelName
      });
      return true;
    }
    if (!kernel2) {
      throw new Error("No kernel to restart");
    }
    const kernelPluginId = "@jupyterlab/apputils-extension:sessionDialogs";
    const skipKernelRestartDialog = (_c = (_b = sessionContext.kernelPreference) === null || _b === void 0 ? void 0 : _b.skipKernelRestartDialog) !== null && _c !== void 0 ? _c : false;
    const skipKernelRestartDialogSetting = (_e = await ((_d = this._settingRegistry) === null || _d === void 0 ? void 0 : _d.get(kernelPluginId, "skipKernelRestartDialog"))) === null || _e === void 0 ? void 0 : _e.composite;
    if (skipKernelRestartDialogSetting || skipKernelRestartDialog) {
      await sessionContext.restartKernel();
      return true;
    }
    const restartBtn = Dialog.warnButton({
      label: trans.__("Restart"),
      ariaLabel: trans.__("Confirm Kernel Restart")
    });
    const result2 = await showDialog({
      title: trans.__("Restart Kernel?"),
      body: trans.__("Do you want to restart the kernel of %1? All variables will be lost.", sessionContext.name),
      buttons: [
        Dialog.cancelButton({ ariaLabel: trans.__("Cancel Kernel Restart") }),
        restartBtn
      ],
      checkbox: {
        label: trans.__("Do not ask me again."),
        caption: trans.__("If checked, the kernel will restart without confirmation prompt in the future; you can change this back in the settings.")
      }
    });
    if (kernel2.isDisposed) {
      return false;
    }
    if (result2.button.accept) {
      if (typeof result2.isChecked === "boolean" && result2.isChecked == true) {
        sessionContext.kernelPreference = {
          ...sessionContext.kernelPreference,
          skipKernelRestartDialog: true
        };
      }
      await sessionContext.restartKernel();
      return true;
    }
    return false;
  }
}
(function(SessionContextDialogs2) {
  function kernelOptions(sessionContext, translator = null) {
    var _a, _b, _c, _d, _e, _f, _g;
    const options = { disabled: false, groups: [] };
    const kernels = Array.from((_b = (_a = sessionContext.kernelManager) === null || _a === void 0 ? void 0 : _a.running()) !== null && _b !== void 0 ? _b : (
      // If kernel manager is unavailable use kernels from running sessions.
      // TODO: Remove this (next version) when kernel manager is guaranteed.
      Array.from(sessionContext.sessionManager.running()).filter((session2) => !!session2.kernel).map((session2) => session2.kernel)
    ));
    const sessions = Array.from((_c = sessionContext.sessionManager.running()) !== null && _c !== void 0 ? _c : []).reduce((sessions2, session2) => {
      var _a2;
      if ((_a2 = session2.kernel) === null || _a2 === void 0 ? void 0 : _a2.id)
        sessions2[session2.kernel.id] = session2;
      return sessions2;
    }, {});
    const preference = {
      ...sessionContext.kernelPreference,
      id: (_e = (_d = sessionContext.session) === null || _d === void 0 ? void 0 : _d.kernel) === null || _e === void 0 ? void 0 : _e.id
    };
    const currentKernelDisplayName = !sessionContext.hasNoKernel ? sessionContext.kernelDisplayName : null;
    const specs = {
      default: "",
      kernelspecs: /* @__PURE__ */ Object.create(null),
      ...sessionContext.specsManager.specs
    };
    const sorted = [];
    const languages = /* @__PURE__ */ Object.create(null);
    for (const name2 in specs.kernelspecs) {
      sorted.push(specs.kernelspecs[name2]);
      languages[name2] = specs.kernelspecs[name2].language;
    }
    sorted.sort((a, b) => a.display_name.localeCompare(b.display_name));
    translator = translator || nullTranslator;
    const trans = translator.load("jupyterlab");
    const language = preference.language || languages[preference.name] || (preference.id ? languages[(_f = sessions[preference.id]) === null || _f === void 0 ? void 0 : _f.name] : "");
    const labels = {
      connectKernel: trans.__("Connect to Existing Kernel"),
      startPreferred: trans.__("Start %1 Kernel", language),
      startOther: trans.__("Start Kernel"),
      connectToPreferred: trans.__("Connect to Existing %1 Kernel", language),
      connectToOther: trans.__("Connect to Other Kernel"),
      noKernel: trans.__("No Kernel"),
      startKernel: trans.__("Start Kernel"),
      useNoKernel: trans.__("Use No Kernel")
    };
    const noKernel = {
      label: labels.useNoKernel,
      options: [
        {
          text: labels.noKernel,
          title: labels.noKernel,
          value: JSON.stringify(null)
        }
      ]
    };
    const optionForKernel = (kernel2, displayName, session2) => {
      const sessionName = session2 ? session2.name || lib$9.PathExt.basename(session2.path) : kernel2.name || trans.__("Unknown Kernel");
      return {
        text: `${sessionName} (${kernel2.id.split("-")[0]})`,
        title: (session2 ? `${trans.__("Path: %1", session2.path)}
` : ``) + `${trans.__("Name: %1", sessionName)}
${trans.__("Kernel Name: %1", displayName !== null && displayName !== void 0 ? displayName : kernel2.name)}
${trans.__("Kernel Id: %1", kernel2.id)}`,
        value: JSON.stringify({ id: kernel2.id })
      };
    };
    const optionForSpec = (spec) => ({
      text: spec.display_name,
      value: JSON.stringify({ name: spec.name })
    });
    if (preference.canStart === false) {
      options.disabled = true;
      options.groups.push(noKernel);
      return options;
    }
    if (language) {
      const preferred = {
        label: labels.startPreferred,
        options: []
      };
      const other = {
        label: labels.startOther,
        options: []
      };
      const preferredRunning = {
        label: labels.connectToPreferred,
        options: []
      };
      const otherRunning = {
        label: labels.connectToOther,
        options: []
      };
      for (const spec of sorted) {
        (spec.language === language ? preferred : other).options.push(optionForSpec(spec));
      }
      options.groups.push(preferred);
      options.groups.push(noKernel);
      options.groups.push(other);
      kernels.map((kernel2) => {
        var _a2, _b2;
        return {
          option: optionForKernel(kernel2, (_b2 = (_a2 = specs.kernelspecs[kernel2.name]) === null || _a2 === void 0 ? void 0 : _a2.display_name) !== null && _b2 !== void 0 ? _b2 : "", sessions[kernel2.id]),
          language: languages[kernel2.name]
        };
      }).sort((a, b) => a.option.text.localeCompare(b.option.text)).forEach((kernel2) => (language === kernel2.language ? preferredRunning : otherRunning).options.push(kernel2.option));
      if (preferredRunning.options.length)
        options.groups.push(preferredRunning);
      if (otherRunning.options.length)
        options.groups.push(otherRunning);
    } else {
      options.groups.push({
        label: labels.startKernel,
        options: sorted.map((spec) => optionForSpec(spec))
      });
      options.groups.push(noKernel);
      options.groups.push({
        label: labels.connectKernel,
        options: kernels.map((kernel2) => {
          var _a2, _b2;
          return optionForKernel(kernel2, (_b2 = (_a2 = specs.kernelspecs[kernel2.name]) === null || _a2 === void 0 ? void 0 : _a2.display_name) !== null && _b2 !== void 0 ? _b2 : "", sessions[kernel2.id]);
        }).sort((a, b) => a.text.localeCompare(b.text))
      });
    }
    if (preference.id || currentKernelDisplayName || preference.name) {
      for (const group of options.groups) {
        for (const option of group.options) {
          const choice = JSON.parse(option.value);
          if (!choice)
            continue;
          if (preference.id) {
            if (preference.id === choice.id) {
              option.selected = true;
              return options;
            }
            continue;
          }
          if (currentKernelDisplayName) {
            if (currentKernelDisplayName === ((_g = specs.kernelspecs[choice.name]) === null || _g === void 0 ? void 0 : _g.display_name)) {
              option.selected = true;
              return options;
            }
            continue;
          }
          if (preference.name) {
            if (preference.name === choice.name) {
              option.selected = true;
              return options;
            }
            continue;
          }
        }
      }
    }
    return options;
  }
  SessionContextDialogs2.kernelOptions = kernelOptions;
})(SessionContextDialogs || (SessionContextDialogs = {}));
var Private$c;
(function(Private2) {
  Private2.createKernelSelector = (sessionContext, translator) => new KernelSelector({
    node: createSelectorNode(sessionContext, translator)
  });
  class KernelSelector extends Widget {
    /**
     * Get the value of the kernel selector widget.
     */
    getValue() {
      const selector = this.node.querySelector("select");
      return JSON.parse(selector.value);
    }
  }
  function createSelectorNode(sessionContext, translator) {
    translator = translator || nullTranslator;
    const trans = translator.load("jupyterlab");
    const body = document.createElement("div");
    const text2 = document.createElement("label");
    text2.textContent = `${trans.__("Select kernel for:")} "${sessionContext.name}"`;
    body.appendChild(text2);
    const select = document.createElement("select");
    const options = SessionContextDialogs.kernelOptions(sessionContext, translator);
    if (options.disabled)
      select.disabled = true;
    for (const group of options.groups) {
      const { label, options: options2 } = group;
      const optgroup = document.createElement("optgroup");
      optgroup.label = label;
      for (const { selected, text: text3, title, value } of options2) {
        const option = document.createElement("option");
        if (selected)
          option.selected = true;
        if (title)
          option.title = title;
        option.text = text3;
        option.value = value;
        optgroup.appendChild(option);
      }
      select.appendChild(optgroup);
    }
    body.appendChild(select);
    return body;
  }
  function getDefaultKernel(options) {
    var _a;
    const { specs, preference } = options;
    const { name: name2, language, canStart, autoStartDefault } = preference;
    if (!specs || canStart === false) {
      return null;
    }
    const defaultName = autoStartDefault ? specs.default : null;
    if (!name2 && !language) {
      return defaultName;
    }
    for (const specName in specs.kernelspecs) {
      if (specName === name2) {
        return name2;
      }
    }
    if (!language) {
      return defaultName;
    }
    const matches2 = [];
    for (const specName in specs.kernelspecs) {
      const kernelLanguage = (_a = specs.kernelspecs[specName]) === null || _a === void 0 ? void 0 : _a.language;
      if (language === kernelLanguage) {
        matches2.push(specName);
      }
    }
    if (matches2.length === 1) {
      const specName = matches2[0];
      console.warn("No exact match found for " + specName + ", using kernel " + specName + " that matches language=" + language);
      return specName;
    }
    return defaultName;
  }
  Private2.getDefaultKernel = getDefaultKernel;
})(Private$c || (Private$c = {}));
var Clipboard;
(function(Clipboard2) {
  function getInstance() {
    return Private$b.instance;
  }
  Clipboard2.getInstance = getInstance;
  function setInstance(value) {
    Private$b.instance = value;
  }
  Clipboard2.setInstance = setInstance;
  function copyToSystem(clipboardData) {
    const node2 = document.body;
    const handler = (event2) => {
      const data = event2.clipboardData || window.clipboardData;
      if (typeof clipboardData === "string") {
        data.setData("text", clipboardData);
      } else {
        clipboardData.types().map((mimeType) => {
          data.setData(mimeType, clipboardData.getData(mimeType));
        });
      }
      event2.preventDefault();
      node2.removeEventListener("copy", handler);
    };
    node2.addEventListener("copy", handler);
    generateEvent(node2);
  }
  Clipboard2.copyToSystem = copyToSystem;
  function generateEvent(node2, type = "copy") {
    let sel = window.getSelection();
    const savedRanges = [];
    for (let i2 = 0, len = (sel === null || sel === void 0 ? void 0 : sel.rangeCount) || 0; i2 < len; ++i2) {
      savedRanges[i2] = sel.getRangeAt(i2).cloneRange();
    }
    const range2 = document.createRange();
    range2.selectNodeContents(node2);
    if (sel) {
      sel.removeAllRanges();
      sel.addRange(range2);
    }
    document.execCommand(type);
    sel = window.getSelection();
    if (sel) {
      sel.removeAllRanges();
      for (let i2 = 0, len = savedRanges.length; i2 < len; ++i2) {
        sel.addRange(savedRanges[i2]);
      }
    }
  }
  Clipboard2.generateEvent = generateEvent;
})(Clipboard || (Clipboard = {}));
var Private$b;
(function(Private2) {
  Private2.instance = new MimeData();
})(Private$b || (Private$b = {}));
var DOMUtils;
(function(DOMUtils2) {
  function hitTestNodes(nodes, x2, y) {
    return ArrayExt.findFirstIndex(nodes, (node2) => {
      return ElementExt.hitTest(node2, x2, y);
    });
  }
  DOMUtils2.hitTestNodes = hitTestNodes;
  function findElement(parent, className) {
    return parent.querySelector(`.${className}`);
  }
  DOMUtils2.findElement = findElement;
  function findElements(parent, className) {
    return parent.getElementsByClassName(className);
  }
  DOMUtils2.findElements = findElements;
  function createDomID() {
    return `id-${UUID.uuid4()}`;
  }
  DOMUtils2.createDomID = createDomID;
  function hasActiveEditableElement(parent, root2 = document) {
    const element = root2.activeElement;
    return !!(element && parent.contains(element) && (element.matches(":read-write") || element.shadowRoot && hasActiveEditableElement(element.shadowRoot, element.shadowRoot)));
  }
  DOMUtils2.hasActiveEditableElement = hasActiveEditableElement;
})(DOMUtils || (DOMUtils = {}));
var Printing;
(function(Printing2) {
  Printing2.symbol = Symbol("printable");
  function isPrintable(a) {
    if (typeof a !== "object" || !a) {
      return false;
    }
    return Printing2.symbol in a;
  }
  Printing2.isPrintable = isPrintable;
  function getPrintFunction(val) {
    if (isPrintable(val)) {
      return val[Printing2.symbol]();
    }
    return null;
  }
  Printing2.getPrintFunction = getPrintFunction;
  function printWidget(widget) {
    return printContent(widget.node);
  }
  Printing2.printWidget = printWidget;
  async function printURL(url2) {
    const settings = libExports.ServerConnection.makeSettings();
    const text2 = await (await libExports.ServerConnection.makeRequest(url2, {}, settings)).text();
    return printContent(text2);
  }
  Printing2.printURL = printURL;
  async function printContent(textOrEl) {
    const isText2 = typeof textOrEl === "string";
    const iframe = createIFrame();
    const parent = window.document.body;
    parent.appendChild(iframe);
    if (isText2) {
      iframe.srcdoc = textOrEl;
      await resolveWhenLoaded(iframe);
    } else {
      iframe.src = "about:blank";
      await resolveWhenLoaded(iframe);
      setIFrameNode(iframe, textOrEl);
    }
    const printed2 = resolveAfterEvent();
    launchPrint(iframe.contentWindow);
    await printed2;
    parent.removeChild(iframe);
  }
  function createIFrame() {
    const el = window.document.createElement("iframe");
    el.setAttribute("sandbox", "allow-modals allow-same-origin");
    const css2 = "visibility:hidden;width:0;height:0;position:absolute;z-index:-9999;bottom:0;";
    el.setAttribute("style", css2);
    el.setAttribute("width", "0");
    el.setAttribute("height", "0");
    return el;
  }
  function setIFrameNode(iframe, node2) {
    iframe.contentDocument.body.appendChild(node2.cloneNode(true));
    iframe.contentDocument.close();
  }
  function resolveWhenLoaded(iframe) {
    return new Promise((resolve3) => {
      iframe.onload = () => resolve3();
    });
  }
  function resolveAfterEvent() {
    return new Promise((resolve3) => {
      const onEvent = () => {
        document.removeEventListener("mousemove", onEvent, true);
        document.removeEventListener("mousedown", onEvent, true);
        document.removeEventListener("keydown", onEvent, true);
        resolve3();
      };
      document.addEventListener("mousemove", onEvent, true);
      document.addEventListener("mousedown", onEvent, true);
      document.addEventListener("keydown", onEvent, true);
    });
  }
  function launchPrint(contentWindow) {
    const result2 = contentWindow.document.execCommand("print", false);
    if (!result2) {
      contentWindow.print();
    }
  }
})(Printing || (Printing = {}));
const USE_CAPTURE = true;
class MainAreaWidget extends Widget {
  /**
   * Construct a new main area widget.
   *
   * @param options - The options for initializing the widget.
   */
  constructor(options) {
    super(options);
    this._changeGuard = false;
    this._spinner = new Spinner();
    this._isRevealed = false;
    this._evtMouseDown = () => {
      if (!this.node.contains(document.activeElement)) {
        this._focusContent();
      }
    };
    this.addClass("jp-MainAreaWidget");
    this.addClass("jp-MainAreaWidget-ContainStrict");
    this.id = DOMUtils.createDomID();
    const trans = (options.translator || nullTranslator).load("jupyterlab");
    const content = this._content = options.content;
    content.node.setAttribute("role", "region");
    content.node.setAttribute("aria-label", trans.__("notebook content"));
    const toolbar = this._toolbar = options.toolbar || new ReactiveToolbar({ noFocusOnClick: true });
    toolbar.node.setAttribute("role", "toolbar");
    toolbar.node.setAttribute("aria-label", trans.__("notebook actions"));
    const contentHeader = this._contentHeader = options.contentHeader || new BoxPanel({
      direction: "top-to-bottom",
      spacing: 0
    });
    const layout = this.layout = new BoxLayout({ spacing: 0 });
    layout.direction = "top-to-bottom";
    BoxLayout.setStretch(toolbar, 0);
    BoxLayout.setStretch(contentHeader, 0);
    BoxLayout.setStretch(content, 1);
    layout.addWidget(toolbar);
    layout.addWidget(contentHeader);
    layout.addWidget(content);
    if (!content.id) {
      content.id = DOMUtils.createDomID();
    }
    content.node.tabIndex = -1;
    this._updateTitle();
    content.title.changed.connect(this._updateTitle, this);
    this.title.closable = true;
    this.title.changed.connect(this._updateContentTitle, this);
    if (options.reveal) {
      this.node.appendChild(this._spinner.node);
      this._revealed = options.reveal.then(() => {
        if (content.isDisposed) {
          this.dispose();
          return;
        }
        content.disposed.connect(() => this.dispose());
        const active = document.activeElement === this._spinner.node;
        this._disposeSpinner();
        this._isRevealed = true;
        if (active) {
          this._focusContent();
        }
      }).catch((e) => {
        const error = new Widget();
        error.addClass("jp-MainAreaWidget-error");
        const pre = document.createElement("pre");
        pre.textContent = String(e);
        error.node.appendChild(pre);
        BoxLayout.setStretch(error, 1);
        this._disposeSpinner();
        content.dispose();
        this._content = null;
        toolbar.dispose();
        this._toolbar = null;
        layout.addWidget(error);
        this._isRevealed = true;
        throw error;
      });
    } else {
      this._spinner.dispose();
      this.removeClass("jp-MainAreaWidget-ContainStrict");
      content.disposed.connect(() => this.dispose());
      this._isRevealed = true;
      this._revealed = Promise.resolve(void 0);
    }
  }
  /**
   * Print method. Deferred to content.
   */
  [Printing.symbol]() {
    if (!this._content) {
      return null;
    }
    return Printing.getPrintFunction(this._content);
  }
  /**
   * The content hosted by the widget.
   */
  get content() {
    return this._content;
  }
  /**
   * The toolbar hosted by the widget.
   */
  get toolbar() {
    return this._toolbar;
  }
  /**
   * A panel for widgets that sit between the toolbar and the content.
   * Imagine a formatting toolbar, notification headers, etc.
   */
  get contentHeader() {
    return this._contentHeader;
  }
  /**
   * Whether the content widget or an error is revealed.
   */
  get isRevealed() {
    return this._isRevealed;
  }
  /**
   * A promise that resolves when the widget is revealed.
   */
  get revealed() {
    return this._revealed;
  }
  /**
   * Handle `'activate-request'` messages.
   */
  onActivateRequest(msg) {
    if (this._isRevealed) {
      this._focusContent();
    } else {
      this._spinner.node.focus();
    }
  }
  /**
   * Handle `after-attach` messages for the widget.
   */
  onAfterAttach(msg) {
    super.onAfterAttach(msg);
    this.node.addEventListener("mousedown", this._evtMouseDown, USE_CAPTURE);
  }
  /**
   * Handle `before-detach` messages for the widget.
   */
  onBeforeDetach(msg) {
    this.node.removeEventListener("mousedown", this._evtMouseDown, USE_CAPTURE);
    super.onBeforeDetach(msg);
  }
  /**
   * Handle `'close-request'` messages.
   */
  onCloseRequest(msg) {
    this.dispose();
  }
  /**
   * Handle `'update-request'` messages by forwarding them to the content.
   */
  onUpdateRequest(msg) {
    if (this._content) {
      MessageLoop.sendMessage(this._content, msg);
    }
  }
  _disposeSpinner() {
    this.node.removeChild(this._spinner.node);
    this._spinner.dispose();
    this.removeClass("jp-MainAreaWidget-ContainStrict");
  }
  /**
   * Update the title based on the attributes of the child widget.
   */
  _updateTitle() {
    if (this._changeGuard || !this.content) {
      return;
    }
    this._changeGuard = true;
    const content = this.content;
    this.title.label = content.title.label;
    this.title.mnemonic = content.title.mnemonic;
    this.title.icon = content.title.icon;
    this.title.iconClass = content.title.iconClass;
    this.title.iconLabel = content.title.iconLabel;
    this.title.caption = content.title.caption;
    this.title.className = content.title.className;
    this.title.dataset = content.title.dataset;
    this._changeGuard = false;
  }
  /**
   * Update the content title based on attributes of the main widget.
   */
  _updateContentTitle() {
    if (this._changeGuard || !this.content) {
      return;
    }
    this._changeGuard = true;
    const content = this.content;
    content.title.label = this.title.label;
    content.title.mnemonic = this.title.mnemonic;
    content.title.icon = this.title.icon;
    content.title.iconClass = this.title.iconClass;
    content.title.iconLabel = this.title.iconLabel;
    content.title.caption = this.title.caption;
    content.title.className = this.title.className;
    content.title.dataset = this.title.dataset;
    this._changeGuard = false;
  }
  /**
   * Give focus to the content.
   */
  _focusContent() {
    if (!this.content) {
      return;
    }
    if (!this.content.node.contains(document.activeElement)) {
      this.content.node.focus();
    }
    this.content.activate();
  }
}
class NotificationManager {
  constructor() {
    this._isDisposed = false;
    this._queue = [];
    this._changed = new Signal(this);
  }
  /**
   * Signal emitted whenever a notification changes.
   */
  get changed() {
    return this._changed;
  }
  /**
   * Total number of notifications.
   */
  get count() {
    return this._queue.length;
  }
  /**
   * Whether the manager is disposed or not.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * The list of notifications.
   */
  get notifications() {
    return this._queue.slice();
  }
  /**
   * Dismiss one notification (specified by its id) or all if no id provided.
   *
   * @param id Notification id
   */
  dismiss(id) {
    if (typeof id === "undefined") {
      const q = this._queue.slice();
      this._queue.length = 0;
      for (const notification of q) {
        this._changed.emit({
          type: "removed",
          notification
        });
      }
    } else {
      const notificationIndex = this._queue.findIndex((n) => n.id === id);
      if (notificationIndex > -1) {
        const notification = this._queue.splice(notificationIndex, 1)[0];
        this._changed.emit({
          type: "removed",
          notification
        });
      }
    }
  }
  /**
   * Dispose the manager.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    Signal.clearData(this);
  }
  /**
   * Test whether a notification exists or not.
   *
   * @param id Notification id
   * @returns Notification status
   */
  has(id) {
    return this._queue.findIndex((n) => n.id === id) > -1;
  }
  /**
   * Add a new notification.
   *
   * This will trigger the `changed` signal with an `added` event.
   *
   * @param message Notification message
   * @param type Notification type
   * @param options Notification option
   * @returns Notification unique id
   */
  notify(message, type, options) {
    const now = Date.now();
    const { progress, ...othersOptions } = options;
    const notification = Object.freeze({
      id: UUID.uuid4(),
      createdAt: now,
      modifiedAt: now,
      message,
      type,
      options: {
        // By default notification will be silent
        autoClose: 0,
        progress: typeof progress === "number" ? Math.min(Math.max(0, progress), 1) : progress,
        ...othersOptions
      }
    });
    this._queue.unshift(notification);
    this._changed.emit({
      type: "added",
      notification
    });
    return notification.id;
  }
  /**
   * Update an existing notification.
   *
   * If the notification does not exists this won't do anything.
   *
   * Once updated the notification will be moved at the begin
   * of the notification stack.
   *
   * @param args Update options
   * @returns Whether the update was successful or not.
   */
  update(args) {
    const { id, message, actions, autoClose, data, progress, type } = args;
    const newProgress = typeof progress === "number" ? Math.min(Math.max(0, progress), 1) : progress;
    const notificationIndex = this._queue.findIndex((n) => n.id === id);
    if (notificationIndex > -1) {
      const oldNotification = this._queue[notificationIndex];
      const notification = Object.freeze({
        ...oldNotification,
        message: message !== null && message !== void 0 ? message : oldNotification.message,
        type: type !== null && type !== void 0 ? type : oldNotification.type,
        options: {
          actions: actions !== null && actions !== void 0 ? actions : oldNotification.options.actions,
          autoClose: autoClose !== null && autoClose !== void 0 ? autoClose : oldNotification.options.autoClose,
          data: data !== null && data !== void 0 ? data : oldNotification.options.data,
          progress: newProgress !== null && newProgress !== void 0 ? newProgress : oldNotification.options.progress
        },
        modifiedAt: Date.now()
      });
      this._queue.splice(notificationIndex, 1);
      this._queue.unshift(notification);
      this._changed.emit({
        type: "updated",
        notification
      });
      return true;
    }
    return false;
  }
}
var Notification;
(function(Notification2) {
  Notification2.manager = new NotificationManager();
  function dismiss(id) {
    Notification2.manager.dismiss(id);
  }
  Notification2.dismiss = dismiss;
  function emit(message, type = "default", options = {}) {
    return Notification2.manager.notify(message, type, options);
  }
  Notification2.emit = emit;
  function error(message, options = {}) {
    return Notification2.manager.notify(message, "error", options);
  }
  Notification2.error = error;
  function info(message, options = {}) {
    return Notification2.manager.notify(message, "info", options);
  }
  Notification2.info = info;
  function promise(promise2, options) {
    var _a;
    const { pending, error: error2, success: success2 } = options;
    const id = Notification2.manager.notify(pending.message, "in-progress", (_a = pending.options) !== null && _a !== void 0 ? _a : {});
    promise2.then((result2) => {
      var _a2, _b, _c;
      Notification2.manager.update({
        id,
        message: success2.message(result2, (_a2 = success2.options) === null || _a2 === void 0 ? void 0 : _a2.data),
        type: "success",
        ...success2.options,
        data: (_c = (_b = success2.options) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : result2
      });
    }).catch((reason) => {
      var _a2, _b, _c;
      Notification2.manager.update({
        id,
        message: error2.message(reason, (_a2 = error2.options) === null || _a2 === void 0 ? void 0 : _a2.data),
        type: "error",
        ...error2.options,
        data: (_c = (_b = error2.options) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : reason
      });
    });
    return id;
  }
  Notification2.promise = promise;
  function success(message, options = {}) {
    return Notification2.manager.notify(message, "success", options);
  }
  Notification2.success = success;
  function update(args) {
    return Notification2.manager.update(args);
  }
  Notification2.update = update;
  function warning2(message, options = {}) {
    return Notification2.manager.notify(message, "warning", options);
  }
  Notification2.warning = warning2;
})(Notification || (Notification = {}));
var lib$5 = {};
var Parser$3 = {};
var Tokenizer = {};
var decode = {};
var decodeDataHtml = {};
Object.defineProperty(decodeDataHtml, "__esModule", { value: true });
decodeDataHtml.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decodeDataXml = {};
Object.defineProperty(decodeDataXml, "__esModule", { value: true });
decodeDataXml.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(c) {
    return c.charCodeAt(0);
  })
);
var decode_codepoint = {};
(function(exports) {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.replaceCodePoint = exports.fromCodePoint = void 0;
  var decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  exports.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports.default = decodeCodePoint;
})(decode_codepoint);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result2, mod, k);
    }
    __setModuleDefault2(result2, mod);
    return result2;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
  var decode_data_html_js_1 = __importDefault2(decodeDataHtml);
  exports.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault2(decodeDataXml);
  exports.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar2(decode_codepoint);
  exports.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = decode_codepoint;
  Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
  function isNumber2(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber2(code2);
  }
  function isEntityInAttributeInvalidEnd(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
  var EntityDecoder = (
    /** @class */
    function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base2) {
        if (start !== end) {
          var digitCount = end - start;
          this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber2(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber2(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
            isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result2 = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result2] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result2, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result2, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result2] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result2 + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result2 + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }()
  );
  exports.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(
          str,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result2 = ret + str.slice(lastIndex);
      ret = "";
      return result2;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === void 0) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports.decodeXML = decodeXML;
})(decode);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QuoteType = void 0;
  var decode_js_12 = decode;
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
    CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
    CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
    CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes2[CharCodes2["Space"] = 32] = "Space";
    CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes2[CharCodes2["Number"] = 35] = "Number";
    CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
    CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
    CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
    CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
    CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
    CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
    CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
    CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
    CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
    CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
    CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
    CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
    CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
    CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
    CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
    CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
    CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
    CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
    CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes || (CharCodes = {}));
  var State;
  (function(State2) {
    State2[State2["Text"] = 1] = "Text";
    State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
    State2[State2["InTagName"] = 3] = "InTagName";
    State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
    State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State2[State2["InAttributeName"] = 9] = "InAttributeName";
    State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
    State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State2[State2["InDeclaration"] = 16] = "InDeclaration";
    State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    State2[State2["BeforeComment"] = 18] = "BeforeComment";
    State2[State2["CDATASequence"] = 19] = "CDATASequence";
    State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
    State2[State2["InCommentLike"] = 21] = "InCommentLike";
    State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
    State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
    State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
    State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
    State2[State2["InHexEntity"] = 29] = "InHexEntity";
  })(State || (State = {}));
  function isWhitespace(c) {
    return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
  }
  function isEndOfTagSection(c) {
    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
  }
  function isNumber2(c) {
    return c >= CharCodes.Zero && c <= CharCodes.Nine;
  }
  function isASCIIAlpha(c) {
    return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
  }
  function isHexDigit(c) {
    return c >= CharCodes.UpperA && c <= CharCodes.UpperF || c >= CharCodes.LowerA && c <= CharCodes.LowerF;
  }
  var QuoteType;
  (function(QuoteType2) {
    QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
    QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
    QuoteType2[QuoteType2["Single"] = 2] = "Single";
    QuoteType2[QuoteType2["Double"] = 3] = "Double";
  })(QuoteType = exports.QuoteType || (exports.QuoteType = {}));
  var Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
    // `</title`
  };
  var Tokenizer2 = (
    /** @class */
    function() {
      function Tokenizer3(_a, cbs) {
        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
        this.cbs = cbs;
        this.state = State.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State.Text;
        this.isSpecial = false;
        this.running = true;
        this.offset = 0;
        this.currentSequence = void 0;
        this.sequenceIndex = 0;
        this.trieIndex = 0;
        this.trieCurrent = 0;
        this.entityResult = 0;
        this.entityExcess = 0;
        this.xmlMode = xmlMode;
        this.decodeEntities = decodeEntities;
        this.entityTrie = xmlMode ? decode_js_12.xmlDecodeTree : decode_js_12.htmlDecodeTree;
      }
      Tokenizer3.prototype.reset = function() {
        this.state = State.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State.Text;
        this.currentSequence = void 0;
        this.running = true;
        this.offset = 0;
      };
      Tokenizer3.prototype.write = function(chunk) {
        this.offset += this.buffer.length;
        this.buffer = chunk;
        this.parse();
      };
      Tokenizer3.prototype.end = function() {
        if (this.running)
          this.finish();
      };
      Tokenizer3.prototype.pause = function() {
        this.running = false;
      };
      Tokenizer3.prototype.resume = function() {
        this.running = true;
        if (this.index < this.buffer.length + this.offset) {
          this.parse();
        }
      };
      Tokenizer3.prototype.getIndex = function() {
        return this.index;
      };
      Tokenizer3.prototype.getSectionStart = function() {
        return this.sectionStart;
      };
      Tokenizer3.prototype.stateText = function(c) {
        if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = State.BeforeTagName;
          this.sectionStart = this.index;
        } else if (this.decodeEntities && c === CharCodes.Amp) {
          this.state = State.BeforeEntity;
        }
      };
      Tokenizer3.prototype.stateSpecialStartSequence = function(c) {
        var isEnd = this.sequenceIndex === this.currentSequence.length;
        var isMatch = isEnd ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          isEndOfTagSection(c)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (c | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!isMatch) {
          this.isSpecial = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = State.InTagName;
        this.stateInTagName(c);
      };
      Tokenizer3.prototype.stateInSpecialTag = function(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c === CharCodes.Gt || isWhitespace(c)) {
            var endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              var actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.isSpecial = false;
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c);
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd) {
            if (this.decodeEntities && c === CharCodes.Amp) {
              this.state = State.BeforeEntity;
            }
          } else if (this.fastForwardTo(CharCodes.Lt)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c === CharCodes.Lt);
        }
      };
      Tokenizer3.prototype.stateCDATASequence = function(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = State.InCommentLike;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = State.InDeclaration;
          this.stateInDeclaration(c);
        }
      };
      Tokenizer3.prototype.fastForwardTo = function(c) {
        while (++this.index < this.buffer.length + this.offset) {
          if (this.buffer.charCodeAt(this.index - this.offset) === c) {
            return true;
          }
        }
        this.index = this.buffer.length + this.offset - 1;
        return false;
      };
      Tokenizer3.prototype.stateInCommentLike = function(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index, 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index, 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = State.Text;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      };
      Tokenizer3.prototype.isTagStartChar = function(c) {
        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
      };
      Tokenizer3.prototype.startSpecial = function(sequence, offset) {
        this.isSpecial = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
        this.state = State.SpecialStartSequence;
      };
      Tokenizer3.prototype.stateBeforeTagName = function(c) {
        if (c === CharCodes.ExclamationMark) {
          this.state = State.BeforeDeclaration;
          this.sectionStart = this.index + 1;
        } else if (c === CharCodes.Questionmark) {
          this.state = State.InProcessingInstruction;
          this.sectionStart = this.index + 1;
        } else if (this.isTagStartChar(c)) {
          var lower = c | 32;
          this.sectionStart = this.index;
          if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
            this.startSpecial(Sequences.TitleEnd, 3);
          } else {
            this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
          }
        } else if (c === CharCodes.Slash) {
          this.state = State.BeforeClosingTagName;
        } else {
          this.state = State.Text;
          this.stateText(c);
        }
      };
      Tokenizer3.prototype.stateInTagName = function(c) {
        if (isEndOfTagSection(c)) {
          this.cbs.onopentagname(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        }
      };
      Tokenizer3.prototype.stateBeforeClosingTagName = function(c) {
        if (isWhitespace(c)) ;
        else if (c === CharCodes.Gt) {
          this.state = State.Text;
        } else {
          this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
          this.sectionStart = this.index;
        }
      };
      Tokenizer3.prototype.stateInClosingTagName = function(c) {
        if (c === CharCodes.Gt || isWhitespace(c)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State.AfterClosingTagName;
          this.stateAfterClosingTagName(c);
        }
      };
      Tokenizer3.prototype.stateAfterClosingTagName = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.state = State.Text;
          this.baseState = State.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer3.prototype.stateBeforeAttributeName = function(c) {
        if (c === CharCodes.Gt) {
          this.cbs.onopentagend(this.index);
          if (this.isSpecial) {
            this.state = State.InSpecialTag;
            this.sequenceIndex = 0;
          } else {
            this.state = State.Text;
          }
          this.baseState = this.state;
          this.sectionStart = this.index + 1;
        } else if (c === CharCodes.Slash) {
          this.state = State.InSelfClosingTag;
        } else if (!isWhitespace(c)) {
          this.state = State.InAttributeName;
          this.sectionStart = this.index;
        }
      };
      Tokenizer3.prototype.stateInSelfClosingTag = function(c) {
        if (c === CharCodes.Gt) {
          this.cbs.onselfclosingtag(this.index);
          this.state = State.Text;
          this.baseState = State.Text;
          this.sectionStart = this.index + 1;
          this.isSpecial = false;
        } else if (!isWhitespace(c)) {
          this.state = State.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        }
      };
      Tokenizer3.prototype.stateInAttributeName = function(c) {
        if (c === CharCodes.Eq || isEndOfTagSection(c)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = State.AfterAttributeName;
          this.stateAfterAttributeName(c);
        }
      };
      Tokenizer3.prototype.stateAfterAttributeName = function(c) {
        if (c === CharCodes.Eq) {
          this.state = State.BeforeAttributeValue;
        } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
          this.cbs.onattribend(QuoteType.NoValue, this.index);
          this.state = State.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        } else if (!isWhitespace(c)) {
          this.cbs.onattribend(QuoteType.NoValue, this.index);
          this.state = State.InAttributeName;
          this.sectionStart = this.index;
        }
      };
      Tokenizer3.prototype.stateBeforeAttributeValue = function(c) {
        if (c === CharCodes.DoubleQuote) {
          this.state = State.InAttributeValueDq;
          this.sectionStart = this.index + 1;
        } else if (c === CharCodes.SingleQuote) {
          this.state = State.InAttributeValueSq;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
          this.sectionStart = this.index;
          this.state = State.InAttributeValueNq;
          this.stateInAttributeValueNoQuotes(c);
        }
      };
      Tokenizer3.prototype.handleInAttributeValue = function(c, quote) {
        if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
          this.state = State.BeforeAttributeName;
        } else if (this.decodeEntities && c === CharCodes.Amp) {
          this.baseState = this.state;
          this.state = State.BeforeEntity;
        }
      };
      Tokenizer3.prototype.stateInAttributeValueDoubleQuotes = function(c) {
        this.handleInAttributeValue(c, CharCodes.DoubleQuote);
      };
      Tokenizer3.prototype.stateInAttributeValueSingleQuotes = function(c) {
        this.handleInAttributeValue(c, CharCodes.SingleQuote);
      };
      Tokenizer3.prototype.stateInAttributeValueNoQuotes = function(c) {
        if (isWhitespace(c) || c === CharCodes.Gt) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(QuoteType.Unquoted, this.index);
          this.state = State.BeforeAttributeName;
          this.stateBeforeAttributeName(c);
        } else if (this.decodeEntities && c === CharCodes.Amp) {
          this.baseState = this.state;
          this.state = State.BeforeEntity;
        }
      };
      Tokenizer3.prototype.stateBeforeDeclaration = function(c) {
        if (c === CharCodes.OpeningSquareBracket) {
          this.state = State.CDATASequence;
          this.sequenceIndex = 0;
        } else {
          this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
        }
      };
      Tokenizer3.prototype.stateInDeclaration = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.ondeclaration(this.sectionStart, this.index);
          this.state = State.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer3.prototype.stateInProcessingInstruction = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = State.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer3.prototype.stateBeforeComment = function(c) {
        if (c === CharCodes.Dash) {
          this.state = State.InCommentLike;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = State.InDeclaration;
        }
      };
      Tokenizer3.prototype.stateInSpecialComment = function(c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
          this.cbs.oncomment(this.sectionStart, this.index, 0);
          this.state = State.Text;
          this.sectionStart = this.index + 1;
        }
      };
      Tokenizer3.prototype.stateBeforeSpecialS = function(c) {
        var lower = c | 32;
        if (lower === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (lower === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = State.InTagName;
          this.stateInTagName(c);
        }
      };
      Tokenizer3.prototype.stateBeforeEntity = function(c) {
        this.entityExcess = 1;
        this.entityResult = 0;
        if (c === CharCodes.Number) {
          this.state = State.BeforeNumericEntity;
        } else if (c === CharCodes.Amp) ;
        else {
          this.trieIndex = 0;
          this.trieCurrent = this.entityTrie[0];
          this.state = State.InNamedEntity;
          this.stateInNamedEntity(c);
        }
      };
      Tokenizer3.prototype.stateInNamedEntity = function(c) {
        this.entityExcess += 1;
        this.trieIndex = (0, decode_js_12.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
        if (this.trieIndex < 0) {
          this.emitNamedEntity();
          this.index--;
          return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        var masked = this.trieCurrent & decode_js_12.BinTrieFlags.VALUE_LENGTH;
        if (masked) {
          var valueLength = (masked >> 14) - 1;
          if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
            this.trieIndex += valueLength;
          } else {
            var entityStart = this.index - this.entityExcess + 1;
            if (entityStart > this.sectionStart) {
              this.emitPartial(this.sectionStart, entityStart);
            }
            this.entityResult = this.trieIndex;
            this.trieIndex += valueLength;
            this.entityExcess = 0;
            this.sectionStart = this.index + 1;
            if (valueLength === 0) {
              this.emitNamedEntity();
            }
          }
        }
      };
      Tokenizer3.prototype.emitNamedEntity = function() {
        this.state = this.baseState;
        if (this.entityResult === 0) {
          return;
        }
        var valueLength = (this.entityTrie[this.entityResult] & decode_js_12.BinTrieFlags.VALUE_LENGTH) >> 14;
        switch (valueLength) {
          case 1: {
            this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_12.BinTrieFlags.VALUE_LENGTH);
            break;
          }
          case 2: {
            this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
            break;
          }
          case 3: {
            this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
            this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
          }
        }
      };
      Tokenizer3.prototype.stateBeforeNumericEntity = function(c) {
        if ((c | 32) === CharCodes.LowerX) {
          this.entityExcess++;
          this.state = State.InHexEntity;
        } else {
          this.state = State.InNumericEntity;
          this.stateInNumericEntity(c);
        }
      };
      Tokenizer3.prototype.emitNumericEntity = function(strict) {
        var entityStart = this.index - this.entityExcess - 1;
        var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
        if (numberStart !== this.index) {
          if (entityStart > this.sectionStart) {
            this.emitPartial(this.sectionStart, entityStart);
          }
          this.sectionStart = this.index + Number(strict);
          this.emitCodePoint((0, decode_js_12.replaceCodePoint)(this.entityResult));
        }
        this.state = this.baseState;
      };
      Tokenizer3.prototype.stateInNumericEntity = function(c) {
        if (c === CharCodes.Semi) {
          this.emitNumericEntity(true);
        } else if (isNumber2(c)) {
          this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
          this.entityExcess++;
        } else {
          if (this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else {
            this.state = this.baseState;
          }
          this.index--;
        }
      };
      Tokenizer3.prototype.stateInHexEntity = function(c) {
        if (c === CharCodes.Semi) {
          this.emitNumericEntity(true);
        } else if (isNumber2(c)) {
          this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
          this.entityExcess++;
        } else if (isHexDigit(c)) {
          this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes.LowerA + 10);
          this.entityExcess++;
        } else {
          if (this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else {
            this.state = this.baseState;
          }
          this.index--;
        }
      };
      Tokenizer3.prototype.allowLegacyEntity = function() {
        return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
      };
      Tokenizer3.prototype.cleanup = function() {
        if (this.running && this.sectionStart !== this.index) {
          if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      };
      Tokenizer3.prototype.shouldContinue = function() {
        return this.index < this.buffer.length + this.offset && this.running;
      };
      Tokenizer3.prototype.parse = function() {
        while (this.shouldContinue()) {
          var c = this.buffer.charCodeAt(this.index - this.offset);
          switch (this.state) {
            case State.Text: {
              this.stateText(c);
              break;
            }
            case State.SpecialStartSequence: {
              this.stateSpecialStartSequence(c);
              break;
            }
            case State.InSpecialTag: {
              this.stateInSpecialTag(c);
              break;
            }
            case State.CDATASequence: {
              this.stateCDATASequence(c);
              break;
            }
            case State.InAttributeValueDq: {
              this.stateInAttributeValueDoubleQuotes(c);
              break;
            }
            case State.InAttributeName: {
              this.stateInAttributeName(c);
              break;
            }
            case State.InCommentLike: {
              this.stateInCommentLike(c);
              break;
            }
            case State.InSpecialComment: {
              this.stateInSpecialComment(c);
              break;
            }
            case State.BeforeAttributeName: {
              this.stateBeforeAttributeName(c);
              break;
            }
            case State.InTagName: {
              this.stateInTagName(c);
              break;
            }
            case State.InClosingTagName: {
              this.stateInClosingTagName(c);
              break;
            }
            case State.BeforeTagName: {
              this.stateBeforeTagName(c);
              break;
            }
            case State.AfterAttributeName: {
              this.stateAfterAttributeName(c);
              break;
            }
            case State.InAttributeValueSq: {
              this.stateInAttributeValueSingleQuotes(c);
              break;
            }
            case State.BeforeAttributeValue: {
              this.stateBeforeAttributeValue(c);
              break;
            }
            case State.BeforeClosingTagName: {
              this.stateBeforeClosingTagName(c);
              break;
            }
            case State.AfterClosingTagName: {
              this.stateAfterClosingTagName(c);
              break;
            }
            case State.BeforeSpecialS: {
              this.stateBeforeSpecialS(c);
              break;
            }
            case State.InAttributeValueNq: {
              this.stateInAttributeValueNoQuotes(c);
              break;
            }
            case State.InSelfClosingTag: {
              this.stateInSelfClosingTag(c);
              break;
            }
            case State.InDeclaration: {
              this.stateInDeclaration(c);
              break;
            }
            case State.BeforeDeclaration: {
              this.stateBeforeDeclaration(c);
              break;
            }
            case State.BeforeComment: {
              this.stateBeforeComment(c);
              break;
            }
            case State.InProcessingInstruction: {
              this.stateInProcessingInstruction(c);
              break;
            }
            case State.InNamedEntity: {
              this.stateInNamedEntity(c);
              break;
            }
            case State.BeforeEntity: {
              this.stateBeforeEntity(c);
              break;
            }
            case State.InHexEntity: {
              this.stateInHexEntity(c);
              break;
            }
            case State.InNumericEntity: {
              this.stateInNumericEntity(c);
              break;
            }
            default: {
              this.stateBeforeNumericEntity(c);
            }
          }
          this.index++;
        }
        this.cleanup();
      };
      Tokenizer3.prototype.finish = function() {
        if (this.state === State.InNamedEntity) {
          this.emitNamedEntity();
        }
        if (this.sectionStart < this.index) {
          this.handleTrailingData();
        }
        this.cbs.onend();
      };
      Tokenizer3.prototype.handleTrailingData = function() {
        var endIndex = this.buffer.length + this.offset;
        if (this.state === State.InCommentLike) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex, 0);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex, 0);
          }
        } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) ;
        else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      };
      Tokenizer3.prototype.emitPartial = function(start, endIndex) {
        if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
          this.cbs.onattribdata(start, endIndex);
        } else {
          this.cbs.ontext(start, endIndex);
        }
      };
      Tokenizer3.prototype.emitCodePoint = function(cp) {
        if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
          this.cbs.onattribentity(cp);
        } else {
          this.cbs.ontextentity(cp);
        }
      };
      return Tokenizer3;
    }()
  );
  exports.default = Tokenizer2;
})(Tokenizer);
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result2 = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result2, mod, k);
  }
  __setModuleDefault$1(result2, mod);
  return result2;
};
Object.defineProperty(Parser$3, "__esModule", { value: true });
Parser$3.Parser = void 0;
var Tokenizer_js_1 = __importStar$1(Tokenizer);
var decode_js_1 = decode;
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser$2 = (
  /** @class */
  function() {
    function Parser3(cbs, options) {
      if (options === void 0) {
        options = {};
      }
      var _a, _b, _c, _d, _e;
      this.options = options;
      this.startIndex = 0;
      this.endIndex = 0;
      this.openTagStart = 0;
      this.tagname = "";
      this.attribname = "";
      this.attribvalue = "";
      this.attribs = null;
      this.stack = [];
      this.foreignContext = [];
      this.buffers = [];
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
      this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
      this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
      this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
      this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
      (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    Parser3.prototype.ontext = function(start, endIndex) {
      var _a, _b;
      var data = this.getSlice(start, endIndex);
      this.endIndex = endIndex - 1;
      (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
      this.startIndex = endIndex;
    };
    Parser3.prototype.ontextentity = function(cp) {
      var _a, _b;
      var index = this.tokenizer.getSectionStart();
      this.endIndex = index - 1;
      (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
      this.startIndex = index;
    };
    Parser3.prototype.isVoidElement = function(name2) {
      return !this.options.xmlMode && voidElements.has(name2);
    };
    Parser3.prototype.onopentagname = function(start, endIndex) {
      this.endIndex = endIndex;
      var name2 = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      this.emitOpenTag(name2);
    };
    Parser3.prototype.emitOpenTag = function(name2) {
      var _a, _b, _c, _d;
      this.openTagStart = this.startIndex;
      this.tagname = name2;
      var impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
      if (impliesClose) {
        while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
          var element = this.stack.pop();
          (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
        }
      }
      if (!this.isVoidElement(name2)) {
        this.stack.push(name2);
        if (foreignContextElements.has(name2)) {
          this.foreignContext.push(true);
        } else if (htmlIntegrationElements.has(name2)) {
          this.foreignContext.push(false);
        }
      }
      (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
      if (this.cbs.onopentag)
        this.attribs = {};
    };
    Parser3.prototype.endOpenTag = function(isImplied) {
      var _a, _b;
      this.startIndex = this.openTagStart;
      if (this.attribs) {
        (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
        this.attribs = null;
      }
      if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
        this.cbs.onclosetag(this.tagname, true);
      }
      this.tagname = "";
    };
    Parser3.prototype.onopentagend = function(endIndex) {
      this.endIndex = endIndex;
      this.endOpenTag(false);
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onclosetag = function(start, endIndex) {
      var _a, _b, _c, _d, _e, _f;
      this.endIndex = endIndex;
      var name2 = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
        this.foreignContext.pop();
      }
      if (!this.isVoidElement(name2)) {
        var pos = this.stack.lastIndexOf(name2);
        if (pos !== -1) {
          if (this.cbs.onclosetag) {
            var count = this.stack.length - pos;
            while (count--) {
              this.cbs.onclosetag(this.stack.pop(), count !== 0);
            }
          } else
            this.stack.length = pos;
        } else if (!this.options.xmlMode && name2 === "p") {
          this.emitOpenTag("p");
          this.closeCurrentTag(true);
        }
      } else if (!this.options.xmlMode && name2 === "br") {
        (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
        (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
        (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onselfclosingtag = function(endIndex) {
      this.endIndex = endIndex;
      if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
        this.closeCurrentTag(false);
        this.startIndex = endIndex + 1;
      } else {
        this.onopentagend(endIndex);
      }
    };
    Parser3.prototype.closeCurrentTag = function(isOpenImplied) {
      var _a, _b;
      var name2 = this.tagname;
      this.endOpenTag(isOpenImplied);
      if (this.stack[this.stack.length - 1] === name2) {
        (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name2, !isOpenImplied);
        this.stack.pop();
      }
    };
    Parser3.prototype.onattribname = function(start, endIndex) {
      this.startIndex = start;
      var name2 = this.getSlice(start, endIndex);
      this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
    };
    Parser3.prototype.onattribdata = function(start, endIndex) {
      this.attribvalue += this.getSlice(start, endIndex);
    };
    Parser3.prototype.onattribentity = function(cp) {
      this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
    };
    Parser3.prototype.onattribend = function(quote, endIndex) {
      var _a, _b;
      this.endIndex = endIndex;
      (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? void 0 : null);
      if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
        this.attribs[this.attribname] = this.attribvalue;
      }
      this.attribvalue = "";
    };
    Parser3.prototype.getInstructionName = function(value) {
      var index = value.search(reNameEnd);
      var name2 = index < 0 ? value : value.substr(0, index);
      if (this.lowerCaseTagNames) {
        name2 = name2.toLowerCase();
      }
      return name2;
    };
    Parser3.prototype.ondeclaration = function(start, endIndex) {
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        var name2 = this.getInstructionName(value);
        this.cbs.onprocessinginstruction("!".concat(name2), "!".concat(value));
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onprocessinginstruction = function(start, endIndex) {
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        var name2 = this.getInstructionName(value);
        this.cbs.onprocessinginstruction("?".concat(name2), "?".concat(value));
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.oncomment = function(start, endIndex, offset) {
      var _a, _b, _c, _d;
      this.endIndex = endIndex;
      (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
      (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.oncdata = function(start, endIndex, offset) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex - offset);
      if (this.options.xmlMode || this.options.recognizeCDATA) {
        (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
        (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
        (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
      } else {
        (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
        (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
      }
      this.startIndex = endIndex + 1;
    };
    Parser3.prototype.onend = function() {
      var _a, _b;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (var index = this.stack.length; index > 0; this.cbs.onclosetag(this.stack[--index], true))
          ;
      }
      (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    Parser3.prototype.reset = function() {
      var _a, _b, _c, _d;
      (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
      this.tokenizer.reset();
      this.tagname = "";
      this.attribname = "";
      this.attribs = null;
      this.stack.length = 0;
      this.startIndex = 0;
      this.endIndex = 0;
      (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
      this.buffers.length = 0;
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
    };
    Parser3.prototype.parseComplete = function(data) {
      this.reset();
      this.end(data);
    };
    Parser3.prototype.getSlice = function(start, end) {
      while (start - this.bufferOffset >= this.buffers[0].length) {
        this.shiftBuffer();
      }
      var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
      while (end - this.bufferOffset > this.buffers[0].length) {
        this.shiftBuffer();
        slice += this.buffers[0].slice(0, end - this.bufferOffset);
      }
      return slice;
    };
    Parser3.prototype.shiftBuffer = function() {
      this.bufferOffset += this.buffers[0].length;
      this.writeIndex--;
      this.buffers.shift();
    };
    Parser3.prototype.write = function(chunk) {
      var _a, _b;
      if (this.ended) {
        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(chunk);
      if (this.tokenizer.running) {
        this.tokenizer.write(chunk);
        this.writeIndex++;
      }
    };
    Parser3.prototype.end = function(chunk) {
      var _a, _b;
      if (this.ended) {
        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
        return;
      }
      if (chunk)
        this.write(chunk);
      this.ended = true;
      this.tokenizer.end();
    };
    Parser3.prototype.pause = function() {
      this.tokenizer.pause();
    };
    Parser3.prototype.resume = function() {
      this.tokenizer.resume();
      while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      }
      if (this.ended)
        this.tokenizer.end();
    };
    Parser3.prototype.parseChunk = function(chunk) {
      this.write(chunk);
    };
    Parser3.prototype.done = function(chunk) {
      this.end(chunk);
    };
    return Parser3;
  }()
);
Parser$3.Parser = Parser$2;
var lib$4 = {};
var lib$3 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
  var ElementType2;
  (function(ElementType3) {
    ElementType3["Root"] = "root";
    ElementType3["Text"] = "text";
    ElementType3["Directive"] = "directive";
    ElementType3["Comment"] = "comment";
    ElementType3["Script"] = "script";
    ElementType3["Style"] = "style";
    ElementType3["Tag"] = "tag";
    ElementType3["CDATA"] = "cdata";
    ElementType3["Doctype"] = "doctype";
  })(ElementType2 = exports.ElementType || (exports.ElementType = {}));
  function isTag2(elem) {
    return elem.type === ElementType2.Tag || elem.type === ElementType2.Script || elem.type === ElementType2.Style;
  }
  exports.isTag = isTag2;
  exports.Root = ElementType2.Root;
  exports.Text = ElementType2.Text;
  exports.Directive = ElementType2.Directive;
  exports.Comment = ElementType2.Comment;
  exports.Script = ElementType2.Script;
  exports.Style = ElementType2.Style;
  exports.Tag = ElementType2.Tag;
  exports.CDATA = ElementType2.CDATA;
  exports.Doctype = ElementType2.Doctype;
})(lib$3);
var node$1 = {};
var __extends = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$1 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
Object.defineProperty(node$1, "__esModule", { value: true });
node$1.cloneNode = node$1.hasChildren = node$1.isDocument = node$1.isDirective = node$1.isComment = node$1.isText = node$1.isCDATA = node$1.isTag = node$1.Element = node$1.Document = node$1.CDATA = node$1.NodeWithChildren = node$1.ProcessingInstruction = node$1.Comment = node$1.Text = node$1.DataNode = node$1.Node = void 0;
var domelementtype_1$1 = lib$3;
var Node$6 = (
  /** @class */
  function() {
    function Node3() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node3.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node3.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node3.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node3.prototype.cloneNode = function(recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      return cloneNode$1(this, recursive);
    };
    return Node3;
  }()
);
node$1.Node = Node$6;
var DataNode = (
  /** @class */
  function(_super) {
    __extends(DataNode2, _super);
    function DataNode2(data) {
      var _this = _super.call(this) || this;
      _this.data = data;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(data) {
        this.data = data;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node$6)
);
node$1.DataNode = DataNode;
var Text$1 = (
  /** @class */
  function(_super) {
    __extends(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode)
);
node$1.Text = Text$1;
var Comment$5 = (
  /** @class */
  function(_super) {
    __extends(Comment3, _super);
    function Comment3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment3.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment3;
  }(DataNode)
);
node$1.Comment = Comment$5;
var ProcessingInstruction = (
  /** @class */
  function(_super) {
    __extends(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name2, data) {
      var _this = _super.call(this, data) || this;
      _this.name = name2;
      _this.type = domelementtype_1$1.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode)
);
node$1.ProcessingInstruction = ProcessingInstruction;
var NodeWithChildren = (
  /** @class */
  function(_super) {
    __extends(NodeWithChildren2, _super);
    function NodeWithChildren2(children2) {
      var _this = _super.call(this) || this;
      _this.children = children2;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(children2) {
        this.children = children2;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node$6)
);
node$1.NodeWithChildren = NodeWithChildren;
var CDATA = (
  /** @class */
  function(_super) {
    __extends(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren)
);
node$1.CDATA = CDATA;
var Document$5 = (
  /** @class */
  function(_super) {
    __extends(Document3, _super);
    function Document3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1$1.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document3.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document3;
  }(NodeWithChildren)
);
node$1.Document = Document$5;
var Element$1 = (
  /** @class */
  function(_super) {
    __extends(Element2, _super);
    function Element2(name2, attribs, children2, type) {
      if (children2 === void 0) {
        children2 = [];
      }
      if (type === void 0) {
        type = name2 === "script" ? domelementtype_1$1.ElementType.Script : name2 === "style" ? domelementtype_1$1.ElementType.Style : domelementtype_1$1.ElementType.Tag;
      }
      var _this = _super.call(this, children2) || this;
      _this.name = name2;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(name2) {
        this.name = name2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name2) {
          var _a, _b;
          return {
            name: name2,
            value: _this.attribs[name2],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name2],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren)
);
node$1.Element = Element$1;
function isTag(node2) {
  return (0, domelementtype_1$1.isTag)(node2);
}
node$1.isTag = isTag;
function isCDATA(node2) {
  return node2.type === domelementtype_1$1.ElementType.CDATA;
}
node$1.isCDATA = isCDATA;
function isText(node2) {
  return node2.type === domelementtype_1$1.ElementType.Text;
}
node$1.isText = isText;
function isComment(node2) {
  return node2.type === domelementtype_1$1.ElementType.Comment;
}
node$1.isComment = isComment;
function isDirective(node2) {
  return node2.type === domelementtype_1$1.ElementType.Directive;
}
node$1.isDirective = isDirective;
function isDocument(node2) {
  return node2.type === domelementtype_1$1.ElementType.Root;
}
node$1.isDocument = isDocument;
function hasChildren(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
node$1.hasChildren = hasChildren;
function cloneNode$1(node2, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result2;
  if (isText(node2)) {
    result2 = new Text$1(node2.data);
  } else if (isComment(node2)) {
    result2 = new Comment$5(node2.data);
  } else if (isTag(node2)) {
    var children2 = recursive ? cloneChildren(node2.children) : [];
    var clone_1 = new Element$1(node2.name, __assign$1({}, node2.attribs), children2);
    children2.forEach(function(child) {
      return child.parent = clone_1;
    });
    if (node2.namespace != null) {
      clone_1.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign$1({}, node2["x-attribsNamespace"]);
    }
    if (node2["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign$1({}, node2["x-attribsPrefix"]);
    }
    result2 = clone_1;
  } else if (isCDATA(node2)) {
    var children2 = recursive ? cloneChildren(node2.children) : [];
    var clone_2 = new CDATA(children2);
    children2.forEach(function(child) {
      return child.parent = clone_2;
    });
    result2 = clone_2;
  } else if (isDocument(node2)) {
    var children2 = recursive ? cloneChildren(node2.children) : [];
    var clone_3 = new Document$5(children2);
    children2.forEach(function(child) {
      return child.parent = clone_3;
    });
    if (node2["x-mode"]) {
      clone_3["x-mode"] = node2["x-mode"];
    }
    result2 = clone_3;
  } else if (isDirective(node2)) {
    var instruction = new ProcessingInstruction(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result2 = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node2.type));
  }
  result2.startIndex = node2.startIndex;
  result2.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result2.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result2;
}
node$1.cloneNode = cloneNode$1;
function cloneChildren(childs) {
  var children2 = childs.map(function(child) {
    return cloneNode$1(child, true);
  });
  for (var i2 = 1; i2 < children2.length; i2++) {
    children2[i2].prev = children2[i2 - 1];
    children2[i2 - 1].next = children2[i2];
  }
  return children2;
}
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DomHandler = void 0;
  var domelementtype_12 = lib$3;
  var node_js_1 = node$1;
  __exportStar(node$1, exports);
  var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = (
    /** @class */
    function() {
      function DomHandler2(callback, options, elementCB) {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
        if (typeof options === "function") {
          elementCB = options;
          options = defaultOpts;
        }
        if (typeof callback === "object") {
          options = callback;
          callback = void 0;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
      }
      DomHandler2.prototype.onparserinit = function(parser2) {
        this.parser = parser2;
      };
      DomHandler2.prototype.onreset = function() {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
      };
      DomHandler2.prototype.onend = function() {
        if (this.done)
          return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
      };
      DomHandler2.prototype.onerror = function(error) {
        this.handleCallback(error);
      };
      DomHandler2.prototype.onclosetag = function() {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
          elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
          this.elementCB(elem);
      };
      DomHandler2.prototype.onopentag = function(name2, attribs) {
        var type = this.options.xmlMode ? domelementtype_12.ElementType.Tag : void 0;
        var element = new node_js_1.Element(name2, attribs, void 0, type);
        this.addNode(element);
        this.tagStack.push(element);
      };
      DomHandler2.prototype.ontext = function(data) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_12.ElementType.Text) {
          lastNode.data += data;
          if (this.options.withEndIndices) {
            lastNode.endIndex = this.parser.endIndex;
          }
        } else {
          var node2 = new node_js_1.Text(data);
          this.addNode(node2);
          this.lastNode = node2;
        }
      };
      DomHandler2.prototype.oncomment = function(data) {
        if (this.lastNode && this.lastNode.type === domelementtype_12.ElementType.Comment) {
          this.lastNode.data += data;
          return;
        }
        var node2 = new node_js_1.Comment(data);
        this.addNode(node2);
        this.lastNode = node2;
      };
      DomHandler2.prototype.oncommentend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.oncdatastart = function() {
        var text2 = new node_js_1.Text("");
        var node2 = new node_js_1.CDATA([text2]);
        this.addNode(node2);
        text2.parent = node2;
        this.lastNode = text2;
      };
      DomHandler2.prototype.oncdataend = function() {
        this.lastNode = null;
      };
      DomHandler2.prototype.onprocessinginstruction = function(name2, data) {
        var node2 = new node_js_1.ProcessingInstruction(name2, data);
        this.addNode(node2);
      };
      DomHandler2.prototype.handleCallback = function(error) {
        if (typeof this.callback === "function") {
          this.callback(error, this.dom);
        } else if (error) {
          throw error;
        }
      };
      DomHandler2.prototype.addNode = function(node2) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
          node2.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
          node2.endIndex = this.parser.endIndex;
        }
        parent.children.push(node2);
        if (previousSibling) {
          node2.prev = previousSibling;
          previousSibling.next = node2;
        }
        node2.parent = parent;
        this.lastNode = null;
      };
      return DomHandler2;
    }()
  );
  exports.DomHandler = DomHandler;
  exports.default = DomHandler;
})(lib$4);
var lib$2 = {};
var stringify$5 = {};
var lib$1 = {};
var lib = {};
var encode = {};
var encodeHtml = {};
Object.defineProperty(encodeHtml, "__esModule", { value: true });
function restoreDiff(arr) {
  for (var i2 = 1; i2 < arr.length; i2++) {
    arr[i2][0] += arr[i2 - 1][0] + 1;
  }
  return arr;
}
encodeHtml.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var _escape = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
  exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(str, index) {
    return str.codePointAt(index);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c, index) {
      return (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
    }
  );
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports.xmlReplacer.exec(str)) !== null) {
      var i2 = match.index;
      var char = str.charCodeAt(i2);
      var next = xmlCodeMap.get(char);
      if (next !== void 0) {
        ret += str.substring(lastIdx, i2) + next;
        lastIdx = i2 + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i2), "&#x").concat((0, exports.getCodePoint)(str, i2).toString(16), ";");
        lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports.encodeXML = encodeXML;
  exports.escape = encodeXML;
  function getEscaper(regex, map2) {
    return function escape2(data) {
      var match;
      var lastIdx = 0;
      var result2 = "";
      while (match = regex.exec(data)) {
        if (lastIdx !== match.index) {
          result2 += data.substring(lastIdx, match.index);
        }
        result2 += map2.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result2 + data.substring(lastIdx);
    };
  }
  exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(_escape);
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(encode, "__esModule", { value: true });
encode.encodeNonAsciiHTML = encode.encodeHTML = void 0;
var encode_html_js_1 = __importDefault$1(encodeHtml);
var escape_js_1 = _escape;
var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function encodeHTML(data) {
  return encodeHTMLTrieRe(htmlReplacer, data);
}
encode.encodeHTML = encodeHTML;
function encodeNonAsciiHTML(data) {
  return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
}
encode.encodeNonAsciiHTML = encodeNonAsciiHTML;
function encodeHTMLTrieRe(regExp, str) {
  var ret = "";
  var lastIdx = 0;
  var match;
  while ((match = regExp.exec(str)) !== null) {
    var i2 = match.index;
    ret += str.substring(lastIdx, i2);
    var char = str.charCodeAt(i2);
    var next = encode_html_js_1.default.get(char);
    if (typeof next === "object") {
      if (i2 + 1 < str.length) {
        var nextChar = str.charCodeAt(i2 + 1);
        var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
        if (value !== void 0) {
          ret += value;
          lastIdx = regExp.lastIndex += 1;
          continue;
        }
      }
      next = next.v;
    }
    if (next !== void 0) {
      ret += next;
      lastIdx = i2 + 1;
    } else {
      var cp = (0, escape_js_1.getCodePoint)(str, i2);
      ret += "&#x".concat(cp.toString(16), ";");
      lastIdx = regExp.lastIndex += Number(cp !== char);
    }
  }
  return ret + str.substr(lastIdx);
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = void 0;
  var decode_js_12 = decode;
  var encode_js_1 = encode;
  var escape_js_12 = _escape;
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
  function decode$12(data, options) {
    if (options === void 0) {
      options = EntityLevel.XML;
    }
    var level = typeof options === "number" ? options : options.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options === "object" ? options.mode : void 0;
      return (0, decode_js_12.decodeHTML)(data, mode);
    }
    return (0, decode_js_12.decodeXML)(data);
  }
  exports.decode = decode$12;
  function decodeStrict(data, options) {
    var _a;
    if (options === void 0) {
      options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? { level: options } : options;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_12.DecodingMode.Strict;
    return decode$12(data, opts);
  }
  exports.decodeStrict = decodeStrict;
  function encode$12(data, options) {
    if (options === void 0) {
      options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? { level: options } : options;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_12.escapeUTF8)(data);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_12.escapeAttribute)(data);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_12.escapeText)(data);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data);
      }
      return (0, encode_js_1.encodeHTML)(data);
    }
    return (0, escape_js_12.encodeXML)(data);
  }
  exports.encode = encode$12;
  var escape_js_2 = _escape;
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = encode;
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = decode;
  Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
})(lib);
var foreignNames = {};
Object.defineProperty(foreignNames, "__esModule", { value: true });
foreignNames.attributeNames = foreignNames.elementNames = void 0;
foreignNames.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(val) {
  return [val.toLowerCase(), val];
}));
foreignNames.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(val) {
  return [val.toLowerCase(), val];
}));
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result2 = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result2, mod, k);
  }
  __setModuleDefault(result2, mod);
  return result2;
};
Object.defineProperty(lib$1, "__esModule", { value: true });
lib$1.render = void 0;
var ElementType = __importStar(lib$3);
var entities_1 = lib;
var foreignNames_js_1 = foreignNames;
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a;
  if (!attributes)
    return;
  var encode2 = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
  return Object.keys(attributes).map(function(key2) {
    var _a2, _b;
    var value = (_a2 = attributes[key2]) !== null && _a2 !== void 0 ? _a2 : "";
    if (opts.xmlMode === "foreign") {
      key2 = (_b = foreignNames_js_1.attributeNames.get(key2)) !== null && _b !== void 0 ? _b : key2;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key2;
    }
    return "".concat(key2, '="').concat(encode2(value), '"');
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node2, options) {
  if (options === void 0) {
    options = {};
  }
  var nodes = "length" in node2 ? node2 : [node2];
  var output = "";
  for (var i2 = 0; i2 < nodes.length; i2++) {
    output += renderNode(nodes[i2], options);
  }
  return output;
}
lib$1.render = render;
lib$1.default = render;
function renderNode(node2, options) {
  switch (node2.type) {
    case ElementType.Root:
      return render(node2.children, options);
    case ElementType.Doctype:
    case ElementType.Directive:
      return renderDirective(node2);
    case ElementType.Comment:
      return renderComment(node2);
    case ElementType.CDATA:
      return renderCdata(node2);
    case ElementType.Script:
    case ElementType.Style:
    case ElementType.Tag:
      return renderTag(node2, options);
    case ElementType.Text:
      return renderText(node2, options);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = __assign(__assign({}, opts), { xmlMode: false });
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
  }
  var tag = "<".concat(elem.name);
  var attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += " ".concat(attribs);
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += "</".concat(elem.name, ">");
    }
  }
  return tag;
}
function renderDirective(elem) {
  return "<".concat(elem.data, ">");
}
function renderText(elem, opts) {
  var _a;
  var data = elem.data || "";
  if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
  }
  return data;
}
function renderCdata(elem) {
  return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment(elem) {
  return "<!--".concat(elem.data, "-->");
}
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(stringify$5, "__esModule", { value: true });
stringify$5.innerText = stringify$5.textContent = stringify$5.getText = stringify$5.getInnerHTML = stringify$5.getOuterHTML = void 0;
var domhandler_1$3 = lib$4;
var dom_serializer_1 = __importDefault(lib$1);
var domelementtype_1 = lib$3;
function getOuterHTML(node2, options) {
  return (0, dom_serializer_1.default)(node2, options);
}
stringify$5.getOuterHTML = getOuterHTML;
function getInnerHTML(node2, options) {
  return (0, domhandler_1$3.hasChildren)(node2) ? node2.children.map(function(node3) {
    return getOuterHTML(node3, options);
  }).join("") : "";
}
stringify$5.getInnerHTML = getInnerHTML;
function getText(node2) {
  if (Array.isArray(node2))
    return node2.map(getText).join("");
  if ((0, domhandler_1$3.isTag)(node2))
    return node2.name === "br" ? "\n" : getText(node2.children);
  if ((0, domhandler_1$3.isCDATA)(node2))
    return getText(node2.children);
  if ((0, domhandler_1$3.isText)(node2))
    return node2.data;
  return "";
}
stringify$5.getText = getText;
function textContent(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent).join("");
  if ((0, domhandler_1$3.hasChildren)(node2) && !(0, domhandler_1$3.isComment)(node2)) {
    return textContent(node2.children);
  }
  if ((0, domhandler_1$3.isText)(node2))
    return node2.data;
  return "";
}
stringify$5.textContent = textContent;
function innerText(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText).join("");
  if ((0, domhandler_1$3.hasChildren)(node2) && (node2.type === domelementtype_1.ElementType.Tag || (0, domhandler_1$3.isCDATA)(node2))) {
    return innerText(node2.children);
  }
  if ((0, domhandler_1$3.isText)(node2))
    return node2.data;
  return "";
}
stringify$5.innerText = innerText;
var traversal = {};
Object.defineProperty(traversal, "__esModule", { value: true });
traversal.prevElementSibling = traversal.nextElementSibling = traversal.getName = traversal.hasAttrib = traversal.getAttributeValue = traversal.getSiblings = traversal.getParent = traversal.getChildren = void 0;
var domhandler_1$2 = lib$4;
function getChildren(elem) {
  return (0, domhandler_1$2.hasChildren)(elem) ? elem.children : [];
}
traversal.getChildren = getChildren;
function getParent(elem) {
  return elem.parent || null;
}
traversal.getParent = getParent;
function getSiblings(elem) {
  var _a, _b;
  var parent = getParent(elem);
  if (parent != null)
    return getChildren(parent);
  var siblings = [elem];
  var prev = elem.prev, next = elem.next;
  while (prev != null) {
    siblings.unshift(prev);
    _a = prev, prev = _a.prev;
  }
  while (next != null) {
    siblings.push(next);
    _b = next, next = _b.next;
  }
  return siblings;
}
traversal.getSiblings = getSiblings;
function getAttributeValue(elem, name2) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name2];
}
traversal.getAttributeValue = getAttributeValue;
function hasAttrib(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
traversal.hasAttrib = hasAttrib;
function getName(elem) {
  return elem.name;
}
traversal.getName = getName;
function nextElementSibling(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1$2.isTag)(next))
    _a = next, next = _a.next;
  return next;
}
traversal.nextElementSibling = nextElementSibling;
function prevElementSibling(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1$2.isTag)(prev))
    _a = prev, prev = _a.prev;
  return prev;
}
traversal.prevElementSibling = prevElementSibling;
var manipulation = {};
Object.defineProperty(manipulation, "__esModule", { value: true });
manipulation.prepend = manipulation.prependChild = manipulation.append = manipulation.appendChild = manipulation.replaceElement = manipulation.removeElement = void 0;
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    var childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
manipulation.removeElement = removeElement;
function replaceElement(elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
manipulation.replaceElement = replaceElement;
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    var sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
manipulation.appendChild = appendChild;
function append(elem, next) {
  removeElement(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
manipulation.append = append;
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    var sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
manipulation.prependChild = prependChild;
function prepend(elem, prev) {
  removeElement(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
manipulation.prepend = prepend;
var querying = {};
Object.defineProperty(querying, "__esModule", { value: true });
querying.findAll = querying.existsOne = querying.findOne = querying.findOneChild = querying.find = querying.filter = void 0;
var domhandler_1$1 = lib$4;
function filter$1(test, node2, recurse, limit2) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit2 === void 0) {
    limit2 = Infinity;
  }
  return find$2(test, Array.isArray(node2) ? node2 : [node2], recurse, limit2);
}
querying.filter = filter$1;
function find$2(test, nodes, recurse, limit2) {
  var result2 = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result2;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result2.push(elem);
      if (--limit2 <= 0)
        return result2;
    }
    if (recurse && (0, domhandler_1$1.hasChildren)(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying.find = find$2;
function findOneChild(test, nodes) {
  return nodes.find(test);
}
querying.findOneChild = findOneChild;
function findOne(test, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i2 = 0; i2 < nodes.length && !elem; i2++) {
    var node2 = nodes[i2];
    if (!(0, domhandler_1$1.isTag)(node2)) {
      continue;
    } else if (test(node2)) {
      elem = node2;
    } else if (recurse && node2.children.length > 0) {
      elem = findOne(test, node2.children, true);
    }
  }
  return elem;
}
querying.findOne = findOne;
function existsOne(test, nodes) {
  return nodes.some(function(checked) {
    return (0, domhandler_1$1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
  });
}
querying.existsOne = existsOne;
function findAll(test, nodes) {
  var result2 = [];
  var nodeStack = [nodes];
  var indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result2;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    var elem = nodeStack[0][indexStack[0]++];
    if (!(0, domhandler_1$1.isTag)(elem))
      continue;
    if (test(elem))
      result2.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
querying.findAll = findAll;
var legacy = {};
Object.defineProperty(legacy, "__esModule", { value: true });
legacy.getElementsByTagType = legacy.getElementsByTagName = legacy.getElementById = legacy.getElements = legacy.testElement = void 0;
var domhandler_1 = lib$4;
var querying_js_1 = querying;
var Checks = {
  tag_name: function(name2) {
    if (typeof name2 === "function") {
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && name2(elem.name);
      };
    } else if (name2 === "*") {
      return domhandler_1.isTag;
    }
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && elem.name === name2;
    };
  },
  tag_type: function(type) {
    if (typeof type === "function") {
      return function(elem) {
        return type(elem.type);
      };
    }
    return function(elem) {
      return elem.type === type;
    };
  },
  tag_contains: function(data) {
    if (typeof data === "function") {
      return function(elem) {
        return (0, domhandler_1.isText)(elem) && data(elem.data);
      };
    }
    return function(elem) {
      return (0, domhandler_1.isText)(elem) && elem.data === data;
    };
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function(elem) {
    return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
function combineFuncs(a, b) {
  return function(elem) {
    return a(elem) || b(elem);
  };
}
function compileTest(options) {
  var funcs = Object.keys(options).map(function(key2) {
    var value = options[key2];
    return Object.prototype.hasOwnProperty.call(Checks, key2) ? Checks[key2](value) : getAttribCheck(key2, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node2) {
  var test = compileTest(options);
  return test ? test(node2) : true;
}
legacy.testElement = testElement;
function getElements(options, nodes, recurse, limit2) {
  if (limit2 === void 0) {
    limit2 = Infinity;
  }
  var test = compileTest(options);
  return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit2) : [];
}
legacy.getElements = getElements;
function getElementById(id, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
legacy.getElementById = getElementById;
function getElementsByTagName(tagName, nodes, recurse, limit2) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit2 === void 0) {
    limit2 = Infinity;
  }
  return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit2);
}
legacy.getElementsByTagName = getElementsByTagName;
function getElementsByTagType(type, nodes, recurse, limit2) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit2 === void 0) {
    limit2 = Infinity;
  }
  return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit2);
}
legacy.getElementsByTagType = getElementsByTagType;
var helpers = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;
  var domhandler_12 = lib$4;
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node2 = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  exports.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_12.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_12.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  exports.compareDocumentPosition = compareDocumentPosition;
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node2, i2, arr) {
      return !arr.includes(node2, i2 + 1);
    });
    nodes.sort(function(a, b) {
      var relative3 = compareDocumentPosition(a, b);
      if (relative3 & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative3 & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
  exports.uniqueSort = uniqueSort;
})(helpers);
var feeds = {};
Object.defineProperty(feeds, "__esModule", { value: true });
feeds.getFeed = void 0;
var stringify_js_1 = stringify$5;
var legacy_js_1 = legacy;
function getFeed(doc2) {
  var feedRoot = getOneElement(isValidFeed, doc2);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
feeds.getFeed = getFeed;
function getAtomFeed(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
      var _a2;
      var children2 = item.children;
      var entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "id", children2);
      addConditionally(entry, "title", "title", children2);
      var href2 = (_a2 = getOneElement("link", children2)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      var description = fetch$1("summary", children2) || fetch$1("content", children2);
      if (description) {
        entry.description = description;
      }
      var pubDate = fetch$1("updated", children2);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  var updated = fetch$1("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a, _b;
  var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
      var children2 = item.children;
      var entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "guid", children2);
      addConditionally(entry, "title", "title", children2);
      addConditionally(entry, "link", "link", children2);
      addConditionally(entry, "description", "description", children2);
      var pubDate = fetch$1("pubDate", children2) || fetch$1("dc:date", children2);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  var updated = fetch$1("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
    var attribs = elem.attribs;
    var media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
      var attrib = MEDIA_KEYS_STRING_1[_i];
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
      var attrib = MEDIA_KEYS_INT_1[_a];
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node2) {
  return (0, legacy_js_1.getElementsByTagName)(tagName, node2, true, 1)[0];
}
function fetch$1(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val = fetch$1(tagName, where, recurse);
  if (val)
    obj[prop] = val;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
  __exportStar(stringify$5, exports);
  __exportStar(traversal, exports);
  __exportStar(manipulation, exports);
  __exportStar(querying, exports);
  __exportStar(legacy, exports);
  __exportStar(helpers, exports);
  __exportStar(feeds, exports);
  var domhandler_12 = lib$4;
  Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
    return domhandler_12.isTag;
  } });
  Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
    return domhandler_12.isCDATA;
  } });
  Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
    return domhandler_12.isText;
  } });
  Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
    return domhandler_12.isComment;
  } });
  Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
    return domhandler_12.isDocument;
  } });
  Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
    return domhandler_12.hasChildren;
  } });
})(lib$2);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result2, mod, k);
    }
    __setModuleDefault2(result2, mod);
    return result2;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DefaultHandler = exports.DomHandler = exports.Parser = void 0;
  var Parser_js_1 = Parser$3;
  var Parser_js_2 = Parser$3;
  Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
    return Parser_js_2.Parser;
  } });
  var domhandler_12 = lib$4;
  var domhandler_2 = lib$4;
  Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function() {
    return domhandler_2.DomHandler;
  } });
  Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function() {
    return domhandler_2.DomHandler;
  } });
  function parseDocument(data, options) {
    var handler = new domhandler_12.DomHandler(void 0, options);
    new Parser_js_1.Parser(handler, options).end(data);
    return handler.root;
  }
  exports.parseDocument = parseDocument;
  function parseDOM(data, options) {
    return parseDocument(data, options).children;
  }
  exports.parseDOM = parseDOM;
  function createDomStream(callback, options, elementCallback) {
    var handler = new domhandler_12.DomHandler(callback, options, elementCallback);
    return new Parser_js_1.Parser(handler, options);
  }
  exports.createDomStream = createDomStream;
  var Tokenizer_js_12 = Tokenizer;
  Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function() {
    return __importDefault2(Tokenizer_js_12).default;
  } });
  exports.ElementType = __importStar2(lib$3);
  var domutils_1 = lib$2;
  var domutils_2 = lib$2;
  Object.defineProperty(exports, "getFeed", { enumerable: true, get: function() {
    return domutils_2.getFeed;
  } });
  var parseFeedDefaultOptions = { xmlMode: true };
  function parseFeed(feed, options) {
    if (options === void 0) {
      options = parseFeedDefaultOptions;
    }
    return (0, domutils_1.getFeed)(parseDOM(feed, options));
  }
  exports.parseFeed = parseFeed;
  exports.DomUtils = __importStar2(lib$2);
})(lib$5);
var escapeStringRegexp$1 = (string) => {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
var isPlainObject$2 = {};
Object.defineProperty(isPlainObject$2, "__esModule", { value: true });
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject$1(o) {
  var ctor, prot;
  if (isObject(o) === false) return false;
  ctor = o.constructor;
  if (ctor === void 0) return true;
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
isPlainObject$2.isPlainObject = isPlainObject$1;
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge$1(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target2, source, options) {
  return target2.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function getMergeFunction(key2, options) {
  if (!options.customMerge) {
    return deepmerge$1;
  }
  var customMerge = options.customMerge(key2);
  return typeof customMerge === "function" ? customMerge : deepmerge$1;
}
function getEnumerableOwnPropertySymbols(target2) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target2).filter(function(symbol) {
    return Object.propertyIsEnumerable.call(target2, symbol);
  }) : [];
}
function getKeys(target2) {
  return Object.keys(target2).concat(getEnumerableOwnPropertySymbols(target2));
}
function propertyIsOnObject(object, property) {
  try {
    return property in object;
  } catch (_) {
    return false;
  }
}
function propertyIsUnsafe(target2, key2) {
  return propertyIsOnObject(target2, key2) && !(Object.hasOwnProperty.call(target2, key2) && Object.propertyIsEnumerable.call(target2, key2));
}
function mergeObject(target2, source, options) {
  var destination = {};
  if (options.isMergeableObject(target2)) {
    getKeys(target2).forEach(function(key2) {
      destination[key2] = cloneUnlessOtherwiseSpecified(target2[key2], options);
    });
  }
  getKeys(source).forEach(function(key2) {
    if (propertyIsUnsafe(target2, key2)) {
      return;
    }
    if (propertyIsOnObject(target2, key2) && options.isMergeableObject(source[key2])) {
      destination[key2] = getMergeFunction(key2, options)(target2[key2], source[key2], options);
    } else {
      destination[key2] = cloneUnlessOtherwiseSpecified(source[key2], options);
    }
  });
  return destination;
}
function deepmerge$1(target2, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target2);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target2, source, options);
  } else {
    return mergeObject(target2, source, options);
  }
}
deepmerge$1.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error("first argument should be an array");
  }
  return array.reduce(function(prev, next) {
    return deepmerge$1(prev, next, options);
  }, {});
};
var deepmerge_1 = deepmerge$1;
var cjs = deepmerge_1;
var parseSrcset$1 = { exports: {} };
(function(module) {
  (function(root2, factory) {
    if (module.exports) {
      module.exports = factory();
    } else {
      root2.parseSrcset = factory();
    }
  })(commonjsGlobal, function() {
    return function(input2) {
      function isSpace(c2) {
        return c2 === " " || // space
        c2 === "	" || // horizontal tab
        c2 === "\n" || // new line
        c2 === "\f" || // form feed
        c2 === "\r";
      }
      function collectCharacters(regEx) {
        var chars, match = regEx.exec(input2.substring(pos));
        if (match) {
          chars = match[0];
          pos += chars.length;
          return chars;
        }
      }
      var inputLength = input2.length, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url2, descriptors, currentDescriptor, state, c, pos = 0, candidates = [];
      while (true) {
        collectCharacters(regexLeadingCommasOrSpaces);
        if (pos >= inputLength) {
          return candidates;
        }
        url2 = collectCharacters(regexLeadingNotSpaces);
        descriptors = [];
        if (url2.slice(-1) === ",") {
          url2 = url2.replace(regexTrailingCommas, "");
          parseDescriptors();
        } else {
          tokenize2();
        }
      }
      function tokenize2() {
        collectCharacters(regexLeadingSpaces);
        currentDescriptor = "";
        state = "in descriptor";
        while (true) {
          c = input2.charAt(pos);
          if (state === "in descriptor") {
            if (isSpace(c)) {
              if (currentDescriptor) {
                descriptors.push(currentDescriptor);
                currentDescriptor = "";
                state = "after descriptor";
              }
            } else if (c === ",") {
              pos += 1;
              if (currentDescriptor) {
                descriptors.push(currentDescriptor);
              }
              parseDescriptors();
              return;
            } else if (c === "(") {
              currentDescriptor = currentDescriptor + c;
              state = "in parens";
            } else if (c === "") {
              if (currentDescriptor) {
                descriptors.push(currentDescriptor);
              }
              parseDescriptors();
              return;
            } else {
              currentDescriptor = currentDescriptor + c;
            }
          } else if (state === "in parens") {
            if (c === ")") {
              currentDescriptor = currentDescriptor + c;
              state = "in descriptor";
            } else if (c === "") {
              descriptors.push(currentDescriptor);
              parseDescriptors();
              return;
            } else {
              currentDescriptor = currentDescriptor + c;
            }
          } else if (state === "after descriptor") {
            if (isSpace(c)) ;
            else if (c === "") {
              parseDescriptors();
              return;
            } else {
              state = "in descriptor";
              pos -= 1;
            }
          }
          pos += 1;
        }
      }
      function parseDescriptors() {
        var pError = false, w, d, h2, i2, candidate = {}, desc, lastChar, value, intVal, floatVal;
        for (i2 = 0; i2 < descriptors.length; i2++) {
          desc = descriptors[i2];
          lastChar = desc[desc.length - 1];
          value = desc.substring(0, desc.length - 1);
          intVal = parseInt(value, 10);
          floatVal = parseFloat(value);
          if (regexNonNegativeInteger.test(value) && lastChar === "w") {
            if (w || d) {
              pError = true;
            }
            if (intVal === 0) {
              pError = true;
            } else {
              w = intVal;
            }
          } else if (regexFloatingPoint.test(value) && lastChar === "x") {
            if (w || d || h2) {
              pError = true;
            }
            if (floatVal < 0) {
              pError = true;
            } else {
              d = floatVal;
            }
          } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
            if (h2 || d) {
              pError = true;
            }
            if (intVal === 0) {
              pError = true;
            } else {
              h2 = intVal;
            }
          } else {
            pError = true;
          }
        }
        if (!pError) {
          candidate.url = url2;
          if (w) {
            candidate.w = w;
          }
          if (d) {
            candidate.d = d;
          }
          if (h2) {
            candidate.h = h2;
          }
          candidates.push(candidate);
        } else if (console && console.log) {
          console.log("Invalid srcset descriptor found in '" + input2 + "' at '" + desc + "'.");
        }
      }
    };
  });
})(parseSrcset$1);
var parseSrcsetExports = parseSrcset$1.exports;
var picocolors_browser = { exports: {} };
var x = String;
var create$6 = function() {
  return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x, blackBright: x, redBright: x, greenBright: x, yellowBright: x, blueBright: x, magentaBright: x, cyanBright: x, whiteBright: x, bgBlackBright: x, bgRedBright: x, bgGreenBright: x, bgYellowBright: x, bgBlueBright: x, bgMagentaBright: x, bgCyanBright: x, bgWhiteBright: x };
};
picocolors_browser.exports = create$6();
picocolors_browser.exports.createColors = create$6;
var picocolors_browserExports = picocolors_browser.exports;
const __viteBrowserExternal = new Proxy({}, {
  get(_, key2) {
    throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${key2}" in client code.  See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
  }
});
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
let pico = picocolors_browserExports;
let terminalHighlight$1 = require$$2;
let CssSyntaxError$3 = class CssSyntaxError2 extends Error {
  constructor(message, line, column, source, file, plugin2) {
    super(message);
    this.name = "CssSyntaxError";
    this.reason = message;
    if (file) {
      this.file = file;
    }
    if (source) {
      this.source = source;
    }
    if (plugin2) {
      this.plugin = plugin2;
    }
    if (typeof line !== "undefined" && typeof column !== "undefined") {
      if (typeof line === "number") {
        this.line = line;
        this.column = column;
      } else {
        this.line = line.line;
        this.column = line.column;
        this.endLine = column.line;
        this.endColumn = column.column;
      }
    }
    this.setMessage();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError2);
    }
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "";
    this.message += this.file ? this.file : "<css input>";
    if (typeof this.line !== "undefined") {
      this.message += ":" + this.line + ":" + this.column;
    }
    this.message += ": " + this.reason;
  }
  showSourceCode(color) {
    if (!this.source) return "";
    let css2 = this.source;
    if (color == null) color = pico.isColorSupported;
    let aside = (text2) => text2;
    let mark = (text2) => text2;
    let highlight = (text2) => text2;
    if (color) {
      let { bold, gray, red } = pico.createColors(true);
      mark = (text2) => bold(red(text2));
      aside = (text2) => gray(text2);
      if (terminalHighlight$1) {
        highlight = (text2) => terminalHighlight$1(text2);
      }
    }
    let lines = css2.split(/\r?\n/);
    let start = Math.max(this.line - 3, 0);
    let end = Math.min(this.line + 2, lines.length);
    let maxWidth = String(end).length;
    return lines.slice(start, end).map((line, index) => {
      let number = start + 1 + index;
      let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
      if (number === this.line) {
        if (line.length > 160) {
          let padding = 20;
          let subLineStart = Math.max(0, this.column - padding);
          let subLineEnd = Math.max(
            this.column + padding,
            this.endColumn + padding
          );
          let subLine = line.slice(subLineStart, subLineEnd);
          let spacing2 = aside(gutter.replace(/\d/g, " ")) + line.slice(0, Math.min(this.column - 1, padding - 1)).replace(/[^\t]/g, " ");
          return mark(">") + aside(gutter) + highlight(subLine) + "\n " + spacing2 + mark("^");
        }
        let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return mark(">") + aside(gutter) + highlight(line) + "\n " + spacing + mark("^");
      }
      return " " + aside(gutter) + highlight(line);
    }).join("\n");
  }
  toString() {
    let code2 = this.showSourceCode();
    if (code2) {
      code2 = "\n\n" + code2 + "\n";
    }
    return this.name + ": " + this.message + code2;
  }
};
var cssSyntaxError = CssSyntaxError$3;
CssSyntaxError$3.default = CssSyntaxError$3;
const DEFAULT_RAW = {
  after: "\n",
  beforeClose: "\n",
  beforeComment: "\n",
  beforeDecl: "\n",
  beforeOpen: " ",
  beforeRule: "\n",
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: false
};
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
let Stringifier$2 = class Stringifier2 {
  constructor(builder2) {
    this.builder = builder2;
  }
  atrule(node2, semicolon) {
    let name2 = "@" + node2.name;
    let params2 = node2.params ? this.rawValue(node2, "params") : "";
    if (typeof node2.raws.afterName !== "undefined") {
      name2 += node2.raws.afterName;
    } else if (params2) {
      name2 += " ";
    }
    if (node2.nodes) {
      this.block(node2, name2 + params2);
    } else {
      let end = (node2.raws.between || "") + (semicolon ? ";" : "");
      this.builder(name2 + params2 + end, node2);
    }
  }
  beforeAfter(node2, detect) {
    let value;
    if (node2.type === "decl") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (node2.type === "comment") {
      value = this.raw(node2, null, "beforeComment");
    } else if (detect === "before") {
      value = this.raw(node2, null, "beforeRule");
    } else {
      value = this.raw(node2, null, "beforeClose");
    }
    let buf = node2.parent;
    let depth = 0;
    while (buf && buf.type !== "root") {
      depth += 1;
      buf = buf.parent;
    }
    if (value.includes("\n")) {
      let indent = this.raw(node2, null, "indent");
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent;
      }
    }
    return value;
  }
  block(node2, start) {
    let between = this.raw(node2, "between", "beforeOpen");
    this.builder(start + between + "{", node2, "start");
    let after;
    if (node2.nodes && node2.nodes.length) {
      this.body(node2);
      after = this.raw(node2, "after");
    } else {
      after = this.raw(node2, "after", "emptyBody");
    }
    if (after) this.builder(after);
    this.builder("}", node2, "end");
  }
  body(node2) {
    let last2 = node2.nodes.length - 1;
    while (last2 > 0) {
      if (node2.nodes[last2].type !== "comment") break;
      last2 -= 1;
    }
    let semicolon = this.raw(node2, "semicolon");
    for (let i2 = 0; i2 < node2.nodes.length; i2++) {
      let child = node2.nodes[i2];
      let before = this.raw(child, "before");
      if (before) this.builder(before);
      this.stringify(child, last2 !== i2 || semicolon);
    }
  }
  comment(node2) {
    let left = this.raw(node2, "left", "commentLeft");
    let right = this.raw(node2, "right", "commentRight");
    this.builder("/*" + left + node2.text + right + "*/", node2);
  }
  decl(node2, semicolon) {
    let between = this.raw(node2, "between", "colon");
    let string = node2.prop + between + this.rawValue(node2, "value");
    if (node2.important) {
      string += node2.raws.important || " !important";
    }
    if (semicolon) string += ";";
    this.builder(string, node2);
  }
  document(node2) {
    this.body(node2);
  }
  raw(node2, own, detect) {
    let value;
    if (!detect) detect = own;
    if (own) {
      value = node2.raws[own];
      if (typeof value !== "undefined") return value;
    }
    let parent = node2.parent;
    if (detect === "before") {
      if (!parent || parent.type === "root" && parent.first === node2) {
        return "";
      }
      if (parent && parent.type === "document") {
        return "";
      }
    }
    if (!parent) return DEFAULT_RAW[detect];
    let root2 = node2.root();
    if (!root2.rawCache) root2.rawCache = {};
    if (typeof root2.rawCache[detect] !== "undefined") {
      return root2.rawCache[detect];
    }
    if (detect === "before" || detect === "after") {
      return this.beforeAfter(node2, detect);
    } else {
      let method = "raw" + capitalize(detect);
      if (this[method]) {
        value = this[method](root2, node2);
      } else {
        root2.walk((i2) => {
          value = i2.raws[own];
          if (typeof value !== "undefined") return false;
        });
      }
    }
    if (typeof value === "undefined") value = DEFAULT_RAW[detect];
    root2.rawCache[detect] = value;
    return value;
  }
  rawBeforeClose(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length > 0) {
        if (typeof i2.raws.after !== "undefined") {
          value = i2.raws.after;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawBeforeComment(root2, node2) {
    let value;
    root2.walkComments((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeDecl");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeDecl(root2, node2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.before !== "undefined") {
        value = i2.raws.before;
        if (value.includes("\n")) {
          value = value.replace(/[^\n]+$/, "");
        }
        return false;
      }
    });
    if (typeof value === "undefined") {
      value = this.raw(node2, null, "beforeRule");
    } else if (value) {
      value = value.replace(/\S/g, "");
    }
    return value;
  }
  rawBeforeOpen(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.type !== "decl") {
        value = i2.raws.between;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawBeforeRule(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
        if (typeof i2.raws.before !== "undefined") {
          value = i2.raws.before;
          if (value.includes("\n")) {
            value = value.replace(/[^\n]+$/, "");
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, "");
    return value;
  }
  rawColon(root2) {
    let value;
    root2.walkDecls((i2) => {
      if (typeof i2.raws.between !== "undefined") {
        value = i2.raws.between.replace(/[^\s:]/g, "");
        return false;
      }
    });
    return value;
  }
  rawEmptyBody(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length === 0) {
        value = i2.raws.after;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawIndent(root2) {
    if (root2.raws.indent) return root2.raws.indent;
    let value;
    root2.walk((i2) => {
      let p = i2.parent;
      if (p && p !== root2 && p.parent && p.parent === root2) {
        if (typeof i2.raws.before !== "undefined") {
          let parts = i2.raws.before.split("\n");
          value = parts[parts.length - 1];
          value = value.replace(/\S/g, "");
          return false;
        }
      }
    });
    return value;
  }
  rawSemicolon(root2) {
    let value;
    root2.walk((i2) => {
      if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
        value = i2.raws.semicolon;
        if (typeof value !== "undefined") return false;
      }
    });
    return value;
  }
  rawValue(node2, prop) {
    let value = node2[prop];
    let raw = node2.raws[prop];
    if (raw && raw.value === value) {
      return raw.raw;
    }
    return value;
  }
  root(node2) {
    this.body(node2);
    if (node2.raws.after) this.builder(node2.raws.after);
  }
  rule(node2) {
    this.block(node2, this.rawValue(node2, "selector"));
    if (node2.raws.ownSemicolon) {
      this.builder(node2.raws.ownSemicolon, node2, "end");
    }
  }
  stringify(node2, semicolon) {
    if (!this[node2.type]) {
      throw new Error(
        "Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier."
      );
    }
    this[node2.type](node2, semicolon);
  }
};
var stringifier = Stringifier$2;
Stringifier$2.default = Stringifier$2;
let Stringifier$1 = stringifier;
function stringify$4(node2, builder2) {
  let str = new Stringifier$1(builder2);
  str.stringify(node2);
}
var stringify_1 = stringify$4;
stringify$4.default = stringify$4;
var symbols = {};
symbols.isClean = Symbol("isClean");
symbols.my = Symbol("my");
let CssSyntaxError$2 = cssSyntaxError;
let Stringifier = stringifier;
let stringify$3 = stringify_1;
let { isClean: isClean$2, my: my$2 } = symbols;
function cloneNode(obj, parent) {
  let cloned = new obj.constructor();
  for (let i2 in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
      continue;
    }
    if (i2 === "proxyCache") continue;
    let value = obj[i2];
    let type = typeof value;
    if (i2 === "parent" && type === "object") {
      if (parent) cloned[i2] = parent;
    } else if (i2 === "source") {
      cloned[i2] = value;
    } else if (Array.isArray(value)) {
      cloned[i2] = value.map((j) => cloneNode(j, cloned));
    } else {
      if (type === "object" && value !== null) value = cloneNode(value);
      cloned[i2] = value;
    }
  }
  return cloned;
}
function sourceOffset(inputCSS, position) {
  if (position && typeof position.offset !== "undefined") {
    return position.offset;
  }
  let column = 1;
  let line = 1;
  let offset = 0;
  for (let i2 = 0; i2 < inputCSS.length; i2++) {
    if (line === position.line && column === position.column) {
      offset = i2;
      break;
    }
    if (inputCSS[i2] === "\n") {
      column = 1;
      line += 1;
    } else {
      column += 1;
    }
  }
  return offset;
}
let Node$5 = class Node2 {
  constructor(defaults = {}) {
    this.raws = {};
    this[isClean$2] = false;
    this[my$2] = true;
    for (let name2 in defaults) {
      if (name2 === "nodes") {
        this.nodes = [];
        for (let node2 of defaults[name2]) {
          if (typeof node2.clone === "function") {
            this.append(node2.clone());
          } else {
            this.append(node2);
          }
        }
      } else {
        this[name2] = defaults[name2];
      }
    }
  }
  addToError(error) {
    error.postcssNode = this;
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s = this.source;
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
      );
    }
    return error;
  }
  after(add) {
    this.parent.insertAfter(this, add);
    return this;
  }
  assign(overrides = {}) {
    for (let name2 in overrides) {
      this[name2] = overrides[name2];
    }
    return this;
  }
  before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  }
  clone(overrides = {}) {
    let cloned = cloneNode(this);
    for (let name2 in overrides) {
      cloned[name2] = overrides[name2];
    }
    return cloned;
  }
  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts);
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      );
    }
    return new CssSyntaxError$2(message);
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
        prop === "text") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  /* c8 ignore next 3 */
  markClean() {
    this[isClean$2] = true;
  }
  markDirty() {
    if (this[isClean$2]) {
      this[isClean$2] = false;
      let next = this;
      while (next = next.parent) {
        next[isClean$2] = false;
      }
    }
  }
  next() {
    if (!this.parent) return void 0;
    let index = this.parent.index(this);
    return this.parent.nodes[index + 1];
  }
  positionBy(opts) {
    let pos = this.source.start;
    if (opts.index) {
      pos = this.positionInside(opts.index);
    } else if (opts.word) {
      let stringRepresentation = this.source.input.css.slice(
        sourceOffset(this.source.input.css, this.source.start),
        sourceOffset(this.source.input.css, this.source.end)
      );
      let index = stringRepresentation.indexOf(opts.word);
      if (index !== -1) pos = this.positionInside(index);
    }
    return pos;
  }
  positionInside(index) {
    let column = this.source.start.column;
    let line = this.source.start.line;
    let offset = sourceOffset(this.source.input.css, this.source.start);
    let end = offset + index;
    for (let i2 = offset; i2 < end; i2++) {
      if (this.source.input.css[i2] === "\n") {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }
    return { column, line };
  }
  prev() {
    if (!this.parent) return void 0;
    let index = this.parent.index(this);
    return this.parent.nodes[index - 1];
  }
  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    };
    let end = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: start.column + 1,
      line: start.line
    };
    if (opts.word) {
      let stringRepresentation = this.source.input.css.slice(
        sourceOffset(this.source.input.css, this.source.start),
        sourceOffset(this.source.input.css, this.source.end)
      );
      let index = stringRepresentation.indexOf(opts.word);
      if (index !== -1) {
        start = this.positionInside(index);
        end = this.positionInside(
          index + opts.word.length
        );
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        };
      } else if (opts.index) {
        start = this.positionInside(opts.index);
      }
      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        };
      } else if (typeof opts.endIndex === "number") {
        end = this.positionInside(opts.endIndex);
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1);
      }
    }
    if (end.line < start.line || end.line === start.line && end.column <= start.column) {
      end = { column: start.column + 1, line: start.line };
    }
    return { end, start };
  }
  raw(prop, defaultType) {
    let str = new Stringifier();
    return str.raw(this, prop, defaultType);
  }
  remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.parent = void 0;
    return this;
  }
  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this;
      let foundSelf = false;
      for (let node2 of nodes) {
        if (node2 === this) {
          foundSelf = true;
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node2);
          bookmark = node2;
        } else {
          this.parent.insertBefore(bookmark, node2);
        }
      }
      if (!foundSelf) {
        this.remove();
      }
    }
    return this;
  }
  root() {
    let result2 = this;
    while (result2.parent && result2.parent.type !== "document") {
      result2 = result2.parent;
    }
    return result2;
  }
  toJSON(_, inputs) {
    let fixed = {};
    let emitInputs = inputs == null;
    inputs = inputs || /* @__PURE__ */ new Map();
    let inputsNextIndex = 0;
    for (let name2 in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name2)) {
        continue;
      }
      if (name2 === "parent" || name2 === "proxyCache") continue;
      let value = this[name2];
      if (Array.isArray(value)) {
        fixed[name2] = value.map((i2) => {
          if (typeof i2 === "object" && i2.toJSON) {
            return i2.toJSON(null, inputs);
          } else {
            return i2;
          }
        });
      } else if (typeof value === "object" && value.toJSON) {
        fixed[name2] = value.toJSON(null, inputs);
      } else if (name2 === "source") {
        let inputId = inputs.get(value.input);
        if (inputId == null) {
          inputId = inputsNextIndex;
          inputs.set(value.input, inputsNextIndex);
          inputsNextIndex++;
        }
        fixed[name2] = {
          end: value.end,
          inputId,
          start: value.start
        };
      } else {
        fixed[name2] = value;
      }
    }
    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map((input2) => input2.toJSON());
    }
    return fixed;
  }
  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor());
    }
    return this.proxyCache;
  }
  toString(stringifier2 = stringify$3) {
    if (stringifier2.stringify) stringifier2 = stringifier2.stringify;
    let result2 = "";
    stringifier2(this, (i2) => {
      result2 += i2;
    });
    return result2;
  }
  warn(result2, text2, opts) {
    let data = { node: this };
    for (let i2 in opts) data[i2] = opts[i2];
    return result2.warn(text2, data);
  }
  get proxyOf() {
    return this;
  }
};
var node = Node$5;
Node$5.default = Node$5;
let Node$4 = node;
let Comment$4 = class Comment2 extends Node$4 {
  constructor(defaults) {
    super(defaults);
    this.type = "comment";
  }
};
var comment = Comment$4;
Comment$4.default = Comment$4;
let Node$3 = node;
let Declaration$4 = class Declaration2 extends Node$3 {
  constructor(defaults) {
    if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
      defaults = { ...defaults, value: String(defaults.value) };
    }
    super(defaults);
    this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var declaration = Declaration$4;
Declaration$4.default = Declaration$4;
let Comment$3 = comment;
let Declaration$3 = declaration;
let Node$2 = node;
let { isClean: isClean$1, my: my$1 } = symbols;
let AtRule$4, parse$4, Root$6, Rule$4;
function cleanSource(nodes) {
  return nodes.map((i2) => {
    if (i2.nodes) i2.nodes = cleanSource(i2.nodes);
    delete i2.source;
    return i2;
  });
}
function markTreeDirty(node2) {
  node2[isClean$1] = false;
  if (node2.proxyOf.nodes) {
    for (let i2 of node2.proxyOf.nodes) {
      markTreeDirty(i2);
    }
  }
}
let Container$7 = class Container2 extends Node$2 {
  append(...children2) {
    for (let child of children2) {
      let nodes = this.normalize(child, this.last);
      for (let node2 of nodes) this.proxyOf.nodes.push(node2);
    }
    this.markDirty();
    return this;
  }
  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween);
    if (this.nodes) {
      for (let node2 of this.nodes) node2.cleanRaws(keepBetween);
    }
  }
  each(callback) {
    if (!this.proxyOf.nodes) return void 0;
    let iterator = this.getIterator();
    let index, result2;
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index = this.indexes[iterator];
      result2 = callback(this.proxyOf.nodes[index], index);
      if (result2 === false) break;
      this.indexes[iterator] += 1;
    }
    delete this.indexes[iterator];
    return result2;
  }
  every(condition) {
    return this.nodes.every(condition);
  }
  getIterator() {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    let iterator = this.lastEach;
    this.indexes[iterator] = 0;
    return iterator;
  }
  getProxyProcessor() {
    return {
      get(node2, prop) {
        if (prop === "proxyOf") {
          return node2;
        } else if (!node2[prop]) {
          return node2[prop];
        } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
          return (...args) => {
            return node2[prop](
              ...args.map((i2) => {
                if (typeof i2 === "function") {
                  return (child, index) => i2(child.toProxy(), index);
                } else {
                  return i2;
                }
              })
            );
          };
        } else if (prop === "every" || prop === "some") {
          return (cb) => {
            return node2[prop](
              (child, ...other) => cb(child.toProxy(), ...other)
            );
          };
        } else if (prop === "root") {
          return () => node2.root().toProxy();
        } else if (prop === "nodes") {
          return node2.nodes.map((i2) => i2.toProxy());
        } else if (prop === "first" || prop === "last") {
          return node2[prop].toProxy();
        } else {
          return node2[prop];
        }
      },
      set(node2, prop, value) {
        if (node2[prop] === value) return true;
        node2[prop] = value;
        if (prop === "name" || prop === "params" || prop === "selector") {
          node2.markDirty();
        }
        return true;
      }
    };
  }
  index(child) {
    if (typeof child === "number") return child;
    if (child.proxyOf) child = child.proxyOf;
    return this.proxyOf.nodes.indexOf(child);
  }
  insertAfter(exist, add) {
    let existIndex = this.index(exist);
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node2);
    let index;
    for (let id in this.indexes) {
      index = this.indexes[id];
      if (existIndex < index) {
        this.indexes[id] = index + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  insertBefore(exist, add) {
    let existIndex = this.index(exist);
    let type = existIndex === 0 ? "prepend" : false;
    let nodes = this.normalize(
      add,
      this.proxyOf.nodes[existIndex],
      type
    ).reverse();
    existIndex = this.index(exist);
    for (let node2 of nodes) this.proxyOf.nodes.splice(existIndex, 0, node2);
    let index;
    for (let id in this.indexes) {
      index = this.indexes[id];
      if (existIndex <= index) {
        this.indexes[id] = index + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  normalize(nodes, sample) {
    if (typeof nodes === "string") {
      nodes = cleanSource(parse$4(nodes).nodes);
    } else if (typeof nodes === "undefined") {
      nodes = [];
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type === "root" && this.type !== "document") {
      nodes = nodes.nodes.slice(0);
      for (let i2 of nodes) {
        if (i2.parent) i2.parent.removeChild(i2, "ignore");
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === "undefined") {
        throw new Error("Value field is missed in node creation");
      } else if (typeof nodes.value !== "string") {
        nodes.value = String(nodes.value);
      }
      nodes = [new Declaration$3(nodes)];
    } else if (nodes.selector || nodes.selectors) {
      nodes = [new Rule$4(nodes)];
    } else if (nodes.name) {
      nodes = [new AtRule$4(nodes)];
    } else if (nodes.text) {
      nodes = [new Comment$3(nodes)];
    } else {
      throw new Error("Unknown node type in node creation");
    }
    let processed = nodes.map((i2) => {
      if (!i2[my$1]) Container2.rebuild(i2);
      i2 = i2.proxyOf;
      if (i2.parent) i2.parent.removeChild(i2);
      if (i2[isClean$1]) markTreeDirty(i2);
      if (!i2.raws) i2.raws = {};
      if (typeof i2.raws.before === "undefined") {
        if (sample && typeof sample.raws.before !== "undefined") {
          i2.raws.before = sample.raws.before.replace(/\S/g, "");
        }
      }
      i2.parent = this.proxyOf;
      return i2;
    });
    return processed;
  }
  prepend(...children2) {
    children2 = children2.reverse();
    for (let child of children2) {
      let nodes = this.normalize(child, this.first, "prepend").reverse();
      for (let node2 of nodes) this.proxyOf.nodes.unshift(node2);
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  push(child) {
    child.parent = this;
    this.proxyOf.nodes.push(child);
    return this;
  }
  removeAll() {
    for (let node2 of this.proxyOf.nodes) node2.parent = void 0;
    this.proxyOf.nodes = [];
    this.markDirty();
    return this;
  }
  removeChild(child) {
    child = this.index(child);
    this.proxyOf.nodes[child].parent = void 0;
    this.proxyOf.nodes.splice(child, 1);
    let index;
    for (let id in this.indexes) {
      index = this.indexes[id];
      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }
    this.markDirty();
    return this;
  }
  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }
    this.walkDecls((decl) => {
      if (opts.props && !opts.props.includes(decl.prop)) return;
      if (opts.fast && !decl.value.includes(opts.fast)) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    this.markDirty();
    return this;
  }
  some(condition) {
    return this.nodes.some(condition);
  }
  walk(callback) {
    return this.each((child, i2) => {
      let result2;
      try {
        result2 = callback(child, i2);
      } catch (e) {
        throw child.addToError(e);
      }
      if (result2 !== false && child.walk) {
        result2 = child.walk(callback);
      }
      return result2;
    });
  }
  walkAtRules(name2, callback) {
    if (!callback) {
      callback = name2;
      return this.walk((child, i2) => {
        if (child.type === "atrule") {
          return callback(child, i2);
        }
      });
    }
    if (name2 instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "atrule" && name2.test(child.name)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "atrule" && child.name === name2) {
        return callback(child, i2);
      }
    });
  }
  walkComments(callback) {
    return this.walk((child, i2) => {
      if (child.type === "comment") {
        return callback(child, i2);
      }
    });
  }
  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk((child, i2) => {
        if (child.type === "decl") {
          return callback(child, i2);
        }
      });
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "decl" && prop.test(child.prop)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "decl" && child.prop === prop) {
        return callback(child, i2);
      }
    });
  }
  walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk((child, i2) => {
        if (child.type === "rule") {
          return callback(child, i2);
        }
      });
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i2) => {
        if (child.type === "rule" && selector.test(child.selector)) {
          return callback(child, i2);
        }
      });
    }
    return this.walk((child, i2) => {
      if (child.type === "rule" && child.selector === selector) {
        return callback(child, i2);
      }
    });
  }
  get first() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[0];
  }
  get last() {
    if (!this.proxyOf.nodes) return void 0;
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Container$7.registerParse = (dependant) => {
  parse$4 = dependant;
};
Container$7.registerRule = (dependant) => {
  Rule$4 = dependant;
};
Container$7.registerAtRule = (dependant) => {
  AtRule$4 = dependant;
};
Container$7.registerRoot = (dependant) => {
  Root$6 = dependant;
};
var container = Container$7;
Container$7.default = Container$7;
Container$7.rebuild = (node2) => {
  if (node2.type === "atrule") {
    Object.setPrototypeOf(node2, AtRule$4.prototype);
  } else if (node2.type === "rule") {
    Object.setPrototypeOf(node2, Rule$4.prototype);
  } else if (node2.type === "decl") {
    Object.setPrototypeOf(node2, Declaration$3.prototype);
  } else if (node2.type === "comment") {
    Object.setPrototypeOf(node2, Comment$3.prototype);
  } else if (node2.type === "root") {
    Object.setPrototypeOf(node2, Root$6.prototype);
  }
  node2[my$1] = true;
  if (node2.nodes) {
    node2.nodes.forEach((child) => {
      Container$7.rebuild(child);
    });
  }
};
let Container$6 = container;
let AtRule$3 = class AtRule2 extends Container$6 {
  constructor(defaults) {
    super(defaults);
    this.type = "atrule";
  }
  append(...children2) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.append(...children2);
  }
  prepend(...children2) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.prepend(...children2);
  }
};
var atRule = AtRule$3;
AtRule$3.default = AtRule$3;
Container$6.registerAtRule(AtRule$3);
let Container$5 = container;
let LazyResult$4, Processor$3;
let Document$4 = class Document2 extends Container$5 {
  constructor(defaults) {
    super({ type: "document", ...defaults });
    if (!this.nodes) {
      this.nodes = [];
    }
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$4(new Processor$3(), this, opts);
    return lazy.stringify();
  }
};
Document$4.registerLazyResult = (dependant) => {
  LazyResult$4 = dependant;
};
Document$4.registerProcessor = (dependant) => {
  Processor$3 = dependant;
};
var document$1 = Document$4;
Document$4.default = Document$4;
let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size2 = defaultSize) => {
    let id = "";
    let i2 = size2;
    while (i2--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
let nanoid$1 = (size2 = 21) => {
  let id = "";
  let i2 = size2;
  while (i2--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var nonSecure = { nanoid: nanoid$1, customAlphabet };
let { existsSync, readFileSync } = require$$2;
let { dirname: dirname$1, join } = require$$2;
let { SourceMapConsumer: SourceMapConsumer$2, SourceMapGenerator: SourceMapGenerator$2 } = require$$2;
function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, "base64").toString();
  } else {
    return window.atob(str);
  }
}
let PreviousMap$2 = class PreviousMap2 {
  constructor(css2, opts) {
    if (opts.map === false) return;
    this.loadAnnotation(css2);
    this.inline = this.startWith(this.annotation, "data:");
    let prev = opts.map ? opts.map.prev : void 0;
    let text2 = this.loadMap(opts.from, prev);
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from;
    }
    if (this.mapFile) this.root = dirname$1(this.mapFile);
    if (text2) this.text = text2;
  }
  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer$2(this.text);
    }
    return this.consumerCache;
  }
  decodeInline(text2) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    let baseUri = /^data:application\/json;base64,/;
    let charsetUri = /^data:application\/json;charset=utf-?8,/;
    let uri = /^data:application\/json,/;
    let uriMatch = text2.match(charsetUri) || text2.match(uri);
    if (uriMatch) {
      return decodeURIComponent(text2.substr(uriMatch[0].length));
    }
    let baseUriMatch = text2.match(baseCharsetUri) || text2.match(baseUri);
    if (baseUriMatch) {
      return fromBase64(text2.substr(baseUriMatch[0].length));
    }
    let encoding = text2.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + encoding);
  }
  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(map2) {
    if (typeof map2 !== "object") return false;
    return typeof map2.mappings === "string" || typeof map2._mappings === "string" || Array.isArray(map2.sections);
  }
  loadAnnotation(css2) {
    let comments = css2.match(/\/\*\s*# sourceMappingURL=/g);
    if (!comments) return;
    let start = css2.lastIndexOf(comments.pop());
    let end = css2.indexOf("*/", start);
    if (start > -1 && end > -1) {
      this.annotation = this.getAnnotationURL(css2.substring(start, end));
    }
  }
  loadFile(path2) {
    this.root = dirname$1(path2);
    if (existsSync(path2)) {
      this.mapFile = path2;
      return readFileSync(path2, "utf-8").toString().trim();
    }
  }
  loadMap(file, prev) {
    if (prev === false) return false;
    if (prev) {
      if (typeof prev === "string") {
        return prev;
      } else if (typeof prev === "function") {
        let prevPath = prev(file);
        if (prevPath) {
          let map2 = this.loadFile(prevPath);
          if (!map2) {
            throw new Error(
              "Unable to load previous source map: " + prevPath.toString()
            );
          }
          return map2;
        }
      } else if (prev instanceof SourceMapConsumer$2) {
        return SourceMapGenerator$2.fromSourceMap(prev).toString();
      } else if (prev instanceof SourceMapGenerator$2) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error(
          "Unsupported previous source map format: " + prev.toString()
        );
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      let map2 = this.annotation;
      if (file) map2 = join(dirname$1(file), map2);
      return this.loadFile(map2);
    }
  }
  startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var previousMap = PreviousMap$2;
PreviousMap$2.default = PreviousMap$2;
let { nanoid } = nonSecure;
let { isAbsolute, resolve: resolve$1 } = require$$2;
let { SourceMapConsumer: SourceMapConsumer$1, SourceMapGenerator: SourceMapGenerator$1 } = require$$2;
let { fileURLToPath, pathToFileURL: pathToFileURL$1 } = require$$2;
let CssSyntaxError$1 = cssSyntaxError;
let PreviousMap$1 = previousMap;
let terminalHighlight = require$$2;
let fromOffsetCache = Symbol("fromOffsetCache");
let sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);
let pathAvailable$1 = Boolean(resolve$1 && isAbsolute);
let Input$4 = class Input2 {
  constructor(css2, opts = {}) {
    if (css2 === null || typeof css2 === "undefined" || typeof css2 === "object" && !css2.toString) {
      throw new Error(`PostCSS received ${css2} instead of CSS string`);
    }
    this.css = css2.toString();
    if (this.css[0] === "\uFEFF" || this.css[0] === "") {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }
    if (opts.from) {
      if (!pathAvailable$1 || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
        this.file = opts.from;
      } else {
        this.file = resolve$1(opts.from);
      }
    }
    if (pathAvailable$1 && sourceMapAvailable$1) {
      let map2 = new PreviousMap$1(this.css, opts);
      if (map2.text) {
        this.map = map2;
        let file = map2.consumer().file;
        if (!this.file && file) this.file = this.mapResolve(file);
      }
    }
    if (!this.file) {
      this.id = "<input css " + nanoid(6) + ">";
    }
    if (this.map) this.map.file = this.from;
  }
  error(message, line, column, opts = {}) {
    let endColumn, endLine, result2;
    if (line && typeof line === "object") {
      let start = line;
      let end = column;
      if (typeof start.offset === "number") {
        let pos = this.fromOffset(start.offset);
        line = pos.line;
        column = pos.col;
      } else {
        line = start.line;
        column = start.column;
      }
      if (typeof end.offset === "number") {
        let pos = this.fromOffset(end.offset);
        endLine = pos.line;
        endColumn = pos.col;
      } else {
        endLine = end.line;
        endColumn = end.column;
      }
    } else if (!column) {
      let pos = this.fromOffset(line);
      line = pos.line;
      column = pos.col;
    }
    let origin = this.origin(line, column, endLine, endColumn);
    if (origin) {
      result2 = new CssSyntaxError$1(
        message,
        origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
        origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      );
    } else {
      result2 = new CssSyntaxError$1(
        message,
        endLine === void 0 ? line : { column, line },
        endLine === void 0 ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      );
    }
    result2.input = { column, endColumn, endLine, line, source: this.css };
    if (this.file) {
      if (pathToFileURL$1) {
        result2.input.url = pathToFileURL$1(this.file).toString();
      }
      result2.input.file = this.file;
    }
    return result2;
  }
  fromOffset(offset) {
    let lastLine, lineToIndex;
    if (!this[fromOffsetCache]) {
      let lines = this.css.split("\n");
      lineToIndex = new Array(lines.length);
      let prevIndex = 0;
      for (let i2 = 0, l = lines.length; i2 < l; i2++) {
        lineToIndex[i2] = prevIndex;
        prevIndex += lines[i2].length + 1;
      }
      this[fromOffsetCache] = lineToIndex;
    } else {
      lineToIndex = this[fromOffsetCache];
    }
    lastLine = lineToIndex[lineToIndex.length - 1];
    let min2 = 0;
    if (offset >= lastLine) {
      min2 = lineToIndex.length - 1;
    } else {
      let max2 = lineToIndex.length - 2;
      let mid;
      while (min2 < max2) {
        mid = min2 + (max2 - min2 >> 1);
        if (offset < lineToIndex[mid]) {
          max2 = mid - 1;
        } else if (offset >= lineToIndex[mid + 1]) {
          min2 = mid + 1;
        } else {
          min2 = mid;
          break;
        }
      }
    }
    return {
      col: offset - lineToIndex[min2] + 1,
      line: min2 + 1
    };
  }
  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }
    return resolve$1(this.map.consumer().sourceRoot || this.map.root || ".", file);
  }
  origin(line, column, endLine, endColumn) {
    if (!this.map) return false;
    let consumer = this.map.consumer();
    let from2 = consumer.originalPositionFor({ column, line });
    if (!from2.source) return false;
    let to;
    if (typeof endLine === "number") {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine });
    }
    let fromUrl;
    if (isAbsolute(from2.source)) {
      fromUrl = pathToFileURL$1(from2.source);
    } else {
      fromUrl = new URL(
        from2.source,
        this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile)
      );
    }
    let result2 = {
      column: from2.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from2.line,
      url: fromUrl.toString()
    };
    if (fromUrl.protocol === "file:") {
      if (fileURLToPath) {
        result2.file = fileURLToPath(fromUrl);
      } else {
        throw new Error(`file: protocol is not available in this PostCSS build`);
      }
    }
    let source = consumer.sourceContentFor(from2.source);
    if (source) result2.source = source;
    return result2;
  }
  toJSON() {
    let json = {};
    for (let name2 of ["hasBOM", "css", "file", "id"]) {
      if (this[name2] != null) {
        json[name2] = this[name2];
      }
    }
    if (this.map) {
      json.map = { ...this.map };
      if (json.map.consumerCache) {
        json.map.consumerCache = void 0;
      }
    }
    return json;
  }
  get from() {
    return this.file || this.id;
  }
};
var input = Input$4;
Input$4.default = Input$4;
if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input$4);
}
let Container$4 = container;
let LazyResult$3, Processor$2;
let Root$5 = class Root2 extends Container$4 {
  constructor(defaults) {
    super(defaults);
    this.type = "root";
    if (!this.nodes) this.nodes = [];
  }
  normalize(child, sample, type) {
    let nodes = super.normalize(child);
    if (sample) {
      if (type === "prepend") {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (let node2 of nodes) {
          node2.raws.before = sample.raws.before;
        }
      }
    }
    return nodes;
  }
  removeChild(child, ignore2) {
    let index = this.index(child);
    if (!ignore2 && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before;
    }
    return super.removeChild(child);
  }
  toResult(opts = {}) {
    let lazy = new LazyResult$3(new Processor$2(), this, opts);
    return lazy.stringify();
  }
};
Root$5.registerLazyResult = (dependant) => {
  LazyResult$3 = dependant;
};
Root$5.registerProcessor = (dependant) => {
  Processor$2 = dependant;
};
var root$1 = Root$5;
Root$5.default = Root$5;
Container$4.registerRoot(Root$5);
let list$2 = {
  comma(string) {
    return list$2.split(string, [","], true);
  },
  space(string) {
    let spaces = [" ", "\n", "	"];
    return list$2.split(string, spaces);
  },
  split(string, separators, last2) {
    let array = [];
    let current = "";
    let split = false;
    let func = 0;
    let inQuote = false;
    let prevQuote = "";
    let escape2 = false;
    for (let letter of string) {
      if (escape2) {
        escape2 = false;
      } else if (letter === "\\") {
        escape2 = true;
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false;
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true;
        prevQuote = letter;
      } else if (letter === "(") {
        func += 1;
      } else if (letter === ")") {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.includes(letter)) split = true;
      }
      if (split) {
        if (current !== "") array.push(current.trim());
        current = "";
        split = false;
      } else {
        current += letter;
      }
    }
    if (last2 || current !== "") array.push(current.trim());
    return array;
  }
};
var list_1 = list$2;
list$2.default = list$2;
let Container$3 = container;
let list$1 = list_1;
let Rule$3 = class Rule3 extends Container$3 {
  constructor(defaults) {
    super(defaults);
    this.type = "rule";
    if (!this.nodes) this.nodes = [];
  }
  get selectors() {
    return list$1.comma(this.selector);
  }
  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null;
    let sep2 = match ? match[0] : "," + this.raw("between", "beforeOpen");
    this.selector = values.join(sep2);
  }
};
var rule = Rule$3;
Rule$3.default = Rule$3;
Container$3.registerRule(Rule$3);
let AtRule$2 = atRule;
let Comment$2 = comment;
let Declaration$2 = declaration;
let Input$3 = input;
let PreviousMap = previousMap;
let Root$4 = root$1;
let Rule$2 = rule;
function fromJSON$1(json, inputs) {
  if (Array.isArray(json)) return json.map((n) => fromJSON$1(n));
  let { inputs: ownInputs, ...defaults } = json;
  if (ownInputs) {
    inputs = [];
    for (let input2 of ownInputs) {
      let inputHydrated = { ...input2, __proto__: Input$3.prototype };
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap.prototype
        };
      }
      inputs.push(inputHydrated);
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map((n) => fromJSON$1(n, inputs));
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source;
    defaults.source = source;
    if (inputId != null) {
      defaults.source.input = inputs[inputId];
    }
  }
  if (defaults.type === "root") {
    return new Root$4(defaults);
  } else if (defaults.type === "decl") {
    return new Declaration$2(defaults);
  } else if (defaults.type === "rule") {
    return new Rule$2(defaults);
  } else if (defaults.type === "comment") {
    return new Comment$2(defaults);
  } else if (defaults.type === "atrule") {
    return new AtRule$2(defaults);
  } else {
    throw new Error("Unknown node type: " + json.type);
  }
}
var fromJSON_1 = fromJSON$1;
fromJSON$1.default = fromJSON$1;
let { dirname, relative, resolve, sep } = require$$2;
let { SourceMapConsumer, SourceMapGenerator } = require$$2;
let { pathToFileURL } = require$$2;
let Input$2 = input;
let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
let pathAvailable = Boolean(dirname && resolve && relative && sep);
let MapGenerator$2 = class MapGenerator2 {
  constructor(stringify2, root2, opts, cssString) {
    this.stringify = stringify2;
    this.mapOpts = opts.map || {};
    this.root = root2;
    this.opts = opts;
    this.css = cssString;
    this.originalCSS = cssString;
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    this.memoizedFileURLs = /* @__PURE__ */ new Map();
    this.memoizedPaths = /* @__PURE__ */ new Map();
    this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let content;
    if (this.isInline()) {
      content = "data:application/json;base64," + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === "string") {
      content = this.mapOpts.annotation;
    } else if (typeof this.mapOpts.annotation === "function") {
      content = this.mapOpts.annotation(this.opts.to, this.root);
    } else {
      content = this.outputFile() + ".map";
    }
    let eol = "\n";
    if (this.css.includes("\r\n")) eol = "\r\n";
    this.css += eol + "/*# sourceMappingURL=" + content + " */";
  }
  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from2 = this.toUrl(this.path(prev.file));
      let root2 = prev.root || dirname(prev.file);
      let map2;
      if (this.mapOpts.sourcesContent === false) {
        map2 = new SourceMapConsumer(prev.text);
        if (map2.sourcesContent) {
          map2.sourcesContent = null;
        }
      } else {
        map2 = prev.consumer();
      }
      this.map.applySourceMap(map2, from2, this.toUrl(this.path(root2)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    if (this.root) {
      let node2;
      for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
        node2 = this.root.nodes[i2];
        if (node2.type !== "comment") continue;
        if (node2.text.startsWith("# sourceMappingURL=")) {
          this.root.removeChild(i2);
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, "");
    }
  }
  generate() {
    this.clearAnnotation();
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap();
    } else {
      let result2 = "";
      this.stringify(this.root, (i2) => {
        result2 += i2;
      });
      return [result2];
    }
  }
  generateMap() {
    if (this.root) {
      this.generateString();
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer();
      prev.file = this.outputFile();
      this.map = SourceMapGenerator.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      });
    } else {
      this.map = new SourceMapGenerator({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    }
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.root && this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();
    if (this.isInline()) {
      return [this.css];
    } else {
      return [this.css, this.map];
    }
  }
  generateString() {
    this.css = "";
    this.map = new SourceMapGenerator({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    });
    let line = 1;
    let column = 1;
    let noSource = "<no source>";
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    };
    let last2, lines;
    this.stringify(this.root, (str, node2, type) => {
      this.css += str;
      if (node2 && type !== "end") {
        mapping.generated.line = line;
        mapping.generated.column = column - 1;
        if (node2.source && node2.source.start) {
          mapping.source = this.sourcePath(node2);
          mapping.original.line = node2.source.start.line;
          mapping.original.column = node2.source.start.column - 1;
          this.map.addMapping(mapping);
        } else {
          mapping.source = noSource;
          mapping.original.line = 1;
          mapping.original.column = 0;
          this.map.addMapping(mapping);
        }
      }
      lines = str.match(/\n/g);
      if (lines) {
        line += lines.length;
        last2 = str.lastIndexOf("\n");
        column = str.length - last2;
      } else {
        column += str.length;
      }
      if (node2 && type !== "start") {
        let p = node2.parent || { raws: {} };
        let childless = node2.type === "decl" || node2.type === "atrule" && !node2.nodes;
        if (!childless || node2 !== p.last || p.raws.semicolon) {
          if (node2.source && node2.source.end) {
            mapping.source = this.sourcePath(node2);
            mapping.original.line = node2.source.end.line;
            mapping.original.column = node2.source.end.column - 1;
            mapping.generated.line = line;
            mapping.generated.column = column - 2;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            this.map.addMapping(mapping);
          }
        }
      }
    });
  }
  isAnnotation() {
    if (this.isInline()) {
      return true;
    }
    if (typeof this.mapOpts.annotation !== "undefined") {
      return this.mapOpts.annotation;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.annotation);
    }
    return true;
  }
  isInline() {
    if (typeof this.mapOpts.inline !== "undefined") {
      return this.mapOpts.inline;
    }
    let annotation = this.mapOpts.annotation;
    if (typeof annotation !== "undefined" && annotation !== true) {
      return false;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.inline);
    }
    return true;
  }
  isMap() {
    if (typeof this.opts.map !== "undefined") {
      return !!this.opts.map;
    }
    return this.previous().length > 0;
  }
  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== "undefined") {
      return this.mapOpts.sourcesContent;
    }
    if (this.previous().length) {
      return this.previous().some((i2) => i2.withContent());
    }
    return true;
  }
  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to);
    } else if (this.opts.from) {
      return this.path(this.opts.from);
    } else {
      return "to.css";
    }
  }
  path(file) {
    if (this.mapOpts.absolute) return file;
    if (file.charCodeAt(0) === 60) return file;
    if (/^\w+:\/\//.test(file)) return file;
    let cached = this.memoizedPaths.get(file);
    if (cached) return cached;
    let from2 = this.opts.to ? dirname(this.opts.to) : ".";
    if (typeof this.mapOpts.annotation === "string") {
      from2 = dirname(resolve(from2, this.mapOpts.annotation));
    }
    let path2 = relative(from2, file);
    this.memoizedPaths.set(file, path2);
    return path2;
  }
  previous() {
    if (!this.previousMaps) {
      this.previousMaps = [];
      if (this.root) {
        this.root.walk((node2) => {
          if (node2.source && node2.source.input.map) {
            let map2 = node2.source.input.map;
            if (!this.previousMaps.includes(map2)) {
              this.previousMaps.push(map2);
            }
          }
        });
      } else {
        let input2 = new Input$2(this.originalCSS, this.opts);
        if (input2.map) this.previousMaps.push(input2.map);
      }
    }
    return this.previousMaps;
  }
  setSourcesContent() {
    let already = {};
    if (this.root) {
      this.root.walk((node2) => {
        if (node2.source) {
          let from2 = node2.source.input.from;
          if (from2 && !already[from2]) {
            already[from2] = true;
            let fromUrl = this.usesFileUrls ? this.toFileUrl(from2) : this.toUrl(this.path(from2));
            this.map.setSourceContent(fromUrl, node2.source.input.css);
          }
        }
      });
    } else if (this.css) {
      let from2 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(from2, this.css);
    }
  }
  sourcePath(node2) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from);
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node2.source.input.from);
    } else {
      return this.toUrl(this.path(node2.source.input.from));
    }
  }
  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString("base64");
    } else {
      return window.btoa(unescape(encodeURIComponent(str)));
    }
  }
  toFileUrl(path2) {
    let cached = this.memoizedFileURLs.get(path2);
    if (cached) return cached;
    if (pathToFileURL) {
      let fileURL = pathToFileURL(path2).toString();
      this.memoizedFileURLs.set(path2, fileURL);
      return fileURL;
    } else {
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
    }
  }
  toUrl(path2) {
    let cached = this.memoizedURLs.get(path2);
    if (cached) return cached;
    if (sep === "\\") {
      path2 = path2.replace(/\\/g, "/");
    }
    let url2 = encodeURI(path2).replace(/[#?]/g, encodeURIComponent);
    this.memoizedURLs.set(path2, url2);
    return url2;
  }
};
var mapGenerator = MapGenerator$2;
const SINGLE_QUOTE = "'".charCodeAt(0);
const DOUBLE_QUOTE = '"'.charCodeAt(0);
const BACKSLASH = "\\".charCodeAt(0);
const SLASH = "/".charCodeAt(0);
const NEWLINE = "\n".charCodeAt(0);
const SPACE = " ".charCodeAt(0);
const FEED = "\f".charCodeAt(0);
const TAB = "	".charCodeAt(0);
const CR = "\r".charCodeAt(0);
const OPEN_SQUARE = "[".charCodeAt(0);
const CLOSE_SQUARE = "]".charCodeAt(0);
const OPEN_PARENTHESES = "(".charCodeAt(0);
const CLOSE_PARENTHESES = ")".charCodeAt(0);
const OPEN_CURLY = "{".charCodeAt(0);
const CLOSE_CURLY = "}".charCodeAt(0);
const SEMICOLON = ";".charCodeAt(0);
const ASTERISK = "*".charCodeAt(0);
const COLON = ":".charCodeAt(0);
const AT = "@".charCodeAt(0);
const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
const RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
const RE_HEX_ESCAPE = /[\da-f]/i;
var tokenize = function tokenizer2(input2, options = {}) {
  let css2 = input2.css.valueOf();
  let ignore2 = options.ignoreErrors;
  let code2, content, escape2, next, quote;
  let currentToken, escaped, escapePos, n, prev;
  let length2 = css2.length;
  let pos = 0;
  let buffer = [];
  let returned = [];
  function position() {
    return pos;
  }
  function unclosed(what) {
    throw input2.error("Unclosed " + what, pos);
  }
  function endOfFile() {
    return returned.length === 0 && pos >= length2;
  }
  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length2) return;
    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code2 = css2.charCodeAt(pos);
    switch (code2) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos;
        do {
          next += 1;
          code2 = css2.charCodeAt(next);
        } while (code2 === SPACE || code2 === NEWLINE || code2 === TAB || code2 === CR || code2 === FEED);
        currentToken = ["space", css2.slice(pos, next)];
        pos = next - 1;
        break;
      }
      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code2);
        currentToken = [controlChar, controlChar, pos];
        break;
      }
      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : "";
        n = css2.charCodeAt(pos + 1);
        if (prev === "url" && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
          next = pos;
          do {
            escaped = false;
            next = css2.indexOf(")", next + 1);
            if (next === -1) {
              if (ignore2 || ignoreUnclosed) {
                next = pos;
                break;
              } else {
                unclosed("bracket");
              }
            }
            escapePos = next;
            while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ["brackets", css2.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          next = css2.indexOf(")", pos + 1);
          content = css2.slice(pos, next + 1);
          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ["(", "(", pos];
          } else {
            currentToken = ["brackets", content, pos, next];
            pos = next;
          }
        }
        break;
      }
      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code2 === SINGLE_QUOTE ? "'" : '"';
        next = pos;
        do {
          escaped = false;
          next = css2.indexOf(quote, next + 1);
          if (next === -1) {
            if (ignore2 || ignoreUnclosed) {
              next = pos + 1;
              break;
            } else {
              unclosed("string");
            }
          }
          escapePos = next;
          while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);
        currentToken = ["string", css2.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case AT: {
        RE_AT_END.lastIndex = pos + 1;
        RE_AT_END.test(css2);
        if (RE_AT_END.lastIndex === 0) {
          next = css2.length - 1;
        } else {
          next = RE_AT_END.lastIndex - 2;
        }
        currentToken = ["at-word", css2.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      case BACKSLASH: {
        next = pos;
        escape2 = true;
        while (css2.charCodeAt(next + 1) === BACKSLASH) {
          next += 1;
          escape2 = !escape2;
        }
        code2 = css2.charCodeAt(next + 1);
        if (escape2 && code2 !== SLASH && code2 !== SPACE && code2 !== NEWLINE && code2 !== TAB && code2 !== CR && code2 !== FEED) {
          next += 1;
          if (RE_HEX_ESCAPE.test(css2.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css2.charAt(next + 1))) {
              next += 1;
            }
            if (css2.charCodeAt(next + 1) === SPACE) {
              next += 1;
            }
          }
        }
        currentToken = ["word", css2.slice(pos, next + 1), pos, next];
        pos = next;
        break;
      }
      default: {
        if (code2 === SLASH && css2.charCodeAt(pos + 1) === ASTERISK) {
          next = css2.indexOf("*/", pos + 2) + 1;
          if (next === 0) {
            if (ignore2 || ignoreUnclosed) {
              next = css2.length;
            } else {
              unclosed("comment");
            }
          }
          currentToken = ["comment", css2.slice(pos, next + 1), pos, next];
          pos = next;
        } else {
          RE_WORD_END.lastIndex = pos + 1;
          RE_WORD_END.test(css2);
          if (RE_WORD_END.lastIndex === 0) {
            next = css2.length - 1;
          } else {
            next = RE_WORD_END.lastIndex - 2;
          }
          currentToken = ["word", css2.slice(pos, next + 1), pos, next];
          buffer.push(currentToken);
          pos = next;
        }
        break;
      }
    }
    pos++;
    return currentToken;
  }
  function back(token) {
    returned.push(token);
  }
  return {
    back,
    endOfFile,
    nextToken,
    position
  };
};
let AtRule$1 = atRule;
let Comment$1 = comment;
let Declaration$1 = declaration;
let Root$3 = root$1;
let Rule$1 = rule;
let tokenizer = tokenize;
const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
};
function findLastWithPosition(tokens2) {
  for (let i2 = tokens2.length - 1; i2 >= 0; i2--) {
    let token = tokens2[i2];
    let pos = token[3] || token[2];
    if (pos) return pos;
  }
}
let Parser$1 = class Parser2 {
  constructor(input2) {
    this.input = input2;
    this.root = new Root$3();
    this.current = this.root;
    this.spaces = "";
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = { input: input2, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(token) {
    let node2 = new AtRule$1();
    node2.name = token[1].slice(1);
    if (node2.name === "") {
      this.unnamedAtrule(node2, token);
    }
    this.init(node2, token[2]);
    let type;
    let prev;
    let shift2;
    let last2 = false;
    let open = false;
    let params2 = [];
    let brackets = [];
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      type = token[0];
      if (type === "(" || type === "[") {
        brackets.push(type === "(" ? ")" : "]");
      } else if (type === "{" && brackets.length > 0) {
        brackets.push("}");
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
      }
      if (brackets.length === 0) {
        if (type === ";") {
          node2.source.end = this.getPosition(token[2]);
          node2.source.end.offset++;
          this.semicolon = true;
          break;
        } else if (type === "{") {
          open = true;
          break;
        } else if (type === "}") {
          if (params2.length > 0) {
            shift2 = params2.length - 1;
            prev = params2[shift2];
            while (prev && prev[0] === "space") {
              prev = params2[--shift2];
            }
            if (prev) {
              node2.source.end = this.getPosition(prev[3] || prev[2]);
              node2.source.end.offset++;
            }
          }
          this.end(token);
          break;
        } else {
          params2.push(token);
        }
      } else {
        params2.push(token);
      }
      if (this.tokenizer.endOfFile()) {
        last2 = true;
        break;
      }
    }
    node2.raws.between = this.spacesAndCommentsFromEnd(params2);
    if (params2.length) {
      node2.raws.afterName = this.spacesAndCommentsFromStart(params2);
      this.raw(node2, "params", params2);
      if (last2) {
        token = params2[params2.length - 1];
        node2.source.end = this.getPosition(token[3] || token[2]);
        node2.source.end.offset++;
        this.spaces = node2.raws.between;
        node2.raws.between = "";
      }
    } else {
      node2.raws.afterName = "";
      node2.params = "";
    }
    if (open) {
      node2.nodes = [];
      this.current = node2;
    }
  }
  checkMissedSemicolon(tokens2) {
    let colon = this.colon(tokens2);
    if (colon === false) return;
    let founded = 0;
    let token;
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens2[j];
      if (token[0] !== "space") {
        founded += 1;
        if (founded === 2) break;
      }
    }
    throw this.input.error(
      "Missed semicolon",
      token[0] === "word" ? token[3] + 1 : token[2]
    );
  }
  colon(tokens2) {
    let brackets = 0;
    let prev, token, type;
    for (let [i2, element] of tokens2.entries()) {
      token = element;
      type = token[0];
      if (type === "(") {
        brackets += 1;
      }
      if (type === ")") {
        brackets -= 1;
      }
      if (brackets === 0 && type === ":") {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === "word" && prev[1] === "progid") {
          continue;
        } else {
          return i2;
        }
      }
      prev = token;
    }
    return false;
  }
  comment(token) {
    let node2 = new Comment$1();
    this.init(node2, token[2]);
    node2.source.end = this.getPosition(token[3] || token[2]);
    node2.source.end.offset++;
    let text2 = token[1].slice(2, -2);
    if (/^\s*$/.test(text2)) {
      node2.text = "";
      node2.raws.left = text2;
      node2.raws.right = "";
    } else {
      let match = text2.match(/^(\s*)([^]*\S)(\s*)$/);
      node2.text = match[2];
      node2.raws.left = match[1];
      node2.raws.right = match[3];
    }
  }
  createTokenizer() {
    this.tokenizer = tokenizer(this.input);
  }
  decl(tokens2, customProperty) {
    let node2 = new Declaration$1();
    this.init(node2, tokens2[0][2]);
    let last2 = tokens2[tokens2.length - 1];
    if (last2[0] === ";") {
      this.semicolon = true;
      tokens2.pop();
    }
    node2.source.end = this.getPosition(
      last2[3] || last2[2] || findLastWithPosition(tokens2)
    );
    node2.source.end.offset++;
    while (tokens2[0][0] !== "word") {
      if (tokens2.length === 1) this.unknownWord(tokens2);
      node2.raws.before += tokens2.shift()[1];
    }
    node2.source.start = this.getPosition(tokens2[0][2]);
    node2.prop = "";
    while (tokens2.length) {
      let type = tokens2[0][0];
      if (type === ":" || type === "space" || type === "comment") {
        break;
      }
      node2.prop += tokens2.shift()[1];
    }
    node2.raws.between = "";
    let token;
    while (tokens2.length) {
      token = tokens2.shift();
      if (token[0] === ":") {
        node2.raws.between += token[1];
        break;
      } else {
        if (token[0] === "word" && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }
        node2.raws.between += token[1];
      }
    }
    if (node2.prop[0] === "_" || node2.prop[0] === "*") {
      node2.raws.before += node2.prop[0];
      node2.prop = node2.prop.slice(1);
    }
    let firstSpaces = [];
    let next;
    while (tokens2.length) {
      next = tokens2[0][0];
      if (next !== "space" && next !== "comment") break;
      firstSpaces.push(tokens2.shift());
    }
    this.precheckMissedSemicolon(tokens2);
    for (let i2 = tokens2.length - 1; i2 >= 0; i2--) {
      token = tokens2[i2];
      if (token[1].toLowerCase() === "!important") {
        node2.important = true;
        let string = this.stringFrom(tokens2, i2);
        string = this.spacesFromEnd(tokens2) + string;
        if (string !== " !important") node2.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === "important") {
        let cache2 = tokens2.slice(0);
        let str = "";
        for (let j = i2; j > 0; j--) {
          let type = cache2[j][0];
          if (str.trim().startsWith("!") && type !== "space") {
            break;
          }
          str = cache2.pop()[1] + str;
        }
        if (str.trim().startsWith("!")) {
          node2.important = true;
          node2.raws.important = str;
          tokens2 = cache2;
        }
      }
      if (token[0] !== "space" && token[0] !== "comment") {
        break;
      }
    }
    let hasWord = tokens2.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
    if (hasWord) {
      node2.raws.between += firstSpaces.map((i2) => i2[1]).join("");
      firstSpaces = [];
    }
    this.raw(node2, "value", firstSpaces.concat(tokens2), customProperty);
    if (node2.value.includes(":") && !customProperty) {
      this.checkMissedSemicolon(tokens2);
    }
  }
  doubleColon(token) {
    throw this.input.error(
      "Double colon",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
  emptyRule(token) {
    let node2 = new Rule$1();
    this.init(node2, token[2]);
    node2.selector = "";
    node2.raws.between = "";
    this.current = node2;
  }
  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.spaces = "";
    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2]);
      this.current.source.end.offset++;
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  }
  endFile() {
    if (this.current.parent) this.unclosedBlock();
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
    this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(token) {
    this.spaces += token[1];
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1];
      if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = "";
      }
    }
  }
  // Helpers
  getPosition(offset) {
    let pos = this.input.fromOffset(offset);
    return {
      column: pos.col,
      line: pos.line,
      offset
    };
  }
  init(node2, offset) {
    this.current.push(node2);
    node2.source = {
      input: this.input,
      start: this.getPosition(offset)
    };
    node2.raws.before = this.spaces;
    this.spaces = "";
    if (node2.type !== "comment") this.semicolon = false;
  }
  other(start) {
    let end = false;
    let type = null;
    let colon = false;
    let bracket = null;
    let brackets = [];
    let customProperty = start[1].startsWith("--");
    let tokens2 = [];
    let token = start;
    while (token) {
      type = token[0];
      tokens2.push(token);
      if (type === "(" || type === "[") {
        if (!bracket) bracket = token;
        brackets.push(type === "(" ? ")" : "]");
      } else if (customProperty && colon && type === "{") {
        if (!bracket) bracket = token;
        brackets.push("}");
      } else if (brackets.length === 0) {
        if (type === ";") {
          if (colon) {
            this.decl(tokens2, customProperty);
            return;
          } else {
            break;
          }
        } else if (type === "{") {
          this.rule(tokens2);
          return;
        } else if (type === "}") {
          this.tokenizer.back(tokens2.pop());
          end = true;
          break;
        } else if (type === ":") {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }
      token = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);
    if (end && colon) {
      if (!customProperty) {
        while (tokens2.length) {
          token = tokens2[tokens2.length - 1][0];
          if (token !== "space" && token !== "comment") break;
          this.tokenizer.back(tokens2.pop());
        }
      }
      this.decl(tokens2, customProperty);
    } else {
      this.unknownWord(tokens2);
    }
  }
  parse() {
    let token;
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      switch (token[0]) {
        case "space":
          this.spaces += token[1];
          break;
        case ";":
          this.freeSemicolon(token);
          break;
        case "}":
          this.end(token);
          break;
        case "comment":
          this.comment(token);
          break;
        case "at-word":
          this.atrule(token);
          break;
        case "{":
          this.emptyRule(token);
          break;
        default:
          this.other(token);
          break;
      }
    }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(node2, prop, tokens2, customProperty) {
    let token, type;
    let length2 = tokens2.length;
    let value = "";
    let clean = true;
    let next, prev;
    for (let i2 = 0; i2 < length2; i2 += 1) {
      token = tokens2[i2];
      type = token[0];
      if (type === "space" && i2 === length2 - 1 && !customProperty) {
        clean = false;
      } else if (type === "comment") {
        prev = tokens2[i2 - 1] ? tokens2[i2 - 1][0] : "empty";
        next = tokens2[i2 + 1] ? tokens2[i2 + 1][0] : "empty";
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ",") {
            clean = false;
          } else {
            value += token[1];
          }
        } else {
          clean = false;
        }
      } else {
        value += token[1];
      }
    }
    if (!clean) {
      let raw = tokens2.reduce((all, i2) => all + i2[1], "");
      node2.raws[prop] = { raw, value };
    }
    node2[prop] = value;
  }
  rule(tokens2) {
    tokens2.pop();
    let node2 = new Rule$1();
    this.init(node2, tokens2[0][2]);
    node2.raws.between = this.spacesAndCommentsFromEnd(tokens2);
    this.raw(node2, "selector", tokens2);
    this.current = node2;
  }
  spacesAndCommentsFromEnd(tokens2) {
    let lastTokenType;
    let spaces = "";
    while (tokens2.length) {
      lastTokenType = tokens2[tokens2.length - 1][0];
      if (lastTokenType !== "space" && lastTokenType !== "comment") break;
      spaces = tokens2.pop()[1] + spaces;
    }
    return spaces;
  }
  // Errors
  spacesAndCommentsFromStart(tokens2) {
    let next;
    let spaces = "";
    while (tokens2.length) {
      next = tokens2[0][0];
      if (next !== "space" && next !== "comment") break;
      spaces += tokens2.shift()[1];
    }
    return spaces;
  }
  spacesFromEnd(tokens2) {
    let lastTokenType;
    let spaces = "";
    while (tokens2.length) {
      lastTokenType = tokens2[tokens2.length - 1][0];
      if (lastTokenType !== "space") break;
      spaces = tokens2.pop()[1] + spaces;
    }
    return spaces;
  }
  stringFrom(tokens2, from2) {
    let result2 = "";
    for (let i2 = from2; i2 < tokens2.length; i2++) {
      result2 += tokens2[i2][1];
    }
    tokens2.splice(from2, tokens2.length - from2);
    return result2;
  }
  unclosedBlock() {
    let pos = this.current.source.start;
    throw this.input.error("Unclosed block", pos.line, pos.column);
  }
  unclosedBracket(bracket) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    );
  }
  unexpectedClose(token) {
    throw this.input.error(
      "Unexpected }",
      { offset: token[2] },
      { offset: token[2] + 1 }
    );
  }
  unknownWord(tokens2) {
    throw this.input.error(
      "Unknown word",
      { offset: tokens2[0][2] },
      { offset: tokens2[0][2] + tokens2[0][1].length }
    );
  }
  unnamedAtrule(node2, token) {
    throw this.input.error(
      "At-rule without name",
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    );
  }
};
var parser = Parser$1;
let Container$2 = container;
let Input$1 = input;
let Parser = parser;
function parse$3(css2, opts) {
  let input2 = new Input$1(css2, opts);
  let parser2 = new Parser(input2);
  try {
    parser2.parse();
  } catch (e) {
    if (process.env.NODE_ENV !== "production") {
      if (e.name === "CssSyntaxError" && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
        } else if (/\.sass/i.test(opts.from)) {
          e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
        } else if (/\.less$/i.test(opts.from)) {
          e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
        }
      }
    }
    throw e;
  }
  return parser2.root;
}
var parse_1 = parse$3;
parse$3.default = parse$3;
Container$2.registerParse(parse$3);
let Warning$2 = class Warning2 {
  constructor(text2, opts = {}) {
    this.type = "warning";
    this.text = text2;
    if (opts.node && opts.node.source) {
      let range2 = opts.node.rangeBy(opts);
      this.line = range2.start.line;
      this.column = range2.start.column;
      this.endLine = range2.end.line;
      this.endColumn = range2.end.column;
    }
    for (let opt in opts) this[opt] = opts[opt];
  }
  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message;
    }
    if (this.plugin) {
      return this.plugin + ": " + this.text;
    }
    return this.text;
  }
};
var warning = Warning$2;
Warning$2.default = Warning$2;
let Warning$1 = warning;
let Result$3 = class Result2 {
  constructor(processor2, root2, opts) {
    this.processor = processor2;
    this.messages = [];
    this.root = root2;
    this.opts = opts;
    this.css = void 0;
    this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(text2, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }
    let warning2 = new Warning$1(text2, opts);
    this.messages.push(warning2);
    return warning2;
  }
  warnings() {
    return this.messages.filter((i2) => i2.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var result = Result$3;
Result$3.default = Result$3;
let printed = {};
var warnOnce$2 = function warnOnce2(message) {
  if (printed[message]) return;
  printed[message] = true;
  if (typeof console !== "undefined" && console.warn) {
    console.warn(message);
  }
};
let Container$1 = container;
let Document$3 = document$1;
let MapGenerator$1 = mapGenerator;
let parse$2 = parse_1;
let Result$2 = result;
let Root$2 = root$1;
let stringify$2 = stringify_1;
let { isClean, my } = symbols;
let warnOnce$1 = warnOnce$2;
const TYPE_TO_CLASS_NAME = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
};
const PLUGIN_PROPS = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
};
const NOT_VISITORS = {
  Once: true,
  postcssPlugin: true,
  prepare: true
};
const CHILDREN = 0;
function isPromise(obj) {
  return typeof obj === "object" && typeof obj.then === "function";
}
function getEvents(node2) {
  let key2 = false;
  let type = TYPE_TO_CLASS_NAME[node2.type];
  if (node2.type === "decl") {
    key2 = node2.prop.toLowerCase();
  } else if (node2.type === "atrule") {
    key2 = node2.name.toLowerCase();
  }
  if (key2 && node2.append) {
    return [
      type,
      type + "-" + key2,
      CHILDREN,
      type + "Exit",
      type + "Exit-" + key2
    ];
  } else if (key2) {
    return [type, type + "-" + key2, type + "Exit", type + "Exit-" + key2];
  } else if (node2.append) {
    return [type, CHILDREN, type + "Exit"];
  } else {
    return [type, type + "Exit"];
  }
}
function toStack(node2) {
  let events;
  if (node2.type === "document") {
    events = ["Document", CHILDREN, "DocumentExit"];
  } else if (node2.type === "root") {
    events = ["Root", CHILDREN, "RootExit"];
  } else {
    events = getEvents(node2);
  }
  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node: node2,
    visitorIndex: 0,
    visitors: []
  };
}
function cleanMarks(node2) {
  node2[isClean] = false;
  if (node2.nodes) node2.nodes.forEach((i2) => cleanMarks(i2));
  return node2;
}
let postcss$1 = {};
let LazyResult$2 = class LazyResult2 {
  constructor(processor2, css2, opts) {
    this.stringified = false;
    this.processed = false;
    let root2;
    if (typeof css2 === "object" && css2 !== null && (css2.type === "root" || css2.type === "document")) {
      root2 = cleanMarks(css2);
    } else if (css2 instanceof LazyResult2 || css2 instanceof Result$2) {
      root2 = cleanMarks(css2.root);
      if (css2.map) {
        if (typeof opts.map === "undefined") opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css2.map;
      }
    } else {
      let parser2 = parse$2;
      if (opts.syntax) parser2 = opts.syntax.parse;
      if (opts.parser) parser2 = opts.parser;
      if (parser2.parse) parser2 = parser2.parse;
      try {
        root2 = parser2(css2, opts);
      } catch (error) {
        this.processed = true;
        this.error = error;
      }
      if (root2 && !root2[my]) {
        Container$1.rebuild(root2);
      }
    }
    this.result = new Result$2(processor2, root2, opts);
    this.helpers = { ...postcss$1, postcss: postcss$1, result: this.result };
    this.plugins = this.processor.plugins.map((plugin2) => {
      if (typeof plugin2 === "object" && plugin2.prepare) {
        return { ...plugin2, ...plugin2.prepare(this.result) };
      } else {
        return plugin2;
      }
    });
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    if (this.processed) return Promise.resolve(this.result);
    if (!this.processing) {
      this.processing = this.runAsync();
    }
    return this.processing;
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(error, node2) {
    let plugin2 = this.result.lastPlugin;
    try {
      if (node2) node2.addToError(error);
      this.error = error;
      if (error.name === "CssSyntaxError" && !error.plugin) {
        error.plugin = plugin2.postcssPlugin;
        error.setMessage();
      } else if (plugin2.postcssVersion) {
        if (process.env.NODE_ENV !== "production") {
          let pluginName = plugin2.postcssPlugin;
          let pluginVer = plugin2.postcssVersion;
          let runtimeVer = this.result.processor.version;
          let a = pluginVer.split(".");
          let b = runtimeVer.split(".");
          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
            console.error(
              "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
            );
          }
        }
      }
    } catch (err) {
      if (console && console.error) console.error(err);
    }
    return error;
  }
  prepareVisitors() {
    this.listeners = {};
    let add = (plugin2, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = [];
      this.listeners[type].push([plugin2, cb]);
    };
    for (let plugin2 of this.plugins) {
      if (typeof plugin2 === "object") {
        for (let event2 in plugin2) {
          if (!PLUGIN_PROPS[event2] && /^[A-Z]/.test(event2)) {
            throw new Error(
              `Unknown event ${event2} in ${plugin2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          }
          if (!NOT_VISITORS[event2]) {
            if (typeof plugin2[event2] === "object") {
              for (let filter2 in plugin2[event2]) {
                if (filter2 === "*") {
                  add(plugin2, event2, plugin2[event2][filter2]);
                } else {
                  add(
                    plugin2,
                    event2 + "-" + filter2.toLowerCase(),
                    plugin2[event2][filter2]
                  );
                }
              }
            } else if (typeof plugin2[event2] === "function") {
              add(plugin2, event2, plugin2[event2]);
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let i2 = 0; i2 < this.plugins.length; i2++) {
      let plugin2 = this.plugins[i2];
      let promise = this.runOnRoot(plugin2);
      if (isPromise(promise)) {
        try {
          await promise;
        } catch (error) {
          throw this.handleError(error);
        }
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean]) {
        root2[isClean] = true;
        let stack = [toStack(root2)];
        while (stack.length > 0) {
          let promise = this.visitTick(stack);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (e) {
              let node2 = stack[stack.length - 1].node;
              throw this.handleError(e, node2);
            }
          }
        }
      }
      if (this.listeners.OnceExit) {
        for (let [plugin2, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin2;
          try {
            if (root2.type === "document") {
              let roots = root2.nodes.map(
                (subRoot) => visitor(subRoot, this.helpers)
              );
              await Promise.all(roots);
            } else {
              await visitor(root2, this.helpers);
            }
          } catch (e) {
            throw this.handleError(e);
          }
        }
      }
    }
    this.processed = true;
    return this.stringify();
  }
  runOnRoot(plugin2) {
    this.result.lastPlugin = plugin2;
    try {
      if (typeof plugin2 === "object" && plugin2.Once) {
        if (this.result.root.type === "document") {
          let roots = this.result.root.nodes.map(
            (root2) => plugin2.Once(root2, this.helpers)
          );
          if (isPromise(roots[0])) {
            return Promise.all(roots);
          }
          return roots;
        }
        return plugin2.Once(this.result.root, this.helpers);
      } else if (typeof plugin2 === "function") {
        return plugin2(this.result.root, this.result);
      }
    } catch (error) {
      throw this.handleError(error);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    let opts = this.result.opts;
    let str = stringify$2;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    let map2 = new MapGenerator$1(str, this.result.root, this.result.opts);
    let data = map2.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    this.processed = true;
    if (this.processing) {
      throw this.getAsyncError();
    }
    for (let plugin2 of this.plugins) {
      let promise = this.runOnRoot(plugin2);
      if (isPromise(promise)) {
        throw this.getAsyncError();
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root2 = this.result.root;
      while (!root2[isClean]) {
        root2[isClean] = true;
        this.walkSync(root2);
      }
      if (this.listeners.OnceExit) {
        if (root2.type === "document") {
          for (let subRoot of root2.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot);
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root2);
        }
      }
    }
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (process.env.NODE_ENV !== "production") {
      if (!("from" in this.opts)) {
        warnOnce$1(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        );
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this.css;
  }
  visitSync(visitors, node2) {
    for (let [plugin2, visitor] of visitors) {
      this.result.lastPlugin = plugin2;
      let promise;
      try {
        promise = visitor(node2, this.helpers);
      } catch (e) {
        throw this.handleError(e, node2.proxyOf);
      }
      if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
        return true;
      }
      if (isPromise(promise)) {
        throw this.getAsyncError();
      }
    }
  }
  visitTick(stack) {
    let visit = stack[stack.length - 1];
    let { node: node2, visitors } = visit;
    if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
      stack.pop();
      return;
    }
    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
      let [plugin2, visitor] = visitors[visit.visitorIndex];
      visit.visitorIndex += 1;
      if (visit.visitorIndex === visitors.length) {
        visit.visitors = [];
        visit.visitorIndex = 0;
      }
      this.result.lastPlugin = plugin2;
      try {
        return visitor(node2.toProxy(), this.helpers);
      } catch (e) {
        throw this.handleError(e, node2);
      }
    }
    if (visit.iterator !== 0) {
      let iterator = visit.iterator;
      let child;
      while (child = node2.nodes[node2.indexes[iterator]]) {
        node2.indexes[iterator] += 1;
        if (!child[isClean]) {
          child[isClean] = true;
          stack.push(toStack(child));
          return;
        }
      }
      visit.iterator = 0;
      delete node2.indexes[iterator];
    }
    let events = visit.events;
    while (visit.eventIndex < events.length) {
      let event2 = events[visit.eventIndex];
      visit.eventIndex += 1;
      if (event2 === CHILDREN) {
        if (node2.nodes && node2.nodes.length) {
          node2[isClean] = true;
          visit.iterator = node2.getIterator();
        }
        return;
      } else if (this.listeners[event2]) {
        visit.visitors = this.listeners[event2];
        return;
      }
    }
    stack.pop();
  }
  walkSync(node2) {
    node2[isClean] = true;
    let events = getEvents(node2);
    for (let event2 of events) {
      if (event2 === CHILDREN) {
        if (node2.nodes) {
          node2.each((child) => {
            if (!child[isClean]) this.walkSync(child);
          });
        }
      } else {
        let visitors = this.listeners[event2];
        if (visitors) {
          if (this.visitSync(visitors, node2.toProxy())) return;
        }
      }
    }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
LazyResult$2.registerPostcss = (dependant) => {
  postcss$1 = dependant;
};
var lazyResult = LazyResult$2;
LazyResult$2.default = LazyResult$2;
Root$2.registerLazyResult(LazyResult$2);
Document$3.registerLazyResult(LazyResult$2);
let MapGenerator = mapGenerator;
let parse$1 = parse_1;
const Result$1 = result;
let stringify$1 = stringify_1;
let warnOnce = warnOnce$2;
let NoWorkResult$1 = class NoWorkResult2 {
  constructor(processor2, css2, opts) {
    css2 = css2.toString();
    this.stringified = false;
    this._processor = processor2;
    this._css = css2;
    this._opts = opts;
    this._map = void 0;
    let root2;
    let str = stringify$1;
    this.result = new Result$1(this._processor, root2, this._opts);
    this.result.css = css2;
    let self2 = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return self2.root;
      }
    });
    let map2 = new MapGenerator(str, root2, this._opts, css2);
    if (map2.isMap()) {
      let [generatedCSS, generatedMap] = map2.generate();
      if (generatedCSS) {
        this.result.css = generatedCSS;
      }
      if (generatedMap) {
        this.result.map = generatedMap;
      }
    } else {
      map2.clearAnnotation();
      this.result.css = map2.css;
    }
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    return Promise.resolve(this.result);
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (process.env.NODE_ENV !== "production") {
      if (!("from" in this._opts)) {
        warnOnce(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        );
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root) {
      return this._root;
    }
    let root2;
    let parser2 = parse$1;
    try {
      root2 = parser2(this._css, this._opts);
    } catch (error) {
      this.error = error;
    }
    if (this.error) {
      throw this.error;
    } else {
      this._root = root2;
      return root2;
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var noWorkResult = NoWorkResult$1;
NoWorkResult$1.default = NoWorkResult$1;
let Document$2 = document$1;
let LazyResult$1 = lazyResult;
let NoWorkResult = noWorkResult;
let Root$1 = root$1;
let Processor$1 = class Processor2 {
  constructor(plugins = []) {
    this.version = "8.4.49";
    this.plugins = this.normalize(plugins);
  }
  normalize(plugins) {
    let normalized = [];
    for (let i2 of plugins) {
      if (i2.postcss === true) {
        i2 = i2();
      } else if (i2.postcss) {
        i2 = i2.postcss;
      }
      if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
        normalized = normalized.concat(i2.plugins);
      } else if (typeof i2 === "object" && i2.postcssPlugin) {
        normalized.push(i2);
      } else if (typeof i2 === "function") {
        normalized.push(i2);
      } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
        if (process.env.NODE_ENV !== "production") {
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
        }
      } else {
        throw new Error(i2 + " is not a PostCSS plugin");
      }
    }
    return normalized;
  }
  process(css2, opts = {}) {
    if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
      return new NoWorkResult(this, css2, opts);
    } else {
      return new LazyResult$1(this, css2, opts);
    }
  }
  use(plugin2) {
    this.plugins = this.plugins.concat(this.normalize([plugin2]));
    return this;
  }
};
var processor = Processor$1;
Processor$1.default = Processor$1;
Root$1.registerProcessor(Processor$1);
Document$2.registerProcessor(Processor$1);
let AtRule = atRule;
let Comment = comment;
let Container = container;
let CssSyntaxError = cssSyntaxError;
let Declaration = declaration;
let Document$1 = document$1;
let fromJSON = fromJSON_1;
let Input = input;
let LazyResult = lazyResult;
let list = list_1;
let Node$1 = node;
let parse = parse_1;
let Processor = processor;
let Result = result;
let Root = root$1;
let Rule = rule;
let stringify = stringify_1;
let Warning = warning;
function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new Processor(plugins);
}
postcss.plugin = function plugin(name2, initializer) {
  let warningPrinted = false;
  function creator(...args) {
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true;
      console.warn(
        name2 + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
      );
      if (process.env.LANG && process.env.LANG.startsWith("cn")) {
        console.warn(
          name2 + ":  postcss.plugin . :\nhttps://www.w3ctech.com/topic/2226"
        );
      }
    }
    let transformer = initializer(...args);
    transformer.postcssPlugin = name2;
    transformer.postcssVersion = new Processor().version;
    return transformer;
  }
  let cache2;
  Object.defineProperty(creator, "postcss", {
    get() {
      if (!cache2) cache2 = creator();
      return cache2;
    }
  });
  creator.process = function(css2, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css2, processOpts);
  };
  return creator;
};
postcss.stringify = stringify;
postcss.parse = parse;
postcss.fromJSON = fromJSON;
postcss.list = list;
postcss.comment = (defaults) => new Comment(defaults);
postcss.atRule = (defaults) => new AtRule(defaults);
postcss.decl = (defaults) => new Declaration(defaults);
postcss.rule = (defaults) => new Rule(defaults);
postcss.root = (defaults) => new Root(defaults);
postcss.document = (defaults) => new Document$1(defaults);
postcss.CssSyntaxError = CssSyntaxError;
postcss.Declaration = Declaration;
postcss.Container = Container;
postcss.Processor = Processor;
postcss.Document = Document$1;
postcss.Comment = Comment;
postcss.Warning = Warning;
postcss.AtRule = AtRule;
postcss.Result = Result;
postcss.Input = Input;
postcss.Rule = Rule;
postcss.Root = Root;
postcss.Node = Node$1;
LazyResult.registerPostcss(postcss);
var postcss_1 = postcss;
postcss.default = postcss;
const htmlparser = lib$5;
const escapeStringRegexp = escapeStringRegexp$1;
const { isPlainObject } = isPlainObject$2;
const deepmerge = cjs;
const parseSrcset = parseSrcsetExports;
const { parse: postcssParse } = postcss_1;
const mediaTags = [
  "img",
  "audio",
  "video",
  "picture",
  "svg",
  "object",
  "map",
  "iframe",
  "embed"
];
const vulnerableTags = ["script", "style"];
function each(obj, cb) {
  if (obj) {
    Object.keys(obj).forEach(function(key2) {
      cb(obj[key2], key2);
    });
  }
}
function has(obj, key2) {
  return {}.hasOwnProperty.call(obj, key2);
}
function filter(a, cb) {
  const n = [];
  each(a, function(v) {
    if (cb(v)) {
      n.push(v);
    }
  });
  return n;
}
function isEmptyObject(obj) {
  for (const key2 in obj) {
    if (has(obj, key2)) {
      return false;
    }
  }
  return true;
}
function stringifySrcset(parsedSrcset) {
  return parsedSrcset.map(function(part) {
    if (!part.url) {
      throw new Error("URL missing");
    }
    return part.url + (part.w ? ` ${part.w}w` : "") + (part.h ? ` ${part.h}h` : "") + (part.d ? ` ${part.d}x` : "");
  }).join(", ");
}
var sanitizeHtml_1 = sanitizeHtml;
const VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
function sanitizeHtml(html2, options, _recursing) {
  if (html2 == null) {
    return "";
  }
  if (typeof html2 === "number") {
    html2 = html2.toString();
  }
  let result2 = "";
  let tempResult = "";
  function Frame(tag, attribs) {
    const that = this;
    this.tag = tag;
    this.attribs = attribs || {};
    this.tagPosition = result2.length;
    this.text = "";
    this.mediaChildren = [];
    this.updateParentNodeText = function() {
      if (stack.length) {
        const parentFrame = stack[stack.length - 1];
        parentFrame.text += that.text;
      }
    };
    this.updateParentNodeMediaChildren = function() {
      if (stack.length && mediaTags.includes(this.tag)) {
        const parentFrame = stack[stack.length - 1];
        parentFrame.mediaChildren.push(this.tag);
      }
    };
  }
  options = Object.assign({}, sanitizeHtml.defaults, options);
  options.parser = Object.assign({}, htmlParserDefaults, options.parser);
  const tagAllowed = function(name2) {
    return options.allowedTags === false || (options.allowedTags || []).indexOf(name2) > -1;
  };
  vulnerableTags.forEach(function(tag) {
    if (tagAllowed(tag) && !options.allowVulnerableTags) {
      console.warn(`

 Your \`allowedTags\` option includes, \`${tag}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
    }
  });
  const nonTextTagsArray = options.nonTextTags || [
    "script",
    "style",
    "textarea",
    "option"
  ];
  let allowedAttributesMap;
  let allowedAttributesGlobMap;
  if (options.allowedAttributes) {
    allowedAttributesMap = {};
    allowedAttributesGlobMap = {};
    each(options.allowedAttributes, function(attributes, tag) {
      allowedAttributesMap[tag] = [];
      const globRegex = [];
      attributes.forEach(function(obj) {
        if (typeof obj === "string" && obj.indexOf("*") >= 0) {
          globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
        } else {
          allowedAttributesMap[tag].push(obj);
        }
      });
      if (globRegex.length) {
        allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
      }
    });
  }
  const allowedClassesMap = {};
  const allowedClassesGlobMap = {};
  const allowedClassesRegexMap = {};
  each(options.allowedClasses, function(classes2, tag) {
    if (allowedAttributesMap) {
      if (!has(allowedAttributesMap, tag)) {
        allowedAttributesMap[tag] = [];
      }
      allowedAttributesMap[tag].push("class");
    }
    allowedClassesMap[tag] = classes2;
    if (Array.isArray(classes2)) {
      const globRegex = [];
      allowedClassesMap[tag] = [];
      allowedClassesRegexMap[tag] = [];
      classes2.forEach(function(obj) {
        if (typeof obj === "string" && obj.indexOf("*") >= 0) {
          globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
        } else if (obj instanceof RegExp) {
          allowedClassesRegexMap[tag].push(obj);
        } else {
          allowedClassesMap[tag].push(obj);
        }
      });
      if (globRegex.length) {
        allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
      }
    }
  });
  const transformTagsMap = {};
  let transformTagsAll;
  each(options.transformTags, function(transform, tag) {
    let transFun;
    if (typeof transform === "function") {
      transFun = transform;
    } else if (typeof transform === "string") {
      transFun = sanitizeHtml.simpleTransform(transform);
    }
    if (tag === "*") {
      transformTagsAll = transFun;
    } else {
      transformTagsMap[tag] = transFun;
    }
  });
  let depth;
  let stack;
  let skipMap;
  let transformMap;
  let skipText;
  let skipTextDepth;
  let addedText = false;
  initializeState();
  const parser2 = new htmlparser.Parser({
    onopentag: function(name2, attribs) {
      if (options.enforceHtmlBoundary && name2 === "html") {
        initializeState();
      }
      if (skipText) {
        skipTextDepth++;
        return;
      }
      const frame = new Frame(name2, attribs);
      stack.push(frame);
      let skip = false;
      const hasText = !!frame.text;
      let transformedTag;
      if (has(transformTagsMap, name2)) {
        transformedTag = transformTagsMap[name2](name2, attribs);
        frame.attribs = attribs = transformedTag.attribs;
        if (transformedTag.text !== void 0) {
          frame.innerText = transformedTag.text;
        }
        if (name2 !== transformedTag.tagName) {
          frame.name = name2 = transformedTag.tagName;
          transformMap[depth] = transformedTag.tagName;
        }
      }
      if (transformTagsAll) {
        transformedTag = transformTagsAll(name2, attribs);
        frame.attribs = attribs = transformedTag.attribs;
        if (name2 !== transformedTag.tagName) {
          frame.name = name2 = transformedTag.tagName;
          transformMap[depth] = transformedTag.tagName;
        }
      }
      if (!tagAllowed(name2) || options.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {
        skip = true;
        skipMap[depth] = true;
        if (options.disallowedTagsMode === "discard") {
          if (nonTextTagsArray.indexOf(name2) !== -1) {
            skipText = true;
            skipTextDepth = 1;
          }
        }
        skipMap[depth] = true;
      }
      depth++;
      if (skip) {
        if (options.disallowedTagsMode === "discard") {
          return;
        }
        tempResult = result2;
        result2 = "";
      }
      result2 += "<" + name2;
      if (name2 === "script") {
        if (options.allowedScriptHostnames || options.allowedScriptDomains) {
          frame.innerText = "";
        }
      }
      if (!allowedAttributesMap || has(allowedAttributesMap, name2) || allowedAttributesMap["*"]) {
        each(attribs, function(value, a) {
          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {
            delete frame.attribs[a];
            return;
          }
          if (value === "" && !options.allowedEmptyAttributes.includes(a) && (options.nonBooleanAttributes.includes(a) || options.nonBooleanAttributes.includes("*"))) {
            delete frame.attribs[a];
            return;
          }
          let passedAllowedAttributesMapCheck = false;
          if (!allowedAttributesMap || has(allowedAttributesMap, name2) && allowedAttributesMap[name2].indexOf(a) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a) !== -1 || has(allowedAttributesGlobMap, name2) && allowedAttributesGlobMap[name2].test(a) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a)) {
            passedAllowedAttributesMapCheck = true;
          } else if (allowedAttributesMap && allowedAttributesMap[name2]) {
            for (const o of allowedAttributesMap[name2]) {
              if (isPlainObject(o) && o.name && o.name === a) {
                passedAllowedAttributesMapCheck = true;
                let newValue = "";
                if (o.multiple === true) {
                  const splitStrArray = value.split(" ");
                  for (const s of splitStrArray) {
                    if (o.values.indexOf(s) !== -1) {
                      if (newValue === "") {
                        newValue = s;
                      } else {
                        newValue += " " + s;
                      }
                    }
                  }
                } else if (o.values.indexOf(value) >= 0) {
                  newValue = value;
                }
                value = newValue;
              }
            }
          }
          if (passedAllowedAttributesMapCheck) {
            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {
              if (naughtyHref(name2, value)) {
                delete frame.attribs[a];
                return;
              }
            }
            if (name2 === "script" && a === "src") {
              let allowed = true;
              try {
                const parsed = parseUrl(value);
                if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                  const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {
                    return hostname === parsed.url.hostname;
                  });
                  const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                  });
                  allowed = allowedHostname || allowedDomain;
                }
              } catch (e) {
                allowed = false;
              }
              if (!allowed) {
                delete frame.attribs[a];
                return;
              }
            }
            if (name2 === "iframe" && a === "src") {
              let allowed = true;
              try {
                const parsed = parseUrl(value);
                if (parsed.isRelativeUrl) {
                  allowed = has(options, "allowIframeRelativeUrls") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;
                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                  const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {
                    return hostname === parsed.url.hostname;
                  });
                  const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                  });
                  allowed = allowedHostname || allowedDomain;
                }
              } catch (e) {
                allowed = false;
              }
              if (!allowed) {
                delete frame.attribs[a];
                return;
              }
            }
            if (a === "srcset") {
              try {
                let parsed = parseSrcset(value);
                parsed.forEach(function(value2) {
                  if (naughtyHref("srcset", value2.url)) {
                    value2.evil = true;
                  }
                });
                parsed = filter(parsed, function(v) {
                  return !v.evil;
                });
                if (!parsed.length) {
                  delete frame.attribs[a];
                  return;
                } else {
                  value = stringifySrcset(filter(parsed, function(v) {
                    return !v.evil;
                  }));
                  frame.attribs[a] = value;
                }
              } catch (e) {
                delete frame.attribs[a];
                return;
              }
            }
            if (a === "class") {
              const allowedSpecificClasses = allowedClassesMap[name2];
              const allowedWildcardClasses = allowedClassesMap["*"];
              const allowedSpecificClassesGlob = allowedClassesGlobMap[name2];
              const allowedSpecificClassesRegex = allowedClassesRegexMap[name2];
              const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
              const allowedClassesGlobs = [
                allowedSpecificClassesGlob,
                allowedWildcardClassesGlob
              ].concat(allowedSpecificClassesRegex).filter(function(t) {
                return t;
              });
              if (allowedSpecificClasses && allowedWildcardClasses) {
                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
              } else {
                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
              }
              if (!value.length) {
                delete frame.attribs[a];
                return;
              }
            }
            if (a === "style") {
              if (options.parseStyleAttributes) {
                try {
                  const abstractSyntaxTree = postcssParse(name2 + " {" + value + "}", { map: false });
                  const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);
                  value = stringifyStyleAttributes(filteredAST);
                  if (value.length === 0) {
                    delete frame.attribs[a];
                    return;
                  }
                } catch (e) {
                  if (typeof window !== "undefined") {
                    console.warn('Failed to parse "' + name2 + " {" + value + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`);
                  }
                  delete frame.attribs[a];
                  return;
                }
              } else if (options.allowedStyles) {
                throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
              }
            }
            result2 += " " + a;
            if (value && value.length) {
              result2 += '="' + escapeHtml(value, true) + '"';
            } else if (options.allowedEmptyAttributes.includes(a)) {
              result2 += '=""';
            }
          } else {
            delete frame.attribs[a];
          }
        });
      }
      if (options.selfClosing.indexOf(name2) !== -1) {
        result2 += " />";
      } else {
        result2 += ">";
        if (frame.innerText && !hasText && !options.textFilter) {
          result2 += escapeHtml(frame.innerText);
          addedText = true;
        }
      }
      if (skip) {
        result2 = tempResult + escapeHtml(result2);
        tempResult = "";
      }
    },
    ontext: function(text2) {
      if (skipText) {
        return;
      }
      const lastFrame = stack[stack.length - 1];
      let tag;
      if (lastFrame) {
        tag = lastFrame.tag;
        text2 = lastFrame.innerText !== void 0 ? lastFrame.innerText : text2;
      }
      if (options.disallowedTagsMode === "discard" && (tag === "script" || tag === "style")) {
        result2 += text2;
      } else {
        const escaped = escapeHtml(text2, false);
        if (options.textFilter && !addedText) {
          result2 += options.textFilter(escaped, tag);
        } else if (!addedText) {
          result2 += escaped;
        }
      }
      if (stack.length) {
        const frame = stack[stack.length - 1];
        frame.text += text2;
      }
    },
    onclosetag: function(name2, isImplied) {
      if (skipText) {
        skipTextDepth--;
        if (!skipTextDepth) {
          skipText = false;
        } else {
          return;
        }
      }
      const frame = stack.pop();
      if (!frame) {
        return;
      }
      if (frame.tag !== name2) {
        stack.push(frame);
        return;
      }
      skipText = options.enforceHtmlBoundary ? name2 === "html" : false;
      depth--;
      const skip = skipMap[depth];
      if (skip) {
        delete skipMap[depth];
        if (options.disallowedTagsMode === "discard") {
          frame.updateParentNodeText();
          return;
        }
        tempResult = result2;
        result2 = "";
      }
      if (transformMap[depth]) {
        name2 = transformMap[depth];
        delete transformMap[depth];
      }
      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
        result2 = result2.substr(0, frame.tagPosition);
        return;
      }
      frame.updateParentNodeMediaChildren();
      frame.updateParentNodeText();
      if (
        // Already output />
        options.selfClosing.indexOf(name2) !== -1 || // Escaped tag, closing tag is implied
        isImplied && !tagAllowed(name2) && ["escape", "recursiveEscape"].indexOf(options.disallowedTagsMode) >= 0
      ) {
        if (skip) {
          result2 = tempResult;
          tempResult = "";
        }
        return;
      }
      result2 += "</" + name2 + ">";
      if (skip) {
        result2 = tempResult + escapeHtml(result2);
        tempResult = "";
      }
      addedText = false;
    }
  }, options.parser);
  parser2.write(html2);
  parser2.end();
  return result2;
  function initializeState() {
    result2 = "";
    depth = 0;
    stack = [];
    skipMap = {};
    transformMap = {};
    skipText = false;
    skipTextDepth = 0;
  }
  function escapeHtml(s, quote) {
    if (typeof s !== "string") {
      s = s + "";
    }
    if (options.parser.decodeEntities) {
      s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      if (quote) {
        s = s.replace(/"/g, "&quot;");
      }
    }
    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    if (quote) {
      s = s.replace(/"/g, "&quot;");
    }
    return s;
  }
  function naughtyHref(name2, href) {
    href = href.replace(/[\x00-\x20]+/g, "");
    while (true) {
      const firstIndex = href.indexOf("<!--");
      if (firstIndex === -1) {
        break;
      }
      const lastIndex = href.indexOf("-->", firstIndex + 4);
      if (lastIndex === -1) {
        break;
      }
      href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
    }
    const matches2 = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
    if (!matches2) {
      if (href.match(/^[/\\]{2}/)) {
        return !options.allowProtocolRelative;
      }
      return false;
    }
    const scheme = matches2[1].toLowerCase();
    if (has(options.allowedSchemesByTag, name2)) {
      return options.allowedSchemesByTag[name2].indexOf(scheme) === -1;
    }
    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
  }
  function parseUrl(value) {
    value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
    if (value.startsWith("relative:")) {
      throw new Error("relative: exploit attempt");
    }
    let base2 = "relative://relative-site";
    for (let i2 = 0; i2 < 100; i2++) {
      base2 += `/${i2}`;
    }
    const parsed = new URL(value, base2);
    const isRelativeUrl = parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
    return {
      isRelativeUrl,
      url: parsed
    };
  }
  function filterCss(abstractSyntaxTree, allowedStyles) {
    if (!allowedStyles) {
      return abstractSyntaxTree;
    }
    const astRules = abstractSyntaxTree.nodes[0];
    let selectedRule;
    if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
      selectedRule = deepmerge(
        allowedStyles[astRules.selector],
        allowedStyles["*"]
      );
    } else {
      selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
    }
    if (selectedRule) {
      abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
    }
    return abstractSyntaxTree;
  }
  function stringifyStyleAttributes(filteredAST) {
    return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {
      extractedAttributes.push(
        `${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`
      );
      return extractedAttributes;
    }, []).join(";");
  }
  function filterDeclarations(selectedRule) {
    return function(allowedDeclarationsList, attributeObject) {
      if (has(selectedRule, attributeObject.prop)) {
        const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
          return regularExpression.test(attributeObject.value);
        });
        if (matchesRegex) {
          allowedDeclarationsList.push(attributeObject);
        }
      }
      return allowedDeclarationsList;
    };
  }
  function filterClasses(classes2, allowed, allowedGlobs) {
    if (!allowed) {
      return classes2;
    }
    classes2 = classes2.split(/\s+/);
    return classes2.filter(function(clss) {
      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
        return glob.test(clss);
      });
    }).join(" ");
  }
}
const htmlParserDefaults = {
  decodeEntities: true
};
sanitizeHtml.defaults = {
  allowedTags: [
    // Sections derived from MDN element categories and limited to the more
    // benign categories.
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
    // Content sectioning
    "address",
    "article",
    "aside",
    "footer",
    "header",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hgroup",
    "main",
    "nav",
    "section",
    // Text content
    "blockquote",
    "dd",
    "div",
    "dl",
    "dt",
    "figcaption",
    "figure",
    "hr",
    "li",
    "main",
    "ol",
    "p",
    "pre",
    "ul",
    // Inline text semantics
    "a",
    "abbr",
    "b",
    "bdi",
    "bdo",
    "br",
    "cite",
    "code",
    "data",
    "dfn",
    "em",
    "i",
    "kbd",
    "mark",
    "q",
    "rb",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "time",
    "u",
    "var",
    "wbr",
    // Table content
    "caption",
    "col",
    "colgroup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr"
  ],
  // Tags that cannot be boolean
  nonBooleanAttributes: [
    "abbr",
    "accept",
    "accept-charset",
    "accesskey",
    "action",
    "allow",
    "alt",
    "as",
    "autocapitalize",
    "autocomplete",
    "blocking",
    "charset",
    "cite",
    "class",
    "color",
    "cols",
    "colspan",
    "content",
    "contenteditable",
    "coords",
    "crossorigin",
    "data",
    "datetime",
    "decoding",
    "dir",
    "dirname",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "fetchpriority",
    "for",
    "form",
    "formaction",
    "formenctype",
    "formmethod",
    "formtarget",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "http-equiv",
    "id",
    "imagesizes",
    "imagesrcset",
    "inputmode",
    "integrity",
    "is",
    "itemid",
    "itemprop",
    "itemref",
    "itemtype",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "name",
    "nonce",
    "optimum",
    "pattern",
    "ping",
    "placeholder",
    "popover",
    "popovertarget",
    "popovertargetaction",
    "poster",
    "preload",
    "referrerpolicy",
    "rel",
    "rows",
    "rowspan",
    "sandbox",
    "scope",
    "shape",
    "size",
    "sizes",
    "slot",
    "span",
    "spellcheck",
    "src",
    "srcdoc",
    "srclang",
    "srcset",
    "start",
    "step",
    "style",
    "tabindex",
    "target",
    "title",
    "translate",
    "type",
    "usemap",
    "value",
    "width",
    "wrap",
    // Event handlers
    "onauxclick",
    "onafterprint",
    "onbeforematch",
    "onbeforeprint",
    "onbeforeunload",
    "onbeforetoggle",
    "onblur",
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncontextlost",
    "oncontextmenu",
    "oncontextrestored",
    "oncopy",
    "oncuechange",
    "oncut",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "onformdata",
    "onhashchange",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onlanguagechange",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onmessage",
    "onmessageerror",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onoffline",
    "ononline",
    "onpagehide",
    "onpageshow",
    "onpaste",
    "onpause",
    "onplay",
    "onplaying",
    "onpopstate",
    "onprogress",
    "onratechange",
    "onreset",
    "onresize",
    "onrejectionhandled",
    "onscroll",
    "onscrollend",
    "onsecuritypolicyviolation",
    "onseeked",
    "onseeking",
    "onselect",
    "onslotchange",
    "onstalled",
    "onstorage",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "ontoggle",
    "onunhandledrejection",
    "onunload",
    "onvolumechange",
    "onwaiting",
    "onwheel"
  ],
  disallowedTagsMode: "discard",
  allowedAttributes: {
    a: ["href", "name", "target"],
    // We don't currently allow img itself by default, but
    // these attributes would make sense if we did.
    img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
  },
  allowedEmptyAttributes: [
    "alt"
  ],
  // Lots of these won't come up by default because we don't allow them
  selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
  // URL schemes we permit
  allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
  allowedSchemesByTag: {},
  allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
  allowProtocolRelative: true,
  enforceHtmlBoundary: false,
  parseStyleAttributes: true
};
sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {
  merge = merge === void 0 ? true : merge;
  newAttribs = newAttribs || {};
  return function(tagName, attribs) {
    let attrib;
    if (merge) {
      for (attrib in newAttribs) {
        attribs[attrib] = newAttribs[attrib];
      }
    } else {
      attribs = newAttribs;
    }
    return {
      tagName: newTagName,
      attribs
    };
  };
};
const sanitize = /* @__PURE__ */ getDefaultExportFromCjs(sanitizeHtml_1);
class CssProp {
  static reg(r) {
    return new RegExp("^" + r + "$", "i");
  }
}
CssProp.N = {
  integer: `[+-]?[0-9]+`,
  integer_pos: `[+]?[0-9]+`,
  integer_zero_ff: `([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])`,
  number: `[+-]?([0-9]*[.])?[0-9]+(e-?[0-9]*)?`,
  number_pos: `[+]?([0-9]*[.])?[0-9]+(e-?[0-9]*)?`,
  number_zero_hundred: `[+]?(([0-9]|[1-9][0-9])([.][0-9]+)?|100)`,
  number_zero_one: `[+]?(1([.][0]+)?|0?([.][0-9]+)?)`
};
CssProp.B = {
  angle: `(${CssProp.N.number}(deg|rad|grad|turn)|0)`,
  frequency: `${CssProp.N.number}(Hz|kHz)`,
  ident: String.raw`-?([_a-z]|[\xA0-\xFF]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\xA0-\xFF]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*`,
  len_or_perc: `(0|${CssProp.N.number}(px|em|rem|ex|in|cm|mm|pt|pc|%))`,
  length: `(${CssProp.N.number}(px|em|rem|ex|in|cm|mm|pt|pc)|0)`,
  length_pos: `(${CssProp.N.number_pos}(px|em|rem|ex|in|cm|mm|pt|pc)|0)`,
  percentage: `${CssProp.N.number}%`,
  percentage_pos: `${CssProp.N.number_pos}%`,
  percentage_zero_hundred: `${CssProp.N.number_zero_hundred}%`,
  string: String.raw`(\"([^\n\r\f\\"]|\\\n|\r\n|\r|\f|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*\")|(\'([^\n\r\f\\']|\\\n|\r\n|\r|\f|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*\')`,
  time: `${CssProp.N.number}(s|ms)`,
  url: `url\\(.*?\\)`,
  z_index: `[+-]?[0-9]{1,7}`
};
CssProp.A = {
  absolute_size: `xx-small|x-small|small|medium|large|x-large|xx-large`,
  attachment: `scroll|fixed|local`,
  bg_origin: `border-box|padding-box|content-box`,
  border_style: `none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset`,
  box: `border-box|padding-box|content-box`,
  display_inside: `auto|block|table|flex|grid`,
  display_outside: `block-level|inline-level|none|table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption`,
  ending_shape: `circle|ellipse`,
  generic_family: `serif|sans-serif|cursive|fantasy|monospace`,
  generic_voice: `male|female|child`,
  relative_size: `smaller|larger`,
  repeat_style: `repeat-x|repeat-y|((?:repeat|space|round|no-repeat)(?:\\s*(?:repeat|space|round|no-repeat))?)`,
  side_or_corner: `(left|right)?\\s*(top|bottom)?`,
  single_animation_direction: `normal|reverse|alternate|alternate-reverse`,
  single_animation_fill_mode: `none|forwards|backwards|both`,
  single_animation_play_state: `running|paused`
};
CssProp._COLOR = {
  hex: `\\#(0x)?[0-9a-f]+`,
  name: `aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|transparent|violet|wheat|white|whitesmoke|yellow|yellowgreen`,
  rgb: String.raw`rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)`,
  rgba: String.raw`rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(${CssProp.N.integer_zero_ff}|${CssProp.N.number_zero_one}|${CssProp.B.percentage_zero_hundred})\s*\)`
};
CssProp._C = {
  alpha: `${CssProp.N.integer_zero_ff}|${CssProp.N.number_zero_one}|${CssProp.B.percentage_zero_hundred}`,
  alphavalue: CssProp.N.number_zero_one,
  bg_position: `((${CssProp.B.len_or_perc}|left|center|right|top|bottom)\\s*){1,4}`,
  bg_size: `(${CssProp.B.length_pos}|${CssProp.B.percentage}|auto){1,2}|cover|contain`,
  border_width: `thin|medium|thick|${CssProp.B.length}`,
  bottom: `${CssProp.B.length}|auto`,
  color: `${CssProp._COLOR.hex}|${CssProp._COLOR.rgb}|${CssProp._COLOR.rgba}|${CssProp._COLOR.name}`,
  color_stop_length: `(${CssProp.B.len_or_perc}\\s*){1,2}`,
  linear_color_hint: `${CssProp.B.len_or_perc}`,
  family_name: `${CssProp.B.string}|(${CssProp.B.ident}\\s*)+`,
  image_decl: CssProp.B.url,
  left: `${CssProp.B.length}|auto`,
  loose_quotable_words: `(${CssProp.B.ident})+`,
  margin_width: `${CssProp.B.len_or_perc}|auto`,
  padding_width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}`,
  page_url: CssProp.B.url,
  position: `((${CssProp.B.len_or_perc}|left|center|right|top|bottom)\\s*){1,4}`,
  right: `${CssProp.B.length}|auto`,
  shadow: "",
  size: `closest-side|farthest-side|closest-corner|farthest-corner|${CssProp.B.length}|(${CssProp.B.len_or_perc})\\s+(${CssProp.B.len_or_perc})`,
  top: `${CssProp.B.length}|auto`
};
CssProp._C1 = {
  image_list: `image\\(\\s*(${CssProp.B.url})*\\s*(${CssProp.B.url}|${CssProp._C.color})\\s*\\)`,
  linear_color_stop: `(${CssProp._C.color})(\\s*${CssProp._C.color_stop_length})?`,
  shadow: `((${CssProp._C.color})\\s+((${CssProp.B.length})\\s*){2,4}(s+inset)?)|((inset\\s+)?((${CssProp.B.length})\\s*){2,4}\\s*(${CssProp._C.color})?)`
};
CssProp._C2 = {
  color_stop_list: `((${CssProp._C1.linear_color_stop})(\\s*(${CssProp._C.linear_color_hint}))?\\s*,\\s*)+(${CssProp._C1.linear_color_stop})`,
  shape: `rect\\(\\s*(${CssProp._C.top})\\s*,\\s*(${CssProp._C.right})\\s*,\\s*(${CssProp._C.bottom})\\s*,\\s*(${CssProp._C.left})\\s*\\)`
};
CssProp._C3 = {
  linear_gradient: `linear-gradient\\((((${CssProp.B.angle})|to\\s+(${CssProp.A.side_or_corner}))\\s*,\\s*)?\\s*(${CssProp._C2.color_stop_list})\\s*\\)`,
  radial_gradient: `radial-gradient\\(((((${CssProp.A.ending_shape})|(${CssProp._C.size}))\\s*)*\\s*(at\\s+${CssProp._C.position})?\\s*,\\s*)?\\s*(${CssProp._C2.color_stop_list})\\s*\\)`
};
CssProp._C4 = {
  image: `${CssProp.B.url}|${CssProp._C3.linear_gradient}|${CssProp._C3.radial_gradient}|${CssProp._C1.image_list}`,
  bg_image: `(${CssProp.B.url}|${CssProp._C3.linear_gradient}|${CssProp._C3.radial_gradient}|${CssProp._C1.image_list})|none`
};
CssProp.C = {
  ...CssProp._C,
  ...CssProp._C1,
  ...CssProp._C2,
  ...CssProp._C3,
  ...CssProp._C4
};
CssProp.AP = {
  border_collapse: `collapse|separate`,
  box: `normal|none|contents`,
  box_sizing: `content-box|padding-box|border-box`,
  caption_side: `top|bottom`,
  clear: `none|left|right|both`,
  direction: `ltr|rtl`,
  empty_cells: `show|hide`,
  float: `left|right|none`,
  font_stretch: `normal|wider|narrower|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded`,
  font_style: `normal|italic|oblique`,
  font_variant: `normal|small-caps`,
  font_weight: `normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900`,
  list_style_position: `inside|outside`,
  list_style_type: `disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman|lower-greek|lower-latin|upper-latin|armenian|georgian|lower-alpha|upper-alpha|none`,
  overflow: `visible|hidden|scroll|auto`,
  overflow_wrap: `normal|break-word`,
  overflow_x: `visible|hidden|scroll|auto|no-display|no-content`,
  page_break_after: `auto|always|avoid|left|right`,
  page_break_before: `auto|always|avoid|left|right`,
  page_break_inside: `avoid|auto`,
  position: `static|relative|absolute`,
  resize: `none|both|horizontal|vertical`,
  speak: `normal|none|spell-out`,
  speak_header: `once|always`,
  speak_numeral: `digits|continuous`,
  speak_punctuation: `code|none`,
  table_layout: `auto|fixed`,
  text_align: `left|right|center|justify`,
  text_decoration: `none|((underline|overline|line-through|blink)\\s*)+`,
  text_transform: `capitalize|uppercase|lowercase|none`,
  text_wrap: `normal|unrestricted|none|suppress`,
  unicode_bidi: `normal|embed|bidi-override`,
  visibility: `visible|hidden|collapse`,
  white_space: `normal|pre|nowrap|pre-wrap|pre-line`,
  word_break: `normal|keep-all|break-all`
};
CssProp._CP = {
  background_attachment: `${CssProp.A.attachment}(,\\s*${CssProp.A.attachment})*`,
  background_color: CssProp.C.color,
  background_origin: `${CssProp.A.box}(,\\s*${CssProp.A.box})*`,
  background_repeat: `${CssProp.A.repeat_style}(,\\s*${CssProp.A.repeat_style})*`,
  border: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
  border_radius: `((${CssProp.B.len_or_perc})\\s*){1,4}(\\/\\s*((${CssProp.B.len_or_perc})\\s*){1,4})?`,
  border_spacing: `${CssProp.B.length}\\s*(${CssProp.B.length})?`,
  border_top_color: CssProp.C.color,
  border_top_style: CssProp.A.border_style,
  border_width: `((${CssProp.C.border_width})\\s*){1,4}`,
  color: CssProp.C.color,
  cursor: `(${CssProp.B.url}(\\s*,\\s*)?)*(auto|crosshair|default|pointer|move|e-resize|ne-resize|nw-resize|n-resize|se-resize|sw-resize|s-resize|w-resize|text|wait|help|progress|all-scroll|col-resize|hand|no-drop|not-allowed|row-resize|vertical-text)`,
  display: `inline|block|list-item|run-in|inline-list-item|inline-block|table|inline-table|table-cell|table-caption|flex|inline-flex|grid|inline-grid|${CssProp.A.display_inside}|${CssProp.A.display_outside}|inherit|inline-box|inline-stack`,
  display_outside: CssProp.A.display_outside,
  elevation: `${CssProp.B.angle}|below|level|above|higher|lower`,
  font_family: `(${CssProp.C.family_name}|${CssProp.A.generic_family})(,\\s*(${CssProp.C.family_name}|${CssProp.A.generic_family}))*`,
  height: `${CssProp.B.length}|${CssProp.B.percentage}|auto`,
  letter_spacing: `normal|${CssProp.B.length}`,
  list_style_image: `${CssProp.C.image}|none`,
  margin_right: CssProp.C.margin_width,
  max_height: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|none|auto`,
  min_height: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|auto`,
  opacity: CssProp.C.alphavalue,
  outline_color: `${CssProp.C.color}|invert`,
  outline_width: CssProp.C.border_width,
  padding: `((${CssProp.C.padding_width})\\s*){1,4}`,
  padding_top: CssProp.C.padding_width,
  pitch_range: CssProp.N.number,
  right: `${CssProp.B.length}|${CssProp.B.percentage}|auto`,
  stress: CssProp.N.number,
  text_indent: `${CssProp.B.length}|${CssProp.B.percentage}`,
  text_shadow: `none|${CssProp.C.shadow}(,\\s*(${CssProp.C.shadow}))*`,
  volume: `${CssProp.N.number_pos}|${CssProp.B.percentage_pos}|silent|x-soft|soft|medium|loud|x-loud`,
  word_wrap: CssProp.AP.overflow_wrap,
  zoom: `normal|${CssProp.N.number_pos}|${CssProp.B.percentage_pos}`,
  backface_visibility: CssProp.AP.visibility,
  background_clip: `${CssProp.A.box}(,\\s*(${CssProp.A.box}))*`,
  background_position: `${CssProp.C.bg_position}(,\\s*(${CssProp.C.bg_position}))*`,
  border_bottom_color: CssProp.C.color,
  border_bottom_style: CssProp.A.border_style,
  border_color: `((${CssProp.C.color})\\s*){1,4}`,
  border_left_color: CssProp.C.color,
  border_right_color: CssProp.C.color,
  border_style: `((${CssProp.A.border_style})\\s*){1,4}`,
  border_top_left_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
  border_top_width: CssProp.C.border_width,
  box_shadow: `none|${CssProp.C.shadow}(,\\s*(${CssProp.C.shadow}))*`,
  clip: `${CssProp.C.shape}|auto`,
  display_inside: CssProp.A.display_inside,
  font_size: `${CssProp.A.absolute_size}|${CssProp.A.relative_size}|${CssProp.B.length_pos}|${CssProp.B.percentage_pos}`,
  line_height: `normal|${CssProp.N.number_pos}|${CssProp.B.length_pos}|${CssProp.B.percentage_pos}`,
  margin_left: CssProp.C.margin_width,
  max_width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|none|auto`,
  outline_style: CssProp.A.border_style,
  padding_bottom: CssProp.C.padding_width,
  padding_right: CssProp.C.padding_width,
  perspective: `none|${CssProp.B.length}`,
  richness: CssProp.N.number,
  text_overflow: `((clip|ellipsis|${CssProp.B.string})\\s*){1,2}`,
  top: `${CssProp.B.length}|${CssProp.B.percentage}|auto`,
  width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|auto`,
  z_index: `auto|${CssProp.B.z_index}`,
  // Simplified background
  background: `(((${CssProp.C.bg_position}\\s*(\\/\\s*${CssProp.C.bg_size})?)|(${CssProp.A.repeat_style})|(${CssProp.A.attachment})|(${CssProp.A.bg_origin})|(${CssProp.C.bg_image})|(${CssProp.C.color}))\\s*)+`,
  background_size: `${CssProp.C.bg_size}(,\\s*${CssProp.C.bg_size})*`,
  border_bottom_left_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
  border_bottom_width: CssProp.C.border_width,
  border_left_style: CssProp.A.border_style,
  border_right_style: CssProp.A.border_style,
  border_top: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
  bottom: `${CssProp.B.len_or_perc}|auto`,
  list_style: `((${CssProp.AP.list_style_type}|${CssProp.AP.list_style_position}|${CssProp.C.image}|none})\\s*){1,3}`,
  margin_top: CssProp.C.margin_width,
  outline: `((${CssProp.C.color}|invert|${CssProp.A.border_style}|${CssProp.C.border_width})\\s*){1,3}`,
  overflow_y: CssProp.AP.overflow_x,
  pitch: `${CssProp.B.frequency}|x-low|low|medium|high|x-high`,
  vertical_align: `baseline|sub|super|top|text-top|middle|bottom|text-bottom|${CssProp.B.len_or_perc}`,
  word_spacing: `normal|${CssProp.B.length}`,
  background_image: `${CssProp.C.bg_image}(,\\s*${CssProp.C.bg_image})*`,
  border_bottom_right_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
  border_left_width: CssProp.C.border_width,
  border_right_width: CssProp.C.border_width,
  left: `${CssProp.B.len_or_perc}|auto`,
  margin_bottom: CssProp.C.margin_width,
  pause_after: `${CssProp.B.time}|${CssProp.B.percentage}`,
  speech_rate: `${CssProp.N.number}|x-slow|slow|medium|fast|x-fast|faster|slower`,
  transition_duration: `${CssProp.B.time}(,\\s*${CssProp.B.time})*`,
  border_bottom: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
  border_right: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
  margin: `((${CssProp.C.margin_width})\\s*){1,4}`,
  padding_left: CssProp.C.padding_width,
  border_left: `((${CssProp.C.border_width}|${CssProp.A.border_style}|${CssProp.C.color})\\s*){1,3}`,
  quotes: `(${CssProp.B.string}\\s*${CssProp.B.string})+|none`,
  border_top_right_radius: `(${CssProp.B.length}|${CssProp.B.percentage})(\\s*(${CssProp.B.length}|${CssProp.B.percentage}))?`,
  min_width: `${CssProp.B.length_pos}|${CssProp.B.percentage_pos}|auto`
};
CssProp._CP1 = {
  font: `(((((${CssProp.AP.font_style}|${CssProp.AP.font_variant}|${CssProp.AP.font_weight})\\s*){1,3})?\\s*(${CssProp._CP.font_size})\\s*(\\/\\s*(${CssProp._CP.line_height}))?\\s+(${CssProp._CP.font_family}))|caption|icon|menu|message-box|small-caption|status-bar)`
};
CssProp.CP = { ...CssProp._CP, ...CssProp._CP1 };
CssProp.BORDER_COLLAPSE = CssProp.reg(CssProp.AP.border_collapse);
CssProp.BOX = CssProp.reg(CssProp.AP.box);
CssProp.BOX_SIZING = CssProp.reg(CssProp.AP.box_sizing);
CssProp.CAPTION_SIDE = CssProp.reg(CssProp.AP.caption_side);
CssProp.CLEAR = CssProp.reg(CssProp.AP.clear);
CssProp.DIRECTION = CssProp.reg(CssProp.AP.direction);
CssProp.EMPTY_CELLS = CssProp.reg(CssProp.AP.empty_cells);
CssProp.FLOAT = CssProp.reg(CssProp.AP.float);
CssProp.FONT_STRETCH = CssProp.reg(CssProp.AP.font_stretch);
CssProp.FONT_STYLE = CssProp.reg(CssProp.AP.font_style);
CssProp.FONT_VARIANT = CssProp.reg(CssProp.AP.font_variant);
CssProp.FONT_WEIGHT = CssProp.reg(CssProp.AP.font_weight);
CssProp.LIST_STYLE_POSITION = CssProp.reg(CssProp.AP.list_style_position);
CssProp.LIST_STYLE_TYPE = CssProp.reg(CssProp.AP.list_style_type);
CssProp.OVERFLOW = CssProp.reg(CssProp.AP.overflow);
CssProp.OVERFLOW_WRAP = CssProp.reg(CssProp.AP.overflow_wrap);
CssProp.OVERFLOW_X = CssProp.reg(CssProp.AP.overflow_x);
CssProp.PAGE_BREAK_AFTER = CssProp.reg(CssProp.AP.page_break_after);
CssProp.PAGE_BREAK_BEFORE = CssProp.reg(CssProp.AP.page_break_before);
CssProp.PAGE_BREAK_INSIDE = CssProp.reg(CssProp.AP.page_break_inside);
CssProp.POSITION = CssProp.reg(CssProp.AP.position);
CssProp.RESIZE = CssProp.reg(CssProp.AP.resize);
CssProp.SPEAK = CssProp.reg(CssProp.AP.speak);
CssProp.SPEAK_HEADER = CssProp.reg(CssProp.AP.speak_header);
CssProp.SPEAK_NUMERAL = CssProp.reg(CssProp.AP.speak_numeral);
CssProp.SPEAK_PUNCTUATION = CssProp.reg(CssProp.AP.speak_punctuation);
CssProp.TABLE_LAYOUT = CssProp.reg(CssProp.AP.table_layout);
CssProp.TEXT_ALIGN = CssProp.reg(CssProp.AP.text_align);
CssProp.TEXT_DECORATION = CssProp.reg(CssProp.AP.text_decoration);
CssProp.TEXT_TRANSFORM = CssProp.reg(CssProp.AP.text_transform);
CssProp.TEXT_WRAP = CssProp.reg(CssProp.AP.text_wrap);
CssProp.UNICODE_BIDI = CssProp.reg(CssProp.AP.unicode_bidi);
CssProp.VISIBILITY = CssProp.reg(CssProp.AP.visibility);
CssProp.WHITE_SPACE = CssProp.reg(CssProp.AP.white_space);
CssProp.WORD_BREAK = CssProp.reg(CssProp.AP.word_break);
CssProp.BACKGROUND_ATTACHMENT = CssProp.reg(CssProp.CP.background_attachment);
CssProp.BACKGROUND_COLOR = CssProp.reg(CssProp.CP.background_color);
CssProp.BACKGROUND_ORIGIN = CssProp.reg(CssProp.CP.background_origin);
CssProp.BACKGROUND_REPEAT = CssProp.reg(CssProp.CP.background_repeat);
CssProp.BORDER = CssProp.reg(CssProp.CP.border);
CssProp.BORDER_RADIUS = CssProp.reg(CssProp.CP.border_radius);
CssProp.BORDER_SPACING = CssProp.reg(CssProp.CP.border_spacing);
CssProp.BORDER_TOP_COLOR = CssProp.reg(CssProp.CP.border_top_color);
CssProp.BORDER_TOP_STYLE = CssProp.reg(CssProp.CP.border_top_style);
CssProp.BORDER_WIDTH = CssProp.reg(CssProp.CP.border_width);
CssProp.COLOR = CssProp.reg(CssProp.CP.color);
CssProp.CURSOR = CssProp.reg(CssProp.CP.cursor);
CssProp.DISPLAY = CssProp.reg(CssProp.CP.display);
CssProp.DISPLAY_OUTSIDE = CssProp.reg(CssProp.CP.display_outside);
CssProp.ELEVATION = CssProp.reg(CssProp.CP.elevation);
CssProp.FONT_FAMILY = CssProp.reg(CssProp.CP.font_family);
CssProp.HEIGHT = CssProp.reg(CssProp.CP.height);
CssProp.LETTER_SPACING = CssProp.reg(CssProp.CP.letter_spacing);
CssProp.LIST_STYLE_IMAGE = CssProp.reg(CssProp.CP.list_style_image);
CssProp.MARGIN_RIGHT = CssProp.reg(CssProp.CP.margin_right);
CssProp.MAX_HEIGHT = CssProp.reg(CssProp.CP.max_height);
CssProp.MIN_HEIGHT = CssProp.reg(CssProp.CP.min_height);
CssProp.OPACITY = CssProp.reg(CssProp.CP.opacity);
CssProp.OUTLINE_COLOR = CssProp.reg(CssProp.CP.outline_color);
CssProp.OUTLINE_WIDTH = CssProp.reg(CssProp.CP.outline_width);
CssProp.PADDING = CssProp.reg(CssProp.CP.padding);
CssProp.PADDING_TOP = CssProp.reg(CssProp.CP.padding_top);
CssProp.PITCH_RANGE = CssProp.reg(CssProp.CP.pitch_range);
CssProp.RIGHT = CssProp.reg(CssProp.CP.right);
CssProp.STRESS = CssProp.reg(CssProp.CP.stress);
CssProp.TEXT_INDENT = CssProp.reg(CssProp.CP.text_indent);
CssProp.TEXT_SHADOW = CssProp.reg(CssProp.CP.text_shadow);
CssProp.VOLUME = CssProp.reg(CssProp.CP.volume);
CssProp.WORD_WRAP = CssProp.reg(CssProp.CP.word_wrap);
CssProp.ZOOM = CssProp.reg(CssProp.CP.zoom);
CssProp.BACKFACE_VISIBILITY = CssProp.reg(CssProp.CP.backface_visibility);
CssProp.BACKGROUND_CLIP = CssProp.reg(CssProp.CP.background_clip);
CssProp.BACKGROUND_POSITION = CssProp.reg(CssProp.CP.background_position);
CssProp.BORDER_BOTTOM_COLOR = CssProp.reg(CssProp.CP.border_bottom_color);
CssProp.BORDER_BOTTOM_STYLE = CssProp.reg(CssProp.CP.border_bottom_style);
CssProp.BORDER_COLOR = CssProp.reg(CssProp.CP.border_color);
CssProp.BORDER_LEFT_COLOR = CssProp.reg(CssProp.CP.border_left_color);
CssProp.BORDER_RIGHT_COLOR = CssProp.reg(CssProp.CP.border_right_color);
CssProp.BORDER_STYLE = CssProp.reg(CssProp.CP.border_style);
CssProp.BORDER_TOP_LEFT_RADIUS = CssProp.reg(CssProp.CP.border_top_left_radius);
CssProp.BORDER_TOP_WIDTH = CssProp.reg(CssProp.CP.border_top_width);
CssProp.BOX_SHADOW = CssProp.reg(CssProp.CP.box_shadow);
CssProp.CLIP = CssProp.reg(CssProp.CP.clip);
CssProp.DISPLAY_INSIDE = CssProp.reg(CssProp.CP.display_inside);
CssProp.FONT_SIZE = CssProp.reg(CssProp.CP.font_size);
CssProp.LINE_HEIGHT = CssProp.reg(CssProp.CP.line_height);
CssProp.MARGIN_LEFT = CssProp.reg(CssProp.CP.margin_left);
CssProp.MAX_WIDTH = CssProp.reg(CssProp.CP.max_width);
CssProp.OUTLINE_STYLE = CssProp.reg(CssProp.CP.outline_style);
CssProp.PADDING_BOTTOM = CssProp.reg(CssProp.CP.padding_bottom);
CssProp.PADDING_RIGHT = CssProp.reg(CssProp.CP.padding_right);
CssProp.PERSPECTIVE = CssProp.reg(CssProp.CP.perspective);
CssProp.RICHNESS = CssProp.reg(CssProp.CP.richness);
CssProp.TEXT_OVERFLOW = CssProp.reg(CssProp.CP.text_overflow);
CssProp.TOP = CssProp.reg(CssProp.CP.top);
CssProp.WIDTH = CssProp.reg(CssProp.CP.width);
CssProp.Z_INDEX = CssProp.reg(CssProp.CP.z_index);
CssProp.BACKGROUND = CssProp.reg(CssProp.CP.background);
CssProp.BACKGROUND_SIZE = CssProp.reg(CssProp.CP.background_size);
CssProp.BORDER_BOTTOM_LEFT_RADIUS = CssProp.reg(CssProp.CP.border_bottom_left_radius);
CssProp.BORDER_BOTTOM_WIDTH = CssProp.reg(CssProp.CP.border_bottom_width);
CssProp.BORDER_LEFT_STYLE = CssProp.reg(CssProp.CP.border_left_style);
CssProp.BORDER_RIGHT_STYLE = CssProp.reg(CssProp.CP.border_right_style);
CssProp.BORDER_TOP = CssProp.reg(CssProp.CP.border_top);
CssProp.BOTTOM = CssProp.reg(CssProp.CP.bottom);
CssProp.LIST_STYLE = CssProp.reg(CssProp.CP.list_style);
CssProp.MARGIN_TOP = CssProp.reg(CssProp.CP.margin_top);
CssProp.OUTLINE = CssProp.reg(CssProp.CP.outline);
CssProp.OVERFLOW_Y = CssProp.reg(CssProp.CP.overflow_y);
CssProp.PITCH = CssProp.reg(CssProp.CP.pitch);
CssProp.VERTICAL_ALIGN = CssProp.reg(CssProp.CP.vertical_align);
CssProp.WORD_SPACING = CssProp.reg(CssProp.CP.word_spacing);
CssProp.BACKGROUND_IMAGE = CssProp.reg(CssProp.CP.background_image);
CssProp.BORDER_BOTTOM_RIGHT_RADIUS = CssProp.reg(CssProp.CP.border_bottom_right_radius);
CssProp.BORDER_LEFT_WIDTH = CssProp.reg(CssProp.CP.border_left_width);
CssProp.BORDER_RIGHT_WIDTH = CssProp.reg(CssProp.CP.border_right_width);
CssProp.LEFT = CssProp.reg(CssProp.CP.left);
CssProp.MARGIN_BOTTOM = CssProp.reg(CssProp.CP.margin_bottom);
CssProp.PAUSE_AFTER = CssProp.reg(CssProp.CP.pause_after);
CssProp.SPEECH_RATE = CssProp.reg(CssProp.CP.speech_rate);
CssProp.TRANSITION_DURATION = CssProp.reg(CssProp.CP.transition_duration);
CssProp.BORDER_BOTTOM = CssProp.reg(CssProp.CP.border_bottom);
CssProp.BORDER_RIGHT = CssProp.reg(CssProp.CP.border_right);
CssProp.MARGIN = CssProp.reg(CssProp.CP.margin);
CssProp.PADDING_LEFT = CssProp.reg(CssProp.CP.padding_left);
CssProp.BORDER_LEFT = CssProp.reg(CssProp.CP.border_left);
CssProp.FONT = CssProp.reg(CssProp.CP.font);
CssProp.QUOTES = CssProp.reg(CssProp.CP.quotes);
CssProp.BORDER_TOP_RIGHT_RADIUS = CssProp.reg(CssProp.CP.border_top_right_radius);
CssProp.MIN_WIDTH = CssProp.reg(CssProp.CP.min_width);
class Sanitizer {
  constructor() {
    this._autolink = true;
    this._allowNamedProperties = false;
    this._generateOptions = () => ({
      // HTML tags that are allowed to be used. Tags were extracted from Google Caja
      allowedTags: [
        "a",
        "abbr",
        "acronym",
        "address",
        "area",
        "article",
        "aside",
        "audio",
        "b",
        "bdi",
        "bdo",
        "big",
        "blockquote",
        "br",
        "button",
        "canvas",
        "caption",
        "center",
        "cite",
        "code",
        "col",
        "colgroup",
        "colspan",
        "command",
        "data",
        "datalist",
        "dd",
        "del",
        "details",
        "dfn",
        "dir",
        "div",
        "dl",
        "dt",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "font",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "hgroup",
        "hr",
        "i",
        // 'iframe' is allowed by Google Caja, but disallowed by default by sanitize-html
        // , 'iframe'
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "map",
        "mark",
        "menu",
        "meter",
        "nav",
        "nobr",
        "ol",
        "optgroup",
        "option",
        "output",
        "p",
        "pre",
        "progress",
        "q",
        "rowspan",
        "s",
        "samp",
        "section",
        "select",
        "small",
        "source",
        "span",
        "strike",
        "strong",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "track",
        "tt",
        "u",
        "ul",
        "var",
        "video",
        "wbr"
      ],
      // Attributes that HTML tags are allowed to have, extracted from Google Caja.
      // See https://github.com/jupyterlab/jupyterlab/issues/1812#issuecomment-285848435
      allowedAttributes: {
        "*": [
          "class",
          "dir",
          "draggable",
          "hidden",
          ...this._allowNamedProperties ? ["id"] : [],
          "inert",
          "itemprop",
          "itemref",
          "itemscope",
          "lang",
          "spellcheck",
          "style",
          "title",
          "translate"
        ],
        // 'rel' and 'target' were *not* allowed by Google Caja
        a: [
          "accesskey",
          "coords",
          "href",
          "hreflang",
          ...this._allowNamedProperties ? ["name"] : [],
          "rel",
          "shape",
          "tabindex",
          "target",
          "type"
        ],
        area: [
          "accesskey",
          "alt",
          "coords",
          "href",
          "nohref",
          "shape",
          "tabindex"
        ],
        // 'autoplay' was *not* allowed by Google Caja
        audio: [
          "autoplay",
          "controls",
          "loop",
          "mediagroup",
          "muted",
          "preload",
          "src"
        ],
        bdo: ["dir"],
        blockquote: ["cite"],
        br: ["clear"],
        button: [
          "accesskey",
          "data-commandlinker-args",
          "data-commandlinker-command",
          "disabled",
          ...this._allowNamedProperties ? ["name"] : [],
          "tabindex",
          "type",
          "value"
        ],
        canvas: ["height", "width"],
        caption: ["align"],
        col: ["align", "char", "charoff", "span", "valign", "width"],
        colgroup: ["align", "char", "charoff", "span", "valign", "width"],
        command: [
          "checked",
          "command",
          "disabled",
          "icon",
          "label",
          "radiogroup",
          "type"
        ],
        data: ["value"],
        del: ["cite", "datetime"],
        details: ["open"],
        dir: ["compact"],
        div: ["align"],
        dl: ["compact"],
        fieldset: ["disabled"],
        font: ["color", "face", "size"],
        form: [
          "accept",
          "autocomplete",
          "enctype",
          "method",
          ...this._allowNamedProperties ? ["name"] : [],
          "novalidate"
        ],
        h1: ["align"],
        h2: ["align"],
        h3: ["align"],
        h4: ["align"],
        h5: ["align"],
        h6: ["align"],
        hr: ["align", "noshade", "size", "width"],
        iframe: [
          "align",
          "frameborder",
          "height",
          "marginheight",
          "marginwidth",
          "width"
        ],
        img: [
          "align",
          "alt",
          "border",
          "height",
          "hspace",
          "ismap",
          ...this._allowNamedProperties ? ["name"] : [],
          "src",
          "usemap",
          "vspace",
          "width"
        ],
        input: [
          "accept",
          "accesskey",
          "align",
          "alt",
          "autocomplete",
          "checked",
          "disabled",
          "inputmode",
          "ismap",
          "list",
          "max",
          "maxlength",
          "min",
          "multiple",
          ...this._allowNamedProperties ? ["name"] : [],
          "placeholder",
          "readonly",
          "required",
          "size",
          "src",
          "step",
          "tabindex",
          "type",
          "usemap",
          "value"
        ],
        ins: ["cite", "datetime"],
        label: ["accesskey", "for"],
        legend: ["accesskey", "align"],
        li: ["type", "value"],
        map: this._allowNamedProperties ? ["name"] : [],
        menu: ["compact", "label", "type"],
        meter: ["high", "low", "max", "min", "value"],
        ol: ["compact", "reversed", "start", "type"],
        optgroup: ["disabled", "label"],
        option: ["disabled", "label", "selected", "value"],
        output: ["for", ...this._allowNamedProperties ? ["name"] : []],
        p: ["align"],
        pre: ["width"],
        progress: ["max", "min", "value"],
        q: ["cite"],
        select: [
          "autocomplete",
          "disabled",
          "multiple",
          ...this._allowNamedProperties ? ["name"] : [],
          "required",
          "size",
          "tabindex"
        ],
        source: ["type"],
        table: [
          "align",
          "bgcolor",
          "border",
          "cellpadding",
          "cellspacing",
          "frame",
          "rules",
          "summary",
          "width"
        ],
        tbody: ["align", "char", "charoff", "valign"],
        td: [
          "abbr",
          "align",
          "axis",
          "bgcolor",
          "char",
          "charoff",
          "colspan",
          "headers",
          "height",
          "nowrap",
          "rowspan",
          "scope",
          "valign",
          "width"
        ],
        textarea: [
          "accesskey",
          "autocomplete",
          "cols",
          "disabled",
          "inputmode",
          ...this._allowNamedProperties ? ["name"] : [],
          "placeholder",
          "readonly",
          "required",
          "rows",
          "tabindex",
          "wrap"
        ],
        tfoot: ["align", "char", "charoff", "valign"],
        th: [
          "abbr",
          "align",
          "axis",
          "bgcolor",
          "char",
          "charoff",
          "colspan",
          "headers",
          "height",
          "nowrap",
          "rowspan",
          "scope",
          "valign",
          "width"
        ],
        thead: ["align", "char", "charoff", "valign"],
        tr: ["align", "bgcolor", "char", "charoff", "valign"],
        track: ["default", "kind", "label", "srclang"],
        ul: ["compact", "type"],
        video: [
          "autoplay",
          "controls",
          "height",
          "loop",
          "mediagroup",
          "muted",
          "poster",
          "preload",
          "src",
          "width"
        ]
      },
      // Inline CSS styles that HTML tags may have (and their allowed values)
      allowedStyles: {
        // To simplify the data, all styles are allowed on all tags that allow the style attribute
        "*": {
          "backface-visibility": [CssProp.BACKFACE_VISIBILITY],
          background: [CssProp.BACKGROUND],
          "background-attachment": [CssProp.BACKGROUND_ATTACHMENT],
          "background-clip": [CssProp.BACKGROUND_CLIP],
          "background-color": [CssProp.BACKGROUND_COLOR],
          "background-image": [CssProp.BACKGROUND_IMAGE],
          "background-origin": [CssProp.BACKGROUND_ORIGIN],
          "background-position": [CssProp.BACKGROUND_POSITION],
          "background-repeat": [CssProp.BACKGROUND_REPEAT],
          "background-size": [CssProp.BACKGROUND_SIZE],
          border: [CssProp.BORDER],
          "border-bottom": [CssProp.BORDER_BOTTOM],
          "border-bottom-color": [CssProp.BORDER_BOTTOM_COLOR],
          "border-bottom-left-radius": [CssProp.BORDER_BOTTOM_LEFT_RADIUS],
          "border-bottom-right-radius": [CssProp.BORDER_BOTTOM_RIGHT_RADIUS],
          "border-bottom-style": [CssProp.BORDER_BOTTOM_STYLE],
          "border-bottom-width": [CssProp.BORDER_BOTTOM_WIDTH],
          "border-collapse": [CssProp.BORDER_COLLAPSE],
          "border-color": [CssProp.BORDER_COLOR],
          "border-left": [CssProp.BORDER_LEFT],
          "border-left-color": [CssProp.BORDER_LEFT_COLOR],
          "border-left-style": [CssProp.BORDER_LEFT_STYLE],
          "border-left-width": [CssProp.BORDER_LEFT_WIDTH],
          "border-radius": [CssProp.BORDER_RADIUS],
          "border-right": [CssProp.BORDER_RIGHT],
          "border-right-color": [CssProp.BORDER_RIGHT_COLOR],
          "border-right-style": [CssProp.BORDER_RIGHT_STYLE],
          "border-right-width": [CssProp.BORDER_RIGHT_WIDTH],
          "border-spacing": [CssProp.BORDER_SPACING],
          "border-style": [CssProp.BORDER_STYLE],
          "border-top": [CssProp.BORDER_TOP],
          "border-top-color": [CssProp.BORDER_TOP_COLOR],
          "border-top-left-radius": [CssProp.BORDER_TOP_LEFT_RADIUS],
          "border-top-right-radius": [CssProp.BORDER_TOP_RIGHT_RADIUS],
          "border-top-style": [CssProp.BORDER_TOP_STYLE],
          "border-top-width": [CssProp.BORDER_TOP_WIDTH],
          "border-width": [CssProp.BORDER_WIDTH],
          bottom: [CssProp.BOTTOM],
          box: [CssProp.BOX],
          "box-shadow": [CssProp.BOX_SHADOW],
          "box-sizing": [CssProp.BOX_SIZING],
          "caption-side": [CssProp.CAPTION_SIDE],
          clear: [CssProp.CLEAR],
          clip: [CssProp.CLIP],
          color: [CssProp.COLOR],
          cursor: [CssProp.CURSOR],
          direction: [CssProp.DIRECTION],
          display: [CssProp.DISPLAY],
          "display-inside": [CssProp.DISPLAY_INSIDE],
          "display-outside": [CssProp.DISPLAY_OUTSIDE],
          elevation: [CssProp.ELEVATION],
          "empty-cells": [CssProp.EMPTY_CELLS],
          float: [CssProp.FLOAT],
          font: [CssProp.FONT],
          "font-family": [CssProp.FONT_FAMILY],
          "font-size": [CssProp.FONT_SIZE],
          "font-stretch": [CssProp.FONT_STRETCH],
          "font-style": [CssProp.FONT_STYLE],
          "font-variant": [CssProp.FONT_VARIANT],
          "font-weight": [CssProp.FONT_WEIGHT],
          height: [CssProp.HEIGHT],
          left: [CssProp.LEFT],
          "letter-spacing": [CssProp.LETTER_SPACING],
          "line-height": [CssProp.LINE_HEIGHT],
          "list-style": [CssProp.LIST_STYLE],
          "list-style-image": [CssProp.LIST_STYLE_IMAGE],
          "list-style-position": [CssProp.LIST_STYLE_POSITION],
          "list-style-type": [CssProp.LIST_STYLE_TYPE],
          margin: [CssProp.MARGIN],
          "margin-bottom": [CssProp.MARGIN_BOTTOM],
          "margin-left": [CssProp.MARGIN_LEFT],
          "margin-right": [CssProp.MARGIN_RIGHT],
          "margin-top": [CssProp.MARGIN_TOP],
          "max-height": [CssProp.MAX_HEIGHT],
          "max-width": [CssProp.MAX_WIDTH],
          "min-height": [CssProp.MIN_HEIGHT],
          "min-width": [CssProp.MIN_WIDTH],
          opacity: [CssProp.OPACITY],
          outline: [CssProp.OUTLINE],
          "outline-color": [CssProp.OUTLINE_COLOR],
          "outline-style": [CssProp.OUTLINE_STYLE],
          "outline-width": [CssProp.OUTLINE_WIDTH],
          overflow: [CssProp.OVERFLOW],
          "overflow-wrap": [CssProp.OVERFLOW_WRAP],
          "overflow-x": [CssProp.OVERFLOW_X],
          "overflow-y": [CssProp.OVERFLOW_Y],
          padding: [CssProp.PADDING],
          "padding-bottom": [CssProp.PADDING_BOTTOM],
          "padding-left": [CssProp.PADDING_LEFT],
          "padding-right": [CssProp.PADDING_RIGHT],
          "padding-top": [CssProp.PADDING_TOP],
          "page-break-after": [CssProp.PAGE_BREAK_AFTER],
          "page-break-before": [CssProp.PAGE_BREAK_BEFORE],
          "page-break-inside": [CssProp.PAGE_BREAK_INSIDE],
          "pause-after": [CssProp.PAUSE_AFTER],
          perspective: [CssProp.PERSPECTIVE],
          pitch: [CssProp.PITCH],
          "pitch-range": [CssProp.PITCH_RANGE],
          position: [CssProp.POSITION],
          quotes: [CssProp.QUOTES],
          resize: [CssProp.RESIZE],
          richness: [CssProp.RICHNESS],
          right: [CssProp.RIGHT],
          speak: [CssProp.SPEAK],
          "speak-header": [CssProp.SPEAK_HEADER],
          "speak-numeral": [CssProp.SPEAK_NUMERAL],
          "speak-punctuation": [CssProp.SPEAK_PUNCTUATION],
          "speech-rate": [CssProp.SPEECH_RATE],
          stress: [CssProp.STRESS],
          "table-layout": [CssProp.TABLE_LAYOUT],
          "text-align": [CssProp.TEXT_ALIGN],
          "text-decoration": [CssProp.TEXT_DECORATION],
          "text-indent": [CssProp.TEXT_INDENT],
          "text-overflow": [CssProp.TEXT_OVERFLOW],
          "text-shadow": [CssProp.TEXT_SHADOW],
          "text-transform": [CssProp.TEXT_TRANSFORM],
          "text-wrap": [CssProp.TEXT_WRAP],
          top: [CssProp.TOP],
          "unicode-bidi": [CssProp.UNICODE_BIDI],
          "vertical-align": [CssProp.VERTICAL_ALIGN],
          visibility: [CssProp.VISIBILITY],
          volume: [CssProp.VOLUME],
          "white-space": [CssProp.WHITE_SPACE],
          width: [CssProp.WIDTH],
          "word-break": [CssProp.WORD_BREAK],
          "word-spacing": [CssProp.WORD_SPACING],
          "word-wrap": [CssProp.WORD_WRAP],
          "z-index": [CssProp.Z_INDEX],
          zoom: [CssProp.ZOOM]
        }
      },
      transformTags: {
        // Set the "rel" attribute for <a> tags to "nofollow".
        a: sanitize.simpleTransform("a", { rel: "nofollow" }),
        // Set the "disabled" attribute for <input> tags.
        input: sanitize.simpleTransform("input", { disabled: "disabled" })
      },
      allowedSchemes: [...sanitize.defaults.allowedSchemes],
      allowedSchemesByTag: {
        // Allow 'attachment:' img src (used for markdown cell attachments).
        img: sanitize.defaults.allowedSchemes.concat(["attachment"])
      },
      // Override of the default option, so we can skip 'src' attribute validation.
      // 'src' Attributes are validated to be URIs, which does not allow for embedded (image) data.
      // Since embedded data is no longer deemed to be a threat, validation can be skipped.
      // See https://github.com/jupyterlab/jupyterlab/issues/5183
      allowedSchemesAppliedToAttributes: ["href", "cite"]
    });
    this._options = this._generateOptions();
  }
  /**
   * Sanitize an HTML string.
   *
   * @param dirty - The dirty text.
   *
   * @param options - The optional sanitization options.
   *
   * @returns The sanitized string.
   */
  sanitize(dirty, options) {
    return sanitize(dirty, { ...this._options, ...options || {} });
  }
  /**
   * @returns Whether to replace URLs by HTML anchors.
   */
  getAutolink() {
    return this._autolink;
  }
  /**
   * Set the allowed schemes
   *
   * @param scheme Allowed schemes
   */
  setAllowedSchemes(scheme) {
    this._options.allowedSchemes = [...scheme];
  }
  /**
   * Set the URL replacement boolean.
   *
   * @param autolink URL replacement boolean.
   */
  setAutolink(autolink) {
    this._autolink = autolink;
  }
  /**
   * Set the whether to allow `name` and `id` attributes.
   */
  setAllowNamedProperties(allowNamedProperties) {
    this._allowNamedProperties = allowNamedProperties;
    this._options = this._generateOptions();
  }
}
const COLLAPSER_CLASS = "jp-Collapser";
const COLLAPSER_CHILD_CLASS = "jp-Collapser-child";
const INPUT_COLLAPSER = "jp-InputCollapser";
const OUTPUT_COLLAPSER = "jp-OutputCollapser";
class Collapser extends ReactWidget {
  /**
   * Construct a new collapser.
   */
  constructor() {
    super();
    this.addClass(COLLAPSER_CLASS);
  }
  /**
   * Is the input/output of the parent collapsed.
   */
  get collapsed() {
    return false;
  }
  /**
   * Render the collapser with the virtual DOM.
   */
  render() {
    const childClass = COLLAPSER_CHILD_CLASS;
    return reactExports.createElement("div", { className: childClass, onClick: (e) => this.handleClick(e) });
  }
}
class InputCollapser extends Collapser {
  /**
   * Construct a new input collapser.
   */
  constructor() {
    super();
    this.addClass(INPUT_COLLAPSER);
  }
  /**
   * Is the cell's input collapsed?
   */
  get collapsed() {
    var _a;
    const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;
    if (cell) {
      return cell.inputHidden;
    } else {
      return false;
    }
  }
  /**
   * Handle a click event for the user to collapse the cell's input.
   */
  handleClick(e) {
    var _a;
    const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;
    if (cell) {
      cell.inputHidden = !cell.inputHidden;
    }
    this.update();
  }
}
class OutputCollapser extends Collapser {
  /**
   * Construct a new output collapser.
   */
  constructor() {
    super();
    this.addClass(OUTPUT_COLLAPSER);
  }
  /**
   * Is the cell's output collapsed?
   */
  get collapsed() {
    var _a;
    const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;
    if (cell) {
      return cell.outputHidden;
    } else {
      return false;
    }
  }
  /**
   * Handle a click event for the user to collapse the cell's output.
   */
  handleClick(e) {
    var _a, _b;
    const cell = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.parent;
    if (cell) {
      cell.outputHidden = !cell.outputHidden;
      if (cell.outputHidden) {
        let area = (_b = cell.parent) === null || _b === void 0 ? void 0 : _b.node;
        if (area) {
          ElementExt.scrollIntoViewIfNeeded(area, cell.node);
        }
      }
    }
    this.update();
  }
}
const CELL_HEADER_CLASS$1 = "jp-CellHeader";
const CELL_FOOTER_CLASS$1 = "jp-CellFooter";
class CellHeader extends Widget {
  /**
   * Construct a new cell header.
   */
  constructor() {
    super();
    this.addClass(CELL_HEADER_CLASS$1);
  }
}
class CellFooter extends Widget {
  /**
   * Construct a new cell footer.
   */
  constructor() {
    super();
    this.addClass(CELL_FOOTER_CLASS$1);
  }
}
const createMutex = () => {
  let token = true;
  return (f) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    }
  };
};
const floor = Math.floor;
const abs = Math.abs;
const min = (a, b) => a < b ? a : b;
const max = (a, b) => a > b ? a : b;
const isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;
const BIT1 = 1;
const BIT2 = 2;
const BIT3 = 4;
const BIT4 = 8;
const BIT6 = 32;
const BIT7 = 64;
const BIT8 = 128;
const BITS5 = 31;
const BITS6 = 63;
const BITS7 = 127;
const BITS31 = 2147483647;
const isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
const create$5 = () => /* @__PURE__ */ new Set();
const last = (arr) => arr[arr.length - 1];
const appendTo = (dest, src) => {
  for (let i2 = 0; i2 < src.length; i2++) {
    dest.push(src[i2]);
  }
};
const from = Array.from;
const some = (arr, f) => {
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (f(arr[i2], i2, arr)) {
      return true;
    }
  }
  return false;
};
const isArray = Array.isArray;
const toLowerCase = (s) => s.toLowerCase();
const trimLeftRegex = /^\s*/g;
const trimLeft = (s) => s.replace(trimLeftRegex, "");
const fromCamelCaseRegex = /([A-Z])/g;
const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
const _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    buf[i2] = /** @type {number} */
    encodedString.codePointAt(i2);
  }
  return buf;
};
const utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
const _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
let utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}
class Encoder {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
}
const createEncoder = () => new Encoder();
const length$1 = (encoder) => {
  let len = encoder.cpos;
  for (let i2 = 0; i2 < encoder.bufs.length; i2++) {
    len += encoder.bufs[i2].length;
  }
  return len;
};
const toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length$1(encoder));
  let curPos = 0;
  for (let i2 = 0; i2 < encoder.bufs.length; i2++) {
    const d = encoder.bufs[i2];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
const verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
const write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
const writeUint8 = write;
const writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
const writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
const _strBuffer = new Uint8Array(3e4);
const _maxStrBSize = _strBuffer.length / 3;
const _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i2 = 0; i2 < written; i2++) {
      write(encoder, _strBuffer[i2]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
const _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i2 = 0; i2 < len; i2++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i2)
    );
  }
};
const writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
const writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
const writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
const writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
const writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
const floatTestBed = new DataView(new ArrayBuffer(4));
const isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
const writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i2 = 0; i2 < data.length; i2++) {
          writeAny(encoder, data[i2]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys2 = Object.keys(data);
        writeVarUint(encoder, keys2.length);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const key2 = keys2[i2];
          writeVarString(encoder, key2);
          writeAny(encoder, data[key2]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
class RleEncoder extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v);
      this.s = v;
    }
  }
}
const flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
class UintOptRleEncoder {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
}
const flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
class IntDiffOptRleEncoder {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.diff === v - this.s) {
      this.s = v;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v - this.s;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
}
class StringEncoder {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
}
const create$4 = (s) => new Error(s);
const methodUnimplemented = () => {
  throw create$4("Method unimplemented");
};
const unexpectedCase = () => {
  throw create$4("Unexpected case");
};
const getUnixTime = Date.now;
const create$3 = () => /* @__PURE__ */ new Map();
const copy = (m2) => {
  const r = create$3();
  m2.forEach((v, k) => {
    r.set(k, v);
  });
  return r;
};
const setIfUndefined = (map2, key2, createT) => {
  let set2 = map2.get(key2);
  if (set2 === void 0) {
    map2.set(key2, set2 = createT());
  }
  return set2;
};
const map = (m2, f) => {
  const res = [];
  for (const [key2, value] of m2) {
    res.push(f(value, key2));
  }
  return res;
};
const any = (m2, f) => {
  for (const [key2, value] of m2) {
    if (f(value, key2)) {
      return true;
    }
  }
  return false;
};
class ObservableV2 {
  constructor() {
    this._observers = create$3();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name2, f) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name2,
      create$5
    ).add(f);
    return f;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name2, f) {
    const _f = (...args) => {
      this.off(
        name2,
        /** @type {any} */
        _f
      );
      f(...args);
    };
    this.on(
      name2,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name2, f) {
    const observers2 = this._observers.get(name2);
    if (observers2 !== void 0) {
      observers2.delete(f);
      if (observers2.size === 0) {
        this._observers.delete(name2);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name2, args) {
    return from((this._observers.get(name2) || create$3()).values()).forEach((f) => f(...args));
  }
  destroy() {
    this._observers = create$3();
  }
}
class Observable {
  constructor() {
    this._observers = create$3();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name2, f) {
    setIfUndefined(this._observers, name2, create$5).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name2, f) {
    const _f = (...args) => {
      this.off(name2, _f);
      f(...args);
    };
    this.on(name2, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name2, f) {
    const observers2 = this._observers.get(name2);
    if (observers2 !== void 0) {
      observers2.delete(f);
      if (observers2.size === 0) {
        this._observers.delete(name2);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name2, args) {
    return from((this._observers.get(name2) || create$3()).values()).forEach((f) => f(...args));
  }
  destroy() {
    this._observers = create$3();
  }
}
const assign = Object.assign;
const keys = Object.keys;
const forEach = (obj, f) => {
  for (const key2 in obj) {
    f(obj[key2], key2);
  }
};
const length = (obj) => keys(obj).length;
const size = (obj) => keys(obj).length;
const isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
const every = (obj, f) => {
  for (const key2 in obj) {
    if (!f(obj[key2], key2)) {
      return false;
    }
  }
  return true;
};
const hasProperty = (obj, key2) => Object.prototype.hasOwnProperty.call(obj, key2);
const equalFlat = (a, b) => a === b || size(a) === size(b) && every(a, (val, key2) => (val !== void 0 || hasProperty(b, key2)) && b[key2] === val);
const freeze = Object.freeze;
const deepFreeze = (o) => {
  for (const key2 in o) {
    const c = o[key2];
    if (typeof c === "object" || typeof c === "function") {
      deepFreeze(o[key2]);
    }
  }
  return freeze(o);
};
const callAll = (fs, args, i2 = 0) => {
  try {
    for (; i2 < fs.length; i2++) {
      fs[i2](...args);
    }
  } finally {
    if (i2 < fs.length) {
      callAll(fs, args, i2 + 1);
    }
  }
};
const equalityStrict = (a, b) => a === b;
const equalityDeep = (a, b) => {
  if (a == null || b == null) {
    return equalityStrict(a, b);
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a === b) {
    return true;
  }
  switch (a.constructor) {
    case ArrayBuffer:
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case Uint8Array: {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b[i2]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a.size !== b.size) {
        return false;
      }
      for (const value of a) {
        if (!b.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a.size !== b.size) {
        return false;
      }
      for (const key2 of a.keys()) {
        if (!b.has(key2) || !equalityDeep(a.get(key2), b.get(key2))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length(a) !== length(b)) {
        return false;
      }
      for (const key2 in a) {
        if (!hasProperty(a, key2) || !equalityDeep(a[key2], b[key2])) {
          return false;
        }
      }
      break;
    case Array:
      if (a.length !== b.length) {
        return false;
      }
      for (let i2 = 0; i2 < a.length; i2++) {
        if (!equalityDeep(a[i2], b[i2])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
const isOneOf = (value, options) => options.includes(value);
const getRandomValues = crypto.getRandomValues.bind(crypto);
const uint32 = () => getRandomValues(new Uint32Array(1))[0];
const uuidv4Template = "10000000-1000-4000-8000" + -1e11;
const uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
);
const create$2 = (f) => (
  /** @type {Promise<T>} */
  new Promise(f)
);
Promise.all.bind(Promise);
const undefinedToNull = (v) => v === void 0 ? null : v;
class VarStoragePolyfill {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key2, newValue) {
    this.map.set(key2, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key2) {
    return this.map.get(key2);
  }
}
let _localStorage = new VarStoragePolyfill();
let usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
const varStorage = _localStorage;
const isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
let params;
const computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create$3();
      const pargs = process.argv;
      let currParamName = null;
      for (let i2 = 0; i2 < pargs.length; i2++) {
        const parg = pargs[i2];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create$3();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key2, value] = kv.split("=");
          params.set(`--${fromCamelCase(key2, "-")}`, value);
          params.set(`-${fromCamelCase(key2, "-")}`, value);
        }
      });
    } else {
      params = create$3();
    }
  }
  return params;
};
const hasParam = (name2) => computeParams().has(name2);
const getVariable = (name2) => isNode ? undefinedToNull(process.env[name2.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name2));
const hasConf = (name2) => hasParam("--" + name2) || getVariable(name2) !== null;
hasConf("production");
const forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
const supportsColor = forceColor || !hasParam("--no-colors") && // @todo deprecate --no-colors
!hasConf("no-color") && (!isNode || process.stdout.isTTY) && (!isNode || hasParam("--color") || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));
class Pair {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
}
const create$1 = (left, right) => new Pair(left, right);
typeof DOMParser !== "undefined" ? new DOMParser() : null;
const mapToStyleString = (m2) => map(m2, (value, key2) => `${key2}:${value};`).join("");
const create = Symbol;
const BOLD = create();
const UNBOLD = create();
const BLUE = create();
const GREY = create();
const GREEN = create();
const RED = create();
const PURPLE = create();
const ORANGE = create();
const UNCOLOR = create();
const computeNoColorLoggingArgs = (args) => {
  var _a;
  if (args.length === 1 && ((_a = args[0]) == null ? void 0 : _a.constructor) === Function) {
    args = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i2 = 0;
  for (; i2 < args.length; i2++) {
    const arg = args[i2];
    if (arg === void 0) {
      break;
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      break;
    }
  }
  if (i2 > 0) {
    logArgs.push(strBuilder.join(""));
  }
  for (; i2 < args.length; i2++) {
    const arg = args[i2];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
const _browserStyleMap = {
  [BOLD]: create$1("font-weight", "bold"),
  [UNBOLD]: create$1("font-weight", "normal"),
  [BLUE]: create$1("color", "blue"),
  [GREEN]: create$1("color", "green"),
  [GREY]: create$1("color", "grey"),
  [RED]: create$1("color", "red"),
  [PURPLE]: create$1("color", "purple"),
  [ORANGE]: create$1("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create$1("color", "black")
};
const computeBrowserLoggingArgs = (args) => {
  var _a;
  if (args.length === 1 && ((_a = args[0]) == null ? void 0 : _a.constructor) === Function) {
    args = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args[0]();
  }
  const strBuilder = [];
  const styles = [];
  const currentStyle = create$3();
  let logArgs = [];
  let i2 = 0;
  for (; i2 < args.length; i2++) {
    const arg = args[i2];
    const style2 = _browserStyleMap[arg];
    if (style2 !== void 0) {
      currentStyle.set(style2.left, style2.right);
    } else {
      if (arg === void 0) {
        break;
      }
      if (arg.constructor === String || arg.constructor === Number) {
        const style3 = mapToStyleString(currentStyle);
        if (i2 > 0 || style3.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style3);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i2 > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i2 < args.length; i2++) {
    const arg = args[i2];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
const computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
const print = (...args) => {
  console.log(...computeLoggingArgs(args));
  vconsoles.forEach((vc) => vc.print(args));
};
const warn = (...args) => {
  console.warn(...computeLoggingArgs(args));
  args.unshift(ORANGE);
  vconsoles.forEach((vc) => vc.print(args));
};
const vconsoles = create$5();
const createIterator = (next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
});
const iteratorFilter = (iterator, filter2) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter2(res.value));
  return res;
});
const iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? void 0 : fmap(value) };
});
class DeleteItem {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
}
class DeleteSet {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  for (let i2 = 0; i2 < deletes.length; i2++) {
    const del = deletes[i2];
    iterateStructs(transaction, structs, del.clock, del.len, f);
  }
});
const findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
const isDeleted = (ds, id) => {
  const dis = ds.clients.get(id.client);
  return dis !== void 0 && findIndexDS(dis, id.clock) !== null;
};
const sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a, b) => a.clock - b.clock);
    let i2, j;
    for (i2 = 1, j = 1; i2 < dels.length; i2++) {
      const left = dels[j - 1];
      const right = dels[i2];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i2) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
};
const mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i2 = dssI + 1; i2 < dss.length; i2++) {
          appendTo(dels, dss[i2].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
const addToDeleteSet = (ds, client, clock, length2) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length2));
};
const writeDeleteSet = (encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i2 = 0; i2 < len; i2++) {
      const item = dsitems[i2];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
const generateNewClientId = uint32;
class Doc extends ObservableV2 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.isDestroyed = false;
    this.whenLoaded = create$2((resolve3) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve3(this);
      });
    });
    const provideSyncedPromise = () => create$2((resolve3) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve3();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f, origin = null) {
    return transact(this, f, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name2, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type = setIfUndefined(this.share, name2, () => {
      const t = new TypeConstructor();
      t._integrate(this, null);
      return t;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t = new TypeConstructor();
        t._map = type._map;
        type._map.forEach(
          /** @param {Item?} n */
          (n) => {
            for (; n !== null; n = n.left) {
              n.parent = t;
            }
          }
        );
        t._start = type._start;
        for (let n = t._start; n !== null; n = n.right) {
          n.parent = t;
        }
        t._length = type._length;
        this.share.set(name2, t);
        t._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t
        );
      } else {
        throw new Error(`Type with the name ${name2} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name2 = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name2, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name2 = "") {
    return this.get(name2, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name2 = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name2, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name2 = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name2, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name2 = "") {
    return this.get(name2, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key2) => {
      doc2[key2] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = true;
    from(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
}
class DSEncoderV1 {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
}
class UpdateEncoderV1 extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id) {
    writeVarUint(this.restEncoder, id.client);
    writeVarUint(this.restEncoder, id.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id) {
    writeVarUint(this.restEncoder, id.client);
    writeVarUint(this.restEncoder, id.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    writeVarString(this.restEncoder, s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key2) {
    writeVarString(this.restEncoder, key2);
  }
}
class DSEncoderV2 {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
}
class UpdateEncoderV2 extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id) {
    this.clientEncoder.write(id.client);
    this.leftClockEncoder.write(id.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id) {
    this.clientEncoder.write(id.client);
    this.rightClockEncoder.write(id.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    this.stringEncoder.write(s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key2) {
    const clock = this.keyMap.get(key2);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key2);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
}
const writeStructs = (encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i2 = startNewStructs + 1; i2 < structs.length; i2++) {
    structs[i2].write(encoder, 0);
  }
};
const writeClientsStructs = (encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
};
const writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
class EventHandler {
  constructor() {
    this.l = [];
  }
}
const createEventHandler = () => new EventHandler();
const addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
const removeEventHandlerListener = (eventHandler, f) => {
  const l = eventHandler.l;
  const len = l.length;
  eventHandler.l = l.filter((g) => f !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
const callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
class ID {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
}
const compareIDs = (a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
const createID = (client, clock) => new ID(client, clock);
const findRootTypeKey = (type) => {
  for (const [key2, value] of type.doc.share.entries()) {
    if (value === type) {
      return key2;
    }
  }
  throw unexpectedCase();
};
const isParentOf = (parent, child) => {
  while (child !== null) {
    if (child.parent === parent) {
      return true;
    }
    child = /** @type {AbstractType<any>} */
    child.parent._item;
  }
  return false;
};
const isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
const splitSnapshotAffectedStructs = (transaction, snapshot) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create$5);
  const store = transaction.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot.ds, (_item) => {
    });
    meta.add(snapshot);
  }
};
class StructStore {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
}
const getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
const getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
const addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
const findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
const find$1 = (store, id) => {
  const structs = store.clients.get(id.client);
  return structs[findIndexSS(structs, id.clock)];
};
const getItem = (
  /** @type {function(StructStore,ID):Item} */
  find$1
);
const findIndexCleanStart = (transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
};
const getItemCleanStart = (transaction, id) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id.clock)];
};
const getItemCleanEnd = (transaction, store, id) => {
  const structs = store.clients.get(id.client);
  const index = findIndexSS(structs, id.clock);
  const struct = structs[index];
  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));
  }
  return struct;
};
const replaceStruct = (store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
const iterateStructs = (transaction, structs, clockStart, len, f) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
};
let Transaction$1 = class Transaction2 {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
const writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
const addChangedTypeToTransaction = (transaction, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type, create$5).add(parentSub);
  }
};
const tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i2 = pos;
  for (; i2 > 0; right = left, left = structs[--i2 - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i2;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
const tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
const tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
const cleanupTransactions = (transactionCleanups, i2) => {
  if (i2 < transactionCleanups.length) {
    const transaction = transactionCleanups[i2];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events, type) => {
          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
            events = events.filter(
              (event2) => event2.target._item === null || !event2.target._item.deleted
            );
            events.forEach((event2) => {
              event2.currentTarget = type;
              event2._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type._dEH, events, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i3 = structs.length - 1; i3 >= firstChangePos; ) {
            i3 -= 1 + tryToMergeWithLefts(structs, i3);
          }
        }
      });
      for (let i3 = mergeStructs.length - 1; i3 >= 0; i3--) {
        const { client, clock } = mergeStructs[i3].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i2 + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i2 + 1);
      }
    }
  }
};
const transact = (doc2, f, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result2 = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction$1(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result2 = f(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result2;
};
class StackItem {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(deletions, insertions) {
    this.insertions = insertions;
    this.deletions = deletions;
    this.meta = /* @__PURE__ */ new Map();
  }
}
const clearUndoManagerStackItem = (tr, um, stackItem) => {
  iterateDeletedStructs(tr, stackItem.deletions, (item) => {
    if (item instanceof Item && um.scope.some((type) => isParentOf(type, item))) {
      keepItem(item, false);
    }
  });
};
const popStackItem = (undoManager, stack, eventType) => {
  let _tr = null;
  const doc2 = undoManager.doc;
  const scope = undoManager.scope;
  transact(doc2, (transaction) => {
    while (stack.length > 0 && undoManager.currStackItem === null) {
      const store = doc2.store;
      const stackItem = (
        /** @type {StackItem} */
        stack.pop()
      );
      const itemsToRedo = /* @__PURE__ */ new Set();
      const itemsToDelete = [];
      let performedChange = false;
      iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
        if (struct instanceof Item) {
          if (struct.redone !== null) {
            let { item, diff } = followRedone(store, struct.id);
            if (diff > 0) {
              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
            }
            struct = item;
          }
          if (!struct.deleted && scope.some((type) => isParentOf(
            type,
            /** @type {Item} */
            struct
          ))) {
            itemsToDelete.push(struct);
          }
        }
      });
      iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
        if (struct instanceof Item && scope.some((type) => isParentOf(type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !isDeleted(stackItem.insertions, struct.id)) {
          itemsToRedo.add(struct);
        }
      });
      itemsToRedo.forEach((struct) => {
        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
      });
      for (let i2 = itemsToDelete.length - 1; i2 >= 0; i2--) {
        const item = itemsToDelete[i2];
        if (undoManager.deleteFilter(item)) {
          item.delete(transaction);
          performedChange = true;
        }
      }
      undoManager.currStackItem = performedChange ? stackItem : null;
    }
    transaction.changed.forEach((subProps, type) => {
      if (subProps.has(null) && type._searchMarker) {
        type._searchMarker.length = 0;
      }
    });
    _tr = transaction;
  }, undoManager);
  const res = undoManager.currStackItem;
  if (res != null) {
    const changedParentTypes = _tr.changedParentTypes;
    undoManager.emit("stack-item-popped", [{ stackItem: res, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);
    undoManager.currStackItem = null;
  }
  return res;
};
class UndoManager extends ObservableV2 {
  /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */
  constructor(typeScope, {
    captureTimeout = 500,
    captureTransaction = (_tr) => true,
    deleteFilter = () => true,
    trackedOrigins = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges = false,
    doc: doc2 = (
      /** @type {Doc} */
      isArray(typeScope) ? typeScope[0].doc : typeScope.doc
    )
  } = {}) {
    super();
    this.scope = [];
    this.doc = doc2;
    this.addToScope(typeScope);
    this.deleteFilter = deleteFilter;
    trackedOrigins.add(this);
    this.trackedOrigins = trackedOrigins;
    this.captureTransaction = captureTransaction;
    this.undoStack = [];
    this.redoStack = [];
    this.undoing = false;
    this.redoing = false;
    this.currStackItem = null;
    this.lastChange = 0;
    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
    this.captureTimeout = captureTimeout;
    this.afterTransactionHandler = (transaction) => {
      if (!this.captureTransaction(transaction) || !this.scope.some((type) => transaction.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
        return;
      }
      const undoing = this.undoing;
      const redoing = this.redoing;
      const stack = undoing ? this.redoStack : this.undoStack;
      if (undoing) {
        this.stopCapturing();
      } else if (!redoing) {
        this.clear(false, true);
      }
      const insertions = new DeleteSet();
      transaction.afterState.forEach((endClock, client) => {
        const startClock = transaction.beforeState.get(client) || 0;
        const len = endClock - startClock;
        if (len > 0) {
          addToDeleteSet(insertions, client, startClock, len);
        }
      });
      const now = getUnixTime();
      let didAdd = false;
      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
        const lastOp = stack[stack.length - 1];
        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
      } else {
        stack.push(new StackItem(transaction.deleteSet, insertions));
        didAdd = true;
      }
      if (!undoing && !redoing) {
        this.lastChange = now;
      }
      iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        /** @param {Item|GC} item */
        (item) => {
          if (item instanceof Item && this.scope.some((type) => isParentOf(type, item))) {
            keepItem(item, true);
          }
        }
      );
      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
      if (didAdd) {
        this.emit("stack-item-added", changeEvent);
      } else {
        this.emit("stack-item-updated", changeEvent);
      }
    };
    this.doc.on("afterTransaction", this.afterTransactionHandler);
    this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */
  addToScope(ytypes) {
    ytypes = isArray(ytypes) ? ytypes : [ytypes];
    ytypes.forEach((ytype) => {
      if (this.scope.every((yt) => yt !== ytype)) {
        if (ytype.doc !== this.doc) warn("[yjs#509] Not same Y.Doc");
        this.scope.push(ytype);
      }
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.trackedOrigins.add(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.trackedOrigins.delete(origin);
  }
  clear(clearUndoStack = true, clearRedoStack = true) {
    if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
      this.doc.transact((tr) => {
        if (clearUndoStack) {
          this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.undoStack = [];
        }
        if (clearRedoStack) {
          this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.redoStack = [];
        }
        this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
      });
    }
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = true;
    let res;
    try {
      res = popStackItem(this, this.undoStack, "undo");
    } finally {
      this.undoing = false;
    }
    return res;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = true;
    let res;
    try {
      res = popStackItem(this, this.redoStack, "redo");
    } finally {
      this.redoing = false;
    }
    return res;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this);
    this.doc.off("afterTransaction", this.afterTransactionHandler);
    super.destroy();
  }
}
const errorComputeChanges = "You must not compute changes after the event-handler fired.";
class YEvent {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target2, transaction) {
    this.target = target2;
    this.currentTarget = target2;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create$4(errorComputeChanges);
      }
      const keys2 = /* @__PURE__ */ new Map();
      const target2 = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target2)
      );
      changed.forEach((key2) => {
        if (key2 !== null) {
          const item = (
            /** @type {Item} */
            target2._map.get(key2)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys2.set(key2, { action, oldValue });
        }
      });
      this._keys = keys2;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create$4(errorComputeChanges);
      }
      const target2 = this.target;
      const added = create$5();
      const deleted = create$5();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target2)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target2._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
}
const getPathTo = (parent, child) => {
  const path2 = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path2.unshift(child._item.parentSub);
    } else {
      let i2 = 0;
      let c = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c !== child._item && c !== null) {
        if (!c.deleted && c.countable) {
          i2 += c.length;
        }
        c = c.right;
      }
      path2.unshift(i2);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path2;
};
const warnPrematureAccess = () => {
  warn("Invalid access: Add Yjs type to a document before reading data.");
};
const maxSearchMarker = 80;
let globalSearchMarkerTimestamp = 0;
class ArraySearchMarker {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p, index) {
    p.marker = true;
    this.p = p;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
}
const refreshMarkerTimestamp = (marker2) => {
  marker2.timestamp = globalSearchMarkerTimestamp++;
};
const overwriteMarker = (marker2, p, index) => {
  marker2.p.marker = false;
  marker2.p = p;
  p.marker = true;
  marker2.index = index;
  marker2.timestamp = globalSearchMarkerTimestamp++;
};
const markPosition = (searchMarker, p, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker2 = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);
    overwriteMarker(marker2, p, index);
    return marker2;
  } else {
    const pm = new ArraySearchMarker(p, index);
    searchMarker.push(pm);
    return pm;
  }
};
const findMarker = (yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker2 = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);
  let p = yarray._start;
  let pindex = 0;
  if (marker2 !== null) {
    p = marker2.p;
    pindex = marker2.index;
    refreshMarkerTimestamp(marker2);
  }
  while (p.right !== null && pindex < index) {
    if (!p.deleted && p.countable) {
      if (index < pindex + p.length) {
        break;
      }
      pindex += p.length;
    }
    p = p.right;
  }
  while (p.left !== null && pindex > index) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  if (marker2 !== null && abs(marker2.index - pindex) < /** @type {YText|YArray<any>} */
  p.parent.length / maxSearchMarker) {
    overwriteMarker(marker2, p, pindex);
    return marker2;
  } else {
    return markPosition(yarray._searchMarker, p, pindex);
  }
};
const updateMarkerChanges = (searchMarker, index, len) => {
  for (let i2 = searchMarker.length - 1; i2 >= 0; i2--) {
    const m2 = searchMarker[i2];
    if (len > 0) {
      let p = m2.p;
      p.marker = false;
      while (p && (p.deleted || !p.countable)) {
        p = p.left;
        if (p && !p.deleted && p.countable) {
          m2.index -= p.length;
        }
      }
      if (p === null || p.marker === true) {
        searchMarker.splice(i2, 1);
        continue;
      }
      m2.p = p;
      p.marker = true;
    }
    if (index < m2.index || len > 0 && index === m2.index) {
      m2.index = max(index, m2.index + len);
    }
  }
};
const callTypeObservers = (type, transaction, event2) => {
  const changedType = type;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event2);
    if (type._item === null) {
      break;
    }
    type = /** @type {AbstractType<any>} */
    type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event2, transaction);
};
class AbstractType {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y, item) {
    this.doc = y;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f) {
    addEventHandlerListener(this._eH, f);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f) {
    addEventHandlerListener(this._dEH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f) {
    removeEventHandlerListener(this._eH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f) {
    removeEventHandlerListener(this._dEH, f);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const typeListSlice = (type, start, end) => {
  type.doc ?? warnPrematureAccess();
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len = end - start;
  const cs = [];
  let n = type._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      if (c.length <= start) {
        start -= c.length;
      } else {
        for (let i2 = start; i2 < c.length && len > 0; i2++) {
          cs.push(c[i2]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs;
};
const typeListToArray = (type) => {
  type.doc ?? warnPrematureAccess();
  const cs = [];
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i2 = 0; i2 < c.length; i2++) {
        cs.push(c[i2]);
      }
    }
    n = n.right;
  }
  return cs;
};
const typeListForEach = (type, f) => {
  let index = 0;
  let n = type._start;
  type.doc ?? warnPrematureAccess();
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i2 = 0; i2 < c.length; i2++) {
        f(c[i2], index++, type);
      }
    }
    n = n.right;
  }
};
const typeListMap = (type, f) => {
  const result2 = [];
  typeListForEach(type, (c, i2) => {
    result2.push(f(c, i2, type));
  });
  return result2;
};
const typeListCreateIterator = (type) => {
  let n = type._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
const typeListGet = (type, index) => {
  type.doc ?? warnPrematureAccess();
  const marker2 = findMarker(type, index);
  let n = type._start;
  if (marker2 !== null) {
    n = marker2.p;
    index -= marker2.index;
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        return n.content.getContent()[index];
      }
      index -= n.length;
    }
  }
};
const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c) => {
    if (c === null) {
      jsonContent.push(c);
    } else {
      switch (c.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c);
          break;
        default:
          packJsonContent();
          switch (c.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
const lengthExceeded = () => create$4("Length exceeded!");
const typeListInsertGenerics = (transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded();
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker2 = findMarker(parent, index);
  let n = parent._start;
  if (marker2 !== null) {
    n = marker2.p;
    index -= marker2.index;
    if (index === 0) {
      n = n.prev;
      index += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index <= n.length) {
        if (index < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        }
        break;
      }
      index -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
const typeListPushGenerics = (transaction, parent, content) => {
  const marker2 = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker2.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
const typeListDelete = (transaction, parent, index, length2) => {
  if (length2 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length2;
  const marker2 = findMarker(parent, index);
  let n = parent._start;
  if (marker2 !== null) {
    n = marker2.p;
    index -= marker2.index;
  }
  for (; n !== null && index > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
      }
      index -= n.length;
    }
  }
  while (length2 > 0 && n !== null) {
    if (!n.deleted) {
      if (length2 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length2));
      }
      n.delete(transaction);
      length2 -= n.length;
    }
    n = n.right;
  }
  if (length2 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length2
      /* in case we remove the above exception */
    );
  }
};
const typeMapDelete = (transaction, parent, key2) => {
  const c = parent._map.get(key2);
  if (c !== void 0) {
    c.delete(transaction);
  }
};
const typeMapSet = (transaction, parent, key2, value) => {
  const left = parent._map.get(key2) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key2, content).integrate(transaction, 0);
};
const typeMapGet = (parent, key2) => {
  parent.doc ?? warnPrematureAccess();
  const val = parent._map.get(key2);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
const typeMapGetAll = (parent) => {
  const res = {};
  parent.doc ?? warnPrematureAccess();
  parent._map.forEach((value, key2) => {
    if (!value.deleted) {
      res[key2] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
const typeMapHas = (parent, key2) => {
  parent.doc ?? warnPrematureAccess();
  const val = parent._map.get(key2);
  return val !== void 0 && !val.deleted;
};
const typeMapGetAllSnapshot = (parent, snapshot) => {
  const res = {};
  parent._map.forEach((value, key2) => {
    let v = value;
    while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {
      v = v.left;
    }
    if (v !== null && isVisible(v, snapshot)) {
      res[key2] = v.content.getContent()[v.length - 1];
    }
  });
  return res;
};
const createMapIterator = (type) => {
  type.doc ?? warnPrematureAccess();
  return iteratorFilter(
    type._map.entries(),
    /** @param {any} entry */
    (entry) => !entry[1].deleted
  );
};
class YArrayEvent extends YEvent {
}
class YArray extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a = new YArray();
    a.push(items);
    return a;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new YArray();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const arr = new YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length2 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length2);
      });
    } else {
      this._prelimContent.splice(index, length2);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f) {
    return typeListMap(
      this,
      /** @type {any} */
      f
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
}
class YMapEvent extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
}
class YMap extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimContent.forEach((value, key2) => {
      this.set(key2, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new YMap();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const map2 = new YMap();
    this.forEach((value, key2) => {
      map2.set(key2, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map2;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? warnPrematureAccess();
    const map2 = {};
    this._map.forEach((item, key2) => {
      if (!item.deleted) {
        const v = item.content.getContent()[item.length - 1];
        map2[key2] = v instanceof AbstractType ? v.toJSON() : v;
      }
    });
    return map2;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v) => v[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v) => v[1].content.getContent()[v[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v) => (
        /** @type {any} */
        [v[0], v[1].content.getContent()[v[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    this.doc ?? warnPrematureAccess();
    this._map.forEach((item, key2) => {
      if (!item.deleted) {
        f(item.content.getContent()[item.length - 1], key2, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key2) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key2);
      });
    } else {
      this._prelimContent.delete(key2);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key2, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key2,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key2, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key2) {
    return (
      /** @type {any} */
      typeMapGet(this, key2)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key2) {
    return typeMapHas(this, key2);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key2, map2) {
          typeMapDelete(transaction, map2, key2);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
}
const equalAttrs = (a, b) => a === b || typeof a === "object" && typeof b === "object" && a && b && equalFlat(a, b);
class ItemTextListPosition {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
}
const findNextPosition = (transaction, pos, count) => {
  while (pos.right !== null && count > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
          }
          pos.index += pos.right.length;
          count -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
const findPosition$1 = (transaction, parent, index, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker2 = useSearchMarker ? findMarker(parent, index) : null;
  if (marker2) {
    const pos = new ItemTextListPosition(marker2.p.left, marker2.p, marker2.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker2.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
};
const insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key2) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key2, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
const updateCurrentAttributes = (currentAttributes, format2) => {
  const { key: key2, value } = format2;
  if (value === null) {
    currentAttributes.delete(key2);
  } else {
    currentAttributes.set(key2, value);
  }
};
const minimizeAttributeChanges = (currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    )) ;
    else {
      break;
    }
    currPos.forward();
  }
};
const insertAttributes = (transaction, parent, currPos, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key2 in attributes) {
    const val = attributes[key2];
    const currentVal = currPos.currentAttributes.get(key2) ?? null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key2, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key2, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
const insertText = (transaction, parent, currPos, text2, attributes) => {
  currPos.currentAttributes.forEach((_val, key2) => {
    if (attributes[key2] === void 0) {
      attributes[key2] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text2.constructor === String ? new ContentString(
    /** @type {string} */
    text2
  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
const formatText = (transaction, parent, currPos, length2, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop: while (currPos.right !== null && (length2 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
    if (!currPos.right.deleted) {
      switch (currPos.right.content.constructor) {
        case ContentFormat: {
          const { key: key2, value } = (
            /** @type {ContentFormat} */
            currPos.right.content
          );
          const attr2 = attributes[key2];
          if (attr2 !== void 0) {
            if (equalAttrs(attr2, value)) {
              negatedAttributes.delete(key2);
            } else {
              if (length2 === 0) {
                break iterationLoop;
              }
              negatedAttributes.set(key2, value);
            }
            currPos.right.delete(transaction);
          } else {
            currPos.currentAttributes.set(key2, value);
          }
          break;
        }
        default:
          if (length2 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length2));
          }
          length2 -= currPos.right.length;
          break;
      }
    }
    currPos.forward();
  }
  if (length2 > 0) {
    let newlines = "";
    for (; length2 > 0; length2--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
const cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  let end = start;
  const endFormats = create$3();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key: key2, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = startAttributes.get(key2) ?? null;
          if (endFormats.get(key2) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && (currAttributes.get(key2) ?? null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key2);
              } else {
                currAttributes.set(key2, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
};
const cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key2 = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key2)) {
        item.delete(transaction);
      } else {
        attrs.add(key2);
      }
    }
    item = item.left;
  }
};
const cleanupYTextFormatting = (type) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type._start
      );
      let end = type._start;
      let startAttributes = create$3();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
const cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
const deleteText = (transaction, currPos, length2) => {
  const startLength = length2;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length2 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length2 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length2));
          }
          length2 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length2);
  }
  return currPos;
};
class YTextEvent extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y, (transaction) => {
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert2 = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert2 === "object" || insert2.length > 0) {
                  op = { insert: insert2 };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key2) => {
                      if (value !== null) {
                        op.attributes[key2] = value;
                      }
                    });
                  }
                }
                insert2 = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op) delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert2 = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert2 += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key: key2, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = currentAttributes.get(key2) ?? null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, oldAttributes.get(key2) ?? null)) {
                      delete attributes[key2];
                    } else {
                      attributes[key2] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key2, value);
                const curVal = currentAttributes.get(key2) ?? null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key2] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key2, value);
                const attr2 = attributes[key2];
                if (attr2 !== void 0) {
                  if (!equalAttrs(attr2, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key2];
                    } else {
                      attributes[key2] = value;
                    }
                  } else if (attr2 !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class YText extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    try {
      this._pending.forEach((f) => f());
    } catch (e) {
      console.error(e);
    }
    this._pending = null;
  }
  _copy() {
    return new YText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const text2 = new YText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event2 = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event2);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? warnPrematureAccess();
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize: sanitize3 = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i2 = 0; i2 < delta.length; i2++) {
          const op = delta[i2];
          if (op.insert !== void 0) {
            const ins = !sanitize3 && typeof op.insert === "string" && i2 === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot, prevSnapshot, computeYChange) {
    this.doc ?? warnPrematureAccess();
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key2) => {
          addAttributes = true;
          attributes[key2] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n !== null) {
        if (isVisible(n, snapshot) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n, snapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key2) => {
                  attrs[key2] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n.content
                );
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    };
    if (snapshot || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot) {
          splitSnapshotAffectedStructs(transaction, snapshot);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text2, attributes) {
    if (text2.length <= 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition$1(transaction, this, index, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v, k) => {
            attributes[k] = v;
          });
        }
        insertText(transaction, this, pos, text2, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text2, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes) {
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition$1(transaction, this, index, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length2) {
    if (length2 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        deleteText(transaction, findPosition$1(transaction, this, index, true), length2);
      });
    } else {
      this._pending.push(() => this.delete(index, length2));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length2, attributes) {
    if (length2 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition$1(transaction, this, index, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length2, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length2, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
}
class YXmlTreeWalker {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root2, f = () => true) {
    this._filter = f;
    this._root = root2;
    this._currentNode = /** @type {Item} */
    root2._start;
    this._firstCall = true;
    root2.doc ?? warnPrematureAccess();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n = this._currentNode;
    let type = n && n.content && /** @type {any} */
    n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
      do {
        type = /** @type {any} */
        n.content.type;
        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n = type._start;
        } else {
          while (n !== null) {
            if (n.right !== null) {
              n = n.right;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = /** @type {AbstractType<any>} */
              n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(
        /** @type {ContentType} */
        n.content.type
      )));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n;
    return { value: (
      /** @type {any} */
      n.content.type
    ), done: false };
  }
}
class YXmlFragment extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new YXmlFragment();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const el = new YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter2) {
    return new YXmlTreeWalker(this, filter2);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element) => element.nodeName && element.nodeName.toUpperCase() === query);
    const next = iterator.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from(new YXmlTreeWalker(this, (element) => element.nodeName && element.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref2, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref2 && ref2 instanceof AbstractType ? ref2._item : ref2;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref2 === null ? 0 : pc.findIndex((el) => el === ref2) + 1;
      if (index === 0 && ref2 !== null) {
        throw create$4("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length2 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length2);
      });
    } else {
      this._prelimContent.splice(index, length2);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
}
class YXmlElement extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key2) => {
      this.setAttribute(key2, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new YXmlElement(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value, key2) => {
      if (typeof value === "string") {
        el.setAttribute(key2, value);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys2 = [];
    for (const key2 in attrs) {
      keys2.push(key2);
    }
    keys2.sort();
    const keysLen = keys2.length;
    for (let i2 = 0; i2 < keysLen; i2++) {
      const key2 = keys2[i2];
      stringBuilder.push(key2 + '="' + attrs[key2] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot) {
    return (
      /** @type {any} */
      snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key2 in attrs) {
      const value = attrs[key2];
      if (typeof value === "string") {
        dom.setAttribute(key2, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
}
class YXmlEvent extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(target2, subs, transaction) {
    super(target2, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
}
class AbstractStruct {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id, length2) {
    this.id = id;
    this.length = length2;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
}
const structGCRefNumber = 0;
class GC extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
}
class ContentBinary {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
class ContentDeleted {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
class ContentDoc {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
class ContentEmbed {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
class ContentFormat {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key2, value) {
    this.key = key2;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p = (
      /** @type {YText} */
      item.parent
    );
    p._searchMarker = null;
    p._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const isDevMode = getVariable("node_env") === "development";
class ContentAny {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
    isDevMode && deepFreeze(arr);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i2 = offset; i2 < len; i2++) {
      const c = this.arr[i2];
      encoder.writeAny(c);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
class ContentString {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "";
      right.str = "" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const YArrayRefID = 0;
const YMapRefID = 1;
const YTextRefID = 2;
const YXmlElementRefID = 3;
const YXmlFragmentRefID = 4;
class ContentType {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type) {
    this.type = type;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const followRedone = (store, id) => {
  let nextID2 = id;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID2 = createID(nextID2.client, nextID2.clock + diff);
    }
    item = getItem(store, nextID2);
    diff = nextID2.clock - item.id.clock;
    nextID2 = item.redone;
  } while (nextID2 !== null && item instanceof Item);
  return {
    item,
    diff
  };
};
const keepItem = (item, keep) => {
  while (item !== null && item.keep !== keep) {
    item.keep = keep;
    item = /** @type {AbstractType<any>} */
    item.parent._item;
  }
};
const splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
const isDeletedByUndoStack = (stack, id) => some(
  stack,
  /** @param {StackItem} s */
  (s) => isDeleted(s.deletions, id)
);
const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ownClientID = doc2.clientID;
  const redone = item.redone;
  if (redone !== null) {
    return getItemCleanStart(transaction, redone);
  }
  let parentItem = (
    /** @type {AbstractType<any>} */
    item.parent._item
  );
  let left = null;
  let right;
  if (parentItem !== null && parentItem.deleted === true) {
    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
      return null;
    }
    while (parentItem.redone !== null) {
      parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
  }
  const parentType = parentItem === null ? (
    /** @type {AbstractType<any>} */
    item.parent
  ) : (
    /** @type {ContentType} */
    parentItem.content.type
  );
  if (item.parentSub === null) {
    left = item.left;
    right = item;
    while (left !== null) {
      let leftTrace = left;
      while (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item !== parentItem) {
        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
      }
      if (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item === parentItem) {
        left = leftTrace;
        break;
      }
      left = left.left;
    }
    while (right !== null) {
      let rightTrace = right;
      while (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item !== parentItem) {
        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
      }
      if (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item === parentItem) {
        right = rightTrace;
        break;
      }
      right = right.right;
    }
  } else {
    right = null;
    if (item.right && !ignoreRemoteMapChanges) {
      left = item;
      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
        left = left.right;
        while (left.redone) left = getItemCleanStart(transaction, left.redone);
      }
      if (left && left.right !== null) {
        return null;
      }
    } else {
      left = parentType._map.get(item.parentSub) || null;
    }
  }
  const nextClock = getState(store, ownClientID);
  const nextId = createID(ownClientID, nextClock);
  const redoneItem = new Item(
    nextId,
    left,
    left && left.lastId,
    right,
    right && right.id,
    parentType,
    item.parentSub,
    item.content.copy()
  );
  item.redone = nextId;
  keepItem(redoneItem, true);
  redoneItem.integrate(transaction, 0);
  return redoneItem;
};
class Item extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker2) => {
          if (marker2.p === right) {
            marker2.p = this;
            if (!this.deleted && this.countable) {
              marker2.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
}
const glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
const importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;
const outdatedTimeout = 3e4;
class Awareness extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove2 = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove2.push(clientid);
        }
      });
      if (remove2.length > 0) {
        removeAwarenessStates(this, remove2, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
}
const removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i2 = 0; i2 < clients.length; i2++) {
    const clientID = clients[i2];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
class YDocument {
  constructor(options) {
    var _a;
    this.onStateChanged = (event2) => {
      const stateChange = new Array();
      event2.keysChanged.forEach((key2) => {
        const change = event2.changes.keys.get(key2);
        if (change) {
          stateChange.push({
            name: key2,
            oldValue: change.oldValue,
            newValue: this.ystate.get(key2)
          });
        }
      });
      this._changed.emit({ stateChange });
    };
    this._changed = new Signal(this);
    this._isDisposed = false;
    this._disposed = new Signal(this);
    this._ydoc = (_a = options === null || options === void 0 ? void 0 : options.ydoc) !== null && _a !== void 0 ? _a : new Doc();
    this._ystate = this._ydoc.getMap("state");
    this._undoManager = new UndoManager([], {
      trackedOrigins: /* @__PURE__ */ new Set([this]),
      doc: this._ydoc
    });
    this._awareness = new Awareness(this._ydoc);
    this._ystate.observe(this.onStateChanged);
  }
  /**
   * YJS document.
   */
  get ydoc() {
    return this._ydoc;
  }
  /**
   * Shared state
   */
  get ystate() {
    return this._ystate;
  }
  /**
   * YJS document undo manager
   */
  get undoManager() {
    return this._undoManager;
  }
  /**
   * Shared awareness
   */
  get awareness() {
    return this._awareness;
  }
  /**
   * The changed signal.
   */
  get changed() {
    return this._changed;
  }
  /**
   * A signal emitted when the document is disposed.
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * Whether the document is disposed or not.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Document state
   */
  get state() {
    return JSONExt.deepCopy(this.ystate.toJSON());
  }
  /**
   * Whether the object can undo changes.
   */
  canUndo() {
    return this.undoManager.undoStack.length > 0;
  }
  /**
   * Whether the object can redo changes.
   */
  canRedo() {
    return this.undoManager.redoStack.length > 0;
  }
  /**
   * Dispose of the resources.
   */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    this.ystate.unobserve(this.onStateChanged);
    this.awareness.destroy();
    this.undoManager.destroy();
    this.ydoc.destroy();
    this._disposed.emit();
    Signal.clearData(this);
  }
  /**
   * Get the value for a state attribute
   *
   * @param key Key to get
   */
  getState(key2) {
    const value = this.ystate.get(key2);
    return typeof value === "undefined" ? value : JSONExt.deepCopy(value);
  }
  /**
   * Set the value of a state attribute
   *
   * @param key Key to set
   * @param value New attribute value
   */
  setState(key2, value) {
    if (!JSONExt.deepEqual(this.ystate.get(key2), value)) {
      this.ystate.set(key2, value);
    }
  }
  /**
   * Get the document source
   *
   * @returns The source
   */
  get source() {
    return this.getSource();
  }
  /**
   * Set the document source
   *
   * @param value The source to set
   */
  set source(value) {
    this.setSource(value);
  }
  /**
   * Undo an operation.
   */
  undo() {
    this.undoManager.undo();
  }
  /**
   * Redo an operation.
   */
  redo() {
    this.undoManager.redo();
  }
  /**
   * Clear the change stack.
   */
  clearUndoHistory() {
    this.undoManager.clear();
  }
  /**
   * Perform a transaction. While the function f is called, all changes to the shared
   * document are bundled into a single event.
   */
  transact(f, undoable = true, origin = null) {
    this.ydoc.transact(f, undoable ? this : origin);
  }
}
class YFile extends YDocument {
  /**
   * Create a new file
   *
   * #### Notes
   * The document is empty and must be populated
   */
  constructor() {
    super();
    this.version = "1.0.0";
    this.ysource = this.ydoc.getText("source");
    this._modelObserver = (event2) => {
      this._changed.emit({ sourceChange: event2.changes.delta });
    };
    this.undoManager.addToScope(this.ysource);
    this.ysource.observe(this._modelObserver);
  }
  /**
   * Creates a standalone YFile
   */
  static create() {
    return new YFile();
  }
  /**
   * File text
   */
  get source() {
    return this.getSource();
  }
  set source(v) {
    this.setSource(v);
  }
  /**
   * Dispose of the resources.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.ysource.unobserve(this._modelObserver);
    super.dispose();
  }
  /**
   * Get the file text.
   *
   * @returns File text.
   */
  getSource() {
    return this.ysource.toString();
  }
  /**
   * Set the file text.
   *
   * @param value New text
   */
  setSource(value) {
    this.transact(() => {
      const ytext = this.ysource;
      ytext.delete(0, ytext.length);
      ytext.insert(0, value);
    });
  }
  /**
   * Replace content from `start' to `end` with `value`.
   *
   * @param start: The start index of the range to replace (inclusive).
   * @param end: The end index of the range to replace (exclusive).
   * @param value: New source (optional).
   */
  updateSource(start, end, value = "") {
    this.transact(() => {
      const ysource = this.ysource;
      ysource.insert(start, value);
      ysource.delete(start + value.length, end - start);
    });
  }
}
const createCellModelFromSharedType = (type, options = {}) => {
  switch (type.get("cell_type")) {
    case "code":
      return new YCodeCell(type, type.get("source"), type.get("outputs"), options);
    case "markdown":
      return new YMarkdownCell(type, type.get("source"), options);
    case "raw":
      return new YRawCell(type, type.get("source"), options);
    default:
      throw new Error("Found unknown cell type");
  }
};
const createCell = (cell, notebook) => {
  var _a, _b;
  const ymodel = new YMap();
  const ysource = new YText();
  const ymetadata = new YMap();
  ymodel.set("source", ysource);
  ymodel.set("metadata", ymetadata);
  ymodel.set("cell_type", cell.cell_type);
  ymodel.set("id", (_a = cell.id) !== null && _a !== void 0 ? _a : UUID.uuid4());
  let ycell;
  switch (cell.cell_type) {
    case "markdown": {
      ycell = new YMarkdownCell(ymodel, ysource, { notebook }, ymetadata);
      if (cell.attachments != null) {
        ycell.setAttachments(cell.attachments);
      }
      break;
    }
    case "code": {
      const youtputs = new YArray();
      ymodel.set("outputs", youtputs);
      ycell = new YCodeCell(ymodel, ysource, youtputs, {
        notebook
      }, ymetadata);
      const cCell = cell;
      ycell.execution_count = (_b = cCell.execution_count) !== null && _b !== void 0 ? _b : null;
      if (cCell.outputs) {
        ycell.setOutputs(cCell.outputs);
      }
      break;
    }
    default: {
      ycell = new YRawCell(ymodel, ysource, { notebook }, ymetadata);
      if (cell.attachments) {
        ycell.setAttachments(cell.attachments);
      }
      break;
    }
  }
  if (cell.metadata != null) {
    ycell.setMetadata(cell.metadata);
  }
  if (cell.source != null) {
    ycell.setSource(typeof cell.source === "string" ? cell.source : cell.source.join(""));
  }
  return ycell;
};
const createStandaloneCell = (cell) => createCell(cell);
class YBaseCell {
  /**
   * Create a new YCell that works standalone. It cannot be
   * inserted into a YNotebook because the Yjs model is already
   * attached to an anonymous Y.Doc instance.
   */
  static create(id) {
    return createCell({ id, cell_type: this.prototype.cell_type });
  }
  /**
   * Base cell constructor
   *
   * ### Notes
   * Don't use the constructor directly - prefer using ``YNotebook.insertCell``
   *
   * The ``ysource`` is needed because ``ymodel.get('source')`` will
   * not return the real source if the model is not yet attached to
   * a document. Requesting it explicitly allows to introspect a non-empty
   * source before the cell is attached to the document.
   *
   * @param ymodel Cell map
   * @param ysource Cell source
   * @param options \{ notebook?: The notebook the cell is attached to \}
   * @param ymetadata Cell metadata
   */
  constructor(ymodel, ysource, options = {}, ymetadata) {
    this._modelObserver = (events, transaction) => {
      if (transaction.origin !== "silent-change") {
        this._changed.emit(this.getChanges(events));
      }
    };
    this._metadataChanged = new Signal(this);
    this._notebook = null;
    this._changed = new Signal(this);
    this._disposed = new Signal(this);
    this._isDisposed = false;
    this._undoManager = null;
    this.ymodel = ymodel;
    this._ysource = ysource;
    this._ymetadata = ymetadata !== null && ymetadata !== void 0 ? ymetadata : this.ymodel.get("metadata");
    this._prevSourceLength = ysource ? ysource.length : 0;
    this._notebook = null;
    this._awareness = null;
    this._undoManager = null;
    if (options.notebook) {
      this._notebook = options.notebook;
    } else {
      const doc2 = new Doc();
      doc2.getArray().insert(0, [this.ymodel]);
      this._awareness = new Awareness(doc2);
      this._undoManager = new UndoManager([this.ymodel], {
        trackedOrigins: /* @__PURE__ */ new Set([this])
      });
    }
    this.ymodel.observeDeep(this._modelObserver);
  }
  /**
   * Cell notebook awareness or null if the cell is standalone.
   */
  get awareness() {
    var _a, _b, _c;
    return (_c = (_a = this._awareness) !== null && _a !== void 0 ? _a : (_b = this.notebook) === null || _b === void 0 ? void 0 : _b.awareness) !== null && _c !== void 0 ? _c : null;
  }
  /**
   * The type of the cell.
   */
  get cell_type() {
    throw new Error("A YBaseCell must not be constructed");
  }
  /**
   * The changed signal.
   */
  get changed() {
    return this._changed;
  }
  /**
   * Signal emitted when the cell is disposed.
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * Cell id
   */
  get id() {
    return this.getId();
  }
  /**
   * Whether the model has been disposed or not.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Whether the cell is standalone or not.
   *
   * If the cell is standalone. It cannot be
   * inserted into a YNotebook because the Yjs model is already
   * attached to an anonymous Y.Doc instance.
   */
  get isStandalone() {
    return this._notebook !== null;
  }
  /**
   * Cell metadata.
   *
   * #### Notes
   * You should prefer to access and modify the specific key of interest.
   */
  get metadata() {
    return this.getMetadata();
  }
  set metadata(v) {
    this.setMetadata(v);
  }
  /**
   * Signal triggered when the cell metadata changes.
   */
  get metadataChanged() {
    return this._metadataChanged;
  }
  /**
   * The notebook that this cell belongs to.
   */
  get notebook() {
    return this._notebook;
  }
  /**
   * Cell input content.
   */
  get source() {
    return this.getSource();
  }
  set source(v) {
    this.setSource(v);
  }
  /**
   * The cell undo manager.
   */
  get undoManager() {
    var _a;
    if (!this.notebook) {
      return this._undoManager;
    }
    return ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.disableDocumentWideUndoRedo) ? this._undoManager : this.notebook.undoManager;
  }
  /**
   * Defer setting the undo manager as it requires the
   * cell to be attached to the notebook Y document.
   */
  setUndoManager() {
    if (this._undoManager) {
      throw new Error("The cell undo manager is already set.");
    }
    if (this._notebook && this._notebook.disableDocumentWideUndoRedo) {
      this._undoManager = new UndoManager([this.ymodel], {
        trackedOrigins: /* @__PURE__ */ new Set([this])
      });
    }
  }
  get ysource() {
    return this._ysource;
  }
  /**
   * Whether the object can undo changes.
   */
  canUndo() {
    return !!this.undoManager && this.undoManager.undoStack.length > 0;
  }
  /**
   * Whether the object can redo changes.
   */
  canRedo() {
    return !!this.undoManager && this.undoManager.redoStack.length > 0;
  }
  /**
   * Clear the change stack.
   */
  clearUndoHistory() {
    var _a;
    (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.clear();
  }
  /**
   * Undo an operation.
   */
  undo() {
    var _a;
    (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.undo();
  }
  /**
   * Redo an operation.
   */
  redo() {
    var _a;
    (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.redo();
  }
  /**
   * Dispose of the resources.
   */
  dispose() {
    var _a;
    if (this._isDisposed)
      return;
    this._isDisposed = true;
    this.ymodel.unobserveDeep(this._modelObserver);
    if (this._awareness) {
      const doc2 = this._awareness.doc;
      this._awareness.destroy();
      doc2.destroy();
    }
    if (this._undoManager) {
      if (this._undoManager === ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.undoManager)) {
        this._undoManager = null;
      } else {
        this._undoManager.destroy();
      }
    }
    this._disposed.emit();
    Signal.clearData(this);
  }
  /**
   * Get cell id.
   *
   * @returns Cell id
   */
  getId() {
    return this.ymodel.get("id");
  }
  /**
   * Gets cell's source.
   *
   * @returns Cell's source.
   */
  getSource() {
    return this.ysource.toString();
  }
  /**
   * Sets cell's source.
   *
   * @param value: New source.
   */
  setSource(value) {
    this.transact(() => {
      this.ysource.delete(0, this.ysource.length);
      this.ysource.insert(0, value);
    });
  }
  /**
   * Replace content from `start' to `end` with `value`.
   *
   * @param start: The start index of the range to replace (inclusive).
   *
   * @param end: The end index of the range to replace (exclusive).
   *
   * @param value: New source (optional).
   */
  updateSource(start, end, value = "") {
    this.transact(() => {
      const ysource = this.ysource;
      ysource.insert(start, value);
      ysource.delete(start + value.length, end - start);
    });
  }
  /**
   * Delete a metadata cell.
   *
   * @param key The key to delete
   */
  deleteMetadata(key2) {
    if (typeof this.getMetadata(key2) === "undefined") {
      return;
    }
    this.transact(() => {
      this._ymetadata.delete(key2);
      const jupyter = this.getMetadata("jupyter");
      if (key2 === "collapsed" && jupyter) {
        const { outputs_hidden, ...others } = jupyter;
        if (Object.keys(others).length === 0) {
          this._ymetadata.delete("jupyter");
        } else {
          this._ymetadata.set("jupyter", others);
        }
      } else if (key2 === "jupyter") {
        this._ymetadata.delete("collapsed");
      }
    }, false);
  }
  getMetadata(key2) {
    const metadata = this._ymetadata;
    if (metadata === void 0) {
      return void 0;
    }
    if (typeof key2 === "string") {
      const value = metadata.get(key2);
      return typeof value === "undefined" ? void 0 : JSONExt.deepCopy(metadata.get(key2));
    } else {
      return JSONExt.deepCopy(metadata.toJSON());
    }
  }
  setMetadata(metadata, value) {
    var _a, _b;
    if (typeof metadata === "string") {
      if (typeof value === "undefined") {
        throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);
      }
      const key2 = metadata;
      if (JSONExt.deepEqual((_a = this.getMetadata(key2)) !== null && _a !== void 0 ? _a : null, value)) {
        return;
      }
      this.transact(() => {
        var _a2;
        this._ymetadata.set(key2, value);
        if (key2 === "collapsed") {
          const jupyter = (_a2 = this.getMetadata("jupyter")) !== null && _a2 !== void 0 ? _a2 : {};
          if (jupyter.outputs_hidden !== value) {
            this.setMetadata("jupyter", {
              ...jupyter,
              outputs_hidden: value
            });
          }
        } else if (key2 === "jupyter") {
          const isHidden3 = value["outputs_hidden"];
          if (typeof isHidden3 !== "undefined") {
            if (this.getMetadata("collapsed") !== isHidden3) {
              this.setMetadata("collapsed", isHidden3);
            }
          } else {
            this.deleteMetadata("collapsed");
          }
        }
      }, false);
    } else {
      const clone = JSONExt.deepCopy(metadata);
      if (clone.collapsed != null) {
        clone.jupyter = clone.jupyter || {};
        clone.jupyter.outputs_hidden = clone.collapsed;
      } else if (((_b = clone === null || clone === void 0 ? void 0 : clone.jupyter) === null || _b === void 0 ? void 0 : _b.outputs_hidden) != null) {
        clone.collapsed = clone.jupyter.outputs_hidden;
      }
      if (!JSONExt.deepEqual(clone, this.getMetadata())) {
        this.transact(() => {
          for (const [key2, value2] of Object.entries(clone)) {
            this._ymetadata.set(key2, value2);
          }
        }, false);
      }
    }
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return {
      id: this.getId(),
      cell_type: this.cell_type,
      source: this.getSource(),
      metadata: this.getMetadata()
    };
  }
  /**
   * Perform a transaction. While the function f is called, all changes to the shared
   * document are bundled into a single event.
   *
   * @param f Transaction to execute
   * @param undoable Whether to track the change in the action history or not (default `true`)
   */
  transact(f, undoable = true, origin = null) {
    !this.notebook || this.notebook.disableDocumentWideUndoRedo ? this.ymodel.doc == null ? f() : this.ymodel.doc.transact(f, undoable ? this : origin) : this.notebook.transact(f, undoable);
  }
  /**
   * Extract changes from YJS events
   *
   * @param events YJS events
   * @returns Cell changes
   */
  getChanges(events) {
    const changes = {};
    const sourceEvent = events.find((event2) => event2.target === this.ymodel.get("source"));
    if (sourceEvent) {
      changes.sourceChange = sourceEvent.changes.delta;
    }
    const metadataEvents = events.find((event2) => event2.target === this._ymetadata);
    if (metadataEvents) {
      changes.metadataChange = metadataEvents.changes.keys;
      metadataEvents.changes.keys.forEach((change, key2) => {
        switch (change.action) {
          case "add":
            this._metadataChanged.emit({
              key: key2,
              newValue: this._ymetadata.get(key2),
              type: "add"
            });
            break;
          case "delete":
            this._metadataChanged.emit({
              key: key2,
              oldValue: change.oldValue,
              type: "remove"
            });
            break;
          case "update":
            {
              const newValue = this._ymetadata.get(key2);
              const oldValue = change.oldValue;
              let equal = true;
              if (typeof oldValue == "object" && typeof newValue == "object") {
                equal = JSONExt.deepEqual(oldValue, newValue);
              } else {
                equal = oldValue === newValue;
              }
              if (!equal) {
                this._metadataChanged.emit({
                  key: key2,
                  type: "change",
                  oldValue,
                  newValue
                });
              }
            }
            break;
        }
      });
    }
    const modelEvent = events.find((event2) => event2.target === this.ymodel);
    const ysource = this.ymodel.get("source");
    if (modelEvent && modelEvent.keysChanged.has("source")) {
      changes.sourceChange = [
        { delete: this._prevSourceLength },
        { insert: ysource.toString() }
      ];
    }
    this._prevSourceLength = ysource.length;
    return changes;
  }
}
class YCodeCell extends YBaseCell {
  /**
   * Create a new YCodeCell that works standalone. It cannot be
   * inserted into a YNotebook because the Yjs model is already
   * attached to an anonymous Y.Doc instance.
   */
  static create(id) {
    return super.create(id);
  }
  /**
   * Code cell constructor
   *
   * ### Notes
   * Don't use the constructor directly - prefer using ``YNotebook.insertCell``
   *
   * The ``ysource`` is needed because ``ymodel.get('source')`` will
   * not return the real source if the model is not yet attached to
   * a document. Requesting it explicitly allows to introspect a non-empty
   * source before the cell is attached to the document.
   *
   * @param ymodel Cell map
   * @param ysource Cell source
   * @param youtputs Code cell outputs
   * @param options \{ notebook?: The notebook the cell is attached to \}
   * @param ymetadata Cell metadata
   */
  constructor(ymodel, ysource, youtputs, options = {}, ymetadata) {
    super(ymodel, ysource, options, ymetadata);
    this._youtputs = youtputs;
  }
  /**
   * The type of the cell.
   */
  get cell_type() {
    return "code";
  }
  /**
   * The code cell's prompt number. Will be null if the cell has not been run.
   */
  get execution_count() {
    return this.ymodel.get("execution_count") || null;
  }
  set execution_count(count) {
    if (this.ymodel.get("execution_count") !== count) {
      this.transact(() => {
        this.ymodel.set("execution_count", count);
      }, false);
    }
  }
  /**
   * The code cell's execution state.
   */
  get executionState() {
    var _a;
    return (_a = this.ymodel.get("execution_state")) !== null && _a !== void 0 ? _a : "idle";
  }
  set executionState(state) {
    if (this.ymodel.get("execution_state") !== state) {
      this.transact(() => {
        this.ymodel.set("execution_state", state);
      }, false);
    }
  }
  /**
   * Cell outputs.
   */
  get outputs() {
    return this.getOutputs();
  }
  set outputs(v) {
    this.setOutputs(v);
  }
  get youtputs() {
    return this._youtputs;
  }
  /**
   * Execution, display, or stream outputs.
   */
  getOutputs() {
    return JSONExt.deepCopy(this._youtputs.toJSON());
  }
  createOutputs(outputs) {
    const newOutputs = [];
    for (const output of JSONExt.deepCopy(outputs)) {
      let _newOutput1;
      if (output.output_type === "stream") {
        const { text: text2, ...outputWithoutText } = output;
        _newOutput1 = outputWithoutText;
        const newText = new YText();
        let _text = text2 instanceof Array ? text2.join() : text2;
        newText.insert(0, _text);
        _newOutput1["text"] = newText;
      } else {
        _newOutput1 = output;
      }
      const _newOutput2 = [];
      for (const [key2, value] of Object.entries(_newOutput1)) {
        _newOutput2.push([key2, value]);
      }
      const newOutput = new YMap(_newOutput2);
      newOutputs.push(newOutput);
    }
    return newOutputs;
  }
  /**
   * Replace all outputs.
   */
  setOutputs(outputs) {
    this.transact(() => {
      this._youtputs.delete(0, this._youtputs.length);
      const newOutputs = this.createOutputs(outputs);
      this._youtputs.insert(0, newOutputs);
    }, false);
  }
  /**
   * Remove text from a stream output.
   */
  removeStreamOutput(index, start, origin = null) {
    this.transact(() => {
      const output = this._youtputs.get(index);
      const prevText = output.get("text");
      const length2 = prevText.length - start;
      prevText.delete(start, length2);
    }, false, origin);
  }
  /**
   * Append text to a stream output.
   */
  appendStreamOutput(index, text2, origin = null) {
    this.transact(() => {
      const output = this._youtputs.get(index);
      const prevText = output.get("text");
      prevText.insert(prevText.length, text2);
    }, false, origin);
  }
  /**
   * Replace content from `start' to `end` with `outputs`.
   *
   * @param start: The start index of the range to replace (inclusive).
   *
   * @param end: The end index of the range to replace (exclusive).
   *
   * @param outputs: New outputs (optional).
   */
  updateOutputs(start, end, outputs = [], origin = null) {
    const fin = end < this._youtputs.length ? end - start : this._youtputs.length - start;
    this.transact(() => {
      this._youtputs.delete(start, fin);
      const newOutputs = this.createOutputs(outputs);
      this._youtputs.insert(start, newOutputs);
    }, false, origin);
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return {
      ...super.toJSON(),
      outputs: this.getOutputs(),
      execution_count: this.execution_count
    };
  }
  /**
   * Extract changes from YJS events
   *
   * @param events YJS events
   * @returns Cell changes
   */
  getChanges(events) {
    const changes = super.getChanges(events);
    const streamOutputEvent = events.find(
      // Changes to the 'text' of a cell's stream output can be accessed like so:
      // ycell['outputs'][output_idx]['text']
      // This translates to an event path of: ['outputs', output_idx, 'text]
      (event2) => event2.path.length === 3 && event2.path[0] === "outputs" && event2.path[2] === "text"
    );
    if (streamOutputEvent) {
      changes.streamOutputChange = streamOutputEvent.changes.delta;
    }
    const outputEvent = events.find((event2) => event2.target === this.ymodel.get("outputs"));
    if (outputEvent) {
      changes.outputsChange = outputEvent.changes.delta;
    }
    const modelEvent = events.find((event2) => event2.target === this.ymodel);
    if (modelEvent && modelEvent.keysChanged.has("execution_count")) {
      const change = modelEvent.changes.keys.get("execution_count");
      changes.executionCountChange = {
        oldValue: change.oldValue,
        newValue: this.ymodel.get("execution_count")
      };
    }
    if (modelEvent && modelEvent.keysChanged.has("execution_state")) {
      const change = modelEvent.changes.keys.get("execution_state");
      changes.executionStateChange = {
        oldValue: change.oldValue,
        newValue: this.ymodel.get("execution_state")
      };
    }
    return changes;
  }
}
class YAttachmentCell extends YBaseCell {
  /**
   * Cell attachments
   */
  get attachments() {
    return this.getAttachments();
  }
  set attachments(v) {
    this.setAttachments(v);
  }
  /**
   * Gets the cell attachments.
   *
   * @returns The cell attachments.
   */
  getAttachments() {
    return this.ymodel.get("attachments");
  }
  /**
   * Sets the cell attachments
   *
   * @param attachments: The cell attachments.
   */
  setAttachments(attachments) {
    this.transact(() => {
      if (attachments == null) {
        this.ymodel.delete("attachments");
      } else {
        this.ymodel.set("attachments", attachments);
      }
    }, false);
  }
  /**
   * Extract changes from YJS events
   *
   * @param events YJS events
   * @returns Cell changes
   */
  getChanges(events) {
    const changes = super.getChanges(events);
    const modelEvent = events.find((event2) => event2.target === this.ymodel);
    if (modelEvent && modelEvent.keysChanged.has("attachments")) {
      const change = modelEvent.changes.keys.get("attachments");
      changes.attachmentsChange = {
        oldValue: change.oldValue,
        newValue: this.ymodel.get("attachments")
      };
    }
    return changes;
  }
}
class YRawCell extends YAttachmentCell {
  /**
   * Create a new YRawCell that works standalone. It cannot be
   * inserted into a YNotebook because the Yjs model is already
   * attached to an anonymous Y.Doc instance.
   */
  static create(id) {
    return super.create(id);
  }
  /**
   * String identifying the type of cell.
   */
  get cell_type() {
    return "raw";
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return {
      id: this.getId(),
      cell_type: "raw",
      source: this.getSource(),
      metadata: this.getMetadata(),
      attachments: this.getAttachments()
    };
  }
}
class YMarkdownCell extends YAttachmentCell {
  /**
   * Create a new YMarkdownCell that works standalone. It cannot be
   * inserted into a YNotebook because the Yjs model is already
   * attached to an anonymous Y.Doc instance.
   */
  static create(id) {
    return super.create(id);
  }
  /**
   * String identifying the type of cell.
   */
  get cell_type() {
    return "markdown";
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return {
      id: this.getId(),
      cell_type: "markdown",
      source: this.getSource(),
      metadata: this.getMetadata(),
      attachments: this.getAttachments()
    };
  }
}
class YNotebook extends YDocument {
  /**
   * Create a new notebook
   *
   * #### Notes
   * The document is empty and must be populated
   *
   * @param options
   */
  constructor(options = {}) {
    var _a;
    super();
    this.version = "2.0.0";
    this.ymeta = this.ydoc.getMap("meta");
    this._onMetaChanged = (events) => {
      const metadataEvents = events.find((event2) => event2.target === this.ymeta.get("metadata"));
      if (metadataEvents) {
        const metadataChange = metadataEvents.changes.keys;
        const ymetadata = this.ymeta.get("metadata");
        metadataEvents.changes.keys.forEach((change, key2) => {
          switch (change.action) {
            case "add":
              this._metadataChanged.emit({
                key: key2,
                type: "add",
                newValue: ymetadata.get(key2)
              });
              break;
            case "delete":
              this._metadataChanged.emit({
                key: key2,
                type: "remove",
                oldValue: change.oldValue
              });
              break;
            case "update":
              {
                const newValue = ymetadata.get(key2);
                const oldValue = change.oldValue;
                let equal = true;
                if (typeof oldValue == "object" && typeof newValue == "object") {
                  equal = JSONExt.deepEqual(oldValue, newValue);
                } else {
                  equal = oldValue === newValue;
                }
                if (!equal) {
                  this._metadataChanged.emit({
                    key: key2,
                    type: "change",
                    oldValue,
                    newValue
                  });
                }
              }
              break;
          }
        });
        this._changed.emit({ metadataChange });
      }
      const metaEvent = events.find((event2) => event2.target === this.ymeta);
      if (!metaEvent) {
        return;
      }
      if (metaEvent.keysChanged.has("metadata")) {
        const change = metaEvent.changes.keys.get("metadata");
        if ((change === null || change === void 0 ? void 0 : change.action) === "add" && !change.oldValue) {
          const metadataChange = /* @__PURE__ */ new Map();
          for (const key2 of Object.keys(this.metadata)) {
            metadataChange.set(key2, {
              action: "add",
              oldValue: void 0
            });
            this._metadataChanged.emit({
              key: key2,
              type: "add",
              newValue: this.getMetadata(key2)
            });
          }
          this._changed.emit({ metadataChange });
        }
      }
      if (metaEvent.keysChanged.has("nbformat")) {
        const change = metaEvent.changes.keys.get("nbformat");
        const nbformatChanged = {
          key: "nbformat",
          oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : void 0,
          newValue: this.nbformat
        };
        this._changed.emit({ nbformatChanged });
      }
      if (metaEvent.keysChanged.has("nbformat_minor")) {
        const change = metaEvent.changes.keys.get("nbformat_minor");
        const nbformatChanged = {
          key: "nbformat_minor",
          oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : void 0,
          newValue: this.nbformat_minor
        };
        this._changed.emit({ nbformatChanged });
      }
    };
    this._onYCellsChanged = (event2) => {
      event2.changes.added.forEach((item) => {
        const type = item.content.type;
        if (!this._ycellMapping.has(type)) {
          const c = createCellModelFromSharedType(type, { notebook: this });
          c.setUndoManager();
          this._ycellMapping.set(type, c);
        }
      });
      event2.changes.deleted.forEach((item) => {
        const type = item.content.type;
        const model = this._ycellMapping.get(type);
        if (model) {
          model.dispose();
          this._ycellMapping.delete(type);
        }
      });
      let index = 0;
      const cellsChange = [];
      event2.changes.delta.forEach((d) => {
        if (d.insert != null) {
          const insertedCells = d.insert.map((ycell) => this._ycellMapping.get(ycell));
          cellsChange.push({ insert: insertedCells });
          this.cells.splice(index, 0, ...insertedCells);
          index += d.insert.length;
        } else if (d.delete != null) {
          cellsChange.push(d);
          this.cells.splice(index, d.delete);
        } else if (d.retain != null) {
          cellsChange.push(d);
          index += d.retain;
        }
      });
      this._changed.emit({
        cellsChange
      });
    };
    this._metadataChanged = new Signal(this);
    this._ycells = this.ydoc.getArray("cells");
    this._ycellMapping = /* @__PURE__ */ new WeakMap();
    this._disableDocumentWideUndoRedo = (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : false;
    this.cells = this._ycells.toArray().map((ycell) => {
      if (!this._ycellMapping.has(ycell)) {
        this._ycellMapping.set(ycell, createCellModelFromSharedType(ycell, { notebook: this }));
      }
      return this._ycellMapping.get(ycell);
    });
    this.undoManager.addToScope(this._ycells);
    this._ycells.observe(this._onYCellsChanged);
    this.ymeta.observeDeep(this._onMetaChanged);
  }
  /**
   * Creates a standalone YNotebook
   *
   * Note: This method is useful when we need to initialize
   * the YNotebook from the JavaScript side.
   */
  static create(options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const ynotebook = new YNotebook({
      disableDocumentWideUndoRedo: (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : false
    });
    const data = {
      cells: (_c = (_b = options.data) === null || _b === void 0 ? void 0 : _b.cells) !== null && _c !== void 0 ? _c : [],
      nbformat: (_e = (_d = options.data) === null || _d === void 0 ? void 0 : _d.nbformat) !== null && _e !== void 0 ? _e : 4,
      nbformat_minor: (_g = (_f = options.data) === null || _f === void 0 ? void 0 : _f.nbformat_minor) !== null && _g !== void 0 ? _g : 5,
      metadata: (_j = (_h = options.data) === null || _h === void 0 ? void 0 : _h.metadata) !== null && _j !== void 0 ? _j : {}
    };
    ynotebook.fromJSON(data);
    return ynotebook;
  }
  /**
   * Wether the undo/redo logic should be
   * considered on the full document across all cells.
   *
   * Default: false
   */
  get disableDocumentWideUndoRedo() {
    return this._disableDocumentWideUndoRedo;
  }
  /**
   * Notebook metadata
   */
  get metadata() {
    return this.getMetadata();
  }
  set metadata(v) {
    this.setMetadata(v);
  }
  /**
   * Signal triggered when a metadata changes.
   */
  get metadataChanged() {
    return this._metadataChanged;
  }
  /**
   * nbformat major version
   */
  get nbformat() {
    return this.ymeta.get("nbformat");
  }
  set nbformat(value) {
    this.transact(() => {
      this.ymeta.set("nbformat", value);
    }, false);
  }
  /**
   * nbformat minor version
   */
  get nbformat_minor() {
    return this.ymeta.get("nbformat_minor");
  }
  set nbformat_minor(value) {
    this.transact(() => {
      this.ymeta.set("nbformat_minor", value);
    }, false);
  }
  /**
   * Dispose of the resources.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._ycells.unobserve(this._onYCellsChanged);
    this.ymeta.unobserveDeep(this._onMetaChanged);
    super.dispose();
  }
  /**
   * Get a shared cell by index.
   *
   * @param index: Cell's position.
   *
   * @returns The requested shared cell.
   */
  getCell(index) {
    return this.cells[index];
  }
  /**
   * Add a shared cell at the notebook bottom.
   *
   * @param cell Cell to add.
   *
   * @returns The added cell.
   */
  addCell(cell) {
    return this.insertCell(this._ycells.length, cell);
  }
  /**
   * Insert a shared cell into a specific position.
   *
   * @param index: Cell's position.
   * @param cell: Cell to insert.
   *
   * @returns The inserted cell.
   */
  insertCell(index, cell) {
    return this.insertCells(index, [cell])[0];
  }
  /**
   * Insert a list of shared cells into a specific position.
   *
   * @param index: Position to insert the cells.
   * @param cells: Array of shared cells to insert.
   *
   * @returns The inserted cells.
   */
  insertCells(index, cells) {
    const yCells = cells.map((c) => {
      const cell = createCell(c, this);
      this._ycellMapping.set(cell.ymodel, cell);
      return cell;
    });
    this.transact(() => {
      this._ycells.insert(index, yCells.map((cell) => cell.ymodel));
    });
    yCells.forEach((c) => {
      c.setUndoManager();
    });
    return yCells;
  }
  /**
   * Move a cell.
   *
   * @param fromIndex: Index of the cell to move.
   * @param toIndex: New position of the cell.
   */
  moveCell(fromIndex, toIndex) {
    this.moveCells(fromIndex, toIndex);
  }
  /**
   * Move cells.
   *
   * @param fromIndex: Index of the first cells to move.
   * @param toIndex: New position of the first cell (in the current array).
   * @param n: Number of cells to move (default 1)
   */
  moveCells(fromIndex, toIndex, n = 1) {
    const clones = new Array(n).fill(true).map((_, idx) => this.getCell(fromIndex + idx).toJSON());
    this.transact(() => {
      this._ycells.delete(fromIndex, n);
      this._ycells.insert(fromIndex > toIndex ? toIndex : toIndex - n + 1, clones.map((clone) => createCell(clone, this).ymodel));
    });
  }
  /**
   * Remove a cell.
   *
   * @param index: Index of the cell to remove.
   */
  deleteCell(index) {
    this.deleteCellRange(index, index + 1);
  }
  /**
   * Remove a range of cells.
   *
   * @param from: The start index of the range to remove (inclusive).
   * @param to: The end index of the range to remove (exclusive).
   */
  deleteCellRange(from2, to) {
    this.transact(() => {
      this._ycells.delete(from2, to - from2);
    });
  }
  /**
   * Delete a metadata notebook.
   *
   * @param key The key to delete
   */
  deleteMetadata(key2) {
    if (typeof this.getMetadata(key2) === "undefined") {
      return;
    }
    const allMetadata = this.metadata;
    delete allMetadata[key2];
    this.setMetadata(allMetadata);
  }
  getMetadata(key2) {
    const ymetadata = this.ymeta.get("metadata");
    if (ymetadata === void 0) {
      return void 0;
    }
    if (typeof key2 === "string") {
      const value = ymetadata.get(key2);
      return typeof value === "undefined" ? void 0 : JSONExt.deepCopy(value);
    } else {
      return JSONExt.deepCopy(ymetadata.toJSON());
    }
  }
  setMetadata(metadata, value) {
    var _a;
    if (typeof metadata === "string") {
      if (typeof value === "undefined") {
        throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);
      }
      if (JSONExt.deepEqual((_a = this.getMetadata(metadata)) !== null && _a !== void 0 ? _a : null, value)) {
        return;
      }
      const update = {};
      update[metadata] = value;
      this.updateMetadata(update);
    } else {
      if (!this.metadata || !JSONExt.deepEqual(this.metadata, metadata)) {
        const clone = JSONExt.deepCopy(metadata);
        const ymetadata = this.ymeta.get("metadata");
        if (ymetadata === void 0) {
          return void 0;
        }
        this.transact(() => {
          ymetadata.clear();
          for (const [key2, value2] of Object.entries(clone)) {
            ymetadata.set(key2, value2);
          }
        });
      }
    }
  }
  /**
   * Updates the metadata associated with the notebook.
   *
   * @param value: Metadata's attribute to update.
   */
  updateMetadata(value) {
    const clone = JSONExt.deepCopy(value);
    const ymetadata = this.ymeta.get("metadata");
    if (ymetadata === void 0) {
      return void 0;
    }
    this.transact(() => {
      for (const [key2, value2] of Object.entries(clone)) {
        ymetadata.set(key2, value2);
      }
    });
  }
  /**
   * Get the notebook source
   *
   * @returns The notebook
   */
  getSource() {
    return this.toJSON();
  }
  /**
   * Set the notebook source
   *
   * @param value The notebook
   */
  setSource(value) {
    this.fromJSON(value);
  }
  /**
   * Override the notebook with a JSON-serialized document.
   *
   * @param value The notebook
   */
  fromJSON(value) {
    this.transact(() => {
      this.nbformat = value.nbformat;
      this.nbformat_minor = value.nbformat_minor;
      const metadata = value.metadata;
      if (metadata["orig_nbformat"] !== void 0) {
        delete metadata["orig_nbformat"];
      }
      if (!this.metadata) {
        const ymetadata = new YMap();
        for (const [key2, value2] of Object.entries(metadata)) {
          ymetadata.set(key2, value2);
        }
        this.ymeta.set("metadata", ymetadata);
      } else {
        this.metadata = metadata;
      }
      const useId = value.nbformat === 4 && value.nbformat_minor >= 5;
      const ycells = value.cells.map((cell) => {
        if (!useId) {
          delete cell.id;
        }
        return cell;
      });
      this.insertCells(this.cells.length, ycells);
      this.deleteCellRange(0, this.cells.length);
    });
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    const pruneCellId = this.nbformat === 4 && this.nbformat_minor <= 4;
    return {
      metadata: this.metadata,
      nbformat_minor: this.nbformat_minor,
      nbformat: this.nbformat,
      cells: this.cells.map((c) => {
        const raw = c.toJSON();
        if (pruneCellId) {
          delete raw.id;
        }
        return raw;
      })
    };
  }
}
var IEditorMimeTypeService;
(function(IEditorMimeTypeService2) {
  IEditorMimeTypeService2.defaultMimeType = "text/plain";
})(IEditorMimeTypeService || (IEditorMimeTypeService = {}));
var CodeEditor;
(function(CodeEditor2) {
  class Model {
    /**
     * Construct a new Model.
     */
    constructor(options = {}) {
      var _a, _b;
      this.standaloneModel = false;
      this._isDisposed = false;
      this._selections = new ObservableMap();
      this._mimeType = IEditorMimeTypeService.defaultMimeType;
      this._mimeTypeChanged = new Signal(this);
      this.standaloneModel = typeof options.sharedModel === "undefined";
      this.sharedModel = (_a = options.sharedModel) !== null && _a !== void 0 ? _a : new YFile();
      this._mimeType = (_b = options.mimeType) !== null && _b !== void 0 ? _b : IEditorMimeTypeService.defaultMimeType;
    }
    /**
     * A signal emitted when a mimetype changes.
     */
    get mimeTypeChanged() {
      return this._mimeTypeChanged;
    }
    /**
     * Get the selections for the model.
     */
    get selections() {
      return this._selections;
    }
    /**
     * A mime type of the model.
     */
    get mimeType() {
      return this._mimeType;
    }
    set mimeType(newValue) {
      const oldValue = this.mimeType;
      if (oldValue === newValue) {
        return;
      }
      this._mimeType = newValue;
      this._mimeTypeChanged.emit({
        name: "mimeType",
        oldValue,
        newValue
      });
    }
    /**
     * Whether the model is disposed.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Dispose of the resources used by the model.
     */
    dispose() {
      if (this._isDisposed) {
        return;
      }
      this._isDisposed = true;
      this._selections.dispose();
      if (this.standaloneModel) {
        this.sharedModel.dispose();
      }
      Signal.clearData(this);
    }
  }
  CodeEditor2.Model = Model;
})(CodeEditor || (CodeEditor = {}));
const HAS_SELECTION_CLASS = "jp-mod-has-primary-selection";
const HAS_IN_LEADING_WHITESPACE_CLASS = "jp-mod-in-leading-whitespace";
const DROP_TARGET_CLASS$1 = "jp-mod-dropTarget";
const leadingWhitespaceRe = /^\s+$/;
class CodeEditorWrapper extends Widget {
  /**
   * Construct a new code editor widget.
   */
  constructor(options) {
    super();
    const { factory, model, editorOptions } = options;
    const editor = this.editor = factory({
      host: this.node,
      model,
      ...editorOptions
    });
    editor.model.selections.changed.connect(this._onSelectionsChanged, this);
  }
  /**
   * Get the model used by the widget.
   */
  get model() {
    return this.editor.model;
  }
  /**
   * Dispose of the resources held by the widget.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.editor.dispose();
    super.dispose();
  }
  /**
   * Handle the DOM events for the widget.
   *
   * @param event - The DOM event sent to the widget.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the notebook panel's node. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "lm-dragenter":
        this._evtDragEnter(event2);
        break;
      case "lm-dragleave":
        this._evtDragLeave(event2);
        break;
      case "lm-dragover":
        this._evtDragOver(event2);
        break;
      case "lm-drop":
        this._evtDrop(event2);
        break;
    }
  }
  /**
   * Handle `'activate-request'` messages.
   */
  onActivateRequest(msg) {
    this.editor.focus();
  }
  /**
   * A message handler invoked on an `'after-attach'` message.
   */
  onAfterAttach(msg) {
    super.onAfterAttach(msg);
    const node2 = this.node;
    node2.addEventListener("lm-dragenter", this);
    node2.addEventListener("lm-dragleave", this);
    node2.addEventListener("lm-dragover", this);
    node2.addEventListener("lm-drop", this);
  }
  /**
   * Handle `before-detach` messages for the widget.
   */
  onBeforeDetach(msg) {
    const node2 = this.node;
    node2.removeEventListener("lm-dragenter", this);
    node2.removeEventListener("lm-dragleave", this);
    node2.removeEventListener("lm-dragover", this);
    node2.removeEventListener("lm-drop", this);
  }
  /**
   * Handle a change in model selections.
   */
  _onSelectionsChanged() {
    const { start, end } = this.editor.getSelection();
    if (start.column !== end.column || start.line !== end.line) {
      this.addClass(HAS_SELECTION_CLASS);
      this.removeClass(HAS_IN_LEADING_WHITESPACE_CLASS);
    } else {
      this.removeClass(HAS_SELECTION_CLASS);
      if (this.editor.getLine(end.line).slice(0, end.column).match(leadingWhitespaceRe)) {
        this.addClass(HAS_IN_LEADING_WHITESPACE_CLASS);
      } else {
        this.removeClass(HAS_IN_LEADING_WHITESPACE_CLASS);
      }
    }
  }
  /**
   * Handle the `'lm-dragenter'` event for the widget.
   */
  _evtDragEnter(event2) {
    if (this.editor.getOption("readOnly") === true) {
      return;
    }
    const data = Private$a.findTextData(event2.mimeData);
    if (data === void 0) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    this.addClass("jp-mod-dropTarget");
  }
  /**
   * Handle the `'lm-dragleave'` event for the widget.
   */
  _evtDragLeave(event2) {
    this.removeClass(DROP_TARGET_CLASS$1);
    if (this.editor.getOption("readOnly") === true) {
      return;
    }
    const data = Private$a.findTextData(event2.mimeData);
    if (data === void 0) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
  }
  /**
   * Handle the `'lm-dragover'` event for the widget.
   */
  _evtDragOver(event2) {
    this.removeClass(DROP_TARGET_CLASS$1);
    if (this.editor.getOption("readOnly") === true) {
      return;
    }
    const data = Private$a.findTextData(event2.mimeData);
    if (data === void 0) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    event2.dropAction = "copy";
    this.addClass(DROP_TARGET_CLASS$1);
  }
  /**
   * Handle the `'lm-drop'` event for the widget.
   */
  _evtDrop(event2) {
    if (this.editor.getOption("readOnly") === true) {
      return;
    }
    const data = Private$a.findTextData(event2.mimeData);
    if (data === void 0) {
      return;
    }
    const coordinate = {
      top: event2.y,
      bottom: event2.y,
      left: event2.x,
      right: event2.x
    };
    const position = this.editor.getPositionForCoordinate(coordinate);
    if (position === null) {
      return;
    }
    this.removeClass(DROP_TARGET_CLASS$1);
    event2.preventDefault();
    event2.stopPropagation();
    if (event2.proposedAction === "none") {
      event2.dropAction = "none";
      return;
    }
    const offset = this.editor.getOffsetAt(position);
    this.model.sharedModel.updateSource(offset, offset, data);
  }
}
var Private$a;
(function(Private2) {
  function findTextData(mime) {
    const types2 = mime.types();
    const textType = types2.find((t) => t.indexOf("text") === 0);
    if (textType === void 0) {
      return void 0;
    }
    return mime.getData(textType);
  }
  Private2.findTextData = findTextData;
})(Private$a || (Private$a = {}));
const INPUT_AREA_CLASS = "jp-InputArea";
const INPUT_AREA_PROMPT_CLASS = "jp-InputArea-prompt";
const INPUT_PROMPT_CLASS$1 = "jp-InputPrompt";
const INPUT_AREA_EDITOR_CLASS = "jp-InputArea-editor";
class InputArea extends Widget {
  /**
   * Construct an input area widget.
   */
  constructor(options) {
    super();
    this.addClass(INPUT_AREA_CLASS);
    const { contentFactory, editorOptions, model } = options;
    this.model = model;
    this.contentFactory = contentFactory;
    const prompt = this._prompt = contentFactory.createInputPrompt();
    prompt.addClass(INPUT_AREA_PROMPT_CLASS);
    const editor = this._editor = new CodeEditorWrapper({
      factory: contentFactory.editorFactory,
      model,
      editorOptions
    });
    editor.addClass(INPUT_AREA_EDITOR_CLASS);
    const layout = this.layout = new PanelLayout();
    layout.addWidget(prompt);
    layout.addWidget(editor);
  }
  /**
   * Get the CodeEditorWrapper used by the cell.
   */
  get editorWidget() {
    return this._editor;
  }
  /**
   * Get the CodeEditor used by the cell.
   */
  get editor() {
    return this._editor.editor;
  }
  /**
   * Get the prompt node used by the cell.
   */
  get promptNode() {
    return this._prompt.node;
  }
  /**
   * Get the rendered input area widget, if any.
   */
  get renderedInput() {
    return this._rendered;
  }
  /**
   * Render an input instead of the text editor.
   */
  renderInput(widget) {
    const layout = this.layout;
    if (this._rendered) {
      this._rendered.parent = null;
    }
    this._editor.hide();
    this._rendered = widget;
    layout.addWidget(widget);
  }
  /**
   * Show the text editor.
   */
  showEditor() {
    if (this._rendered) {
      this._rendered.parent = null;
    }
    this._editor.show();
  }
  /**
   * Set the prompt of the input area.
   */
  setPrompt(value) {
    this._prompt.executionCount = value;
  }
  /**
   * Dispose of the resources held by the widget.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._prompt = null;
    this._editor = null;
    this._rendered = null;
    super.dispose();
  }
}
(function(InputArea2) {
  class ContentFactory {
    /**
     * Construct a `ContentFactory`.
     */
    constructor(options) {
      this._editor = options.editorFactory;
    }
    /**
     * Return the `CodeEditor.Factory` being used.
     */
    get editorFactory() {
      return this._editor;
    }
    /**
     * Create an input prompt.
     */
    createInputPrompt() {
      return new InputPrompt();
    }
  }
  InputArea2.ContentFactory = ContentFactory;
})(InputArea || (InputArea = {}));
class InputPrompt extends Widget {
  /*
   * Create an output prompt widget.
   */
  constructor() {
    super();
    this._executionCount = null;
    this.addClass(INPUT_PROMPT_CLASS$1);
  }
  /**
   * The execution count for the prompt.
   */
  get executionCount() {
    return this._executionCount;
  }
  set executionCount(value) {
    this._executionCount = value;
    if (value === null) {
      this.node.textContent = " ";
    } else {
      this.node.textContent = `[${value || " "}]:`;
    }
  }
}
class AttachmentModel {
  /**
   * Construct a new attachment model.
   */
  constructor(options) {
    this.trusted = false;
    this._changed = new Signal(this);
    this._raw = {};
    const data = Private$9.getData(options.value);
    this._data = new ObservableJSON({ values: data });
    this._rawData = data;
    const value = options.value;
    for (const key2 in value) {
      switch (key2) {
        case "data":
          break;
        default:
          this._raw[key2] = Private$9.extract(value, key2);
      }
    }
  }
  /**
   * A signal emitted when the attachment model changes.
   */
  get changed() {
    return this._changed;
  }
  /**
   * Dispose of the resources used by the attachment model.
   */
  dispose() {
    this._data.dispose();
    Signal.clearData(this);
  }
  /**
   * The data associated with the model.
   */
  get data() {
    return this._rawData;
  }
  /**
   * The metadata associated with the model.
   */
  get metadata() {
    return {};
  }
  /**
   * Set the data associated with the model.
   *
   * #### Notes
   * Depending on the implementation of the mime model,
   * this call may or may not have deferred effects,
   */
  setData(options) {
    if (options.data) {
      this._updateObservable(this._data, options.data);
      this._rawData = options.data;
    }
    this._changed.emit(void 0);
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    const attachment = {};
    for (const key2 in this._raw) {
      attachment[key2] = Private$9.extract(this._raw, key2);
    }
    return attachment;
  }
  /**
   * Update an observable JSON object using a readonly JSON object.
   */
  _updateObservable(observable2, data) {
    const oldKeys = observable2.keys();
    const newKeys = Object.keys(data);
    for (const key2 of oldKeys) {
      if (newKeys.indexOf(key2) === -1) {
        observable2.delete(key2);
      }
    }
    for (const key2 of newKeys) {
      const oldValue = observable2.get(key2);
      const newValue = data[key2];
      if (oldValue !== newValue) {
        observable2.set(key2, newValue);
      }
    }
  }
}
(function(AttachmentModel2) {
  function getData(bundle) {
    return Private$9.getData(bundle);
  }
  AttachmentModel2.getData = getData;
})(AttachmentModel || (AttachmentModel = {}));
var Private$9;
(function(Private2) {
  function getData(bundle) {
    return convertBundle(bundle);
  }
  Private2.getData = getData;
  function getBundleOptions(options) {
    const data = getData(options.value);
    return { data };
  }
  Private2.getBundleOptions = getBundleOptions;
  function extract(value, key2) {
    const item = value[key2];
    if (item === void 0 || JSONExt.isPrimitive(item)) {
      return item;
    }
    return JSONExt.deepCopy(item);
  }
  Private2.extract = extract;
  function convertBundle(bundle) {
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const mimeType in bundle) {
      map2[mimeType] = extract(bundle, mimeType);
    }
    return map2;
  }
})(Private$9 || (Private$9 = {}));
var INFINITY = 1 / 0;
var symbolTag = "[object Symbol]";
var reUnescapedHtml = /[&<>"'`]/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "`": "&#96;"
};
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
function basePropertyOf(object) {
  return function(key2) {
    return object == null ? void 0 : object[key2];
  };
}
var escapeHtmlChar = basePropertyOf(htmlEscapes);
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var Symbol$1 = root.Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function escape(string) {
  string = toString(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
}
var lodash_escape = escape;
const escape$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_escape);
const inline = "$";
const MATHSPLIT = /(\$\$?|\\(?:begin|end)\{[a-z]*\*?\}|\\[{}$]|[{}]|(?:\n\s*)+|@@\d+@@|\\\\(?:\(|\)|\[|\]))/i;
function removeMath(text2) {
  const math = [];
  let start = null;
  let end = null;
  let last2 = null;
  let braces = 0;
  let deTilde;
  const hasCodeSpans = text2.includes("`") || text2.includes("~~~");
  if (hasCodeSpans) {
    text2 = text2.replace(/~/g, "~T").replace(/^(?<fence>`{3,}|(~T){3,})[^`\n]*\n([\s\S]*?)^\k<fence>`*$/gm, (wholematch) => wholematch.replace(/\$/g, "~D")).replace(/(^|[^\\])(`+)([^\n]*?[^`\n])\2(?!`)/gm, (wholematch) => wholematch.replace(/\$/g, "~D"));
    deTilde = (text3) => {
      return text3.replace(/~([TD])/g, (wholematch, character) => character === "T" ? "~" : inline);
    };
  } else {
    deTilde = (text3) => {
      return text3;
    };
  }
  let blocks = text2.replace(/\r\n?/g, "\n").split(MATHSPLIT);
  for (let i2 = 1, m2 = blocks.length; i2 < m2; i2 += 2) {
    const block = blocks[i2];
    if (block.charAt(0) === "@") {
      blocks[i2] = "@@" + math.length + "@@";
      math.push(block);
    } else if (start !== null) {
      if (block === end) {
        if (braces) {
          last2 = i2;
        } else {
          blocks = processMath(start, i2, deTilde, math, blocks);
          start = null;
          end = null;
          last2 = null;
        }
      } else if (block.match(/\n.*\n/)) {
        if (last2 !== null) {
          i2 = last2;
          blocks = processMath(start, i2, deTilde, math, blocks);
        }
        start = null;
        end = null;
        last2 = null;
        braces = 0;
      } else if (block === "{") {
        braces++;
      } else if (block === "}" && braces) {
        braces--;
      }
    } else {
      if (block === inline || block === "$$") {
        start = i2;
        end = block;
        braces = 0;
      } else if (block === "\\\\(" || block === "\\\\[") {
        start = i2;
        end = block.slice(-1) === "(" ? "\\\\)" : "\\\\]";
        braces = 0;
      } else if (block.substr(1, 5) === "begin") {
        start = i2;
        end = "\\end" + block.substr(6);
        braces = 0;
      }
    }
  }
  if (start !== null && last2 !== null) {
    blocks = processMath(start, last2, deTilde, math, blocks);
    start = null;
    end = null;
    last2 = null;
  }
  return { text: deTilde(blocks.join("")), math };
}
function replaceMath(text2, math) {
  const process2 = (match, n) => {
    let group = math[n];
    if (group.substr(0, 3) === "\\\\(" && group.substr(group.length - 3) === "\\\\)") {
      group = "\\(" + group.substring(3, group.length - 3) + "\\)";
    } else if (group.substr(0, 3) === "\\\\[" && group.substr(group.length - 3) === "\\\\]") {
      group = "\\[" + group.substring(3, group.length - 3) + "\\]";
    }
    return group;
  };
  return text2.replace(/@@(\d+)@@/g, process2);
}
function processMath(i2, j, preProcess, math, blocks) {
  let block = blocks.slice(i2, j + 1).join("").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  if (navigator && navigator.appName === "Microsoft Internet Explorer") {
    block = block.replace(/(%[^\n]*)\n/g, "$1<br/>\n");
  }
  while (j > i2) {
    blocks[j] = "";
    j--;
  }
  blocks[i2] = "@@" + math.length + "@@";
  if (preProcess) {
    block = preProcess(block);
  }
  math.push(block);
  return blocks;
}
function renderHTML(options) {
  let { host, source, trusted, sanitizer, resolver, linkHandler, shouldTypeset, latexTypesetter, translator } = options;
  translator = translator || nullTranslator;
  const trans = translator === null || translator === void 0 ? void 0 : translator.load("jupyterlab");
  let originalSource = source;
  if (!source) {
    host.textContent = "";
    return Promise.resolve(void 0);
  }
  if (!trusted) {
    originalSource = `${source}`;
    source = sanitizer.sanitize(source);
  }
  host.innerHTML = source;
  if (host.getElementsByTagName("script").length > 0) {
    if (trusted) {
      Private$8.evalInnerHTMLScriptTags(host);
    } else {
      const container2 = document.createElement("div");
      const warning2 = document.createElement("pre");
      warning2.textContent = trans.__("This HTML output contains inline scripts. Are you sure that you want to run arbitrary Javascript within your JupyterLab session?");
      const runButton = document.createElement("button");
      runButton.textContent = trans.__("Run");
      runButton.onclick = (event2) => {
        host.innerHTML = originalSource;
        Private$8.evalInnerHTMLScriptTags(host);
        if (host.firstChild) {
          host.removeChild(host.firstChild);
        }
      };
      container2.appendChild(warning2);
      container2.appendChild(runButton);
      host.insertBefore(container2, host.firstChild);
    }
  }
  Private$8.handleDefaults(host, resolver);
  let promise;
  if (resolver) {
    promise = Private$8.handleUrls(host, resolver, linkHandler);
  } else {
    promise = Promise.resolve(void 0);
  }
  return promise.then(() => {
    if (shouldTypeset && latexTypesetter) {
      latexTypesetter.typeset(host);
    }
  });
}
function renderImage(options) {
  const { host, mimeType, source, width, height, needsBackground, unconfined } = options;
  host.textContent = "";
  const img = document.createElement("img");
  img.src = `data:${mimeType};base64,${source}`;
  if (typeof height === "number") {
    img.height = height;
  }
  if (typeof width === "number") {
    img.width = width;
  }
  if (needsBackground === "light") {
    img.classList.add("jp-needs-light-background");
  } else if (needsBackground === "dark") {
    img.classList.add("jp-needs-dark-background");
  }
  if (unconfined === true) {
    img.classList.add("jp-mod-unconfined");
  }
  host.appendChild(img);
  return Promise.resolve(void 0);
}
async function renderMarkdown(options) {
  const { host, source, markdownParser, ...others } = options;
  if (!source) {
    host.textContent = "";
    return;
  }
  let html2 = "";
  if (markdownParser) {
    const parts = removeMath(source);
    html2 = await markdownParser.render(parts["text"]);
    html2 = replaceMath(html2, parts["math"]);
  } else {
    html2 = `<pre>${source}</pre>`;
  }
  await renderHTML({
    host,
    source: html2,
    ...others
  });
  Private$8.headerAnchors(host);
}
(function(renderMarkdown2) {
  function createHeaderId(header) {
    var _a;
    return ((_a = header.textContent) !== null && _a !== void 0 ? _a : "").replace(/ /g, "-");
  }
  renderMarkdown2.createHeaderId = createHeaderId;
})(renderMarkdown || (renderMarkdown = {}));
var ILinker;
(function(ILinker2) {
  const controlCodes = "\\u0000-\\u0020\\u007f-\\u009f";
  ILinker2.webLinkRegex = new RegExp("(?<path>(?:[a-zA-Z][a-zA-Z0-9+.-]{2,}:\\/\\/|data:|www\\.)[^\\s" + controlCodes + '"]{2,}[^\\s' + controlCodes + `"'(){}\\[\\],:;.!?])`, "ug");
  const winAbsPathRegex = /(?:[a-zA-Z]:(?:(?:\\|\/)[\w\.-]*)+)/;
  const winRelPathRegex = /(?:(?:\~|\.)(?:(?:\\|\/)[\w\.-]*)+)/;
  const winPathRegex = new RegExp(`(${winAbsPathRegex.source}|${winRelPathRegex.source})`);
  const posixPathRegex = /((?:\~|\.)?(?:\/[\w\.-]*)+)/;
  const lineColumnRegex = /(?:(?:\:|", line )(?<line>[\d]+))?(?:\:(?<column>[\d]+))?/;
  const isWindows = navigator.userAgent.indexOf("Windows") >= 0;
  ILinker2.pathLinkRegex = new RegExp(`(?<path>${isWindows ? winPathRegex.source : posixPathRegex.source})${lineColumnRegex.source}`, "g");
})(ILinker || (ILinker = {}));
var Private$8;
(function(Private2) {
  function evalInnerHTMLScriptTags(host) {
    const scripts = Array.from(host.getElementsByTagName("script"));
    for (const script of scripts) {
      if (!script.parentNode) {
        continue;
      }
      const clone = document.createElement("script");
      const attrs = script.attributes;
      for (let i2 = 0, n = attrs.length; i2 < n; ++i2) {
        const { name: name2, value } = attrs[i2];
        clone.setAttribute(name2, value);
      }
      clone.textContent = script.textContent;
      script.parentNode.replaceChild(clone, script);
    }
  }
  Private2.evalInnerHTMLScriptTags = evalInnerHTMLScriptTags;
  function handleDefaults(node2, resolver) {
    const anchors = node2.getElementsByTagName("a");
    for (let i2 = 0; i2 < anchors.length; i2++) {
      const el = anchors[i2];
      if (!(el instanceof HTMLAnchorElement)) {
        continue;
      }
      const path2 = el.href;
      const isLocal = resolver && resolver.isLocal ? resolver.isLocal(path2) : lib$9.URLExt.isLocal(path2);
      if (!el.target) {
        el.target = isLocal ? "_self" : "_blank";
      }
      if (!isLocal) {
        el.rel = "noopener";
      }
    }
    const imgs = node2.getElementsByTagName("img");
    for (let i2 = 0; i2 < imgs.length; i2++) {
      if (!imgs[i2].alt) {
        imgs[i2].alt = "Image";
      }
    }
  }
  Private2.handleDefaults = handleDefaults;
  function handleUrls(node2, resolver, linkHandler) {
    const promises = [];
    const nodes = node2.querySelectorAll("*[src]");
    for (let i2 = 0; i2 < nodes.length; i2++) {
      promises.push(handleAttr(nodes[i2], "src", resolver));
    }
    const anchors = node2.getElementsByTagName("a");
    for (let i2 = 0; i2 < anchors.length; i2++) {
      promises.push(handleAnchor(anchors[i2], resolver, linkHandler));
    }
    const links = node2.getElementsByTagName("link");
    for (let i2 = 0; i2 < links.length; i2++) {
      promises.push(handleAttr(links[i2], "href", resolver));
    }
    return Promise.all(promises).then(() => void 0);
  }
  Private2.handleUrls = handleUrls;
  async function handlePaths(node2, resolver, linkHandler) {
    const anchors = node2.getElementsByTagName("a");
    for (let i2 = 0; i2 < anchors.length; i2++) {
      await handlePathAnchor(anchors[i2], resolver, linkHandler);
    }
  }
  Private2.handlePaths = handlePaths;
  function headerAnchors(node2) {
    const headerNames = ["h1", "h2", "h3", "h4", "h5", "h6"];
    for (const headerType of headerNames) {
      const headers = node2.getElementsByTagName(headerType);
      for (let i2 = 0; i2 < headers.length; i2++) {
        const header = headers[i2];
        header.id = renderMarkdown.createHeaderId(header);
        const anchor = document.createElement("a");
        anchor.target = "_self";
        anchor.textContent = "";
        anchor.href = "#" + header.id;
        anchor.classList.add("jp-InternalAnchorLink");
        header.appendChild(anchor);
      }
    }
  }
  Private2.headerAnchors = headerAnchors;
  async function handleAttr(node2, name2, resolver) {
    const source = node2.getAttribute(name2) || "";
    const isLocal = resolver.isLocal ? resolver.isLocal(source) : lib$9.URLExt.isLocal(source);
    if (!source || !isLocal) {
      return;
    }
    try {
      const urlPath = await resolver.resolveUrl(source);
      let url2 = await resolver.getDownloadUrl(urlPath);
      if (lib$9.URLExt.parse(url2).protocol !== "data:") {
        url2 += (/\?/.test(url2) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
      }
      node2.setAttribute(name2, url2);
    } catch (err) {
      node2.setAttribute(name2, "");
      throw err;
    }
  }
  function handleAnchor(anchor, resolver, linkHandler) {
    let href = anchor.getAttribute("href") || "";
    const isLocal = resolver.isLocal ? resolver.isLocal(href) : lib$9.URLExt.isLocal(href);
    if (!href || !isLocal) {
      return Promise.resolve(void 0);
    }
    const hash = anchor.hash;
    if (hash) {
      if (hash === href) {
        anchor.target = "_self";
        return Promise.resolve(void 0);
      }
      href = href.replace(hash, "");
    }
    return resolver.resolveUrl(href).then((urlPath) => {
      const path2 = decodeURIComponent(urlPath);
      if (linkHandler) {
        linkHandler.handleLink(anchor, path2, hash);
      }
      return resolver.getDownloadUrl(urlPath);
    }).then((url2) => {
      anchor.href = url2 + hash;
    }).catch((err) => {
      anchor.href = "";
    });
  }
  async function handlePathAnchor(anchor, resolver, linkHandler) {
    let path2 = anchor.dataset.path || "";
    let locator = anchor.dataset.locator ? "#" + anchor.dataset.locator : "";
    delete anchor.dataset.path;
    delete anchor.dataset.locator;
    const allowRoot = true;
    const isLocal = resolver.isLocal ? resolver.isLocal(path2, allowRoot) : lib$9.URLExt.isLocal(path2, allowRoot);
    if (!path2 || !isLocal || !resolver.resolvePath || !linkHandler || !linkHandler.handlePath) {
      anchor.replaceWith(...anchor.childNodes);
      return Promise.resolve(void 0);
    }
    try {
      const resolution = await resolver.resolvePath(path2);
      if (!resolution) {
        console.log("Path resolution bailing: does not exist");
        return Promise.resolve(void 0);
      }
      linkHandler.handlePath(anchor, resolution.path, resolution.scope, locator);
      anchor.href = resolution.path + locator;
    } catch (err) {
      console.warn("Path anchor error:", err);
      anchor.href = "#linking-failed-see-console";
    }
  }
  const ANSI_COLORS = [
    "ansi-black",
    "ansi-red",
    "ansi-green",
    "ansi-yellow",
    "ansi-blue",
    "ansi-magenta",
    "ansi-cyan",
    "ansi-white",
    "ansi-black-intense",
    "ansi-red-intense",
    "ansi-green-intense",
    "ansi-yellow-intense",
    "ansi-blue-intense",
    "ansi-magenta-intense",
    "ansi-cyan-intense",
    "ansi-white-intense"
  ];
  function pushColoredChunk(chunk, fg, bg, bold, underline, inverse, out) {
    if (chunk) {
      const classes2 = [];
      const styles = [];
      if (bold && typeof fg === "number" && 0 <= fg && fg < 8) {
        fg += 8;
      }
      if (inverse) {
        [fg, bg] = [bg, fg];
      }
      if (typeof fg === "number") {
        classes2.push(ANSI_COLORS[fg] + "-fg");
      } else if (fg.length) {
        styles.push(`color: rgb(${fg})`);
      } else if (inverse) {
        classes2.push("ansi-default-inverse-fg");
      }
      if (typeof bg === "number") {
        classes2.push(ANSI_COLORS[bg] + "-bg");
      } else if (bg.length) {
        styles.push(`background-color: rgb(${bg})`);
      } else if (inverse) {
        classes2.push("ansi-default-inverse-bg");
      }
      if (bold) {
        classes2.push("ansi-bold");
      }
      if (underline) {
        classes2.push("ansi-underline");
      }
      if (classes2.length || styles.length) {
        out.push("<span");
        if (classes2.length) {
          out.push(` class="${classes2.join(" ")}"`);
        }
        if (styles.length) {
          out.push(` style="${styles.join("; ")}"`);
        }
        out.push(">");
        out.push(chunk);
        out.push("</span>");
      } else {
        out.push(chunk);
      }
    }
  }
  function getExtendedColors(numbers) {
    let r;
    let g;
    let b;
    const n = numbers.shift();
    if (n === 2 && numbers.length >= 3) {
      r = numbers.shift();
      g = numbers.shift();
      b = numbers.shift();
      if ([r, g, b].some((c) => c < 0 || 255 < c)) {
        throw new RangeError("Invalid range for RGB colors");
      }
    } else if (n === 5 && numbers.length >= 1) {
      const idx = numbers.shift();
      if (idx < 0) {
        throw new RangeError("Color index must be >= 0");
      } else if (idx < 16) {
        return idx;
      } else if (idx < 232) {
        r = Math.floor((idx - 16) / 36);
        r = r > 0 ? 55 + r * 40 : 0;
        g = Math.floor((idx - 16) % 36 / 6);
        g = g > 0 ? 55 + g * 40 : 0;
        b = (idx - 16) % 6;
        b = b > 0 ? 55 + b * 40 : 0;
      } else if (idx < 256) {
        r = g = b = (idx - 232) * 10 + 8;
      } else {
        throw new RangeError("Color index must be < 256");
      }
    } else {
      throw new RangeError("Invalid extended color specification");
    }
    return [r, g, b];
  }
  function ansiSpan(str) {
    const ansiRe = /\x1b\[(.*?)([@-~])/g;
    let fg = [];
    let bg = [];
    let bold = false;
    let underline = false;
    let inverse = false;
    let match;
    const out = [];
    const numbers = [];
    let start = 0;
    str = escape$1(str);
    str += "\x1B[m";
    while (match = ansiRe.exec(str)) {
      if (match[2] === "m") {
        const items = match[1].split(";");
        for (let i2 = 0; i2 < items.length; i2++) {
          const item = items[i2];
          if (item === "") {
            numbers.push(0);
          } else if (item.search(/^\d+$/) !== -1) {
            numbers.push(parseInt(item, 10));
          } else {
            numbers.length = 0;
            break;
          }
        }
      }
      const chunk = str.substring(start, match.index);
      pushColoredChunk(chunk, fg, bg, bold, underline, inverse, out);
      start = ansiRe.lastIndex;
      while (numbers.length) {
        const n = numbers.shift();
        switch (n) {
          case 0:
            fg = bg = [];
            bold = false;
            underline = false;
            inverse = false;
            break;
          case 1:
          case 5:
            bold = true;
            break;
          case 4:
            underline = true;
            break;
          case 7:
            inverse = true;
            break;
          case 21:
          case 22:
            bold = false;
            break;
          case 24:
            underline = false;
            break;
          case 27:
            inverse = false;
            break;
          case 30:
          case 31:
          case 32:
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
            fg = n - 30;
            break;
          case 38:
            try {
              fg = getExtendedColors(numbers);
            } catch (e) {
              numbers.length = 0;
            }
            break;
          case 39:
            fg = [];
            break;
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
            bg = n - 40;
            break;
          case 48:
            try {
              bg = getExtendedColors(numbers);
            } catch (e) {
              numbers.length = 0;
            }
            break;
          case 49:
            bg = [];
            break;
          case 90:
          case 91:
          case 92:
          case 93:
          case 94:
          case 95:
          case 96:
          case 97:
            fg = n - 90 + 8;
            break;
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
            bg = n - 100 + 8;
            break;
        }
      }
    }
    return out.join("");
  }
  Private2.ansiSpan = ansiSpan;
})(Private$8 || (Private$8 = {}));
class RenderedCommon extends Widget {
  /**
   * Construct a new rendered common widget.
   *
   * @param options - The options for initializing the widget.
   */
  constructor(options) {
    var _a, _b;
    super();
    this.mimeType = options.mimeType;
    this.sanitizer = options.sanitizer;
    this.resolver = options.resolver;
    this.linkHandler = options.linkHandler;
    this.translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
    this.latexTypesetter = options.latexTypesetter;
    this.markdownParser = (_b = options.markdownParser) !== null && _b !== void 0 ? _b : null;
    this.node.dataset["mimeType"] = this.mimeType;
  }
  /**
   * Render a mime model.
   *
   * @param model - The mime model to render.
   *
   * @param keepExisting - Whether to keep the existing rendering.
   *
   * @returns A promise which resolves when rendering is complete.
   *
   * #### Notes
   * By default, if the DOM node for this widget already has content, it
   * is emptied before rendering. Subclasses that do not want this behavior
   * (if, for instance, they are using DOM diffing), should override this
   * method or call `super.renderModel(model, true)`.
   */
  async renderModel(model, keepExisting) {
    if (!keepExisting) {
      while (this.node.firstChild) {
        this.node.removeChild(this.node.firstChild);
      }
    }
    this.toggleClass("jp-mod-trusted", model.trusted);
    await this.render(model);
    const { fragment } = model.metadata;
    if (fragment) {
      this.setFragment(fragment);
    }
  }
  /**
   * Set the URI fragment identifier.
   *
   * @param fragment - The URI fragment identifier.
   */
  setFragment(fragment) {
  }
}
class RenderedImage extends RenderedCommon {
  /**
   * Construct a new rendered image widget.
   *
   * @param options - The options for initializing the widget.
   */
  constructor(options) {
    super(options);
    this.addClass("jp-RenderedImage");
  }
  /**
   * Render a mime model.
   *
   * @param model - The mime model to render.
   *
   * @returns A promise which resolves when rendering is complete.
   */
  render(model) {
    const metadata = model.metadata[this.mimeType];
    return renderImage({
      host: this.node,
      mimeType: this.mimeType,
      source: String(model.data[this.mimeType]),
      width: metadata && metadata.width,
      height: metadata && metadata.height,
      needsBackground: model.metadata["needs_background"],
      unconfined: metadata && metadata.unconfined
    });
  }
}
const imageRendererFactory = {
  safe: true,
  mimeTypes: [
    "image/bmp",
    "image/png",
    "image/jpeg",
    "image/gif",
    "image/webp"
  ],
  defaultRank: 90,
  createRenderer: (options) => new RenderedImage(options)
};
class MimeModel {
  /**
   * Construct a new mime model.
   */
  constructor(options = {}) {
    this.trusted = !!options.trusted;
    this._data = options.data || {};
    this._metadata = options.metadata || {};
    this._callback = options.callback || Private$7.noOp;
  }
  /**
   * The data associated with the model.
   */
  get data() {
    return this._data;
  }
  /**
   * The metadata associated with the model.
   */
  get metadata() {
    return this._metadata;
  }
  /**
   * Set the data associated with the model.
   *
   * #### Notes
   * Depending on the implementation of the mime model,
   * this call may or may not have deferred effects,
   */
  setData(options) {
    this._data = options.data || this._data;
    this._metadata = options.metadata || this._metadata;
    this._callback(options);
  }
}
var Private$7;
(function(Private2) {
  function noOp() {
  }
  Private2.noOp = noOp;
})(Private$7 || (Private$7 = {}));
const MAJOR_VERSION = 4;
const MINOR_VERSION = 4;
function isExecuteResult(output) {
  return output.output_type === "execute_result";
}
function isDisplayData(output) {
  return output.output_type === "display_data";
}
function isDisplayUpdate(output) {
  return output.output_type === "update_display_data";
}
function isStream(output) {
  return output.output_type === "stream";
}
function isError(output) {
  return output.output_type === "error";
}
class OutputModel {
  /**
   * Construct a new output model.
   */
  constructor(options) {
    this._changed = new Signal(this);
    this._raw = {};
    this._text = void 0;
    const { data, metadata, trusted } = Private$6.getBundleOptions(options);
    this._rawData = data;
    if (options.value !== void 0 && isStream(options.value)) {
      this._text = new ObservableString(typeof options.value.text === "string" ? options.value.text : options.value.text.join(""));
    }
    this._metadata = new ObservableJSON({ values: metadata });
    this._rawMetadata = metadata;
    this.trusted = trusted;
    const value = options.value;
    for (const key2 in value) {
      switch (key2) {
        case "data":
        case "metadata":
          break;
        default:
          this._raw[key2] = Private$6.extract(value, key2);
      }
    }
    this.type = value.output_type;
    if (isExecuteResult(value)) {
      this.executionCount = value.execution_count;
    } else {
      this.executionCount = null;
    }
  }
  /**
   * A signal emitted when the output model changes.
   */
  get changed() {
    return this._changed;
  }
  /**
   * Dispose of the resources used by the output model.
   */
  dispose() {
    var _a;
    (_a = this._text) === null || _a === void 0 ? void 0 : _a.dispose();
    this._metadata.dispose();
    Signal.clearData(this);
  }
  /**
   * The data associated with the model.
   */
  get data() {
    return Private$6.getData(this.toJSON());
  }
  get streamText() {
    return this._text;
  }
  /**
   * The metadata associated with the model.
   */
  get metadata() {
    return this._rawMetadata;
  }
  /**
   * Set the data associated with the model.
   *
   * #### Notes
   * Depending on the implementation of the mime model,
   * this call may or may not have deferred effects,
   */
  setData(options) {
    if (options.data) {
      this._rawData = options.data;
    }
    if (options.metadata) {
      this._updateObservable(this._metadata, options.metadata);
      this._rawMetadata = options.metadata;
    }
    this._changed.emit();
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    const output = {};
    for (const key2 in this._raw) {
      output[key2] = Private$6.extract(this._raw, key2);
    }
    if (this._text !== void 0) {
      output["text"] = this._text.text;
    }
    switch (this.type) {
      case "display_data":
      case "execute_result":
      case "update_display_data":
        output["data"] = this._rawData;
        output["metadata"] = this.metadata;
        break;
    }
    delete output["transient"];
    return output;
  }
  /**
   * Update an observable JSON object using a readonly JSON object.
   */
  _updateObservable(observable2, data) {
    const oldKeys = observable2.keys();
    const newKeys = Object.keys(data);
    for (const key2 of oldKeys) {
      if (newKeys.indexOf(key2) === -1) {
        observable2.delete(key2);
      }
    }
    for (const key2 of newKeys) {
      const oldValue = observable2.get(key2);
      const newValue = data[key2];
      if (oldValue !== newValue) {
        observable2.set(key2, newValue);
      }
    }
  }
}
(function(OutputModel2) {
  function getData(output) {
    return Private$6.getData(output);
  }
  OutputModel2.getData = getData;
  function getMetadata(output) {
    return Private$6.getMetadata(output);
  }
  OutputModel2.getMetadata = getMetadata;
})(OutputModel || (OutputModel = {}));
var Private$6;
(function(Private2) {
  function getData(output) {
    let bundle = {};
    if (isExecuteResult(output) || isDisplayData(output) || isDisplayUpdate(output)) {
      bundle = output.data;
    } else if (isStream(output)) {
      if (output.name === "stderr") {
        bundle["application/vnd.jupyter.stderr"] = output.text;
      } else {
        bundle["application/vnd.jupyter.stdout"] = output.text;
      }
    } else if (isError(output)) {
      bundle["application/vnd.jupyter.error"] = output;
      const traceback = output.traceback.join("\n");
      bundle["application/vnd.jupyter.stderr"] = traceback || `${output.ename}: ${output.evalue}`;
    }
    return convertBundle(bundle);
  }
  Private2.getData = getData;
  function getMetadata(output) {
    const value = /* @__PURE__ */ Object.create(null);
    if (isExecuteResult(output) || isDisplayData(output)) {
      for (const key2 in output.metadata) {
        value[key2] = extract(output.metadata, key2);
      }
    }
    return value;
  }
  Private2.getMetadata = getMetadata;
  function getBundleOptions(options) {
    const data = getData(options.value);
    const metadata = getMetadata(options.value);
    const trusted = !!options.trusted;
    return { data, metadata, trusted };
  }
  Private2.getBundleOptions = getBundleOptions;
  function extract(value, key2) {
    const item = value[key2];
    if (item === void 0 || JSONExt.isPrimitive(item)) {
      return item;
    }
    return JSON.parse(JSON.stringify(item));
  }
  Private2.extract = extract;
  function convertBundle(bundle) {
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const mimeType in bundle) {
      map2[mimeType] = extract(bundle, mimeType);
    }
    return map2;
  }
})(Private$6 || (Private$6 = {}));
class RenderMimeRegistry {
  /**
   * Construct a new rendermime.
   *
   * @param options - The options for initializing the instance.
   */
  constructor(options = {}) {
    var _a, _b, _c, _d, _e, _f;
    this._id = 0;
    this._ranks = {};
    this._types = null;
    this._factories = {};
    this.translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
    this.resolver = (_b = options.resolver) !== null && _b !== void 0 ? _b : null;
    this.linkHandler = (_c = options.linkHandler) !== null && _c !== void 0 ? _c : null;
    this.latexTypesetter = (_d = options.latexTypesetter) !== null && _d !== void 0 ? _d : null;
    this.markdownParser = (_e = options.markdownParser) !== null && _e !== void 0 ? _e : null;
    this.sanitizer = (_f = options.sanitizer) !== null && _f !== void 0 ? _f : new Sanitizer();
    if (options.initialFactories) {
      for (const factory of options.initialFactories) {
        this.addFactory(factory);
      }
    }
  }
  /**
   * The ordered list of mimeTypes.
   */
  get mimeTypes() {
    return this._types || (this._types = Private$5.sortedTypes(this._ranks));
  }
  /**
   * Find the preferred mime type for a mime bundle.
   *
   * @param bundle - The bundle of mime data.
   *
   * @param safe - How to consider safe/unsafe factories. If 'ensure',
   *   it will only consider safe factories. If 'any', any factory will be
   *   considered. If 'prefer', unsafe factories will be considered, but
   *   only after the safe options have been exhausted.
   *
   * @returns The preferred mime type from the available factories,
   *   or `undefined` if the mime type cannot be rendered.
   */
  preferredMimeType(bundle, safe = "ensure") {
    if (safe === "ensure" || safe === "prefer") {
      for (const mt of this.mimeTypes) {
        if (mt in bundle && this._factories[mt].safe) {
          return mt;
        }
      }
    }
    if (safe !== "ensure") {
      for (const mt of this.mimeTypes) {
        if (mt in bundle) {
          return mt;
        }
      }
    }
    return void 0;
  }
  /**
   * Create a renderer for a mime type.
   *
   * @param mimeType - The mime type of interest.
   *
   * @returns A new renderer for the given mime type.
   *
   * @throws An error if no factory exists for the mime type.
   */
  createRenderer(mimeType) {
    if (!(mimeType in this._factories)) {
      throw new Error(`No factory for mime type: '${mimeType}'`);
    }
    return this._factories[mimeType].createRenderer({
      mimeType,
      resolver: this.resolver,
      sanitizer: this.sanitizer,
      linkHandler: this.linkHandler,
      latexTypesetter: this.latexTypesetter,
      markdownParser: this.markdownParser,
      translator: this.translator
    });
  }
  /**
   * Create a new mime model.  This is a convenience method.
   *
   * @options - The options used to create the model.
   *
   * @returns A new mime model.
   */
  createModel(options = {}) {
    return new MimeModel(options);
  }
  /**
   * Create a clone of this rendermime instance.
   *
   * @param options - The options for configuring the clone.
   *
   * @returns A new independent clone of the rendermime.
   */
  clone(options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const clone = new RenderMimeRegistry({
      resolver: (_b = (_a = options.resolver) !== null && _a !== void 0 ? _a : this.resolver) !== null && _b !== void 0 ? _b : void 0,
      sanitizer: (_d = (_c = options.sanitizer) !== null && _c !== void 0 ? _c : this.sanitizer) !== null && _d !== void 0 ? _d : void 0,
      linkHandler: (_f = (_e = options.linkHandler) !== null && _e !== void 0 ? _e : this.linkHandler) !== null && _f !== void 0 ? _f : void 0,
      latexTypesetter: (_h = (_g = options.latexTypesetter) !== null && _g !== void 0 ? _g : this.latexTypesetter) !== null && _h !== void 0 ? _h : void 0,
      markdownParser: (_k = (_j = options.markdownParser) !== null && _j !== void 0 ? _j : this.markdownParser) !== null && _k !== void 0 ? _k : void 0,
      translator: this.translator
    });
    clone._factories = { ...this._factories };
    clone._ranks = { ...this._ranks };
    clone._id = this._id;
    return clone;
  }
  /**
   * Get the renderer factory registered for a mime type.
   *
   * @param mimeType - The mime type of interest.
   *
   * @returns The factory for the mime type, or `undefined`.
   */
  getFactory(mimeType) {
    return this._factories[mimeType];
  }
  /**
   * Add a renderer factory to the rendermime.
   *
   * @param factory - The renderer factory of interest.
   *
   * @param rank - The rank of the renderer. A lower rank indicates
   *   a higher priority for rendering. If not given, the rank will
   *   defer to the `defaultRank` of the factory.  If no `defaultRank`
   *   is given, it will default to 100.
   *
   * #### Notes
   * The renderer will replace an existing renderer for the given
   * mimeType.
   */
  addFactory(factory, rank) {
    if (rank === void 0) {
      rank = factory.defaultRank;
      if (rank === void 0) {
        rank = 100;
      }
    }
    for (const mt of factory.mimeTypes) {
      this._factories[mt] = factory;
      this._ranks[mt] = { rank, id: this._id++ };
    }
    this._types = null;
  }
  /**
   * Remove a mime type.
   *
   * @param mimeType - The mime type of interest.
   */
  removeMimeType(mimeType) {
    delete this._factories[mimeType];
    delete this._ranks[mimeType];
    this._types = null;
  }
  /**
   * Get the rank for a given mime type.
   *
   * @param mimeType - The mime type of interest.
   *
   * @returns The rank of the mime type or undefined.
   */
  getRank(mimeType) {
    const rank = this._ranks[mimeType];
    return rank && rank.rank;
  }
  /**
   * Set the rank of a given mime type.
   *
   * @param mimeType - The mime type of interest.
   *
   * @param rank - The new rank to assign.
   *
   * #### Notes
   * This is a no-op if the mime type is not registered.
   */
  setRank(mimeType, rank) {
    if (!this._ranks[mimeType]) {
      return;
    }
    const id = this._id++;
    this._ranks[mimeType] = { rank, id };
    this._types = null;
  }
}
(function(RenderMimeRegistry2) {
  class UrlResolver {
    /**
     * Create a new url resolver.
     */
    constructor(options) {
      this._path = options.path;
      this._contents = options.contents;
    }
    /**
     * The path of the object, from which local urls can be derived.
     */
    get path() {
      return this._path;
    }
    set path(value) {
      this._path = value;
    }
    /**
     * Resolve a relative url to an absolute url path.
     */
    async resolveUrl(url2) {
      if (this.isLocal(url2)) {
        const cwd = encodeURI(lib$9.PathExt.dirname(this.path));
        url2 = lib$9.PathExt.resolve(cwd, url2);
      }
      return url2;
    }
    /**
     * Get the download url of a given absolute url path.
     *
     * #### Notes
     * The returned URL may include a query parameter.
     */
    async getDownloadUrl(urlPath) {
      if (this.isLocal(urlPath)) {
        return this._contents.getDownloadUrl(decodeURIComponent(urlPath));
      }
      return urlPath;
    }
    /**
     * Whether the URL should be handled by the resolver
     * or not.
     *
     * @param allowRoot - Whether the paths starting at Unix-style filesystem root (`/`) are permitted.
     *
     * #### Notes
     * This is similar to the `isLocal` check in `URLExt`,
     * but it also checks whether the path points to any
     * of the `IDrive`s that may be registered with the contents
     * manager.
     */
    isLocal(url2, allowRoot = false) {
      if (this.isMalformed(url2)) {
        return false;
      }
      return lib$9.URLExt.isLocal(url2, allowRoot) || !!this._contents.driveName(decodeURI(url2));
    }
    /**
     * Resolve a path from Jupyter kernel to a path:
     * - relative to `root_dir` (preferably) this is in jupyter-server scope,
     * - path understood and known by kernel (if such a path exists).
     * Returns `null` if there is no file matching provided path in neither
     * kernel nor jupyter-server contents manager.
     */
    async resolvePath(path2) {
      const rootDir = lib$9.PageConfig.getOption("rootUri").replace("file://", "");
      if (path2.startsWith("~/") && rootDir.startsWith("/home/")) {
        path2 = rootDir.split("/").slice(0, 3).join("/") + path2.substring(1);
      }
      if (path2.startsWith(rootDir) || path2.startsWith("./")) {
        try {
          const relativePath = path2.replace(rootDir, "");
          const response = await this._contents.get(relativePath, {
            content: false
          });
          return {
            path: response.path,
            scope: "server"
          };
        } catch (error) {
          console.warn(`Could not resolve location of ${path2} on server`);
          return null;
        }
      }
      return {
        path: path2,
        scope: "kernel"
      };
    }
    /**
     * Whether the URL can be decoded using `decodeURI`.
     */
    isMalformed(url2) {
      try {
        decodeURI(url2);
        return false;
      } catch (error) {
        if (error instanceof URIError) {
          return true;
        }
        throw error;
      }
    }
  }
  RenderMimeRegistry2.UrlResolver = UrlResolver;
})(RenderMimeRegistry || (RenderMimeRegistry = {}));
var Private$5;
(function(Private2) {
  function sortedTypes(map2) {
    return Object.keys(map2).sort((a, b) => {
      const p1 = map2[a];
      const p2 = map2[b];
      if (p1.rank !== p2.rank) {
        return p1.rank - p2.rank;
      }
      return p1.id - p2.id;
    });
  }
  Private2.sortedTypes = sortedTypes;
})(Private$5 || (Private$5 = {}));
class AttachmentsModel {
  /**
   * Construct a new observable outputs instance.
   */
  constructor(options) {
    var _a;
    this._map = new ObservableMap();
    this._isDisposed = false;
    this._stateChanged = new Signal(this);
    this._changed = new Signal(this);
    this._serialized = null;
    this._changeGuard = false;
    this.contentFactory = (_a = options.contentFactory) !== null && _a !== void 0 ? _a : AttachmentsModel.defaultContentFactory;
    if (options.values) {
      for (const key2 of Object.keys(options.values)) {
        if (options.values[key2] !== void 0) {
          this.set(key2, options.values[key2]);
        }
      }
    }
    this._map.changed.connect(this._onMapChanged, this);
  }
  /**
   * A signal emitted when the model state changes.
   */
  get stateChanged() {
    return this._stateChanged;
  }
  /**
   * A signal emitted when the model changes.
   */
  get changed() {
    return this._changed;
  }
  /**
   * The keys of the attachments in the model.
   */
  get keys() {
    return this._map.keys();
  }
  /**
   * Get the length of the items in the model.
   */
  get length() {
    return this._map.keys().length;
  }
  /**
   * Test whether the model is disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of the resources used by the model.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._isDisposed = true;
    this._map.dispose();
    Signal.clearData(this);
  }
  /**
   * Whether the specified key is set.
   */
  has(key2) {
    return this._map.has(key2);
  }
  /**
   * Get an item at the specified key.
   */
  get(key2) {
    return this._map.get(key2);
  }
  /**
   * Set the value at the specified key.
   */
  set(key2, value) {
    const item = this._createItem({ value });
    this._map.set(key2, item);
  }
  /**
   * Remove the attachment whose name is the specified key
   */
  remove(key2) {
    this._map.delete(key2);
  }
  /**
   * Clear all of the attachments.
   */
  clear() {
    this._map.values().forEach((item) => {
      item.dispose();
    });
    this._map.clear();
  }
  /**
   * Deserialize the model from JSON.
   *
   * #### Notes
   * This will clear any existing data.
   */
  fromJSON(values) {
    this.clear();
    Object.keys(values).forEach((key2) => {
      if (values[key2] !== void 0) {
        this.set(key2, values[key2]);
      }
    });
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    const ret = {};
    for (const key2 of this._map.keys()) {
      ret[key2] = this._map.get(key2).toJSON();
    }
    return ret;
  }
  /**
   * Create an attachment item and hook up its signals.
   */
  _createItem(options) {
    const factory = this.contentFactory;
    const item = factory.createAttachmentModel(options);
    item.changed.connect(this._onGenericChange, this);
    return item;
  }
  /**
   * Handle a change to the list.
   */
  _onMapChanged(sender, args) {
    if (this._serialized && !this._changeGuard) {
      this._changeGuard = true;
      this._serialized.set(this.toJSON());
      this._changeGuard = false;
    }
    this._changed.emit(args);
    this._stateChanged.emit(void 0);
  }
  /**
   * Handle a change to an item.
   */
  _onGenericChange() {
    this._stateChanged.emit(void 0);
  }
}
(function(AttachmentsModel2) {
  class ContentFactory {
    /**
     * Create an attachment model.
     */
    createAttachmentModel(options) {
      return new AttachmentModel(options);
    }
  }
  AttachmentsModel2.ContentFactory = ContentFactory;
  AttachmentsModel2.defaultContentFactory = new ContentFactory();
})(AttachmentsModel || (AttachmentsModel = {}));
class AttachmentsResolver {
  /**
   * Create an attachments resolver object.
   */
  constructor(options) {
    this._parent = options.parent || null;
    this._model = options.model;
  }
  /**
   * Resolve a relative url to a correct server path.
   */
  async resolveUrl(url2) {
    if (this._parent && !url2.startsWith("attachment:")) {
      return this._parent.resolveUrl(url2);
    }
    return url2;
  }
  /**
   * Get the download url of a given absolute server path.
   *
   * #### Notes
   * The returned URL may include a query parameter.
   */
  async getDownloadUrl(path2) {
    if (this._parent && !path2.startsWith("attachment:")) {
      return this._parent.getDownloadUrl(path2);
    }
    const key2 = path2.slice("attachment:".length);
    const attachment = this._model.get(key2);
    if (attachment === void 0) {
      return path2;
    }
    const { data } = attachment;
    const mimeType = Object.keys(data)[0];
    if (mimeType === void 0 || imageRendererFactory.mimeTypes.indexOf(mimeType) === -1) {
      throw new Error(`Cannot render unknown image mime type "${mimeType}".`);
    }
    const dataUrl = `data:${mimeType};base64,${data[mimeType]}`;
    return dataUrl;
  }
  /**
   * Whether the URL should be handled by the resolver
   * or not.
   */
  isLocal(url2) {
    var _a, _b, _c;
    if (this._parent && !url2.startsWith("attachment:")) {
      return (_c = (_b = (_a = this._parent).isLocal) === null || _b === void 0 ? void 0 : _b.call(_a, url2)) !== null && _c !== void 0 ? _c : true;
    }
    return true;
  }
}
class OutputAreaModel {
  /**
   * Construct a new observable outputs instance.
   */
  constructor(options = {}) {
    this.clearNext = false;
    this._lastStreamName = "";
    this._trusted = false;
    this._isDisposed = false;
    this._stateChanged = new Signal(this);
    this._changed = new Signal(this);
    this._trusted = !!options.trusted;
    this.contentFactory = options.contentFactory || OutputAreaModel.defaultContentFactory;
    this.list = new ObservableList();
    if (options.values) {
      for (const value of options.values) {
        const index = this._add(value) - 1;
        const item = this.list.get(index);
        item.changed.connect(this._onGenericChange, this);
      }
    }
    this.list.changed.connect(this._onListChanged, this);
  }
  /**
   * A signal emitted when an item changes.
   */
  get stateChanged() {
    return this._stateChanged;
  }
  /**
   * A signal emitted when the list of items changes.
   */
  get changed() {
    return this._changed;
  }
  /**
   * Get the length of the items in the model.
   */
  get length() {
    return this.list ? this.list.length : 0;
  }
  /**
   * Get whether the model is trusted.
   */
  get trusted() {
    return this._trusted;
  }
  /**
   * Set whether the model is trusted.
   *
   * #### Notes
   * Changing the value will cause all of the models to re-set.
   */
  set trusted(value) {
    if (value === this._trusted) {
      return;
    }
    const trusted = this._trusted = value;
    for (let i2 = 0; i2 < this.list.length; i2++) {
      const oldItem = this.list.get(i2);
      const value2 = oldItem.toJSON();
      const item = this._createItem({ value: value2, trusted });
      this.list.set(i2, item);
      oldItem.dispose();
    }
  }
  /**
   * Test whether the model is disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of the resources used by the model.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._isDisposed = true;
    this.list.dispose();
    Signal.clearData(this);
  }
  /**
   * Get an item at the specified index.
   */
  get(index) {
    return this.list.get(index);
  }
  /**
   * Set the value at the specified index.
   */
  set(index, value) {
    value = JSONExt.deepCopy(value);
    Private$4.normalize(value);
    const item = this._createItem({ value, trusted: this._trusted });
    this.list.set(index, item);
  }
  removeStreamOutput(number) {
    const prev = this.list.get(this.length - 1);
    const curText = prev.streamText;
    const length2 = curText.text.length;
    const options = { silent: true };
    curText.remove(length2 - number, length2, options);
  }
  appendStreamOutput(text2) {
    const prev = this.list.get(this.length - 1);
    const curText = prev.streamText;
    const length2 = curText.text.length;
    const options = { silent: true };
    curText.insert(length2, text2, options);
  }
  /**
   * Add an output, which may be combined with previous output.
   *
   * @returns The total number of outputs.
   *
   * #### Notes
   * The output bundle is copied.
   * Contiguous stream outputs of the same `name` are combined.
   */
  add(output) {
    if (this.clearNext) {
      this.clear();
      this.clearNext = false;
    }
    return this._add(output);
  }
  /**
   * Remove an output at a given index.
   */
  remove(index) {
    var _a;
    (_a = this.list.remove(index)) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  /**
   * Clear all of the output.
   *
   * @param wait Delay clearing the output until the next message is added.
   */
  clear(wait = false) {
    this._lastStreamName = "";
    if (wait) {
      this.clearNext = true;
      return;
    }
    for (const item of this.list) {
      item.dispose();
    }
    this.list.clear();
  }
  /**
   * Deserialize the model from JSON.
   *
   * #### Notes
   * This will clear any existing data.
   */
  fromJSON(values) {
    this.clear();
    for (const value of values) {
      this._add(value);
    }
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return Array.from(map$1(this.list, (output) => output.toJSON()));
  }
  /**
   * Add a copy of the item to the list.
   *
   * @returns The list length
   */
  _add(value) {
    const trusted = this._trusted;
    value = JSONExt.deepCopy(value);
    Private$4.normalize(value);
    if (isStream(value) && value.name === this._lastStreamName && this.length > 0 && this.shouldCombine({
      value,
      lastModel: this.list.get(this.length - 1)
    })) {
      const prev = this.list.get(this.length - 1);
      const curText = prev.streamText;
      const newText = typeof value.text === "string" ? value.text : value.text.join("");
      Private$4.addText(curText, newText);
      return this.length;
    }
    if (isStream(value)) {
      if (typeof value.text !== "string") {
        value.text = value.text.join("");
      }
      value.text = Private$4.processText(value.text);
    }
    const item = this._createItem({ value, trusted });
    const length2 = this.list.push(item);
    if (isStream(value)) {
      this._lastStreamName = value.name;
    } else {
      this._lastStreamName = "";
    }
    return length2;
  }
  /**
   * Whether a new value should be consolidated with the previous output.
   *
   * This will only be called if the minimal criteria of both being stream
   * messages of the same type.
   */
  shouldCombine(options) {
    return true;
  }
  /**
   * Create an output item and hook up its signals.
   */
  _createItem(options) {
    const factory = this.contentFactory;
    const item = factory.createOutputModel(options);
    return item;
  }
  /**
   * Handle a change to the list.
   */
  _onListChanged(sender, args) {
    switch (args.type) {
      case "add":
        args.newValues.forEach((item) => {
          item.changed.connect(this._onGenericChange, this);
        });
        break;
      case "remove":
        args.oldValues.forEach((item) => {
          item.changed.disconnect(this._onGenericChange, this);
        });
        break;
      case "set":
        args.newValues.forEach((item) => {
          item.changed.connect(this._onGenericChange, this);
        });
        args.oldValues.forEach((item) => {
          item.changed.disconnect(this._onGenericChange, this);
        });
        break;
    }
    this._changed.emit(args);
  }
  /**
   * Handle a change to an item.
   */
  _onGenericChange(itemModel) {
    let idx;
    let item = null;
    for (idx = 0; idx < this.list.length; idx++) {
      item = this.list.get(idx);
      if (item === itemModel) {
        break;
      }
    }
    if (item != null) {
      this._stateChanged.emit(idx);
      this._changed.emit({
        type: "set",
        newIndex: idx,
        oldIndex: idx,
        oldValues: [item],
        newValues: [item]
      });
    }
  }
}
(function(OutputAreaModel2) {
  class ContentFactory {
    /**
     * Create an output model.
     */
    createOutputModel(options) {
      return new OutputModel(options);
    }
  }
  OutputAreaModel2.ContentFactory = ContentFactory;
  OutputAreaModel2.defaultContentFactory = new ContentFactory();
})(OutputAreaModel || (OutputAreaModel = {}));
var Private$4;
(function(Private2) {
  function normalize3(value) {
    if (isStream(value)) {
      if (Array.isArray(value.text)) {
        value.text = value.text.join("\n");
      }
    }
  }
  Private2.normalize = normalize3;
  function indexOfAny(text2, re, i2) {
    const index = text2.slice(i2).search(re);
    return index >= 0 ? index + i2 : index;
  }
  function processText(newText, text2) {
    if (text2 === void 0) {
      text2 = "";
    }
    if (!(newText.includes("\b") || newText.includes("\r"))) {
      return text2 + newText;
    }
    let idx0 = text2.length;
    let idx1 = -1;
    let lastEnd = 0;
    const regex = /[\n\b\r]/;
    while (true) {
      idx1 = indexOfAny(newText, regex, lastEnd);
      const prefix = newText.slice(lastEnd, idx1 === -1 ? newText.length : idx1);
      text2 = text2.slice(0, idx0) + prefix + text2.slice(idx0 + prefix.length);
      lastEnd = idx1 + 1;
      if (idx1 === -1) {
        break;
      }
      idx0 += prefix.length;
      const newChar = newText[idx1];
      if (newChar === "\b") {
        if (idx0 > 0 && text2[idx0 - 1] !== "\n") {
          text2 = text2.slice(0, idx0 - 1) + text2.slice(idx0 + 1);
          idx0--;
        }
      } else if (newChar === "\r") {
        let done = false;
        while (!done) {
          if (idx0 === 0) {
            done = true;
          } else if (text2[idx0 - 1] === "\n") {
            done = true;
          } else {
            idx0--;
          }
        }
      } else if (newChar === "\n") {
        text2 = text2 + "\n";
        idx0 = text2.length;
      } else {
        throw Error(`This should not happen`);
      }
    }
    return text2;
  }
  Private2.processText = processText;
  function addText(curText, newText) {
    const text2 = processText(newText, curText.text);
    let done = false;
    let idx = 0;
    while (!done) {
      if (idx === text2.length) {
        if (idx === curText.text.length) {
          done = true;
        } else {
          curText.remove(idx, curText.text.length);
          done = true;
        }
      } else if (idx === curText.text.length) {
        if (idx !== text2.length) {
          curText.insert(curText.text.length, text2.slice(idx));
          done = true;
        }
      } else if (text2[idx] !== curText.text[idx]) {
        curText.remove(idx, curText.text.length);
        curText.insert(idx, text2.slice(idx));
        done = true;
      } else {
        idx++;
      }
    }
  }
  Private2.addText = addText;
})(Private$4 || (Private$4 = {}));
const OUTPUT_AREA_CLASS = "jp-OutputArea";
const OUTPUT_AREA_ITEM_CLASS = "jp-OutputArea-child";
const OUTPUT_AREA_OUTPUT_CLASS = "jp-OutputArea-output";
const OUTPUT_AREA_PROMPT_CLASS = "jp-OutputArea-prompt";
const OUTPUT_AREA_STDIN_HIDING_CLASS = "jp-OutputArea-stdin-hiding";
const OUTPUT_PROMPT_CLASS$1 = "jp-OutputPrompt";
const EXECUTE_CLASS = "jp-OutputArea-executeResult";
const OUTPUT_AREA_STDIN_ITEM_CLASS = "jp-OutputArea-stdin-item";
const STDIN_CLASS = "jp-Stdin";
const STDIN_PROMPT_CLASS = "jp-Stdin-prompt";
const STDIN_INPUT_CLASS = "jp-Stdin-input";
const OUTPUT_PROMPT_OVERLAY = "jp-OutputArea-promptOverlay";
class OutputArea extends Widget {
  /**
   * Construct an output area widget.
   */
  constructor(options) {
    var _a, _b, _c, _d;
    super();
    this.outputLengthChanged = new Signal(this);
    this._onIOPub = (msg) => {
      const model2 = this.model;
      const msgType = msg.header.msg_type;
      let output;
      const transient = msg.content.transient || {};
      const displayId = transient["display_id"];
      let targets;
      switch (msgType) {
        case "execute_result":
        case "display_data":
        case "stream":
        case "error":
          output = { ...msg.content, output_type: msgType };
          model2.add(output);
          break;
        case "clear_output": {
          const wait = msg.content.wait;
          model2.clear(wait);
          break;
        }
        case "update_display_data":
          output = { ...msg.content, output_type: "display_data" };
          targets = this._displayIdMap.get(displayId);
          if (targets) {
            for (const index of targets) {
              model2.set(index, output);
            }
          }
          break;
        case "status": {
          const executionState = msg.content.execution_state;
          if (executionState === "idle") {
            this._pendingInput = false;
          }
          break;
        }
      }
      if (displayId && msgType === "display_data") {
        targets = this._displayIdMap.get(displayId) || [];
        targets.push(model2.length - 1);
        this._displayIdMap.set(displayId, targets);
      }
    };
    this._onExecuteReply = (msg) => {
      const model2 = this.model;
      const content = msg.content;
      if (content.status !== "ok") {
        return;
      }
      const payload = content && content.payload;
      if (!payload || !payload.length) {
        return;
      }
      const pages = payload.filter((i2) => i2.source === "page");
      if (!pages.length) {
        return;
      }
      const page = JSON.parse(JSON.stringify(pages[0]));
      const output = {
        output_type: "display_data",
        data: page.data,
        metadata: {}
      };
      model2.add(output);
    };
    this._displayIdMap = /* @__PURE__ */ new Map();
    this._minHeightTimeout = null;
    this._inputRequested = new Signal(this);
    this._toggleScrolling = new Signal(this);
    this._initialize = new Signal(this);
    this._outputTracker = new WidgetTracker({
      namespace: UUID.uuid4()
    });
    this._inputHistoryScope = "global";
    this._pendingInput = false;
    super.layout = new PanelLayout();
    this.addClass(OUTPUT_AREA_CLASS);
    this.contentFactory = (_a = options.contentFactory) !== null && _a !== void 0 ? _a : OutputArea.defaultContentFactory;
    this.rendermime = options.rendermime;
    this._maxNumberOutputs = (_b = options.maxNumberOutputs) !== null && _b !== void 0 ? _b : Infinity;
    this._translator = (_c = options.translator) !== null && _c !== void 0 ? _c : nullTranslator;
    this._inputHistoryScope = (_d = options.inputHistoryScope) !== null && _d !== void 0 ? _d : "global";
    const model = this.model = options.model;
    for (let i2 = 0; i2 < Math.min(model.length, this._maxNumberOutputs + 1); i2++) {
      const output = model.get(i2);
      this._insertOutput(i2, output);
    }
    model.changed.connect(this.onModelChanged, this);
    model.stateChanged.connect(this.onStateChanged, this);
    if (options.promptOverlay) {
      this._addPromptOverlay();
    }
  }
  /**
   * Narrow the type of OutputArea's layout prop
   */
  get layout() {
    return super.layout;
  }
  /**
   * A read-only sequence of the children widgets in the output area.
   */
  get widgets() {
    return this.layout.widgets;
  }
  /**
   * The kernel future associated with the output area.
   */
  get future() {
    return this._future;
  }
  set future(value) {
    if (this.model.isDisposed) {
      throw Error("Model is disposed");
    }
    if (this._future === value) {
      return;
    }
    if (this._future) {
      this._future.dispose();
    }
    this._future = value;
    value.done.finally(() => {
      this._pendingInput = false;
    }).catch(() => {
    });
    this.model.clear();
    if (this.widgets.length) {
      this._clear();
      this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
    }
    value.onIOPub = this._onIOPub;
    value.onReply = this._onExecuteReply;
    value.onStdin = (msg) => {
      if (libExports.KernelMessage.isInputRequestMsg(msg)) {
        this.onInputRequest(msg, value);
      }
    };
  }
  /**
   * Signal emitted when an output area is requesting an input. The signal
   * carries the input widget that this class creates in response to the input
   * request.
   */
  get inputRequested() {
    return this._inputRequested;
  }
  /**
   * A flag indicating if the output area has pending input.
   */
  get pendingInput() {
    return this._pendingInput;
  }
  /**
   * The maximum number of output items to display on top and bottom of cell output.
   *
   * ### Notes
   * It is set to Infinity if no trim is applied.
   */
  get maxNumberOutputs() {
    return this._maxNumberOutputs;
  }
  set maxNumberOutputs(limit2) {
    if (limit2 <= 0) {
      console.warn(`OutputArea.maxNumberOutputs must be strictly positive.`);
      return;
    }
    const lastShown = this._maxNumberOutputs;
    this._maxNumberOutputs = limit2;
    if (lastShown < limit2) {
      this._showTrimmedOutputs(lastShown);
    }
  }
  /**
   * Dispose of the resources used by the output area.
   */
  dispose() {
    if (this._future) {
      this._future.dispose();
      this._future = null;
    }
    this._displayIdMap.clear();
    this._outputTracker.dispose();
    super.dispose();
  }
  /**
   * Follow changes on the model state.
   */
  onModelChanged(sender, args) {
    switch (args.type) {
      case "add":
        const output = args.newValues[0];
        this._insertOutput(args.newIndex, output);
        if (output.type === "stream") {
          output.streamText.changed.connect((sender2, event2) => {
            this._setOutput(args.newIndex, output);
          });
        }
        break;
      case "remove":
        if (this.widgets.length) {
          if (this.model.length === 0) {
            this._clear();
          } else {
            const startIndex = args.oldIndex;
            for (let i2 = 0; i2 < args.oldValues.length && startIndex < this.widgets.length; ++i2) {
              const widget = this.widgets[startIndex];
              widget.parent = null;
              widget.dispose();
            }
            this._moveDisplayIdIndices(startIndex, args.oldValues.length);
            this._preventHeightChangeJitter();
          }
        }
        break;
      case "set":
        this._setOutput(args.newIndex, args.newValues[0]);
        break;
    }
    this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
  }
  /**
   * Emitted when user requests toggling of the output scrolling mode.
   */
  get toggleScrolling() {
    return this._toggleScrolling;
  }
  get initialize() {
    return this._initialize;
  }
  /**
   * Add overlay allowing to toggle scrolling.
   */
  _addPromptOverlay() {
    const overlay = document.createElement("div");
    overlay.className = OUTPUT_PROMPT_OVERLAY;
    overlay.addEventListener("click", () => {
      this._toggleScrolling.emit();
    });
    this.node.appendChild(overlay);
    requestAnimationFrame(() => {
      this._initialize.emit();
    });
  }
  /**
   * Update indices in _displayIdMap in response to element remove from model items
   *
   * @param startIndex - The index of first element removed
   *
   * @param count - The number of elements removed from model items
   *
   */
  _moveDisplayIdIndices(startIndex, count) {
    this._displayIdMap.forEach((indices) => {
      const rangeEnd = startIndex + count;
      const numIndices = indices.length;
      for (let i2 = numIndices - 1; i2 >= 0; --i2) {
        const index = indices[i2];
        if (index >= startIndex && index < rangeEnd) {
          indices.splice(i2, 1);
        } else if (index >= rangeEnd) {
          indices[i2] -= count;
        }
      }
    });
  }
  /**
   * Follow changes on the output model state.
   */
  onStateChanged(sender, change) {
    const outputLength = Math.min(this.model.length, this._maxNumberOutputs);
    if (change) {
      if (change >= this._maxNumberOutputs) {
        return;
      }
      this._setOutput(change, this.model.get(change));
    } else {
      for (let i2 = 0; i2 < outputLength; i2++) {
        this._setOutput(i2, this.model.get(i2));
      }
    }
    this.outputLengthChanged.emit(outputLength);
  }
  /**
   * Clear the widget outputs.
   */
  _clear() {
    if (!this.widgets.length) {
      return;
    }
    const length2 = this.widgets.length;
    for (let i2 = 0; i2 < length2; i2++) {
      const widget = this.widgets[0];
      widget.parent = null;
      widget.dispose();
    }
    this._displayIdMap.clear();
    this._preventHeightChangeJitter();
  }
  _preventHeightChangeJitter() {
    const rect = this.node.getBoundingClientRect();
    this.node.style.minHeight = `${rect.height}px`;
    if (this._minHeightTimeout) {
      window.clearTimeout(this._minHeightTimeout);
    }
    this._minHeightTimeout = window.setTimeout(() => {
      if (this.isDisposed) {
        return;
      }
      this.node.style.minHeight = "";
    }, 50);
  }
  /**
   * Handle an input request from a kernel.
   */
  onInputRequest(msg, future2) {
    const factory = this.contentFactory;
    const stdinPrompt = msg.content.prompt;
    const password = msg.content.password;
    const panel = new Panel();
    panel.addClass(OUTPUT_AREA_ITEM_CLASS);
    panel.addClass(OUTPUT_AREA_STDIN_ITEM_CLASS);
    const prompt = factory.createOutputPrompt();
    prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
    panel.addWidget(prompt);
    this._pendingInput = true;
    const input2 = factory.createStdin({
      parent_header: msg.header,
      prompt: stdinPrompt,
      password,
      future: future2,
      translator: this._translator,
      inputHistoryScope: this._inputHistoryScope
    });
    input2.addClass(OUTPUT_AREA_OUTPUT_CLASS);
    panel.addWidget(input2);
    if (this.model.length >= this.maxNumberOutputs) {
      this.maxNumberOutputs = this.model.length;
    }
    this._inputRequested.emit(input2);
    const inputNode = input2.node.getElementsByTagName("input")[0];
    void input2.value.then((value) => {
      if (this.model.length >= this.maxNumberOutputs) {
        this.maxNumberOutputs = this.model.length + 1;
      }
      panel.addClass(OUTPUT_AREA_STDIN_HIDING_CLASS);
      this.model.add({
        output_type: "stream",
        name: "stdin",
        text: value + "\n"
      });
      inputNode.focus();
      this._pendingInput = false;
      window.setTimeout(() => {
        const focusedElement = document.activeElement;
        panel.dispose();
        if (focusedElement && focusedElement instanceof HTMLElement) {
          focusedElement.focus();
        }
      }, 500);
    });
    this.layout.addWidget(panel);
  }
  /**
   * Update an output in the layout in place.
   */
  _setOutput(index, model) {
    if (index >= this._maxNumberOutputs) {
      return;
    }
    const panel = this.layout.widgets[index];
    const renderer = panel.widgets ? panel.widgets.filter((it) => "renderModel" in it).pop() : panel;
    const mimeType = this.rendermime.preferredMimeType(model.data, model.trusted ? "any" : "ensure");
    if (Private$3.currentPreferredMimetype.get(renderer) === mimeType && OutputArea.isIsolated(mimeType, model.metadata) === renderer instanceof Private$3.IsolatedRenderer) {
      void renderer.renderModel(model);
    } else {
      this.layout.widgets[index].dispose();
      this._insertOutput(index, model);
    }
  }
  /**
   * Render and insert a single output into the layout.
   *
   * @param index - The index of the output to be inserted.
   * @param model - The model of the output to be inserted.
   */
  _insertOutput(index, model) {
    if (index > this._maxNumberOutputs) {
      return;
    }
    const layout = this.layout;
    if (index === this._maxNumberOutputs) {
      const warning2 = new Private$3.TrimmedOutputs(this._maxNumberOutputs, () => {
        const lastShown = this._maxNumberOutputs;
        this._maxNumberOutputs = Infinity;
        this._showTrimmedOutputs(lastShown);
      });
      layout.insertWidget(index, this._wrappedOutput(warning2));
    } else {
      let output = this.createOutputItem(model);
      if (output) {
        output.toggleClass(EXECUTE_CLASS, model.executionCount !== null);
      } else {
        output = new Widget();
      }
      if (!this._outputTracker.has(output)) {
        void this._outputTracker.add(output);
      }
      layout.insertWidget(index, output);
    }
  }
  /**
   * A widget tracker for individual output widgets in the output area.
   */
  get outputTracker() {
    return this._outputTracker;
  }
  /**
   * Dispose information message and show output models from the given
   * index to maxNumberOutputs
   *
   * @param lastShown Starting model index to insert.
   */
  _showTrimmedOutputs(lastShown) {
    this.widgets[lastShown].dispose();
    for (let idx = lastShown; idx < this.model.length; idx++) {
      this._insertOutput(idx, this.model.get(idx));
    }
    this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
  }
  /**
   * Create an output item with a prompt and actual output
   *
   * @returns a rendered widget, or null if we cannot render
   * #### Notes
   */
  createOutputItem(model) {
    const output = this.createRenderedMimetype(model);
    if (!output) {
      return null;
    }
    return this._wrappedOutput(output, model.executionCount);
  }
  /**
   * Render a mimetype
   */
  createRenderedMimetype(model) {
    const mimeType = this.rendermime.preferredMimeType(model.data, model.trusted ? "any" : "ensure");
    if (!mimeType) {
      return null;
    }
    let output = this.rendermime.createRenderer(mimeType);
    const isolated = OutputArea.isIsolated(mimeType, model.metadata);
    if (isolated === true) {
      output = new Private$3.IsolatedRenderer(output);
    }
    Private$3.currentPreferredMimetype.set(output, mimeType);
    output.renderModel(model).catch((error) => {
      const pre = document.createElement("pre");
      const trans = this._translator.load("jupyterlab");
      pre.textContent = trans.__("Javascript Error: %1", error.message);
      output.node.appendChild(pre);
      output.node.className = "lm-Widget jp-RenderedText";
      output.node.setAttribute("data-mime-type", "application/vnd.jupyter.stderr");
    });
    return output;
  }
  /**
   * Wrap a output widget within a output panel
   *
   * @param output Output widget to wrap
   * @param executionCount Execution count
   * @returns The output panel
   */
  _wrappedOutput(output, executionCount = null) {
    const panel = new Private$3.OutputPanel();
    panel.addClass(OUTPUT_AREA_ITEM_CLASS);
    const prompt = this.contentFactory.createOutputPrompt();
    prompt.executionCount = executionCount;
    prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
    panel.addWidget(prompt);
    output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
    panel.addWidget(output);
    return panel;
  }
}
class SimplifiedOutputArea extends OutputArea {
  /**
   * Handle an input request from a kernel by doing nothing.
   */
  onInputRequest(msg, future2) {
    return;
  }
  /**
   * Create an output item without a prompt, just the output widgets
   */
  createOutputItem(model) {
    const output = this.createRenderedMimetype(model);
    if (!output) {
      return null;
    }
    const panel = new Private$3.OutputPanel();
    panel.addClass(OUTPUT_AREA_ITEM_CLASS);
    output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
    panel.addWidget(output);
    return panel;
  }
}
(function(OutputArea2) {
  async function execute(code2, output, sessionContext, metadata) {
    var _a;
    let stopOnError = true;
    if (metadata && Array.isArray(metadata.tags) && metadata.tags.indexOf("raises-exception") !== -1) {
      stopOnError = false;
    }
    const content = {
      code: code2,
      stop_on_error: stopOnError
    };
    const kernel2 = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
    if (!kernel2) {
      throw new Error("Session has no kernel.");
    }
    const future2 = kernel2.requestExecute(content, false, metadata);
    output.future = future2;
    return future2.done;
  }
  OutputArea2.execute = execute;
  function isIsolated(mimeType, metadata) {
    const mimeMd = metadata[mimeType];
    if (mimeMd && mimeMd["isolated"] !== void 0) {
      return !!mimeMd["isolated"];
    } else {
      return !!metadata["isolated"];
    }
  }
  OutputArea2.isIsolated = isIsolated;
  class ContentFactory {
    /**
     * Create the output prompt for the widget.
     */
    createOutputPrompt() {
      return new OutputPrompt();
    }
    /**
     * Create an stdin widget.
     */
    createStdin(options) {
      return new Stdin(options);
    }
  }
  OutputArea2.ContentFactory = ContentFactory;
  OutputArea2.defaultContentFactory = new ContentFactory();
})(OutputArea || (OutputArea = {}));
class OutputPrompt extends Widget {
  /*
   * Create an output prompt widget.
   */
  constructor() {
    super();
    this._executionCount = null;
    this.addClass(OUTPUT_PROMPT_CLASS$1);
  }
  /**
   * The execution count for the prompt.
   */
  get executionCount() {
    return this._executionCount;
  }
  set executionCount(value) {
    this._executionCount = value;
    if (value === null) {
      this.node.textContent = "";
    } else {
      this.node.textContent = `[${value}]:`;
    }
  }
}
class Stdin extends Widget {
  static _historyIx(key2, ix) {
    const history = Stdin._history.get(key2);
    if (!history) {
      return void 0;
    }
    const len = history.length;
    if (ix <= 0) {
      return len + ix;
    }
  }
  static _historyAt(key2, ix) {
    const history = Stdin._history.get(key2);
    if (!history) {
      return void 0;
    }
    const len = history.length;
    const ixpos = Stdin._historyIx(key2, ix);
    if (ixpos !== void 0 && ixpos < len) {
      return history[ixpos];
    }
  }
  static _historyPush(key2, line) {
    const history = Stdin._history.get(key2);
    history.push(line);
    if (history.length > 1e3) {
      history.shift();
    }
  }
  static _historySearch(key2, pat, ix, reverse = true) {
    const history = Stdin._history.get(key2);
    const len = history.length;
    const ixpos = Stdin._historyIx(key2, ix);
    const substrFound = (x2) => x2.search(pat) !== -1;
    if (ixpos === void 0) {
      return;
    }
    if (reverse) {
      if (ixpos === 0) {
        return;
      }
      const ixFound = history.slice(0, ixpos).findLastIndex(substrFound);
      if (ixFound !== -1) {
        return ixFound - len;
      }
    } else {
      if (ixpos >= len - 1) {
        return;
      }
      const ixFound = history.slice(ixpos + 1).findIndex(substrFound);
      if (ixFound !== -1) {
        return ixFound - len + ixpos + 1;
      }
    }
  }
  /**
   * Construct a new input widget.
   */
  constructor(options) {
    var _a;
    super({
      node: Private$3.createInputWidgetNode(options.prompt, options.password)
    });
    this._promise = new PromiseDelegate();
    this._resolved = false;
    this.addClass(STDIN_CLASS);
    this._future = options.future;
    this._historyIndex = 0;
    this._historyKey = options.inputHistoryScope === "session" ? options.parent_header.session : "";
    this._historyPat = "";
    this._parentHeader = options.parent_header;
    this._password = options.password;
    this._trans = ((_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator).load("jupyterlab");
    this._value = options.prompt + " ";
    this._input = this.node.getElementsByTagName("input")[0];
    if (!this._password) {
      this._input.placeholder = this._trans.__(" for history. Search history with c-/c-");
    } else {
      this._input.placeholder = "";
    }
    if (!Stdin._history.has(this._historyKey)) {
      Stdin._history.set(this._historyKey, []);
    }
  }
  /**
   * The value of the widget.
   */
  get value() {
    return this._promise.promise.then(() => this._value);
  }
  /**
   * Handle the DOM events for the widget.
   *
   * @param event - The DOM event sent to the widget.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the dock panel's node. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    if (this._resolved) {
      event2.preventDefault();
      return;
    }
    const input2 = this._input;
    if (event2.type === "keydown") {
      if (event2.key === "Enter") {
        this.resetSearch();
        this._future.sendInputReply({
          status: "ok",
          value: input2.value
        }, this._parentHeader);
        if (this._password) {
          this._value += "";
        } else {
          this._value += input2.value;
          Stdin._historyPush(this._historyKey, input2.value);
        }
        this._resolved = true;
        this._promise.resolve(void 0);
      } else if (event2.key === "Escape") {
        this.resetSearch();
        input2.blur();
      } else if (event2.ctrlKey && (event2.key === "ArrowUp" || event2.key === "ArrowDown")) {
        if (this._historyPat === "") {
          this._historyPat = input2.value;
        }
        const reverse = event2.key === "ArrowUp";
        const searchHistoryIx = Stdin._historySearch(this._historyKey, this._historyPat, this._historyIndex, reverse);
        if (searchHistoryIx !== void 0) {
          const historyLine = Stdin._historyAt(this._historyKey, searchHistoryIx);
          if (historyLine !== void 0) {
            if (this._historyIndex === 0) {
              this._valueCache = input2.value;
            }
            this._setInputValue(historyLine);
            this._historyIndex = searchHistoryIx;
            event2.preventDefault();
          }
        }
      } else if (event2.key === "ArrowUp") {
        this.resetSearch();
        const historyLine = Stdin._historyAt(this._historyKey, this._historyIndex - 1);
        if (historyLine) {
          if (this._historyIndex === 0) {
            this._valueCache = input2.value;
          }
          this._setInputValue(historyLine);
          --this._historyIndex;
          event2.preventDefault();
        }
      } else if (event2.key === "ArrowDown") {
        this.resetSearch();
        if (this._historyIndex === 0) ;
        else if (this._historyIndex === -1) {
          this._setInputValue(this._valueCache);
          ++this._historyIndex;
        } else {
          const historyLine = Stdin._historyAt(this._historyKey, this._historyIndex + 1);
          if (historyLine) {
            this._setInputValue(historyLine);
            ++this._historyIndex;
          }
        }
      }
    }
  }
  resetSearch() {
    this._historyPat = "";
  }
  /**
   * Handle `after-attach` messages sent to the widget.
   */
  onAfterAttach(msg) {
    this._input.addEventListener("keydown", this);
    this._input.focus();
  }
  /**
   * Handle `before-detach` messages sent to the widget.
   */
  onBeforeDetach(msg) {
    this._input.removeEventListener("keydown", this);
  }
  _setInputValue(value) {
    this._input.value = value;
    this._input.setSelectionRange(value.length, value.length);
  }
}
Stdin._history = /* @__PURE__ */ new Map();
var Private$3;
(function(Private2) {
  function createInputWidgetNode(prompt, password) {
    const node2 = document.createElement("div");
    const promptNode = document.createElement("pre");
    promptNode.className = STDIN_PROMPT_CLASS;
    promptNode.textContent = prompt;
    const input2 = document.createElement("input");
    input2.className = STDIN_INPUT_CLASS;
    if (password) {
      input2.type = "password";
    }
    node2.appendChild(promptNode);
    promptNode.appendChild(input2);
    return node2;
  }
  Private2.createInputWidgetNode = createInputWidgetNode;
  class IsolatedRenderer extends Widget {
    /**
     * Create an isolated renderer.
     */
    constructor(wrapped) {
      super({ node: document.createElement("iframe") });
      this.addClass("jp-mod-isolated");
      this._wrapped = wrapped;
      const iframe = this.node;
      iframe.frameBorder = "0";
      iframe.scrolling = "auto";
      iframe.addEventListener("load", () => {
        iframe.contentDocument.open();
        iframe.contentDocument.write(this._wrapped.node.innerHTML);
        iframe.contentDocument.close();
        const body = iframe.contentDocument.body;
        iframe.style.height = `${body.scrollHeight}px`;
        iframe.heightChangeObserver = new ResizeObserver(() => {
          iframe.style.height = `${body.scrollHeight}px`;
        });
        iframe.heightChangeObserver.observe(body);
      });
    }
    /**
     * Render a mime model.
     *
     * @param model - The mime model to render.
     *
     * @returns A promise which resolves when rendering is complete.
     *
     * #### Notes
     * This method may be called multiple times during the lifetime
     * of the widget to update it if and when new data is available.
     */
    renderModel(model) {
      return this._wrapped.renderModel(model);
    }
  }
  Private2.IsolatedRenderer = IsolatedRenderer;
  Private2.currentPreferredMimetype = new AttachedProperty({
    name: "preferredMimetype",
    create: (owner) => ""
  });
  class OutputPanel extends Panel {
    /**
     * Construct a new `OutputPanel` widget.
     */
    constructor(options) {
      super(options);
    }
    /**
     * A callback that focuses on the widget.
     */
    _onContext(_) {
      this.node.focus();
    }
    /**
     * Handle `after-attach` messages sent to the widget.
     */
    onAfterAttach(msg) {
      super.onAfterAttach(msg);
      this.node.addEventListener("contextmenu", this._onContext.bind(this));
    }
    /**
     * Handle `before-detach` messages sent to the widget.
     */
    onBeforeDetach(msg) {
      super.onAfterDetach(msg);
      this.node.removeEventListener("contextmenu", this._onContext.bind(this));
    }
  }
  Private2.OutputPanel = OutputPanel;
  class TrimmedOutputs extends Widget {
    /**
     * Widget constructor
     *
     * ### Notes
     * The widget will be disposed on click after calling the callback.
     *
     * @param maxNumberOutputs Maximal number of outputs to display
     * @param _onClick Callback on click event on the widget
     */
    constructor(maxNumberOutputs, onClick) {
      const node2 = document.createElement("div");
      const title = `The first ${maxNumberOutputs} are displayed`;
      const msg = "Show more outputs";
      node2.insertAdjacentHTML("afterbegin", `<a title=${title}>
          <pre>${msg}</pre>
        </a>`);
      super({
        node: node2
      });
      this._onClick = onClick;
      this.addClass("jp-TrimmedOutputs");
      this.addClass("jp-RenderedHTMLCommon");
    }
    /**
     * Handle the DOM events for widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the widget's DOM node. It should
     * not be called directly by user code.
     */
    handleEvent(event2) {
      if (event2.type === "click") {
        this._onClick(event2);
      }
    }
    /**
     * Handle `after-attach` messages for the widget.
     */
    onAfterAttach(msg) {
      super.onAfterAttach(msg);
      this.node.addEventListener("click", this);
    }
    /**
     * A message handler invoked on a `'before-detach'`
     * message
     */
    onBeforeDetach(msg) {
      super.onBeforeDetach(msg);
      this.node.removeEventListener("click", this);
    }
  }
  Private2.TrimmedOutputs = TrimmedOutputs;
})(Private$3 || (Private$3 = {}));
const globalModelDBMutex = createMutex();
function isMarkdownCellModel(model) {
  return model.type === "markdown";
}
function isRawCellModel(model) {
  return model.type === "raw";
}
class CellModel extends CodeEditor.Model {
  constructor(options = {}) {
    const { cell_type, sharedModel, ...others } = options;
    super({
      sharedModel: sharedModel !== null && sharedModel !== void 0 ? sharedModel : createStandaloneCell({
        cell_type: cell_type !== null && cell_type !== void 0 ? cell_type : "raw",
        id: options.id
      }),
      ...others
    });
    this.contentChanged = new Signal(this);
    this.stateChanged = new Signal(this);
    this._metadataChanged = new Signal(this);
    this._trusted = false;
    this.standaloneModel = typeof options.sharedModel === "undefined";
    this.trusted = !!this.getMetadata("trusted") || !!options.trusted;
    this.sharedModel.changed.connect(this.onGenericChange, this);
    this.sharedModel.metadataChanged.connect(this._onMetadataChanged, this);
  }
  /**
   * Signal emitted when cell metadata changes.
   */
  get metadataChanged() {
    return this._metadataChanged;
  }
  /**
   * The id for the cell.
   */
  get id() {
    return this.sharedModel.getId();
  }
  /**
   * The metadata associated with the cell.
   */
  get metadata() {
    return this.sharedModel.metadata;
  }
  /**
   * The trusted state of the model.
   */
  get trusted() {
    return this._trusted;
  }
  set trusted(newValue) {
    const oldValue = this.trusted;
    if (oldValue !== newValue) {
      this._trusted = newValue;
      this.onTrustedChanged(this, { newValue, oldValue });
    }
  }
  /**
   * Dispose of the resources held by the model.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.sharedModel.changed.disconnect(this.onGenericChange, this);
    this.sharedModel.metadataChanged.disconnect(this._onMetadataChanged, this);
    super.dispose();
  }
  /**
   * Handle a change to the trusted state.
   *
   * The default implementation is a no-op.
   */
  onTrustedChanged(trusted, args) {
  }
  /**
   * Delete a metadata
   *
   * @param key Metadata key
   */
  deleteMetadata(key2) {
    return this.sharedModel.deleteMetadata(key2);
  }
  /**
   * Get a metadata
   *
   * ### Notes
   * This returns a copy of the key value.
   *
   * @param key Metadata key
   */
  getMetadata(key2) {
    return this.sharedModel.getMetadata(key2);
  }
  /**
   * Set a metadata
   *
   * @param key Metadata key
   * @param value Metadata value
   */
  setMetadata(key2, value) {
    if (typeof value === "undefined") {
      this.sharedModel.deleteMetadata(key2);
    } else {
      this.sharedModel.setMetadata(key2, value);
    }
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return this.sharedModel.toJSON();
  }
  /**
   * Handle a change to the observable value.
   */
  onGenericChange() {
    this.contentChanged.emit(void 0);
  }
  _onMetadataChanged(sender, change) {
    this._metadataChanged.emit(change);
  }
}
class AttachmentsCellModel extends CellModel {
  /**
   * Construct a new cell with optional attachments.
   */
  constructor(options) {
    var _a;
    super(options);
    const factory = (_a = options.contentFactory) !== null && _a !== void 0 ? _a : AttachmentsCellModel.defaultContentFactory;
    const values = this.sharedModel.getAttachments();
    this._attachments = factory.createAttachmentsModel({ values });
    this._attachments.stateChanged.connect(this.onGenericChange, this);
    this._attachments.changed.connect(this._onAttachmentsChange, this);
    this.sharedModel.changed.connect(this._onSharedModelChanged, this);
  }
  /**
   * Get the attachments of the model.
   */
  get attachments() {
    return this._attachments;
  }
  /**
   * Dispose of the resources held by the model.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._attachments.stateChanged.disconnect(this.onGenericChange, this);
    this._attachments.changed.disconnect(this._onAttachmentsChange, this);
    this._attachments.dispose();
    this.sharedModel.changed.disconnect(this._onSharedModelChanged, this);
    super.dispose();
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return super.toJSON();
  }
  /**
   * Handle a change to the cell outputs modelDB and reflect it in the shared model.
   */
  _onAttachmentsChange(sender, event2) {
    const cell = this.sharedModel;
    globalModelDBMutex(() => cell.setAttachments(sender.toJSON()));
  }
  /**
   * Handle a change to the code cell value.
   */
  _onSharedModelChanged(slot, change) {
    if (change.attachmentsChange) {
      const cell = this.sharedModel;
      globalModelDBMutex(() => {
        var _a;
        return this._attachments.fromJSON((_a = cell.getAttachments()) !== null && _a !== void 0 ? _a : {});
      });
    }
  }
}
(function(AttachmentsCellModel2) {
  class ContentFactory {
    /**
     * Create an attachments model.
     */
    createAttachmentsModel(options) {
      return new AttachmentsModel(options);
    }
  }
  AttachmentsCellModel2.ContentFactory = ContentFactory;
  AttachmentsCellModel2.defaultContentFactory = new ContentFactory();
})(AttachmentsCellModel || (AttachmentsCellModel = {}));
class RawCellModel extends AttachmentsCellModel {
  /**
   * Construct a raw cell model from optional shared model.
   */
  constructor(options = {}) {
    super({
      cell_type: "raw",
      ...options
    });
  }
  /**
   * The type of the cell.
   */
  get type() {
    return "raw";
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return super.toJSON();
  }
}
class MarkdownCellModel extends AttachmentsCellModel {
  /**
   * Construct a markdown cell model from optional shared model.
   */
  constructor(options = {}) {
    super({
      cell_type: "markdown",
      ...options
    });
    this.mimeType = "text/x-ipythongfm";
  }
  /**
   * The type of the cell.
   */
  get type() {
    return "markdown";
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return super.toJSON();
  }
}
class CodeCellModel extends CellModel {
  /**
   * Construct a new code cell with optional original cell content.
   */
  constructor(options = {}) {
    var _a;
    super({
      cell_type: "code",
      ...options
    });
    this._executedCode = "";
    this._isDirty = false;
    const factory = (_a = options === null || options === void 0 ? void 0 : options.contentFactory) !== null && _a !== void 0 ? _a : CodeCellModel.defaultContentFactory;
    const trusted = this.trusted;
    const outputs = this.sharedModel.getOutputs();
    this._outputs = factory.createOutputArea({ trusted, values: outputs });
    this.sharedModel.changed.connect(this._onSharedModelChanged, this);
    this._outputs.changed.connect(this.onGenericChange, this);
    this._outputs.changed.connect(this.onOutputsChange, this);
  }
  /**
   * The type of the cell.
   */
  get type() {
    return "code";
  }
  /**
   * The execution count of the cell.
   */
  get executionCount() {
    return this.sharedModel.execution_count || null;
  }
  set executionCount(newValue) {
    this.sharedModel.execution_count = newValue || null;
  }
  /**
   * The execution state of the cell.
   */
  get executionState() {
    return this.sharedModel.executionState;
  }
  set executionState(newValue) {
    this.sharedModel.executionState = newValue;
  }
  /**
   * Whether the cell is dirty or not.
   *
   * A cell is dirty if it is output is not empty and does not
   * result of the input code execution.
   */
  get isDirty() {
    return this._isDirty;
  }
  /**
   * Public Set whether the cell is dirty or not.
   */
  set isDirty(dirty) {
    this._setDirty(dirty);
  }
  /**
   * The cell outputs.
   */
  get outputs() {
    return this._outputs;
  }
  clearExecution() {
    this.outputs.clear();
    this.executionCount = null;
    this.executionState = "idle";
    this._setDirty(false);
    this.sharedModel.deleteMetadata("execution");
    this.trusted = true;
  }
  /**
   * Dispose of the resources held by the model.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.sharedModel.changed.disconnect(this._onSharedModelChanged, this);
    this._outputs.changed.disconnect(this.onGenericChange, this);
    this._outputs.changed.disconnect(this.onOutputsChange, this);
    this._outputs.dispose();
    this._outputs = null;
    super.dispose();
  }
  /**
   * Handle a change to the trusted state.
   */
  onTrustedChanged(trusted, args) {
    const newTrusted = args.newValue;
    if (this._outputs) {
      this._outputs.trusted = newTrusted;
    }
    if (newTrusted) {
      const codeCell = this.sharedModel;
      const metadata = codeCell.getMetadata();
      metadata.trusted = true;
      codeCell.setMetadata(metadata);
    }
    this.stateChanged.emit({
      name: "trusted",
      oldValue: args.oldValue,
      newValue: newTrusted
    });
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return super.toJSON();
  }
  /**
   * Handle a change to the cell outputs modelDB and reflect it in the shared model.
   */
  onOutputsChange(sender, event2) {
    const codeCell = this.sharedModel;
    globalModelDBMutex(() => {
      switch (event2.type) {
        case "add": {
          for (const output of event2.newValues) {
            if (output.type === "stream") {
              output.streamText.changed.connect((sender2, textEvent) => {
                if (textEvent.options !== void 0 && textEvent.options["silent"]) {
                  return;
                }
                const codeCell2 = this.sharedModel;
                if (textEvent.type === "remove") {
                  codeCell2.removeStreamOutput(event2.newIndex, textEvent.start, "silent-change");
                } else {
                  codeCell2.appendStreamOutput(event2.newIndex, textEvent.value, "silent-change");
                }
              }, this);
            }
          }
          const outputs = event2.newValues.map((output) => output.toJSON());
          codeCell.updateOutputs(event2.newIndex, event2.newIndex, outputs, "silent-change");
          break;
        }
        case "set": {
          const newValues = event2.newValues.map((output) => output.toJSON());
          codeCell.updateOutputs(event2.oldIndex, event2.oldIndex + newValues.length, newValues, "silent-change");
          break;
        }
        case "remove":
          codeCell.updateOutputs(event2.oldIndex, event2.oldValues.length, [], "silent-change");
          break;
        default:
          throw new Error(`Invalid event type: ${event2.type}`);
      }
    });
  }
  /**
   * Handle a change to the code cell value.
   */
  _onSharedModelChanged(slot, change) {
    if (change.streamOutputChange) {
      globalModelDBMutex(() => {
        for (const streamOutputChange of change.streamOutputChange) {
          if ("delete" in streamOutputChange) {
            this._outputs.removeStreamOutput(streamOutputChange.delete);
          }
          if ("insert" in streamOutputChange) {
            this._outputs.appendStreamOutput(streamOutputChange.insert.toString());
          }
        }
      });
    }
    if (change.outputsChange) {
      globalModelDBMutex(() => {
        let retain = 0;
        for (const outputsChange of change.outputsChange) {
          if ("retain" in outputsChange) {
            retain += outputsChange.retain;
          }
          if ("delete" in outputsChange) {
            for (let i2 = 0; i2 < outputsChange.delete; i2++) {
              this._outputs.remove(retain);
            }
          }
          if ("insert" in outputsChange) {
            for (const output of outputsChange.insert) {
              this._outputs.add("toJSON" in output ? output.toJSON() : output);
            }
          }
        }
      });
    }
    if (change.executionCountChange) {
      if (change.executionCountChange.newValue && (this.isDirty || !change.executionCountChange.oldValue)) {
        this._setDirty(false);
      }
      this.stateChanged.emit({
        name: "executionCount",
        oldValue: change.executionCountChange.oldValue,
        newValue: change.executionCountChange.newValue
      });
    }
    if (change.executionStateChange) {
      this.stateChanged.emit({
        name: "executionState",
        oldValue: change.executionStateChange.oldValue,
        newValue: change.executionStateChange.newValue
      });
    }
    if (change.sourceChange && this.executionCount !== null) {
      this._setDirty(this._executedCode !== this.sharedModel.getSource().trim());
    }
  }
  /**
   * Set whether the cell is dirty or not.
   */
  _setDirty(v) {
    if (!v) {
      this._executedCode = this.sharedModel.getSource().trim();
    }
    if (v !== this._isDirty) {
      this._isDirty = v;
      this.stateChanged.emit({
        name: "isDirty",
        oldValue: !v,
        newValue: v
      });
    }
  }
}
(function(CodeCellModel2) {
  class ContentFactory {
    /**
     * Create an output area.
     */
    createOutputArea(options) {
      return new OutputAreaModel(options);
    }
  }
  CodeCellModel2.ContentFactory = ContentFactory;
  CodeCellModel2.defaultContentFactory = new ContentFactory();
})(CodeCellModel || (CodeCellModel = {}));
const PLACEHOLDER_CLASS = "jp-Placeholder";
const INPUT_PROMPT_CLASS = "jp-Placeholder-prompt jp-InputPrompt";
const OUTPUT_PROMPT_CLASS = "jp-Placeholder-prompt jp-OutputPrompt";
const CONTENT_CLASS = "jp-Placeholder-content";
const INPUT_PLACEHOLDER_CLASS = "jp-InputPlaceholder";
const OUTPUT_PLACEHOLDER_CLASS = "jp-OutputPlaceholder";
class Placeholder extends Widget {
  /**
   * Construct a new placeholder.
   */
  constructor(options) {
    var _a, _b, _c;
    const node2 = document.createElement("div");
    super({ node: node2 });
    const trans = ((_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator).load("jupyterlab");
    const innerNode = document.createElement("div");
    innerNode.className = (_b = options.promptClass) !== null && _b !== void 0 ? _b : "";
    node2.insertAdjacentHTML("afterbegin", innerNode.outerHTML);
    this._cell = document.createElement("div");
    this._cell.classList.add(CONTENT_CLASS);
    this._cell.title = trans.__("Click to expand");
    const container2 = this._cell.appendChild(document.createElement("div"));
    container2.classList.add("jp-Placeholder-contentContainer");
    this._textContent = container2.appendChild(document.createElement("span"));
    this._textContent.className = "jp-PlaceholderText";
    this._textContent.innerText = (_c = options.text) !== null && _c !== void 0 ? _c : "";
    node2.appendChild(this._cell);
    ellipsesIcon.element({
      container: container2.appendChild(document.createElement("span")),
      className: "jp-MoreHorizIcon",
      elementPosition: "center",
      height: "auto",
      width: "32px"
    });
    this.addClass(PLACEHOLDER_CLASS);
    this._callback = options.callback;
  }
  /**
   * The text displayed in the placeholder.
   */
  set text(t) {
    this._textContent.innerText = t;
  }
  get text() {
    return this._textContent.innerText;
  }
  onAfterAttach(msg) {
    super.onAfterAttach(msg);
    this.node.addEventListener("click", this._callback);
  }
  onBeforeDetach(msg) {
    this.node.removeEventListener("click", this._callback);
    super.onBeforeDetach(msg);
  }
}
class InputPlaceholder extends Placeholder {
  /**
   * Construct a new input placeholder.
   */
  constructor(options) {
    super({ ...options, promptClass: INPUT_PROMPT_CLASS });
    this.addClass(INPUT_PLACEHOLDER_CLASS);
  }
}
class OutputPlaceholder extends Placeholder {
  /**
   * Construct a new output placeholder.
   */
  constructor(options) {
    super({ ...options, promptClass: OUTPUT_PROMPT_CLASS });
    this.addClass(OUTPUT_PLACEHOLDER_CLASS);
  }
}
class Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from2, to, text2) {
    [from2, to] = clip(this, from2, to);
    let parts = [];
    this.decompose(
      0,
      from2,
      parts,
      2
      /* Open.To */
    );
    if (text2.length)
      text2.decompose(
        0,
        text2.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to - from2) + text2.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from2, to = this.length) {
    [from2, to] = clip(this, from2, to);
    let parts = [];
    this.decompose(from2, to, parts, 0);
    return TextNode.from(parts, to - from2);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a = new RawTextCursor(this), b = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a.next(skip);
      b.next(skip);
      skip = 0;
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
        return false;
      pos += a.value.length;
      if (a.done || pos >= end)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from2, to = this.length) {
    return new PartialTextCursor(this, from2, to);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from2, to) {
    let inner;
    if (from2 == null) {
      inner = this.iter();
    } else {
      if (to == null)
        to = this.lines + 1;
      let start = this.line(from2).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text2) {
    if (text2.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text2.length == 1 && !text2[0])
      return Text.empty;
    return text2.length <= 32 ? new TextLeaf(text2) : TextNode.from(TextLeaf.split(text2, []));
  }
}
class TextLeaf extends Text {
  constructor(text2, length2 = textLength(text2)) {
    super();
    this.text = text2;
    this.length = length2;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target2, isLine, line, offset) {
    for (let i2 = 0; ; i2++) {
      let string = this.text[i2], end = offset + string.length;
      if ((isLine ? line : end) >= target2)
        return new Line(offset, end, line, string);
      offset = end + 1;
      line++;
    }
  }
  decompose(from2, to, target2, open) {
    let text2 = from2 <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from2, to), Math.min(to, this.length) - Math.max(0, from2));
    if (open & 1) {
      let prev = target2.pop();
      let joined = appendText(text2.text, prev.text.slice(), 0, text2.length);
      if (joined.length <= 32) {
        target2.push(new TextLeaf(joined, prev.length + text2.length));
      } else {
        let mid = joined.length >> 1;
        target2.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
      }
    } else {
      target2.push(text2);
    }
  }
  replace(from2, to, text2) {
    if (!(text2 instanceof TextLeaf))
      return super.replace(from2, to, text2);
    [from2, to] = clip(this, from2, to);
    let lines = appendText(this.text, appendText(text2.text, sliceText(this.text, 0, from2)), to);
    let newLen = this.length + text2.length - (to - from2);
    if (lines.length <= 32)
      return new TextLeaf(lines, newLen);
    return TextNode.from(TextLeaf.split(lines, []), newLen);
  }
  sliceString(from2, to = this.length, lineSep = "\n") {
    [from2, to] = clip(this, from2, to);
    let result2 = "";
    for (let pos = 0, i2 = 0; pos <= to && i2 < this.text.length; i2++) {
      let line = this.text[i2], end = pos + line.length;
      if (pos > from2 && i2)
        result2 += lineSep;
      if (from2 < end && to > pos)
        result2 += line.slice(Math.max(0, from2 - pos), to - pos);
      pos = end + 1;
    }
    return result2;
  }
  flatten(target2) {
    for (let line of this.text)
      target2.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text2, target2) {
    let part = [], len = -1;
    for (let line of text2) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target2.push(new TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target2.push(new TextLeaf(part, len));
    return target2;
  }
}
class TextNode extends Text {
  constructor(children2, length2) {
    super();
    this.children = children2;
    this.length = length2;
    this.lines = 0;
    for (let child of children2)
      this.lines += child.lines;
  }
  lineInner(target2, isLine, line, offset) {
    for (let i2 = 0; ; i2++) {
      let child = this.children[i2], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target2)
        return child.lineInner(target2, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from2, to, target2, open) {
    for (let i2 = 0, pos = 0; pos <= to && i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (from2 <= end && to >= pos) {
        let childOpen = open & ((pos <= from2 ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from2 && end <= to && !childOpen)
          target2.push(child);
        else
          child.decompose(from2 - pos, to - pos, target2, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from2, to, text2) {
    [from2, to] = clip(this, from2, to);
    if (text2.lines < this.lines)
      for (let i2 = 0, pos = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (from2 >= pos && to <= end) {
          let updated = child.replace(from2 - pos, to - pos, text2);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy2 = this.children.slice();
            copy2[i2] = updated;
            return new TextNode(copy2, this.length - (to - from2) + text2.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from2, to, text2);
  }
  sliceString(from2, to = this.length, lineSep = "\n") {
    [from2, to] = clip(this, from2, to);
    let result2 = "";
    for (let i2 = 0, pos = 0; i2 < this.children.length && pos <= to; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (pos > from2 && i2)
        result2 += lineSep;
      if (from2 < end && to > pos)
        result2 += child.sliceString(from2 - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result2;
  }
  flatten(target2) {
    for (let child of this.children)
      child.flatten(target2);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof TextNode))
      return 0;
    let length2 = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length2;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length2 + chA.scanIdentical(chB, dir);
      length2 += chA.length + 1;
    }
  }
  static from(children2, length2 = children2.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children2)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children2)
        ch.flatten(flat);
      return new TextLeaf(flat, length2);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add(child) {
      let last2;
      if (child.lines > maxChunk && child instanceof TextNode) {
        for (let node2 of child.children)
          add(node2);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last2 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last2.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last2.text.concat(child.text), last2.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children2)
      add(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length2);
  }
}
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text2) {
  let length2 = -1;
  for (let line of text2)
    length2 += line.length + 1;
  return length2;
}
function appendText(text2, target2, from2 = 0, to = 1e9) {
  for (let pos = 0, i2 = 0, first = true; i2 < text2.length && pos <= to; i2++) {
    let line = text2[i2], end = pos + line.length;
    if (end >= from2) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from2)
        line = line.slice(from2 - pos);
      if (first) {
        target2[target2.length - 1] += line;
        first = false;
      } else
        target2.push(line);
    }
    pos = end + 1;
  }
  return target2;
}
function sliceText(text2, from2, to) {
  return appendText(text2, [""], from2, to);
}
class RawTextCursor {
  constructor(text2, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text2];
    this.offsets = [dir > 0 ? 1 : (text2 instanceof TextLeaf ? text2.text.length : text2.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last2 = this.nodes.length - 1;
      let top2 = this.nodes[last2], offsetValue = this.offsets[last2], offset = offsetValue >> 1;
      let size2 = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size2 : 0)) {
        if (last2 == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last2 - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last2] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last2] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last2] += dir;
        } else {
          if (dir < 0)
            this.offsets[last2]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
}
class PartialTextCursor {
  constructor(text2, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text2, start > end ? -1 : 1);
    this.pos = start > end ? text2.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit2 = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit2)
      skip = limit2;
    limit2 -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit2 ? value : dir < 0 ? value.slice(value.length - limit2) : value.slice(0, limit2);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class LineCursor {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
}
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
class Line {
  /**
  @internal
  */
  constructor(from2, to, number, text2) {
    this.from = from2;
    this.to = to;
    this.number = number;
    this.text = text2;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function clip(text2, from2, to) {
  from2 = Math.max(0, Math.min(text2.length, from2));
  return [from2, Math.max(from2, Math.min(text2.length, to))];
}
let extend = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
for (let i2 = 1; i2 < extend.length; i2++)
  extend[i2] += extend[i2 - 1];
function isExtendingChar(code2) {
  for (let i2 = 1; i2 < extend.length; i2 += 2)
    if (extend[i2] > code2)
      return extend[i2 - 1] <= code2;
  return false;
}
function isRegionalIndicator(code2) {
  return code2 >= 127462 && code2 <= 127487;
}
const ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length)
    return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
    pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i2 = pos - 2;
      while (i2 >= 0 && isRegionalIndicator(codePointAt(str, i2))) {
        countBefore++;
        i2 -= 2;
      }
      if (countBefore % 2 == 0)
        break;
      else
        pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found2 = nextClusterBreak(str, pos - 2, includeExtending);
    if (found2 < pos)
      return found2;
    pos--;
  }
  return 0;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function codePointSize(code2) {
  return code2 < 65536 ? 1 : 2;
}
const DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
class ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result2 = 0;
    for (let i2 = 0; i2 < this.sections.length; i2 += 2)
      result2 += this.sections[i2];
    return result2;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result2 = 0;
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
      let ins = this.sections[i2 + 1];
      result2 += ins < 0 ? this.sections[i2] : ins;
    }
    return result2;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f) {
    for (let i2 = 0, posA = 0, posB = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from2, to = from2) {
    for (let i2 = 0, pos = 0; i2 < this.sections.length && pos <= to; ) {
      let len = this.sections[i2++], ins = this.sections[i2++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from2)
        return pos < from2 && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result2 = "";
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      result2 += (result2 ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result2;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ChangeDesc(json);
  }
  /**
  @internal
  */
  static create(sections) {
    return new ChangeDesc(sections);
  }
}
class ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text2) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text2), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i2 = 0, pos = 0; i2 < sections.length; i2 += 2) {
      let len = sections[i2], ins = sections[i2 + 1];
      if (ins >= 0) {
        sections[i2] = ins;
        sections[i2 + 1] = len;
        let index = i2 >> 1;
        while (inserted.length < index)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done: for (let i2 = 0, pos = 0; ; ) {
      let next = i2 == ranges.length ? 1e9 : ranges[i2++];
      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0)
          addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }
      let end = ranges[i2++];
      while (pos < end) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }
    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
      let len = this.sections[i2], ins = this.sections[i2 + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i2 >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length2, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length2)
        addSection(sections, length2 - pos, -1);
      let set2 = new ChangeSet(sections, inserted);
      total = total ? total.compose(set2.map(total)) : set2;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length2)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length2})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from: from2, to = from2, insert: insert2 } = spec;
        if (from2 > to || from2 < 0 || to > length2)
          throw new RangeError(`Invalid change range ${from2} to ${to} (in doc of length ${length2})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from2 == to && insLen == 0)
          return;
        if (from2 < pos)
          flush();
        if (from2 > pos)
          addSection(sections, from2 - pos, -1);
        addSection(sections, to - from2, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length2) {
    return new ChangeSet(length2 ? [length2, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i2 = 0; i2 < json.length; i2++) {
      let part = json[i2];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i3) => i3 && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i2)
          inserted.push(Text.empty);
        inserted[i2] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i2].length);
      }
    }
    return new ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new ChangeSet(sections, inserted);
  }
}
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last2 = sections.length - 2;
  if (last2 >= 0 && ins <= 0 && ins == sections[last2 + 1])
    sections[last2] += len;
  else if (len == 0 && sections[last2] == 0)
    sections[last2 + 1] += ins;
  else if (forceJoin) {
    sections[last2] += len;
    sections[last2 + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index = sections.length - 2 >> 1;
  if (index < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i2 = 0; i2 < desc.sections.length; ) {
    let len = desc.sections[i2++], ins = desc.sections[i2++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text2 = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text2 = text2.append(inserted[i2 - 2 >> 1]);
        if (individual || i2 == desc.sections.length || desc.sections[i2 + 1] < 0)
          break;
        len = desc.sections[i2++];
        ins = desc.sections[i2++];
      }
      f(posA, endA, posB, endB, text2);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a.ins == -1 && b.ins == -1) {
      let len = Math.min(a.len, b.len);
      addSection(sections, len, -1);
      a.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
      let len = b.len;
      addSection(sections, b.ins, -1);
      while (len) {
        let piece = Math.min(a.len, len);
        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
          addSection(sections, 0, a.ins);
          if (insert2)
            addInsert(insert2, sections, a.text);
          inserted = a.i;
        }
        a.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a.ins >= 0) {
      let len = 0, left = a.len;
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len);
          len += piece;
          left -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a.i ? a.ins : 0);
      if (insert2 && inserted < a.i)
        addInsert(insert2, sections, a.text);
      inserted = a.i;
      a.forward(a.len - left);
    } else if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len), sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
class SectionIter {
  constructor(set2) {
    this.set = set2;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length ? Text.empty : inserted[index];
  }
  textBit(len) {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
}
class SelectionRange {
  constructor(from2, to, flags) {
    this.from = from2;
    this.to = to;
    this.flags = flags;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 7;
    return level == 7 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from2, to;
    if (this.empty) {
      from2 = to = change.mapPos(this.from, assoc);
    } else {
      from2 = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from2 == this.from && to == this.to ? this : new SelectionRange(from2, to, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from2, to = from2) {
    if (from2 <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from2, to);
    let head = Math.abs(from2 - this.anchor) > Math.abs(to - this.anchor) ? from2 : to;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
  /**
  @internal
  */
  static create(from2, to, flags) {
    return new SelectionRange(from2, to, flags);
  }
}
class EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i2 = 0; i2 < this.ranges.length; i2++)
      if (!this.ranges[i2].eq(other.ranges[i2], includeAssoc))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range2, main = true) {
    return EditorSelection.create([range2].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range2, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range2;
    return EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new EditorSelection([EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i2 = 0; i2 < ranges.length; i2++) {
      let range2 = ranges[i2];
      if (range2.empty ? range2.from <= pos : range2.from < pos)
        return EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range2.to;
    }
    return new EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a, b) => a.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i2 = 1; i2 < ranges.length; i2++) {
      let range2 = ranges[i2], prev = ranges[i2 - 1];
      if (range2.empty ? range2.from <= prev.to : range2.from < prev.to) {
        let from2 = prev.from, to = Math.max(range2.to, prev.to);
        if (i2 <= mainIndex)
          mainIndex--;
        ranges.splice(--i2, 2, range2.anchor > range2.head ? EditorSelection.range(to, from2) : EditorSelection.range(from2, to));
      }
    }
    return new EditorSelection(ranges, mainIndex);
  }
}
function checkSelection(selection, docLength) {
  for (let range2 of selection.ranges)
    if (range2.to > docLength)
      throw new RangeError("Selection points outside of document");
}
let nextID = 0;
class Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(config2 = {}) {
    return new Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray : (a, b) => a === b), !!config2.static, config2.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x2) => x2;
    return this.compute([field], (state) => get(state.field(field)));
  }
}
function sameArray(a, b) {
  return a == b || a.length == b.length && a.every((e, i2) => e === b[i2]);
}
class FacetProvider {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
}
function compareArray(a, b, compare2) {
  if (a.length != b.length)
    return false;
  for (let i2 = 0; i2 < a.length; i2++)
    if (!compare2(a[i2], b[i2]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values = [];
    for (let i2 = 0; i2 < providerAddrs.length; i2++) {
      let value = getAddr(state, providerAddrs[i2]);
      if (providerTypes[i2] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    return facet.combine(values);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
const initField = /* @__PURE__ */ Facet.define({ static: true });
class StateField {
  constructor(id, createF, updateF, compareF, spec) {
    this.id = id;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config2) {
    let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i2) => i2.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create2) {
    return [this, initField.of({ field: this, create: create2 })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
const Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ prec(Prec_.lowest)
};
class PrecExtension {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
}
class Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content) {
    return Compartment.reconfigure.of({ compartment: this, extension: content });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
}
class CompartmentInstance {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
}
class Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a) => field.slot(a));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id in facets) {
      let providers = facets[id], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id] || [];
      if (providers.every(
        (p) => p.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p) => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => p.dynamicSlot(a));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address));
    return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
}
function flatten(extension, compartments, newCompartments) {
  let result2 = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found2 = result2[known].indexOf(ext);
      if (found2 > -1)
        result2[known].splice(found2, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content);
      inner(content, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result2[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result2[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content = ext.extension;
      if (!content)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result2.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
const languageData = /* @__PURE__ */ Facet.define();
const allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((v) => v),
  static: true
});
const lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
const changeFilter = /* @__PURE__ */ Facet.define();
const transactionFilter = /* @__PURE__ */ Facet.define();
const transactionExtender = /* @__PURE__ */ Facet.define();
const readOnly = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : false
});
class Annotation {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
}
class AnnotationType {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
}
class StateEffectType {
  /**
  @internal
  */
  constructor(map2) {
    this.map = map2;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
}
class StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result2 = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result2.push(mapped);
    }
    return result2;
  }
}
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
class Transaction {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView2) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView2;
    this._doc = null;
    this._state = null;
    if (selection)
      checkSelection(selection, changes.newLength);
    if (!annotations.some((a) => a.type == Transaction.time))
      this.annotations = annotations.concat(Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection, effects, annotations, scrollIntoView2) {
    return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView2);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event2) {
    let e = this.annotation(Transaction.userEvent);
    return !!(e && (e == event2 || e.length > event2.length && e.slice(0, event2.length) == event2 && e[event2.length] == "."));
  }
}
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a, b) {
  let result2 = [];
  for (let iA = 0, iB = 0; ; ) {
    let from2, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from2 = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from2 = b[iB++];
      to = b[iB++];
    } else
      return result2;
    if (!result2.length || result2[result2.length - 1] < from2)
      result2.push(from2, to);
    else if (result2[result2.length - 1] < to)
      result2[result2.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter2) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter2 = false;
  for (let i2 = 1; i2 < specs.length; i2++) {
    if (specs[i2].filter === false)
      filter2 = false;
    let seq = !!specs[i2].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i2], seq ? s.changes.newLength : state.doc.length), seq);
  }
  let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter2 ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result2 = true;
  for (let filter2 of state.facet(changeFilter)) {
    let value = filter2(tr);
    if (value === false) {
      result2 = false;
      break;
    }
    if (Array.isArray(value))
      result2 = result2 === true ? value : joinRanges(result2, value);
  }
  if (result2 !== true) {
    let changes, back;
    if (result2 === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result2);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i2 = filters.length - 1; i2 >= 0; i2--) {
    let filtered = filters[i2](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i2 = extenders.length - 1; i2 >= 0; i2--) {
    let extension = extenders[i2](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i2 = 0; i2 < str.length; i2++) {
    let ch = str[i2];
    if (/\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i2 = 0; i2 < wordChars.length; i2++)
      if (char.indexOf(wordChars[i2]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
class EditorState {
  constructor(config2, doc2, selection, values, computeSlot, tr) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection;
    this.values = values;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr)
      tr._state = this;
    for (let i2 = 0; i2 < this.config.dynamicSlots.length; i2++)
      ensureAddr(this, i2 << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key2) => compartments.set(key2, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
    new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text2) {
    if (typeof text2 == "string")
      text2 = this.toText(text2);
    return this.changeByRange((range2) => ({
      changes: { from: range2.from, to: range2.to, insert: text2 },
      range: EditorSelection.cursor(range2.from + text2.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i2 = 1; i2 < sel.ranges.length; i2++) {
      let result2 = f(sel.ranges[i2]);
      let newChanges = this.changes(result2.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i2; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result2.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result2.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string) {
    return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from2 = 0, to = this.doc.length) {
    return this.doc.sliceString(from2, to, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result2 = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result2[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result2;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json, config2 = {}, fields) {
    if (!json || typeof json.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json, prop)) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
    let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection = selection.asSingle();
    return new EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase, ...insert2) {
    for (let map2 of this.facet(EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map2, phrase)) {
        phrase = map2[phrase];
        break;
      }
    if (insert2.length)
      phrase = phrase.replace(/\$(\$|\d*)/g, (m2, i2) => {
        if (i2 == "$")
          return "$";
        let n = +(i2 || 1);
        return !n || n > insert2.length ? m2 : insert2[n - 1];
      });
    return phrase;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result2 of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result2, name2))
          values.push(result2[name2]);
      }
    }
    return values;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text: text2, from: from2, length: length2 } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from2, end = pos - from2;
    while (start > 0) {
      let prev = findClusterBreak(text2, start, false);
      if (cat(text2.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length2) {
      let next = findClusterBreak(text2, end);
      if (cat(text2.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from2, end + from2);
  }
}
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = /* @__PURE__ */ Facet.define({
  compare(a, b) {
    let kA = Object.keys(a), kB = Object.keys(b);
    return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
class RangeValue {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from2, to = from2) {
    return Range.create(from2, to, this);
  }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
class Range {
  constructor(from2, to, value) {
    this.from = from2;
    this.to = to;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from2, to, value) {
    return new Range(from2, to, value);
  }
}
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
class Chunk {
  constructor(from2, to, value, maxPoint) {
    this.from = from2;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from2, to, f) {
    for (let i2 = this.findIndex(from2, -1e9, true), e = this.findIndex(to, 1e9, false, i2); i2 < e; i2++)
      if (f(this.from[i2] + offset, this.to[i2] + offset, this.value[i2]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from2 = [], to = [], newPos = -1, maxPoint = -1;
    for (let i2 = 0; i2 < this.value.length; i2++) {
      let val = this.value[i2], curFrom = this.from[i2] + offset, curTo = this.to[i2] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from2.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new Chunk(from2, to, value, maxPoint) : null, pos: newPos };
  }
}
class RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last2 = this.chunk.length - 1;
    return last2 < 0 ? 0 : Math.max(this.chunkEnd(last2), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size2 = this.nextLayer.size;
    for (let chunk of this.chunk)
      size2 += chunk.value.length;
    return size2;
  }
  /**
  @internal
  */
  chunkEnd(index) {
    return this.chunkPos[index] + this.chunk[index].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter2 = updateSpec.filter;
    if (add.length == 0 && !filter2)
      return this;
    if (sort)
      add = add.slice().sort(cmpRange);
    if (this.isEmpty)
      return add.length ? RangeSet.of(add) : this;
    let cur = new LayerCursor(this, null, -1).goto(0), i2 = 0, spill = [];
    let builder2 = new RangeSetBuilder();
    while (cur.value || i2 < add.length) {
      if (i2 < add.length && (cur.from - add[i2].from || cur.startSide - add[i2].value.startSide) >= 0) {
        let range2 = add[i2++];
        if (!builder2.addInner(range2.from, range2.to, range2.value))
          spill.push(range2);
      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i2 == add.length || this.chunkEnd(cur.chunkIndex) < add[i2].from) && (!filter2 || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder2.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
        cur.nextChunk();
      } else {
        if (!filter2 || filterFrom > cur.to || filterTo < cur.from || filter2(cur.from, cur.to, cur.value)) {
          if (!builder2.addInner(cur.from, cur.to, cur.value))
            spill.push(Range.create(cur.from, cur.to, cur.value));
        }
        cur.next();
      }
    }
    return builder2.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter: filter2, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i2 = 0; i2 < this.chunk.length; i2++) {
      let start = this.chunkPos[i2], chunk = this.chunk[i2];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from2, to, f) {
    if (this.isEmpty)
      return;
    for (let i2 = 0; i2 < this.chunk.length; i2++) {
      let start = this.chunkPos[i2], chunk = this.chunk[i2];
      if (to >= start && from2 <= start + chunk.length && chunk.between(start, from2 - start, to - start, f) === false)
        return;
    }
    this.nextLayer.between(from2, to, f);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from2 = 0) {
    return HeapCursor.from([this]).goto(from2);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from2 = 0) {
    return HeapCursor.from(sets).goto(from2);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a = oldSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let b = newSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b, textDiff);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length2) => compare(sideA, fromA, sideB, fromB, length2, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from2 = 0, to) {
    if (to == null)
      to = 1e9 - 1;
    let a = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0);
    let b = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0);
    if (a.length != b.length)
      return false;
    if (!a.length)
      return true;
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from2), sideB = new SpanCursor(b, sharedChunks, 0).goto(from2);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from2, to, iterator, minPointSize = -1) {
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from2), pos = from2;
    let openRanges = cursor.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor.to, to);
      if (cursor.point) {
        let active = cursor.activeForPoint(cursor.to);
        let openCount = cursor.pointFrom < from2 ? active.length + 1 : cursor.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
        openRanges = Math.min(cursor.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor.active, openRanges);
        openRanges = cursor.openEnd(curTo);
      }
      if (cursor.to > to)
        return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
      pos = cursor.to;
      cursor.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range2 of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range2.from, range2.to, range2.value);
    return build.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length)
      return RangeSet.empty;
    let result2 = sets[sets.length - 1];
    for (let i2 = sets.length - 2; i2 >= 0; i2--) {
      for (let layer = sets[i2]; layer != RangeSet.empty; layer = layer.nextLayer)
        result2 = new RangeSet(layer.chunkPos, layer.chunk, result2, Math.max(layer.maxPoint, result2.maxPoint));
    }
    return result2;
  }
}
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i2 = 1; i2 < ranges.length; i2++) {
      let cur = ranges[i2];
      if (cmpRange(prev, cur) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from2, to, value) {
    if (!this.addInner(from2, to, value))
      (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from2, to, value);
  }
  /**
  @internal
  */
  addInner(from2, to, value) {
    let diff = from2 - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from2 - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from2;
    this.from.push(from2 - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from2;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from2);
    return true;
  }
  /**
  @internal
  */
  addChunk(from2, chunk) {
    if ((from2 - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from2);
    let last2 = chunk.value.length - 1;
    this.last = chunk.value[last2];
    this.lastFrom = chunk.from[last2] + from2;
    this.lastTo = chunk.to[last2] + from2;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result2 = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result2;
  }
}
function findSharedChunks(a, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set2 of a)
    for (let i2 = 0; i2 < set2.chunk.length; i2++)
      if (set2.chunk[i2].maxPoint <= 0)
        inA.set(set2.chunk[i2], set2.chunkPos[i2]);
  let shared = /* @__PURE__ */ new Set();
  for (let set2 of b)
    for (let i2 = 0; i2 < set2.chunk.length; i2++) {
      let known = inA.get(set2.chunk[i2]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i2] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set2.chunk[i2].length)))
        shared.add(set2.chunk[i2]);
    }
  return shared;
}
class LayerCursor {
  constructor(layer, skip, minPoint, rank = 0) {
    this.layer = layer;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from2 = chunkPos + chunk.from[this.rangeIndex];
        this.from = from2;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index) {
    if (index == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
}
class HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i2 = 0; i2 < sets.length; i2++) {
      for (let cur = sets[i2]; !cur.isEmpty; cur = cur.nextLayer) {
        if (cur.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur, skip, minPoint, i2));
      }
    }
    return heap.length == 1 ? heap[0] : new HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur of this.heap)
      cur.goto(pos, side);
    for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
      heapBubble(this.heap, i2);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur of this.heap)
      cur.forward(pos, side);
    for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
      heapBubble(this.heap, i2);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
}
function heapBubble(heap, index) {
  for (let cur = heap[index]; ; ) {
    let childIndex = (index << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur.compare(child) < 0)
      break;
    heap[childIndex] = cur;
    heap[index] = child;
    index = childIndex;
  }
}
class SpanCursor {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index) {
    remove(this.active, index);
    remove(this.activeTo, index);
    remove(this.activeRank, index);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i2 = 0, { value, to, rank } = this.cursor;
    while (i2 < this.activeRank.length && (rank - this.activeRank[i2] || to - this.activeTo[i2]) > 0)
      i2++;
    insert(this.active, i2, value);
    insert(this.activeTo, i2, to);
    insert(this.activeRank, i2, rank);
    if (trackOpen)
      insert(trackOpen, i2, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from2 = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a = this.minActive;
      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from2) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }
        this.removeActive(a);
        if (trackOpen)
          remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from2) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i2 = trackOpen.length - 1; i2 >= 0 && trackOpen[i2] < from2; i2--)
        this.openStart++;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i2 = this.active.length - 1; i2 >= 0; i2--) {
      if (this.activeRank[i2] < this.pointRank)
        break;
      if (this.activeTo[i2] > to || this.activeTo[i2] == to && this.active[i2].endSide >= this.point.endSide)
        active.push(this.active[i2]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i2 = this.activeTo.length - 1; i2 >= 0 && this.activeTo[i2] > to; i2--)
      open++;
    return open;
  }
}
function compare(a, startA, b, startB, length2, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length2;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let diff = a.to + dPos - b.to || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
    if (a.point || b.point) {
      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
        comparator.comparePoint(pos, clipEnd, a.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active);
    }
    if (end > endB)
      break;
    pos = end;
    if (diff <= 0)
      a.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length)
    return false;
  for (let i2 = 0; i2 < a.length; i2++)
    if (a[i2] != b[i2] && !a[i2].eq(b[i2]))
      return false;
  return true;
}
function remove(array, index) {
  for (let i2 = index, e = array.length - 1; i2 < e; i2++)
    array[i2] = array[i2 + 1];
  array.pop();
}
function insert(array, index, value) {
  for (let i2 = array.length - 1; i2 >= index; i2--)
    array[i2 + 1] = array[i2];
  array[index] = value;
}
function findMinIndex(value, array) {
  let found2 = -1, foundPos = 1e9;
  for (let i2 = 0; i2 < array.length; i2++)
    if ((array[i2] - foundPos || value[i2].endSide - value[found2].endSide) < 0) {
      found2 = i2;
      foundPos = array[i2];
    }
  return found2;
}
function findColumn(string, col, tabSize, strict) {
  for (let i2 = 0, n = 0; ; ) {
    if (n >= col)
      return i2;
    if (i2 == string.length)
      break;
    n += string.charCodeAt(i2) == 9 ? tabSize - n % tabSize : 1;
    i2 = findClusterBreak(string, i2);
  }
  return strict === true ? -1 : string.length;
}
const C = "";
const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
class StyleModule {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = [];
    let { finish } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render2(selectors, spec2, target2, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null) return target2.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render2(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
            value,
            target2
          );
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render2(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target2.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec) render2(splitSelector(prop), spec[prop], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let id = top[COUNT] || 1;
    top[COUNT] = id + 1;
    return C + id.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root2, modules, options) {
    let set2 = root2[SET], nonce = options && options.nonce;
    if (!set2) set2 = new StyleSet(root2, nonce);
    else if (nonce) set2.setNonce(nonce);
    set2.mount(Array.isArray(modules) ? modules : [modules], root2);
  }
}
let adoptedSet = /* @__PURE__ */ new Map();
class StyleSet {
  constructor(root2, nonce) {
    let doc2 = root2.ownerDocument || root2, win = doc2.defaultView;
    if (!root2.head && root2.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2);
      if (adopted) return root2[SET] = adopted;
      this.sheet = new win.CSSStyleSheet();
      adoptedSet.set(doc2, this);
    } else {
      this.styleTag = doc2.createElement("style");
      if (nonce) this.styleTag.setAttribute("nonce", nonce);
    }
    this.modules = [];
    root2[SET] = this;
  }
  mount(modules, root2) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i2 = 0; i2 < modules.length; i2++) {
      let mod = modules[i2], index = this.modules.indexOf(mod);
      if (index < j && index > -1) {
        this.modules.splice(index, 1);
        j--;
        index = -1;
      }
      if (index == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet) for (let k = 0; k < mod.rules.length; k++)
          sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index) pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (sheet) {
      if (root2.adoptedStyleSheets.indexOf(this.sheet) < 0)
        root2.adoptedStyleSheets = [this.sheet, ...root2.adoptedStyleSheets];
    } else {
      let text2 = "";
      for (let i2 = 0; i2 < this.modules.length; i2++)
        text2 += this.modules[i2].getRules() + "\n";
      this.styleTag.textContent = text2;
      let target2 = root2.head || root2;
      if (this.styleTag.parentNode != target2)
        target2.insertBefore(this.styleTag, target2.firstChild);
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
      this.styleTag.setAttribute("nonce", nonce);
  }
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
function getSelection(root2) {
  let target2;
  if (root2.nodeType == 11) {
    target2 = root2.getSelection ? root2 : root2.ownerDocument;
  } else {
    target2 = root2;
  }
  return target2.getSelection();
}
function contains(dom, node2) {
  return node2 ? dom == node2 || dom.contains(node2.nodeType != 1 ? node2.parentNode : node2) : false;
}
function hasSelection(dom, selection) {
  if (!selection.anchorNode)
    return false;
  try {
    return contains(dom, selection.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node2, off, targetNode, targetOff) {
  return targetNode ? scanFor(node2, off, targetNode, targetOff, -1) || scanFor(node2, off, targetNode, targetOff, 1) : false;
}
function domIndex(node2) {
  for (var index = 0; ; index++) {
    node2 = node2.previousSibling;
    if (!node2)
      return index;
  }
}
function isBlockElement(node2) {
  return node2.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node2.nodeName);
}
function scanFor(node2, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node2 == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node2))) {
      if (node2.nodeName == "DIV")
        return false;
      let parent = node2.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node2) + (dir < 0 ? 0 : 1);
      node2 = parent;
    } else if (node2.nodeType == 1) {
      node2 = node2.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node2.nodeType == 1 && node2.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node2) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node2) {
  return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
}
function flattenRect(rect, left) {
  let x2 = left ? rect.left : rect.right;
  return { left: x2, right: x2, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  let vp = win.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale(elt, rect) {
  let scaleX = rect.width / elt.offsetWidth;
  let scaleY = rect.height / elt.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
    scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
    scaleY = 1;
  return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x2, y, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur = dom, stop = false; cur && !stop; ) {
    if (cur.nodeType == 1) {
      let bounding, top2 = cur == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
          stop = true;
        if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
          cur = cur.assignedSlot || cur.parentNode;
          continue;
        }
        let rect2 = cur.getBoundingClientRect();
        ({ scaleX, scaleY } = getScale(cur, rect2));
        bounding = {
          left: rect2.left,
          right: rect2.left + cur.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y == "nearest") {
        if (rect.top < bounding.top) {
          moveY = -(bounding.top - rect.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + moveY + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = -(bounding.top + moveY - rect.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x2 == "nearest") {
        if (rect.left < bounding.left) {
          moveX = -(bounding.left - rect.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + moveX + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = -(bounding.left + moveX - rect.left + xMargin);
        }
      } else {
        let targetLeft = x2 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x2 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur.scrollTop;
            cur.scrollTop += moveY / scaleY;
            movedY = (cur.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur.scrollLeft;
            cur.scrollLeft += moveX / scaleX;
            movedX = (cur.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x2 = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y = "nearest";
        }
      }
      if (top2)
        break;
      cur = cur.assignedSlot || cur.parentNode;
    } else if (cur.nodeType == 11) {
      cur = cur.host;
    } else {
      break;
    }
  }
}
function scrollableParents(dom) {
  let doc2 = dom.ownerDocument, x2, y;
  for (let cur = dom.parentNode; cur; ) {
    if (cur == doc2.body || x2 && y) {
      break;
    } else if (cur.nodeType == 1) {
      if (!y && cur.scrollHeight > cur.clientHeight)
        y = cur;
      if (!x2 && cur.scrollWidth > cur.clientWidth)
        x2 = cur;
      cur = cur.assignedSlot || cur.parentNode;
    } else if (cur.nodeType == 11) {
      cur = cur.host;
    } else {
      break;
    }
  }
  return { x: x2, y };
}
class DOMSelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range2) {
    let { anchorNode, focusNode } = range2;
    this.set(anchorNode, Math.min(range2.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range2.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur = dom; cur; cur = cur.parentNode) {
    stack.push(cur, cur.scrollTop, cur.scrollLeft);
    if (cur == cur.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i2 = 0; i2 < stack.length; ) {
      let elt = stack[i2++], top2 = stack[i2++], left = stack[i2++];
      if (elt.scrollTop != top2)
        elt.scrollTop = top2;
      if (elt.scrollLeft != left)
        elt.scrollLeft = left;
    }
  }
}
let scratchRange;
function textRange(node2, from2, to = from2) {
  let range2 = scratchRange || (scratchRange = document.createRange());
  range2.setEnd(node2, to);
  range2.setStart(node2, from2);
  return range2;
}
function dispatchKey(elt, name2, code2, mods) {
  let options = { key: name2, code: name2, keyCode: code2, which: code2, cancelable: true };
  if (mods)
    ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node2) {
  while (node2) {
    if (node2 && (node2.nodeType == 9 || node2.nodeType == 11 && node2.host))
      return node2;
    node2 = node2.assignedSlot || node2.parentNode;
  }
  return null;
}
function clearAttributes(node2) {
  while (node2.attributes.length)
    node2.removeAttributeNode(node2.attributes[0]);
}
function atElementStart(doc2, selection) {
  let node2 = selection.focusNode, offset = selection.focusOffset;
  if (!node2 || selection.anchorNode != node2 || selection.anchorOffset != offset)
    return false;
  offset = Math.min(offset, maxOffset(node2));
  for (; ; ) {
    if (offset) {
      if (node2.nodeType != 1)
        return false;
      let prev = node2.childNodes[offset - 1];
      if (prev.contentEditable == "false")
        offset--;
      else {
        node2 = prev;
        offset = maxOffset(node2);
      }
    } else if (node2 == doc2) {
      return true;
    } else {
      offset = domIndex(node2);
      node2 = node2.parentNode;
    }
  }
}
function isScrolledToBottom(elt) {
  return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
  for (let node2 = startNode, offset = startOffset; ; ) {
    if (node2.nodeType == 3 && offset > 0) {
      return { node: node2, offset };
    } else if (node2.nodeType == 1 && offset > 0) {
      if (node2.contentEditable == "false")
        return null;
      node2 = node2.childNodes[offset - 1];
      offset = maxOffset(node2);
    } else if (node2.parentNode && !isBlockElement(node2)) {
      offset = domIndex(node2);
      node2 = node2.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node2 = startNode, offset = startOffset; ; ) {
    if (node2.nodeType == 3 && offset < node2.nodeValue.length) {
      return { node: node2, offset };
    } else if (node2.nodeType == 1 && offset < node2.childNodes.length) {
      if (node2.contentEditable == "false")
        return null;
      node2 = node2.childNodes[offset];
      offset = 0;
    } else if (node2.parentNode && !isBlockElement(node2)) {
      offset = domIndex(node2) + 1;
      node2 = node2.parentNode;
    } else {
      return null;
    }
  }
}
class DOMPos {
  constructor(node2, offset, precise = true) {
    this.node = node2;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
}
const noChildren = [];
class ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  sync(view, track) {
    if (this.flags & 2) {
      let parent = this.dom;
      let prev = null, next;
      for (let child of this.children) {
        if (child.flags & 7) {
          if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
            let contentView = ContentView.get(next);
            if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
              child.reuseDOM(next);
          }
          child.sync(view, track);
          child.flags &= ~7;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (track && !track.written && track.node == parent && next != child.dom)
          track.written = true;
        if (child.dom.parentNode == parent) {
          while (next && next != child.dom)
            next = rm$1(next);
        } else {
          parent.insertBefore(child.dom, next);
        }
        prev = child.dom;
      }
      next = prev ? prev.nextSibling : parent.firstChild;
      if (next && track && track.node == parent)
        track.written = true;
      while (next)
        next = rm$1(next);
    } else if (this.flags & 1) {
      for (let child of this.children)
        if (child.flags & 7) {
          child.sync(view, track);
          child.flags &= ~7;
        }
    }
  }
  reuseDOM(_dom) {
  }
  localPosFromDOM(node2, offset) {
    let after;
    if (node2 == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node2) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node2.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node2 == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node2 = parent;
      }
      if (bias < 0)
        after = node2;
      else
        after = node2.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i2 = 0, pos = 0; ; i2++) {
      let child = this.children[i2];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from2, to, offset = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i2 = 0, pos = offset, prevEnd = offset; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (pos < from2 && end > to)
        return child.domBoundsAround(from2, to, pos);
      if (end >= from2 && fromI == -1) {
        fromI = i2;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i2;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    this.flags |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.flags |= 2;
      if (parent.flags & 1)
        return;
      parent.flags |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.flags & 7)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom == dom)
      return;
    if (this.dom)
      this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent = v.parent;
      if (!parent)
        return v;
      v = parent;
    }
  }
  replaceChildren(from2, to, children2 = noChildren) {
    this.markDirty();
    for (let i2 = from2; i2 < to; i2++) {
      let child = this.children[i2];
      if (child.parent == this && children2.indexOf(child) < 0)
        child.destroy();
    }
    if (children2.length < 250)
      this.children.splice(from2, to - from2, ...children2);
    else
      this.children = [].concat(this.children.slice(0, from2), children2, this.children.slice(to));
    for (let i2 = 0; i2 < children2.length; i2++)
      children2[i2].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node2) {
    return node2.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(from2, to, source, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let child of this.children)
      if (child.parent == this)
        child.destroy();
    this.parent = null;
  }
}
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class ChildCursor {
  constructor(children2, pos, i2) {
    this.children = children2;
    this.pos = pos;
    this.i = i2;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let { children: children2 } = parent;
  let before = children2.length ? children2[fromI] : null;
  let last2 = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last2 ? last2.breakAfter : breakAtStart;
  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last2 : null, fromOff == 0, openStart, openEnd))
    return;
  if (toI < children2.length) {
    let after = children2[toI];
    if (after && (toOff < after.length || after.breakAfter && (last2 === null || last2 === void 0 ? void 0 : last2.breakAfter))) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last2 && after.merge(0, toOff, last2, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after;
      } else {
        if (toOff || after.children.length && !after.children[0].length)
          after.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last2)
        last2.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
  }
  if (before) {
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
        before.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children2[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children2[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children2.length && !children2[fromI - 1].breakAfter && children2[toI].merge(0, 0, children2[fromI - 1], false, openStart, openEnd))
    fromI--;
  if (fromI < toI || insert2.length)
    parent.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent, from2, to, insert2, openStart, openEnd) {
  let cur = parent.childCursor();
  let { i: toI, off: toOff } = cur.findPos(to, 1);
  let { i: fromI, off: fromOff } = cur.findPos(from2, -1);
  let dLen = from2 - to;
  for (let view of insert2)
    dLen += view.length;
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
const ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
const ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
  windows: /* @__PURE__ */ /Win/.test(nav.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
  ie,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const MaxJoinLen = 256;
class TextView extends ContentView {
  constructor(text2) {
    super();
    this.text = text2;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(view, track) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3)
      this.createDOM(dom);
  }
  merge(from2, to, source) {
    if (this.flags & 8 || source && (!(source instanceof TextView) || this.length - (to - from2) + source.length > MaxJoinLen || source.flags & 8))
      return false;
    this.text = this.text.slice(0, from2) + (source ? source.text : "") + this.text.slice(to);
    this.markDirty();
    return true;
  }
  split(from2) {
    let result2 = new TextView(this.text.slice(from2));
    this.text = this.text.slice(0, from2);
    this.markDirty();
    result2.flags |= this.flags & 8;
    return result2;
  }
  localPosFromDOM(node2, offset) {
    return node2 == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
}
class MarkView extends ContentView {
  constructor(mark, children2 = [], length2 = 0) {
    super();
    this.mark = mark;
    this.children = children2;
    this.length = length2;
    for (let ch of children2)
      ch.setParent(this);
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs)
        dom.setAttribute(name2, this.mark.attrs[name2]);
    return dom;
  }
  canReuseDOM(other) {
    return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
  }
  reuseDOM(node2) {
    if (node2.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node2);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    if (!this.dom)
      this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
    else if (this.flags & 4)
      this.setAttrs(this.dom);
    super.sync(view, track);
  }
  merge(from2, to, source, _hasStart, openStart, openEnd) {
    if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from2 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    mergeChildrenInto(this, from2, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from2) {
    let result2 = [], off = 0, detachFrom = -1, i2 = 0;
    for (let elt of this.children) {
      let end = off + elt.length;
      if (end > from2)
        result2.push(off < from2 ? elt.split(from2 - off) : elt);
      if (detachFrom < 0 && off >= from2)
        detachFrom = i2;
      off = end;
      i2++;
    }
    let length2 = this.length - from2;
    this.length = from2;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new MarkView(this.mark, result2, length2);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
}
function textCoords(text2, pos, side) {
  let length2 = text2.nodeValue.length;
  if (pos > length2)
    pos = length2;
  let from2 = pos, to = pos, flatten2 = 0;
  if (pos == 0 && side < 0 || pos == length2 && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from2--;
        flatten2 = 1;
      } else if (to < length2) {
        to++;
        flatten2 = -1;
      }
    }
  } else {
    if (side < 0)
      from2--;
    else if (to < length2)
      to++;
  }
  let rects = textRange(text2, from2, to).getClientRects();
  if (!rects.length)
    return null;
  let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten2 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
  return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
}
class WidgetView extends ContentView {
  static create(widget, length2, side) {
    return new WidgetView(widget, length2, side);
  }
  constructor(widget, length2, side) {
    super();
    this.widget = widget;
    this.length = length2;
    this.side = side;
    this.prevWidget = null;
  }
  split(from2) {
    let result2 = WidgetView.create(this.widget, this.length - from2, this.side);
    this.length -= from2;
    return result2;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable)
        this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from2, to, source, hasStart, openStart, openEnd) {
    if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from2 > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from2 + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  become(other) {
    if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
      if (!this.widget.compare(other.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event2) {
    return this.widget.ignoreEvent(event2);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top2 = this;
    while (top2.parent)
      top2 = top2.parent;
    let { view } = top2, text2 = view && view.state.doc, start = this.posAtStart;
    return text2 ? text2.slice(start, start + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    let rects = this.dom.getClientRects(), rect = null;
    if (!rects.length)
      return null;
    let fromBack = this.side ? this.side < 0 : pos > 0;
    for (let i2 = fromBack ? rects.length - 1 : 0; ; i2 += fromBack ? -1 : 1) {
      rect = rects[i2];
      if (pos > 0 ? i2 == 0 : i2 == rects.length - 1 || rect.top < rect.bottom)
        break;
    }
    return flattenRect(rect, !fromBack);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
}
class WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof WidgetBufferView && other.side == this.side;
  }
  split() {
    return new WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      dom.setAttribute("aria-hidden", "true");
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Text.empty;
  }
  get isHidden() {
    return true;
  }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom, { children: children2 } = parent, i2 = 0;
  for (let off = 0; i2 < children2.length; i2++) {
    let child = children2[i2], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end;
  }
  for (let j = i2; j > 0; j--) {
    let prev = children2[j - 1];
    if (prev.dom.parentNode == dom)
      return prev.domAtPos(prev.length);
  }
  for (let j = i2; j < children2.length; j++) {
    let next = children2[j];
    if (next.dom.parentNode == dom)
      return next.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last2, { children: children2 } = parent;
  if (open > 0 && view instanceof MarkView && children2.length && (last2 = children2[children2.length - 1]) instanceof MarkView && last2.mark.eq(view.mark)) {
    joinInlineInto(last2, view.children[0], open - 1);
  } else {
    children2.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before = null, beforePos = -1, after = null, afterPos = -1;
  function scan(view2, pos2) {
    for (let i2 = 0, off = 0; i2 < view2.children.length && off <= pos2; i2++) {
      let child = view2.children[i2], end = off + child.length;
      if (end >= pos2) {
        if (child.children.length) {
          scan(child, pos2 - off);
        } else if ((!after || after.isHidden && side > 0) && (end > pos2 || off == end && child.getSide() > 0)) {
          after = child;
          afterPos = pos2 - off;
        } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
          before = child;
          beforePos = pos2 - off;
        }
      }
      off = end;
    }
  }
  scan(view, pos);
  let target2 = (side < 0 ? before : after) || before || after;
  if (target2)
    return target2.coordsAt(Math.max(0, target2 == before ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last2 = view.dom.lastChild;
  if (!last2)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last2);
  return rects[rects.length - 1] || null;
}
function combineAttrs(source, target2) {
  for (let name2 in source) {
    if (name2 == "class" && target2.class)
      target2.class += " " + source.class;
    else if (name2 == "style" && target2.style)
      target2.style += ";" + source.style;
    else
      target2[name2] = source[name2];
  }
  return target2;
}
const noAttrs = /* @__PURE__ */ Object.create(null);
function attrsEq(a, b, ignore2) {
  if (a == b)
    return true;
  if (!a)
    a = noAttrs;
  if (!b)
    b = noAttrs;
  let keysA = Object.keys(a), keysB = Object.keys(b);
  if (keysA.length - (ignore2 && keysA.indexOf(ignore2) > -1 ? 1 : 0) != keysB.length - (ignore2 && keysB.indexOf(ignore2) > -1 ? 1 : 0))
    return false;
  for (let key2 of keysA) {
    if (key2 != ignore2 && (keysB.indexOf(key2) == -1 || a[key2] !== b[key2]))
      return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs)) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = "";
        else
          dom.removeAttribute(name2);
      }
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2])) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = attrs[name2];
        else
          dom.setAttribute(name2, attrs[name2]);
      }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0; i2 < dom.attributes.length; i2++) {
    let attr2 = dom.attributes[i2];
    attrs[attr2.name] = attr2.value;
  }
  return attrs;
}
class WidgetType {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event2) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  @internal
  */
  get editable() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
}
var BlockType = /* @__PURE__ */ function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
class Decoration extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
    side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start, end } = getInclusive(spec, block);
      startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
}
Decoration.none = RangeSet.empty;
class MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec);
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    var _a, _b;
    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
  }
  range(from2, to = from2) {
    if (from2 >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from2, to);
  }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from2, to = from2) {
    if (to != from2)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from2, to);
  }
}
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from2, to = from2) {
    if (this.isReplace && (from2 > to || from2 == to && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from2)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from2, to);
  }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}
function addRange(from2, to, ranges, margin = 0) {
  let last2 = ranges.length - 1;
  if (last2 >= 0 && ranges[last2] + margin >= from2)
    ranges[last2] = Math.max(ranges[last2], to);
  else
    ranges.push(from2, to);
}
class LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  // Consumes source
  merge(from2, to, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof LineView))
        return false;
      if (!this.dom)
        source.transferDOM(this);
    }
    if (hasStart)
      this.setDeco(source ? source.attrs : null);
    mergeChildrenInto(this, from2, to, source ? source.children.slice() : [], openStart, openEnd);
    return true;
  }
  split(at) {
    let end = new LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end;
    let { i: i2, off } = this.childPos(at);
    if (off) {
      end.append(this.children[i2].split(off), 0);
      this.children[i2].merge(off, this.children[i2].length, null, false, 0, 0);
      i2++;
    }
    for (let j = i2; j < this.children.length; j++)
      end.append(this.children[j], 0);
    while (i2 > 0 && this.children[i2 - 1].length == 0)
      this.children[--i2].destroy();
    this.children.length = i2;
    this.markDirty();
    this.length = at;
    return end;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    this.markDirty();
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(deco) {
    let attrs = deco.spec.attributes, cls = deco.spec.class;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls)
      this.attrs = combineAttrs({ class: cls }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  reuseDOM(node2) {
    if (node2.nodeName == "DIV") {
      this.setDOM(node2);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    var _a;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    } else if (this.flags & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(view, track);
    let last2 = this.dom.lastChild;
    while (last2 && ContentView.get(last2) instanceof MarkView)
      last2 = last2.lastChild;
    if (!last2 || !this.length || last2.nodeName != "BR" && ((_a = ContentView.get(last2)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0, textHeight;
    for (let child of this.children) {
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
      textHeight = rects[0].height;
    }
    return !totalWidth ? null : {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length,
      textHeight
    };
  }
  coordsAt(pos, side) {
    let rect = coordsInChildren(this, pos, side);
    if (!this.children.length && rect && this.parent) {
      let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
      if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
        let dist2 = (height - heightOracle.textHeight) / 2;
        return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
      }
    }
    return rect;
  }
  become(other) {
    return other instanceof LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
  }
  covers() {
    return true;
  }
  static find(docView, pos) {
    for (let i2 = 0, off = 0; i2 < docView.children.length; i2++) {
      let block = docView.children[i2], end = off + block.length;
      if (end >= pos) {
        if (block instanceof LineView)
          return block;
        if (end > pos)
          break;
      }
      off = end + block.breakAfter;
    }
    return null;
  }
}
class BlockWidgetView extends ContentView {
  constructor(widget, length2, deco) {
    super();
    this.widget = widget;
    this.length = length2;
    this.deco = deco;
    this.breakAfter = 0;
    this.prevWidget = null;
  }
  merge(from2, to, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from2 > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from2 + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at) {
    let len = this.length - at;
    this.length = at;
    let end = new BlockWidgetView(this.widget, len, this.deco);
    end.breakAfter = this.breakAfter;
    return end;
  }
  get children() {
    return noChildren;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable)
        this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.compare(this.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      this.deco = other.deco;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event2) {
    return this.widget.ignoreEvent(event2);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    if (this.widget instanceof BlockGapWidget)
      return null;
    return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
  covers(side) {
    let { startSide, endSide } = this.deco;
    return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
  }
}
class BlockGapWidget extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    elt.className = "cm-gap";
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
}
class ContentBuilder {
  constructor(doc2, pos, end, disallowBlockEffectsFor) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.bufferMarks = [];
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last2 = this.content[this.content.length - 1];
    return !(last2.breakAfter || last2 instanceof BlockWidgetView && last2.deco.endSide < 0);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active = this.bufferMarks) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer();
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
      this.flushBuffer();
    else
      this.pendingBuffer = 0;
    if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
      this.getLine();
  }
  buildText(length2, active, openStart) {
    while (length2 > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.flushBuffer();
          this.curLine = null;
          this.atCursorPos = true;
          length2--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(
        this.text.length - this.textOff,
        length2,
        512
        /* T.Chunk */
      );
      this.flushBuffer(active.slice(active.length - openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.atCursorPos = true;
      this.textOff += take;
      length2 -= take;
      openStart = 0;
    }
  }
  span(from2, to, active, openStart) {
    this.buildText(to - from2, active, openStart);
    this.pos = to;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from2, to, deco, active, openStart, index) {
    if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
      if (deco.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (to > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let len = to - from2;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        if (deco.startSide > 0 && !this.posCovered())
          this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
      } else {
        let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from2 < to || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from2 < to || openStart > active.length || deco.startSide <= 0);
        let line = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
          this.pendingBuffer = 0;
        this.flushBuffer(active);
        if (cursorBefore) {
          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
          openStart = active.length + Math.max(0, openStart - active.length);
        }
        line.append(wrapMarks(view, active), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from2 < to || openStart > active.length ? 1 : 2;
        if (this.pendingBuffer)
          this.bufferMarks = active.slice();
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  static build(text2, from2, to, decorations2, dynamicDecorationMap) {
    let builder2 = new ContentBuilder(text2, from2, to, dynamicDecorationMap);
    builder2.openEnd = RangeSet.spans(decorations2, from2, to, builder2);
    if (builder2.openStart < 0)
      builder2.openStart = builder2.openEnd;
    builder2.finish(builder2.openEnd);
    return builder2;
  }
}
function wrapMarks(view, active) {
  for (let mark of active)
    view = new MarkView(mark, [view], view.length);
  return view;
}
class NullWidget extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
}
NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
NullWidget.block = /* @__PURE__ */ new NullWidget("div");
var Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
function dec(str) {
  let result2 = [];
  for (let i2 = 0; i2 < str.length; i2++)
    result2.push(1 << +str[i2]);
  return result2;
}
const LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
const ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /* @__PURE__ */ Object.create(null), BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
  Brackets[l] = r;
  Brackets[r] = -l;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class BidiSpan {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  constructor(from2, to, level) {
    this.from = from2;
    this.to = to;
    this.level = level;
  }
  /**
  @internal
  */
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(forward, dir) {
    return forward == (this.dir == dir);
  }
  /**
  @internal
  */
  static find(order, index, level, assoc) {
    let maybe = -1;
    for (let i2 = 0; i2 < order.length; i2++) {
      let span = order[i2];
      if (span.from <= index && span.to >= index) {
        if (span.level == level)
          return i2;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
          maybe = i2;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
}
function isolatesEq(a, b) {
  if (a.length != b.length)
    return false;
  for (let i2 = 0; i2 < a.length; i2++) {
    let iA = a[i2], iB = b[i2];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
      return false;
  }
  return true;
}
const types = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from2 = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i2 = from2, prev = prevType, prevStrong = prevType; i2 < to; i2++) {
      let type = charType(line.charCodeAt(i2));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i2] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i2 = from2, prev = prevType, prevStrong = prevType; i2 < to; i2++) {
      let type = types[i2];
      if (type == 128) {
        if (i2 < to - 1 && prev == types[i2 + 1] && prev & 24)
          type = types[i2] = prev;
        else
          types[i2] = 256;
      } else if (type == 64) {
        let end = i2 + 1;
        while (end < to && types[end] == 64)
          end++;
        let replace2 = i2 && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i2; j < end; j++)
          types[j] = replace2;
        i2 = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i2] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from2 = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i2 = from2, ch, br, type; i2 < to; i2++) {
      if (br = Brackets[ch = line.charCodeAt(i2)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i2] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i2;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i2]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur = BracketStack[sJ + 2];
          if (cur & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from2 = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i2 = from2; i2 < to; ) {
      let type = types[i2];
      if (type == 256) {
        let end = i2 + 1;
        for (; ; ) {
          if (end == to) {
            if (iI == isolates.length)
              break;
            end = isolates[iI++].to;
            to = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types[end] : outerType) == 1;
        let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i2; ) {
          if (j == fromJ) {
            j = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j] = replace2;
        }
        i2 = end;
      } else {
        prev = type;
        i2++;
      }
    }
  }
}
function emitSpans(line, from2, to, level, baseLevel, isolates, order) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from2, iI = 0; iCh < to; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum)
            break run;
          let iso = isolates[iI];
          if (!sameDir)
            for (let upto = iso.to, jI = iI + 1; ; ) {
              if (upto == to)
                break run;
              if (jI < isolates.length && isolates[jI].from == upto)
                upto = isolates[jI++].to;
              else if (types[upto] == ourType)
                break run;
              else
                break;
            }
          iI++;
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.from > iCh)
              order.push(new BidiSpan(iCh, iso.from, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.to;
          }
          iScan = iso.to;
        } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break;
        } else {
          iScan++;
        }
      }
      if (recurse)
        emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
      else if (iCh < iScan)
        order.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to, iI = isolates.length; iCh > from2; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum)
            break run;
          let iso = isolates[--iI];
          if (!sameDir)
            for (let upto = iso.from, jI = iI; ; ) {
              if (upto == from2)
                break run;
              if (jI && isolates[jI - 1].to == upto)
                upto = isolates[--jI].from;
              else if (types[upto - 1] == ourType)
                break run;
              else
                break;
            }
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.to < iCh)
              order.push(new BidiSpan(iso.to, iCh, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.from;
          }
          iScan = iso.from;
        } else if (iScan == from2 || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
          break;
        } else {
          iScan--;
        }
      }
      if (recurse)
        emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
      else if (iScan < iCh)
        order.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from2, to, order) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line, from2, to, isolates, outerType);
  processBracketPairs(line, from2, to, isolates, outerType);
  processNeutrals(from2, to, isolates, outerType);
  emitSpans(line, from2, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
  if (!line)
    return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line))
    return trivialOrder(line.length);
  if (isolates.length)
    while (line.length > types.length)
      types[types.length] = 256;
  let order = [], level = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level, level, isolates, 0, line.length, order);
  return order;
}
function trivialOrder(length2) {
  return [new BidiSpan(0, length2, 0)];
}
let movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a;
  let startIndex = start.head - line.from;
  let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
  let span = order[spanI], spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order.length)
      return null;
    span = order[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = findClusterBreak(line.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to)
    nextIndex = spanEnd;
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text2, from2, to) {
  for (let i2 = from2; i2 < to; i2++) {
    let type = charType(text2.charCodeAt(i2));
    if (type == 1)
      return LTR;
    if (type == 2 || type == 4)
      return RTL;
  }
  return LTR;
}
const clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
const dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
const mouseSelectionStyle = /* @__PURE__ */ Facet.define();
const exceptionSink = /* @__PURE__ */ Facet.define();
const updateListener = /* @__PURE__ */ Facet.define();
const inputHandler = /* @__PURE__ */ Facet.define();
const focusChangeEffect = /* @__PURE__ */ Facet.define();
const clipboardInputFilter = /* @__PURE__ */ Facet.define();
const clipboardOutputFilter = /* @__PURE__ */ Facet.define();
const perLineTextDirection = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x2) => x2)
});
const nativeSelectionHidden = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x2) => x2)
});
const scrollHandler = /* @__PURE__ */ Facet.define();
class ScrollTarget {
  constructor(range2, y = "nearest", x2 = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
    this.range = range2;
    this.y = y;
    this.x = x2;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
    this.isSnapshot = isSnapshot;
  }
  map(changes) {
    return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(state) {
    return this.range.to <= state.doc.length ? this : new ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t, ch) => t.map(ch) });
const setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
const editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
let nextPluginID = 0;
const viewPlugin = /* @__PURE__ */ Facet.define();
class ViewPlugin {
  constructor(id, create2, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id;
    this.create = create2;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.extension = buildExtensions(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create2, spec) {
    const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
    return new ViewPlugin(nextPluginID++, create2, eventHandlers, eventObservers, (plugin2) => {
      let ext = [viewPlugin.of(plugin2)];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin2);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide)
        ext.push(provide(plugin2));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return ViewPlugin.define((view) => new cls(view), spec);
  }
}
class PluginInstance {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.create(view);
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e) {
          logException(update.state, e, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a;
    if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const editorAttributes = /* @__PURE__ */ Facet.define();
const contentAttributes = /* @__PURE__ */ Facet.define();
const decorations = /* @__PURE__ */ Facet.define();
const outerDecorations = /* @__PURE__ */ Facet.define();
const atomicRanges = /* @__PURE__ */ Facet.define();
const bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length)
    return isolates;
  let sets = isolates.map((i2) => i2 instanceof Function ? i2(view) : i2);
  let result2 = [];
  RangeSet.spans(sets, line.from, line.to, {
    point() {
    },
    span(fromDoc, toDoc, active, open) {
      let from2 = fromDoc - line.from, to = toDoc - line.from;
      let level = result2;
      for (let i2 = active.length - 1; i2 >= 0; i2--, open--) {
        let direction = active[i2].spec.bidiIsolate, update;
        if (direction == null)
          direction = autoDirection(line.text, from2, to);
        if (open > 0 && level.length && (update = level[level.length - 1]).to == from2 && update.direction == direction) {
          update.to = to;
          level = update.inner;
        } else {
          let add = { from: from2, to, direction, inner: [] };
          level.push(add);
          level = add.inner;
        }
      }
    }
  });
  return result2;
}
const scrollMargins = /* @__PURE__ */ Facet.define();
function getScrollMargins(view) {
  let left = 0, right = 0, top2 = 0, bottom = 0;
  for (let source of view.state.facet(scrollMargins)) {
    let m2 = source(view);
    if (m2) {
      if (m2.left != null)
        left = Math.max(left, m2.left);
      if (m2.right != null)
        right = Math.max(right, m2.right);
      if (m2.top != null)
        top2 = Math.max(top2, m2.top);
      if (m2.bottom != null)
        bottom = Math.max(bottom, m2.bottom);
    }
  }
  return { left, right, top: top2, bottom };
}
const styleModule = /* @__PURE__ */ Facet.define();
class ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set2) {
    let i2 = set2.length, me = this;
    for (; i2 > 0; i2--) {
      let range2 = set2[i2 - 1];
      if (range2.fromA > me.toA)
        continue;
      if (range2.toA < me.fromA)
        break;
      me = me.join(range2);
      set2.splice(i2 - 1, 1);
    }
    set2.splice(i2, 0, me);
    return set2;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result2 = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff.length ? null : diff[dI], off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from2 = ranges[rI], to = ranges[rI + 1];
        let fromB = Math.max(posB, from2), toB = Math.min(end, to);
        if (fromB <= toB)
          new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result2);
        if (to > end)
          break;
        else
          rI += 2;
      }
      if (!next)
        return result2;
      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result2);
      posA = next.toA;
      posB = next.toB;
    }
  }
}
class ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (8 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class DocView extends ContentView {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(view) {
    super();
    this.view = view;
    this.decorations = [];
    this.dynamicDecorationMap = [false];
    this.domChanged = null;
    this.hasComposition = null;
    this.markedForComposition = /* @__PURE__ */ new Set();
    this.editContextFormatting = Decoration.none;
    this.lastCompositionAfterCursor = false;
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(update) {
    var _a;
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    this.updateEditContextFormatting(update);
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
      if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel)
        readCompositionAt = this.domChanged.newSel.head;
      else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
        readCompositionAt = update.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let { from: from2, to } = this.hasComposition;
      changedRanges = new ChangedRange(from2, to, update.changes.mapPos(from2, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
    if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (!(this.flags & 7) && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update.startState.doc.length, composition);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, oldLength, composition) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength, composition);
    let { observer } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, track);
      this.flags &= ~7;
      if (track && (track.written || observer.selectionRange.focusNode != track.node))
        this.forceSelection = true;
      this.dom.style.height = "";
    });
    this.markedForComposition.forEach(
      (cView) => cView.flags &= ~8
      /* ViewFlag.Composition */
    );
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children)
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateChildren(changes, oldLength, composition) {
    let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
    let cursor = this.childCursor(oldLength);
    for (let i2 = ranges.length - 1; ; i2--) {
      let next = i2 >= 0 ? ranges[i2] : null;
      if (!next)
        break;
      let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;
      if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
        let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
        let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
        breakAtStart = before.breakAtStart;
        openStart = before.openStart;
        openEnd = after.openEnd;
        let compLine = this.compositionView(composition);
        if (after.breakAtStart) {
          compLine.breakAfter = 1;
        } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
          compLine.breakAfter = after.content[0].breakAfter;
          after.content.shift();
        }
        if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
          before.content.pop();
        }
        content = before.content.concat(compLine).concat(after.content);
      } else {
        ({ content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
      }
      let { i: toI, off: toOff } = cursor.findPos(toA, 1);
      let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
    }
    if (composition)
      this.fixCompositionDOM(composition);
  }
  updateEditContextFormatting(update) {
    this.editContextFormatting = this.editContextFormatting.map(update.changes);
    for (let tr of update.transactions)
      for (let effect of tr.effects)
        if (effect.is(setEditContextFormatting)) {
          this.editContextFormatting = effect.value;
        }
  }
  compositionView(composition) {
    let cur = new TextView(composition.text.nodeValue);
    cur.flags |= 8;
    for (let { deco } of composition.marks)
      cur = new MarkView(deco, [cur], cur.length);
    let line = new LineView();
    line.append(cur, 0);
    return line;
  }
  fixCompositionDOM(composition) {
    let fix = (dom, cView2) => {
      cView2.flags |= 8 | (cView2.children.some(
        (c) => c.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0);
      this.markedForComposition.add(cView2);
      let prev = ContentView.get(dom);
      if (prev && prev != cView2)
        prev.dom = null;
      cView2.setDOM(dom);
    };
    let pos = this.childPos(composition.range.fromB, 1);
    let cView = this.children[pos.i];
    fix(composition.line, cView);
    for (let i2 = composition.marks.length - 1; i2 >= -1; i2--) {
      pos = cView.childPos(pos.off, 1);
      cView = cView.children[pos.i];
      fix(i2 >= 0 ? composition.marks[i2].node : composition.text, cView);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
    let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main;
    let anchor = this.moveToLine(this.domAtPos(main.anchor));
    let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel) ;
        else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text2 = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
              if (text2)
                anchor = new DOMPos(text2.node, text2.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
            rawSel.caretBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head.node, head.offset);
          } catch (_) {
          }
        } else {
          let range2 = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range2.setEnd(head.node, head.offset);
          range2.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range2);
        }
        if (selectionNotFocus && this.view.root.activeElement == this.dom) {
          this.dom.blur();
          if (activeElt)
            activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(sel, cursor) {
    return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view } = this, cursor = view.state.selection.main;
    let sel = getSelection(view.root);
    let { anchorNode, anchorOffset } = view.observer.selectionRange;
    if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
      return;
    let line = LineView.find(this, cursor.head);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor.head == lineStart || cursor.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor.head + cursor.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
      sel.collapse(anchorNode, anchorOffset);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(pos) {
    let dom = this.dom, newPos;
    if (pos.node != dom)
      return pos;
    for (let i2 = pos.offset; !newPos && i2 < dom.childNodes.length; i2++) {
      let view = ContentView.get(dom.childNodes[i2]);
      if (view instanceof LineView)
        newPos = view.domAtPos(0);
    }
    for (let i2 = pos.offset - 1; !newPos && i2 >= 0; i2--) {
      let view = ContentView.get(dom.childNodes[i2]);
      if (view instanceof LineView)
        newPos = view.domAtPos(view.length);
    }
    return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
  }
  nearest(dom) {
    for (let cur = dom; cur; ) {
      let domView = ContentView.get(cur);
      if (domView && domView.rootView == this)
        return domView;
      cur = cur.parentNode;
    }
    return null;
  }
  posFromDOM(node2, offset) {
    let view = this.nearest(node2);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node2, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let { i: i2, off } = this.childCursor().findPos(pos, -1);
    for (; i2 < this.children.length - 1; ) {
      let child = this.children[i2];
      if (off < child.length || child instanceof LineView)
        break;
      i2++;
      off = 0;
    }
    return this.children[i2].domAtPos(off);
  }
  coordsAt(pos, side) {
    let best = null, bestPos = 0;
    for (let off = this.length, i2 = this.children.length - 1; i2 >= 0; i2--) {
      let child = this.children[i2], end = off - child.breakAfter, start = end - child.length;
      if (end < pos)
        break;
      if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
        best = child;
        bestPos = start;
      } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
        if (child.deco.startSide < 0)
          break;
        else if (i2)
          best = null;
      }
      off = start;
    }
    return best ? best.coordsAt(pos - bestPos, side) : null;
  }
  coordsForChar(pos) {
    let { i: i2, off } = this.childPos(pos, 1), child = this.children[i2];
    if (!(child instanceof LineView))
      return null;
    while (child.children.length) {
      let { i: i3, off: childOff } = child.childPos(off, 1);
      for (; ; i3++) {
        if (i3 == child.children.length)
          return null;
        if ((child = child.children[i3]).length)
          break;
      }
      off = childOff;
    }
    if (!(child instanceof TextView))
      return null;
    let end = findClusterBreak(child.text, off);
    if (end == off)
      return null;
    let rects = textRange(child.dom, off, end).getClientRects();
    for (let i3 = 0; i3 < rects.length; i3++) {
      let rect = rects[i3];
      if (i3 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
        return rect;
    }
    return null;
  }
  measureVisibleLineHeights(viewport) {
    let result2 = [], { from: from2, to } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    for (let pos = 0, i2 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (end > to)
        break;
      if (pos >= from2) {
        let childRect = child.dom.getBoundingClientRect();
        result2.push(childRect.height);
        if (isWider) {
          let last2 = child.dom.lastChild;
          let rects = last2 ? clientRectsFor(last2) : [];
          if (rects.length) {
            let rect = rects[rects.length - 1];
            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
            if (width > widest) {
              widest = width;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end;
            }
          }
        }
      }
      pos = end + child.breakAfter;
    }
    return result2;
  }
  textDirectionAt(pos) {
    let { i: i2 } = this.childPos(pos, 1);
    return getComputedStyle(this.children[i2].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      textHeight = rect ? rect.height : lineHeight;
      dummy.remove();
    });
    return { lineHeight, charWidth, textHeight };
  }
  childCursor(pos = this.length) {
    let i2 = this.children.length;
    if (i2)
      pos -= this.children[--i2].length;
    return new ChildCursor(this.children, pos, i2);
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i2 = 0; ; i2++) {
      let next = i2 == vs.viewports.length ? null : vs.viewports[i2];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let i2 = 1;
    let allDeco = this.view.state.facet(decorations).map((d) => {
      let dynamic = this.dynamicDecorationMap[i2++] = typeof d == "function";
      return dynamic ? d(this.view) : d;
    });
    let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i3) => {
      let dynamic = typeof d == "function";
      if (dynamic)
        dynamicOuter = true;
      return dynamic ? d(this.view) : d;
    });
    if (outerDeco.length) {
      this.dynamicDecorationMap[i2++] = dynamicOuter;
      allDeco.push(RangeSet.join(outerDeco));
    }
    this.decorations = [
      this.editContextFormatting,
      ...allDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
    while (i2 < this.decorations.length)
      this.dynamicDecorationMap[i2++] = false;
    return this.decorations;
  }
  scrollIntoView(target2) {
    if (target2.isSnapshot) {
      let ref2 = this.view.viewState.lineBlockAt(target2.range.head);
      this.view.scrollDOM.scrollTop = ref2.top - target2.yMargin;
      this.view.scrollDOM.scrollLeft = target2.xMargin;
      return;
    }
    for (let handler of this.view.state.facet(scrollHandler)) {
      try {
        if (handler(this.view, target2.range, target2))
          return true;
      } catch (e) {
        logException(this.view.state, e, "scroll handler");
      }
    }
    let { range: range2 } = target2;
    let rect = this.coordsAt(range2.head, range2.empty ? range2.assoc : range2.head > range2.anchor ? -1 : 1), other;
    if (!rect)
      return;
    if (!range2.empty && (other = this.coordsAt(range2.anchor, range2.anchor > range2.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    let { offsetWidth, offsetHeight } = this.view.scrollDOM;
    scrollRectIntoView(this.view.scrollDOM, targetRect, range2.head < range2.anchor ? -1 : 1, target2.x, target2.y, Math.max(Math.min(target2.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target2.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
  }
}
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
  let textNode = textBefore || textAfter;
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let descAfter = ContentView.get(textAfter.node);
    if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
      textNode = textAfter;
    } else if (view.docView.lastCompositionAfterCursor) {
      let descBefore = ContentView.get(textBefore.node);
      if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
        textNode = textAfter;
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore;
  if (!textNode)
    return null;
  let from2 = headPos - textNode.offset;
  return { from: from2, to: from2 + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
  let found2 = findCompositionNode(view, headPos);
  if (!found2)
    return null;
  let { node: textNode, from: from2, to } = found2, text2 = textNode.nodeValue;
  if (/[\n\r]/.test(text2))
    return null;
  if (view.state.doc.sliceString(found2.from, found2.to) != text2)
    return null;
  let inv = changes.invertedDesc;
  let range2 = new ChangedRange(inv.mapPos(from2), inv.mapPos(to), from2, to);
  let marks = [];
  for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
    let parentView = ContentView.get(parent);
    if (parentView instanceof MarkView)
      marks.push({ node: parent, deco: parentView.mark });
    else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
      return { range: range2, text: textNode, marks, line: parent };
    else if (parent != view.contentDOM)
      marks.push({ node: parent, deco: new MarkDecoration({
        inclusive: true,
        attributes: getAttrs(parent),
        tagName: parent.tagName.toLowerCase()
      }) });
    else
      return null;
  }
}
function nextToUneditable(node2, offset) {
  if (node2.nodeType != 1)
    return 0;
  return (offset && node2.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node2.childNodes.length && node2.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
let DecorationComparator$1 = class DecorationComparator2 {
  constructor() {
    this.changes = [];
  }
  compareRange(from2, to) {
    addRange(from2, to, this.changes);
  }
  comparePoint(from2, to) {
    addRange(from2, to, this.changes);
  }
};
function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a, b, diff, comp);
  return comp.changes;
}
function inUneditable(node2, inside2) {
  for (let cur = node2; cur && cur != inside2; cur = cur.assignedSlot || cur.parentNode) {
    if (cur.nodeType == 1 && cur.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition)
    changes.iterChangedRanges((from2, to) => {
      if (from2 < composition.to && to > composition.from)
        touched = true;
    });
  return touched;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from2 = linePos, to = linePos;
  if (bias < 0)
    from2 = findClusterBreak(line.text, linePos, false);
  else
    to = findClusterBreak(line.text, linePos);
  let cat = categorize(line.text.slice(from2, to));
  while (from2 > 0) {
    let prev = findClusterBreak(line.text, from2, false);
    if (categorize(line.text.slice(prev, from2)) != cat)
      break;
    from2 = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from2 + line.from, to + line.from);
}
function getdx(x2, rect) {
  return rect.left > x2 ? rect.left - x2 : Math.max(0, x2 - rect.right);
}
function getdy(y, rect) {
  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
  return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top2) {
  return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x2, y) {
  let closest, closestRect, closestX, closestY, closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x2, rect), dy = getdy(y, rect);
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x2, y) : domPosAtCoords(child, x2, y);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
        let side = dy ? y < rect.top ? -1 : 1 : dx ? x2 < rect.left ? -1 : 1 : 0;
        closestOverlap = !side || (side > 0 ? i2 < rects.length - 1 : i2 > 0);
      }
      if (dx == 0) {
        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x2));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y);
  if (closestOverlap && closest.contentEditable != "false")
    return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x2 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset };
}
function domPosInText(node2, x2, y) {
  let len = node2.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i2 = 0; i2 < len; i2++) {
    let rects = textRange(node2, i2, i2 + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom)
        continue;
      if (!generalSide)
        generalSide = x2 - rect.left;
      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
      if (rect.left - 1 <= x2 && rect.right + 1 >= x2 && dy < closestDY) {
        let right = x2 >= (rect.left + rect.right) / 2, after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node2, i2).getBoundingClientRect();
          if (rectBefore.left == rect.right)
            after = !right;
        }
        if (dy <= 0)
          return { node: node2, offset: i2 + (after ? 1 : 0) };
        closestOffset = i2 + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return { node: node2, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node2.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
  var _a, _b;
  let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;
  let block, { docHeight } = view.viewState;
  let { x: x2, y } = coords, yOffset = y - docTop;
  if (yOffset < 0)
    return 0;
  if (yOffset > docHeight)
    return view.state.doc.length;
  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
    block = view.elementAtHeight(yOffset);
    if (block.type == BlockType.Text)
      break;
    for (; ; ) {
      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight)
        break;
      if (bounced)
        return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y = docTop + yOffset;
  let lineStart = block.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x2, y);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x2, y);
  let doc2 = view.dom.ownerDocument;
  let root2 = view.root.elementFromPoint ? view.root : doc2;
  let element = root2.elementFromPoint(x2, y);
  if (element && !view.contentDOM.contains(element))
    element = null;
  if (!element) {
    x2 = Math.max(content.left + 1, Math.min(content.right - 1, x2));
    element = root2.elementFromPoint(x2, y);
    if (element && !view.contentDOM.contains(element))
      element = null;
  }
  let node2, offset = -1;
  if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x2, y);
      if (pos)
        ({ offsetNode: node2, offset } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range2 = doc2.caretRangeFromPoint(x2, y);
      if (range2) {
        ({ startContainer: node2, startOffset: offset } = range2);
        if (!view.contentDOM.contains(node2) || browser.safari && isSuspiciousSafariCaretResult(node2, offset, x2) || browser.chrome && isSuspiciousChromeCaretResult(node2, offset, x2))
          node2 = void 0;
      }
    }
    if (node2)
      offset = Math.min(maxOffset(node2), offset);
  }
  if (!node2 || !view.docView.dom.contains(node2)) {
    let line = LineView.find(view.docView, lineStart);
    if (!line)
      return yOffset > block.top + block.height / 2 ? block.to : block.from;
    ({ node: node2, offset } = domPosAtCoords(line.dom, x2, y));
  }
  let nearest = view.docView.nearest(node2);
  if (!nearest)
    return null;
  if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
    let rect = nearest.dom.getBoundingClientRect();
    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
  } else {
    return nearest.localPosFromDOM(node2, offset) + nearest.posAtStart;
  }
}
function posAtCoordsImprecise(view, contentRect, block, x2, y) {
  let into = Math.round((x2 - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node2, offset, x2) {
  let len;
  if (node2.nodeType != 3 || offset != (len = node2.nodeValue.length))
    return false;
  for (let next = node2.nextSibling; next; next = next.nextSibling)
    if (next.nodeType != 1 || next.nodeName != "BR")
      return false;
  return textRange(node2, len - 1, len).getBoundingClientRect().left > x2;
}
function isSuspiciousChromeCaretResult(node2, offset, x2) {
  if (offset != 0)
    return false;
  for (let cur = node2; ; ) {
    let parent = cur.parentNode;
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
      return false;
    if (parent.classList.contains("cm-line"))
      break;
    cur = parent;
  }
  let rect = node2.nodeType == 1 ? node2.getBoundingClientRect() : textRange(node2, 0, Math.max(node2.nodeValue.length, 1)).getBoundingClientRect();
  return x2 - rect.left > 5;
}
function blockAt(view, pos) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type))
    for (let l of line.type) {
      if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
        return l;
    }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = view.visualLineSide(line, !forward);
    }
    if (!check) {
      if (!by)
        return next;
      check = by(char);
    } else if (!check(char)) {
      return cur;
    }
    cur = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
      let charRect = view.docView.coordsForChar(pos);
      let assoc = !charRect || curY < charRect.top ? -1 : 1;
      return EditorSelection.cursor(pos, assoc, void 0, goal);
    }
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set2 of atoms) {
      set2.between(pos - 1, pos + 1, (from2, to, value) => {
        if (pos > from2 && pos < to) {
          let side = moved || bias || (pos - from2 < to - pos ? -1 : 1);
          pos = side < 0 ? from2 : to;
          moved = side;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
const LineBreakPlaceholder = "";
class DOMReader {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text2) {
    this.text += text2;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start)
      return this;
    let parent = start.parentNode;
    for (let cur = start; ; ) {
      this.findPointBefore(parent, cur);
      let oldLen = this.text.length;
      this.readNode(cur);
      let next = cur.nextSibling;
      if (next == end)
        break;
      let view = ContentView.get(cur), nextView = ContentView.get(next);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen)
        this.lineBreak();
      cur = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node2) {
    let text2 = node2.nodeValue;
    for (let point of this.points)
      if (point.node == node2)
        point.pos = this.text.length + Math.min(point.offset, text2.length);
    for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m2;
      if (this.lineSeparator) {
        nextBreak = text2.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m2 = re.exec(text2)) {
        nextBreak = m2.index;
        breakSize = m2[0].length;
      }
      this.append(text2.slice(off, nextBreak < 0 ? text2.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node2 && point.pos > this.text.length)
            point.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node2) {
    if (node2.cmIgnore)
      return;
    let view = ContentView.get(node2);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node2, fromView.length);
      for (let i2 = fromView.iter(); !i2.next().done; ) {
        if (i2.lineBreak)
          this.lineBreak();
        else
          this.append(i2.value);
      }
    } else if (node2.nodeType == 3) {
      this.readTextNode(node2);
    } else if (node2.nodeName == "BR") {
      if (node2.nextSibling)
        this.lineBreak();
    } else if (node2.nodeType == 1) {
      this.readRange(node2.firstChild, null);
    }
  }
  findPointBefore(node2, next) {
    for (let point of this.points)
      if (point.node == node2 && node2.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointInside(node2, length2) {
    for (let point of this.points)
      if (node2.nodeType == 3 ? point.node == node2 : node2.contains(point.node))
        point.pos = this.text.length + (isAtEnd(node2, point.node, point.offset) ? length2 : 0);
  }
}
function isAtEnd(parent, node2, offset) {
  for (; ; ) {
    if (!node2 || offset < maxOffset(node2))
      return false;
    if (node2 == parent)
      return true;
    offset = domIndex(node2) + 1;
    node2 = node2.parentNode;
  }
}
class DOMPoint {
  constructor(node2, offset) {
    this.node = node2;
    this.offset = offset;
    this.pos = -1;
  }
}
class DOMChange {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    this.domChanged = start > -1;
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      let vp = view.viewport;
      if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
        let from2 = Math.min(head, anchor), to = Math.max(head, anchor);
        let offFrom = vp.from - from2, offTo = vp.to - to;
        if ((offFrom == 0 || offFrom == 1 || from2 == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
          head = 0;
          anchor = view.state.doc.length;
        }
      }
      this.newSel = EditorSelection.single(anchor, head);
    }
  }
}
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let { from: from2, to } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser.android && domChange.text.length < to - from2) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from2, to, LineBreakPlaceholder), domChange.text, preferredPos - from2, preferredSide);
    if (diff) {
      if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from2 + diff.from,
        to: from2 + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey);
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView2 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView2 = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
    return true;
  } else {
    return false;
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
  if (browser.ios && view.inputState.flushIOSKey(change))
    return true;
  let sel = view.state.selection.main;
  if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
    return true;
  let text2 = change.insert.toString();
  if (view.inputState.composing >= 0)
    view.inputState.composing++;
  let defaultTr;
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
  if (!view.state.facet(inputHandler).some((h2) => h2(view, change.from, change.to, text2, defaultInsert)))
    view.dispatch(defaultInsert());
  return true;
}
function applyDefaultInsert(view, change, newSel) {
  let tr, startState = view.state, sel = startState.selection.main;
  if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = { from: composition.from, to: composition.to - dLen };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset = sel.to - change.to, size2 = sel.to - sel.from;
      tr = startState.changeByRange((range2) => {
        if (range2.from == sel.from && range2.to == sel.to)
          return { changes, range: mainSel || range2.map(changes) };
        let to = range2.to - offset, from2 = to - replaced.length;
        if (range2.to - range2.from != size2 || view.state.sliceDoc(from2, to) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        range2.to >= compositionRange.from && range2.from <= compositionRange.to)
          return { range: range2 };
        let rangeChanges = startState.changes({ from: from2, to, insert: change.insert }), selOff = range2.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range2.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from2 = 0;
  while (from2 < minLen && a.charCodeAt(from2) == b.charCodeAt(from2))
    from2++;
  if (from2 == minLen && a.length == b.length)
    return null;
  let toA = a.length, toB = b.length;
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from2 - Math.min(toA, toB));
    preferredPos -= toA + adjust - from2;
  }
  if (toA < from2 && a.length < b.length) {
    let move = preferredPos <= from2 && preferredPos >= toA ? from2 - preferredPos : 0;
    from2 -= move;
    toB = from2 + (toB - toA);
    toA = from2;
  } else if (toB < from2) {
    let move = preferredPos <= from2 && preferredPos >= toB ? from2 - preferredPos : 0;
    from2 -= move;
    toA = from2 + (toA - toB);
    toB = from2;
  }
  return { from: from2, toA, toB };
}
function selectionPoints(view) {
  let result2 = [];
  if (view.root.activeElement != view.contentDOM)
    return result2;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result2.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result2.push(new DOMPoint(focusNode, focusOffset));
  }
  return result2;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
class InputState {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = void 0;
    this.tabFocusMode = -1;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.mouseSelection = null;
    this.draggedContent = null;
    this.handleEvent = this.handleEvent.bind(this);
    this.notifiedFocused = view.hasFocus;
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
    if (browser.gecko)
      firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event2) {
    if (!eventBelongsToEditor(this.view, event2) || this.ignoreDuringComposition(event2))
      return;
    if (event2.type == "keydown" && this.keydown(event2))
      return;
    this.runHandlers(event2.type, event2);
  }
  runHandlers(type, event2) {
    let handlers2 = this.handlers[type];
    if (handlers2) {
      for (let observer of handlers2.observers)
        observer(this.view, event2);
      for (let handler of handlers2.handlers) {
        if (event2.defaultPrevented)
          break;
        if (handler(this.view, event2)) {
          event2.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
    for (let type in handlers2)
      if (type != "scroll") {
        let passive = !handlers2[type].handlers.length;
        let exists = prev[type];
        if (exists && passive != !exists.handlers.length) {
          dom.removeEventListener(type, this.handleEvent);
          exists = null;
        }
        if (!exists)
          dom.addEventListener(type, this.handleEvent, { passive });
      }
    for (let type in prev)
      if (type != "scroll" && !handlers2[type])
        dom.removeEventListener(type, this.handleEvent);
    this.handlers = handlers2;
  }
  keydown(event2) {
    this.lastKeyCode = event2.keyCode;
    this.lastKeyTime = Date.now();
    if (event2.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return true;
    if (this.tabFocusMode > 0 && event2.keyCode != 27 && modifierCodes.indexOf(event2.keyCode) < 0)
      this.tabFocusMode = -1;
    if (browser.android && browser.chrome && !event2.synthetic && (event2.keyCode == 13 || event2.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event2.key, event2.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event2.synthetic && !event2.altKey && !event2.metaKey && ((pending = PendingKeys.find((key2) => key2.keyCode == event2.keyCode)) && !event2.ctrlKey || EmacsyPendingKeys.indexOf(event2.key) > -1 && event2.ctrlKey && !event2.shiftKey)) {
      this.pendingIOSKey = pending || event2;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event2.keyCode != 229)
      this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey(change) {
    let key2 = this.pendingIOSKey;
    if (!key2)
      return false;
    if (key2.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(this.view.contentDOM, key2.key, key2.keyCode, key2 instanceof KeyboardEvent ? key2 : void 0);
  }
  ignoreDuringComposition(event2) {
    if (!/^key/.test(event2.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    this.view.observer.update(update);
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (this.draggedContent && update.docChanged)
      this.draggedContent = this.draggedContent.map(update.changes);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
}
function bindHandler(plugin2, handler) {
  return (view, event2) => {
    try {
      return handler.call(plugin2, event2, view);
    } catch (e) {
      logException(view.state, e);
    }
  };
}
function computeHandlers(plugins) {
  let result2 = /* @__PURE__ */ Object.create(null);
  function record(type) {
    return result2[type] || (result2[type] = { observers: [], handlers: [] });
  }
  for (let plugin2 of plugins) {
    let spec = plugin2.spec;
    if (spec && spec.domEventHandlers)
      for (let type in spec.domEventHandlers) {
        let f = spec.domEventHandlers[type];
        if (f)
          record(type).handlers.push(bindHandler(plugin2.value, f));
      }
    if (spec && spec.domEventObservers)
      for (let type in spec.domEventObservers) {
        let f = spec.domEventObservers[type];
        if (f)
          record(type).observers.push(bindHandler(plugin2.value, f));
      }
  }
  for (let type in handlers)
    record(type).handlers.push(handlers[type]);
  for (let type in observers)
    record(type).observers.push(observers[type]);
  return result2;
}
const PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
const dragScrollMargin = 6;
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a, b) {
  return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
class MouseSelection {
  constructor(view, startEvent, style2, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style2;
    this.mustSelect = mustSelect;
    this.scrollSpeed = { x: 0, y: 0 };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParents = scrollableParents(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event2) {
    if (this.dragging === false)
      this.select(event2);
  }
  move(event2) {
    if (event2.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event2) < 10)
      return;
    this.select(this.lastEvent = event2);
    let sx = 0, sy = 0;
    let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
    if (this.scrollParents.x)
      ({ left, right } = this.scrollParents.x.getBoundingClientRect());
    if (this.scrollParents.y)
      ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
    let margins = getScrollMargins(this.view);
    if (event2.clientX - margins.left <= left + dragScrollMargin)
      sx = -dragScrollSpeed(left - event2.clientX);
    else if (event2.clientX + margins.right >= right - dragScrollMargin)
      sx = dragScrollSpeed(event2.clientX - right);
    if (event2.clientY - margins.top <= top2 + dragScrollMargin)
      sy = -dragScrollSpeed(top2 - event2.clientY);
    else if (event2.clientY + margins.bottom >= bottom - dragScrollMargin)
      sy = dragScrollSpeed(event2.clientY - bottom);
    this.setScrollSpeed(sx, sy);
  }
  up(event2) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event2.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = { x: sx, y: sy };
    if (sx || sy) {
      if (this.scrolling < 0)
        this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    let { x: x2, y } = this.scrollSpeed;
    if (x2 && this.scrollParents.x) {
      this.scrollParents.x.scrollLeft += x2;
      x2 = 0;
    }
    if (y && this.scrollParents.y) {
      this.scrollParents.y.scrollTop += y;
      y = 0;
    }
    if (x2 || y)
      this.view.win.scrollBy(x2, y);
    if (this.dragging === false)
      this.select(this.lastEvent);
  }
  skipAtoms(sel) {
    let ranges = null;
    for (let i2 = 0; i2 < sel.ranges.length; i2++) {
      let range2 = sel.ranges[i2], updated = null;
      if (range2.empty) {
        let pos = skipAtomicRanges(this.atoms, range2.from, 0);
        if (pos != range2.from)
          updated = EditorSelection.cursor(pos, -1);
      } else {
        let from2 = skipAtomicRanges(this.atoms, range2.from, -1);
        let to = skipAtomicRanges(this.atoms, range2.to, 1);
        if (from2 != range2.from || to != range2.to)
          updated = EditorSelection.range(range2.from == range2.anchor ? from2 : to, range2.from == range2.head ? from2 : to);
      }
      if (updated) {
        if (!ranges)
          ranges = sel.ranges.slice();
        ranges[i2] = updated;
      }
    }
    return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
  }
  select(event2) {
    let { view } = this, selection = this.skipAtoms(this.style.get(event2, this.extend, this.multiple));
    if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false))
      this.view.dispatch({
        selection,
        userEvent: "select.pointer"
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.transactions.some((tr) => tr.isUserEvent("input.type")))
      this.destroy();
    else if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function addsSelectionRange(view, event2) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event2) : browser.mac ? event2.metaKey : event2.ctrlKey;
}
function dragMovesSelection(view, event2) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event2) : browser.mac ? !event2.altKey : !event2.ctrlKey;
}
function isInPrimarySelection(view, event2) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i2 = 0; i2 < rects.length; i2++) {
    let rect = rects[i2];
    if (rect.left <= event2.clientX && rect.right >= event2.clientX && rect.top <= event2.clientY && rect.bottom >= event2.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event2) {
  if (!event2.bubbles)
    return true;
  if (event2.defaultPrevented)
    return false;
  for (let node2 = event2.target, cView; node2 != view.contentDOM; node2 = node2.parentNode)
    if (!node2 || node2.nodeType == 11 || (cView = ContentView.get(node2)) && cView.ignoreEvent(event2))
      return false;
  return true;
}
const handlers = /* @__PURE__ */ Object.create(null);
const observers = /* @__PURE__ */ Object.create(null);
const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target2 = parent.appendChild(document.createElement("textarea"));
  target2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target2.focus();
  setTimeout(() => {
    view.focus();
    target2.remove();
    doPaste(view, target2.value);
  }, 50);
}
function textFilter(state, facet, text2) {
  for (let filter2 of state.facet(facet))
    text2 = filter2(text2, state);
  return text2;
}
function doPaste(view, input2) {
  input2 = textFilter(view.state, clipboardInputFilter, input2);
  let { state } = view, changes, i2 = 1, text2 = state.toText(input2);
  let byLine = text2.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text2.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range2) => {
      let line = state.doc.lineAt(range2.from);
      if (line.from == lastLine)
        return { range: range2 };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text2.line(i2++).text : input2) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range2.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range2) => {
      let line = text2.line(i2++);
      return {
        changes: { from: range2.from, to: range2.to, insert: line.text },
        range: EditorSelection.cursor(range2.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text2);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event2) => {
  view.inputState.setSelectionOrigin("select");
  if (event2.keyCode == 27 && view.inputState.tabFocusMode != 0)
    view.inputState.tabFocusMode = Date.now() + 2e3;
  return false;
};
observers.touchstart = (view, e) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event2) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let style2 = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style2 = makeStyle(view, event2);
    if (style2)
      break;
  }
  if (!style2 && event2.button == 0)
    style2 = basicMouseSelection(view, event2);
  if (style2) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event2, style2, mustFocus));
    if (mustFocus)
      view.observer.ignore(() => {
        focusPreventScroll(view.contentDOM);
        let active = view.root.activeElement;
        if (active && !active.contains(view.contentDOM))
          active.blur();
      });
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event2);
      return mouseSel.dragging === false;
    }
  }
  return false;
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from2 = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from2, to);
  }
}
let inside = (x2, y, rect) => y >= rect.top && y <= rect.bottom && x2 >= rect.left && x2 <= rect.right;
function findPositionSide(view, pos, x2, y) {
  let line = LineView.find(view.docView, pos);
  if (!line)
    return 1;
  let off = pos - line.posAtStart;
  if (off == 0)
    return 1;
  if (off == line.length)
    return -1;
  let before = line.coordsAt(off, -1);
  if (before && inside(x2, y, before))
    return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x2, y, after))
    return 1;
  return before && before.bottom >= y ? -1 : 1;
}
function queryPos(view, event2) {
  let pos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event2.clientX, event2.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event2) {
  if (!BadMouseDetail)
    return event2.detail;
  let last2 = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event2;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last2 || lastTime > Date.now() - 400 && Math.abs(last2.clientX - event2.clientX) < 2 && Math.abs(last2.clientY - event2.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event2) {
  let start = queryPos(view, event2), type = getClickType(event2);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event3, extend2, multiple) {
      let cur = queryPos(view, event3), removed;
      let range2 = rangeForClick(view, cur.pos, cur.bias, type);
      if (start.pos != cur.pos && !extend2) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from2 = Math.min(startRange.from, range2.from), to = Math.max(startRange.to, range2.to);
        range2 = from2 < range2.from ? EditorSelection.range(from2, to) : EditorSelection.range(to, from2);
      }
      if (extend2)
        return startSel.replaceRange(startSel.main.extend(range2.from, range2.to));
      else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
        return removed;
      else if (multiple)
        return startSel.addRange(range2);
      else
        return EditorSelection.create([range2]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i2 = 0; i2 < sel.ranges.length; i2++) {
    let { from: from2, to } = sel.ranges[i2];
    if (from2 <= pos && to >= pos)
      return EditorSelection.create(sel.ranges.slice(0, i2).concat(sel.ranges.slice(i2 + 1)), sel.mainIndex == i2 ? 0 : sel.mainIndex - (sel.mainIndex > i2 ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event2) => {
  let { selection: { main: range2 } } = view.state;
  if (event2.target.draggable) {
    let cView = view.docView.nearest(event2.target);
    if (cView && cView.isWidget) {
      let from2 = cView.posAtStart, to = from2 + cView.length;
      if (from2 >= range2.to || to <= range2.from)
        range2 = EditorSelection.range(from2, to);
    }
  }
  let { inputState } = view;
  if (inputState.mouseSelection)
    inputState.mouseSelection.dragging = true;
  inputState.draggedContent = range2;
  if (event2.dataTransfer) {
    event2.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range2.from, range2.to)));
    event2.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
handlers.dragend = (view) => {
  view.inputState.draggedContent = null;
  return false;
};
function dropText(view, event2, text2, direct) {
  text2 = textFilter(view.state, clipboardInputFilter, text2);
  if (!text2)
    return;
  let dropPos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
  let { draggedContent } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event2) ? { from: draggedContent.from, to: draggedContent.to } : null;
  let ins = { from: dropPos, insert: text2 };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
handlers.drop = (view, event2) => {
  if (!event2.dataTransfer)
    return false;
  if (view.state.readOnly)
    return true;
  let files = event2.dataTransfer.files;
  if (files && files.length) {
    let text2 = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event2, text2.filter((s) => s != null).join(view.state.lineBreak), false);
    };
    for (let i2 = 0; i2 < files.length; i2++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text2[i2] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i2]);
    }
    return true;
  } else {
    let text2 = event2.dataTransfer.getData("Text");
    if (text2) {
      dropText(view, event2, text2, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event2) => {
  if (view.state.readOnly)
    return true;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event2.clipboardData;
  if (data) {
    doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text2) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target2 = parent.appendChild(document.createElement("textarea"));
  target2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target2.value = text2;
  target2.focus();
  target2.selectionEnd = text2.length;
  target2.selectionStart = 0;
  setTimeout(() => {
    target2.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content = [], ranges = [], linewise = false;
  for (let range2 of state.selection.ranges)
    if (!range2.empty) {
      content.push(state.sliceDoc(range2.from, range2.to));
      ranges.push(range2);
    }
  if (!content.length) {
    let upto = -1;
    for (let { from: from2 } of state.selection.ranges) {
      let line = state.doc.lineAt(from2);
      if (line.number > upto) {
        content.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: textFilter(state, clipboardOutputFilter, content.join(state.lineBreak)), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event2) => {
  let { text: text2, ranges, linewise } = copiedRange(view.state);
  if (!text2 && !linewise)
    return false;
  lastLinewiseCopy = linewise ? text2 : null;
  if (event2.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
  let data = brokenClipboardAPI ? null : event2.clipboardData;
  if (data) {
    data.clearData();
    data.setData("text/plain", text2);
    return true;
  } else {
    captureCopy(view, text2);
    return false;
  }
};
const isFocusChange = /* @__PURE__ */ Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus);
    if (effect)
      effects.push(effect);
  }
  return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr = focusChangeTransaction(view.state, focus);
      if (tr)
        view.dispatch(tr);
      else
        view.update([]);
    }
  }, 10);
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.observer.editContext)
    return;
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = (view) => {
  if (view.observer.editContext)
    return;
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition)
        view.update([]);
    }, 50);
  }
};
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event2) => {
  var _a, _b;
  if (event2.inputType == "insertReplacementText" && view.observer.editContext) {
    let text2 = (_a = event2.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData("text/plain"), ranges = event2.getTargetRanges();
    if (text2 && ranges.length) {
      let r = ranges[0];
      let from2 = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);
      applyDOMChangeInner(view, { from: from2, to, insert: view.state.toText(text2) }, null);
      return true;
    }
  }
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key2) => key2.inputType == event2.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
      setTimeout(() => {
        var _a2;
        if ((((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  if (browser.ios && event2.inputType == "deleteContentForward") {
    view.observer.flushSoon();
  }
  if (browser.safari && event2.inputType == "insertText" && view.inputState.composing >= 0) {
    setTimeout(() => observers.compositionend(view, event2), 20);
  }
  return false;
};
const appliedFirefoxHack = /* @__PURE__ */ new Set();
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let heightChangeFlag = false;
function clearHeightChangeFlag() {
  heightChangeFlag = false;
}
class HeightOracle {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
  }
  heightForGap(from2, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from2).number + 1;
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to - from2 - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length2) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length2 - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i2 = 0; i2 < lineHeights.length; i2++) {
      let h2 = lineHeights[i2];
      if (h2 < 0) {
        i2++;
      } else if (!this.heightSamples[Math.floor(h2 * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h2 * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i2 = 0; i2 < knownHeights.length; i2++) {
        let h2 = knownHeights[i2];
        if (h2 < 0)
          i2++;
        else
          this.heightSamples[Math.floor(h2 * 10)] = true;
      }
    }
    return changed;
  }
}
class MeasuredHeights {
  constructor(from2, heights) {
    this.from = from2;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class BlockInfo {
  /**
  @internal
  */
  constructor(from2, length2, top2, height, _content) {
    this.from = from2;
    this.length = length2;
    this.top = top2;
    this.height = height;
    this._content = _content;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(other) {
    let content = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);
  }
}
var QueryType = /* @__PURE__ */ function(QueryType2) {
  QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
  QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
  QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType2;
}(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
  constructor(length2, height, flags = 2) {
    this.length = length2;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        heightChangeFlag = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result2) {
    result2.push(this);
  }
  decomposeRight(_from, result2) {
    result2.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this, doc2 = oracle.doc;
    for (let i2 = changes.length - 1; i2 >= 0; i2--) {
      let { fromA, toA, fromB, toB } = changes[i2];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i2 > 0 && start.from <= changes[i2 - 1].toA) {
        fromA = changes[i2 - 1].fromA;
        fromB = changes[i2 - 1].fromB;
        i2--;
        if (fromA < start.from)
          start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me = replace(me, me.replace(fromA, toA, nodes));
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i2 = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i2 == j) {
        if (before > after * 2) {
          let split = nodes[i2 - 1];
          if (split.break)
            nodes.splice(--i2, 1, split.left, null, split.right);
          else
            nodes.splice(--i2, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i2++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i2 - 1] == null) {
      brk = 1;
      i2--;
    } else if (nodes[i2] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i2)), brk, HeightMap.of(nodes.slice(j)));
  }
}
function replace(old, val) {
  if (old == val)
    return old;
  if (old.constructor != val.constructor)
    heightChangeFlag = true;
  return val;
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
  constructor(length2, height, deco) {
    super(length2, height);
    this.deco = deco;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0);
  }
  lineAt(_value, _type, oracle, top2, offset) {
    return this.blockAt(0, oracle, top2, offset);
  }
  forEachLine(from2, to, oracle, top2, offset, f) {
    if (from2 <= offset + this.length && to >= offset)
      f(this.blockAt(0, oracle, top2, offset));
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class HeightMapText extends HeightMapBlock {
  constructor(length2, height) {
    super(length2, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node2 = nodes[0];
    if (nodes.length == 1 && (node2 instanceof HeightMapText || node2 instanceof HeightMapGap && node2.flags & 4) && Math.abs(this.length - node2.length) < 10) {
      if (node2 instanceof HeightMapGap)
        node2 = new HeightMapText(node2.length, this.height);
      else
        node2.height = this.height;
      if (!this.outdated)
        node2.outdated = false;
      return node2;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class HeightMapGap extends HeightMap {
  constructor(length2) {
    super(length2, 0);
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1)
        perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return { firstLine, lastLine, perLine, perChar };
  }
  blockAt(height, oracle, top2, offset) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    if (oracle.lineWrapping) {
      let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
      let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top2, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
      let { from: from2, length: length2 } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from2, length2, top2 + perLine * line, perLine, 0);
    }
  }
  lineAt(value, type, oracle, top2, offset) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, oracle, top2, offset);
    if (type == QueryType.ByPosNoHeight) {
      let { from: from2, to } = oracle.doc.lineAt(value);
      return new BlockInfo(from2, to - from2, 0, 0, 0);
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from2, to, oracle, top2, offset, f) {
    from2 = Math.max(from2, offset);
    to = Math.min(to, offset + this.length);
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    for (let pos = from2, lineTop = top2; pos <= to; ) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from2) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from2 - offset - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from2, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last2 = nodes[nodes.length - 1];
      if (last2 instanceof HeightMapGap)
        nodes[nodes.length - 1] = new HeightMapGap(last2.length + after);
      else
        nodes.push(null, new HeightMapGap(after - 1));
    }
    if (from2 > 0) {
      let first = nodes[0];
      if (first instanceof HeightMapGap)
        nodes[0] = new HeightMapGap(from2 + first.length);
      else
        nodes.unshift(new HeightMapGap(from2 - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result2) {
    result2.push(new HeightMapGap(to - 1), null);
  }
  decomposeRight(from2, result2) {
    result2.push(null, new HeightMapGap(this.length - from2 - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      if (measured.from > offset)
        nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++];
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line = new HeightMapText(len, height);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result2 = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result2.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
        heightChangeFlag = true;
      return replace(this, result2);
    } else if (force || this.outdated) {
      this.setHeight(oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class HeightMapBranch extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
  }
  forEachLine(from2, to, oracle, top2, offset, f) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from2 < rightOffset)
        this.left.forEachLine(from2, to, oracle, top2, offset, f);
      if (to >= rightOffset)
        this.right.forEachLine(from2, to, oracle, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
      if (from2 < mid.from)
        this.left.forEachLine(from2, mid.from - 1, oracle, top2, offset, f);
      if (mid.to >= from2 && mid.from <= to)
        f(mid);
      if (to > mid.to)
        this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
    }
  }
  replace(from2, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from2, to, nodes), this.right);
    if (from2 > this.left.length)
      return this.balanced(this.left, this.right.replace(from2 - rightStart, to - rightStart, nodes));
    let result2 = [];
    if (from2 > 0)
      this.decomposeLeft(from2, result2);
    let left = result2.length;
    for (let node2 of nodes)
      result2.push(node2);
    if (from2 > 0)
      mergeGaps(result2, left - 1);
    if (to < this.length) {
      let right = result2.length;
      this.decomposeRight(to, result2);
      mergeGaps(result2, right);
    }
    return HeightMap.of(result2);
  }
  decomposeLeft(to, result2) {
    let left = this.left.length;
    if (to <= left)
      return this.left.decomposeLeft(to, result2);
    result2.push(this.left);
    if (this.break) {
      left++;
      if (to >= left)
        result2.push(null);
    }
    if (to > left)
      this.right.decomposeLeft(to - left, result2);
  }
  decomposeRight(from2, result2) {
    let left = this.left.length, right = left + this.break;
    if (from2 >= right)
      return this.right.decomposeRight(from2 - right, result2);
    if (from2 < left)
      this.left.decomposeRight(from2, result2);
    if (this.break && from2 < right)
      result2.push(null);
    result2.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = replace(this.left, left);
    this.right = replace(this.right, right);
    this.setHeight(left.height + right.height);
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd), last2 = this.nodes[this.nodes.length - 1];
      if (last2 instanceof HeightMapText)
        last2.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from2, to, deco) {
    if (from2 < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to - from2;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to > from2) {
      this.span(from2, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: from2, to } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from2;
    this.lineEnd = to;
    if (this.writtenTo < from2) {
      if (this.writtenTo < from2 - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from2 - 1));
      this.nodes.push(null);
    }
    if (this.pos > from2)
      this.nodes.push(new HeightMapText(this.pos - from2, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from2, to) {
    let gap = new HeightMapGap(to - from2);
    if (this.oracle.doc.lineAt(from2).to == to)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last2 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last2 instanceof HeightMapText)
      return last2;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    let deco = block.deco;
    if (deco && deco.startSide > 0 && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (deco && deco.endSide > 0)
      this.covering = block;
  }
  addLineDeco(height, breaks, length2) {
    let line = this.ensureLine();
    line.length += length2;
    line.collapsed += length2;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    line.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length2;
  }
  finish(from2) {
    let last2 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last2 instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last2 == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from2;
    for (let node2 of this.nodes) {
      if (node2 instanceof HeightMapText)
        node2.updateHeight(this.oracle, pos);
      pos += node2 ? node2.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from2, to) {
    let builder2 = new NodeBuilder(from2, oracle);
    RangeSet.spans(decorations2, from2, to, builder2, 0);
    return builder2.finish(from2);
  }
}
function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator();
  RangeSet.compare(a, b, diff, comp, 0);
  return comp.changes;
}
class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from2, to, a, b) {
    if (from2 < to || a && a.heightRelevant || b && b.heightRelevant)
      addRange(from2, to, this.changes, 5);
  }
}
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt = parent;
      let style2 = window.getComputedStyle(elt);
      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style2.overflow != "visible") {
        let parentRect = elt.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
      }
      parent = style2.position == "absolute" || style2.position == "fixed" ? elt.offsetParent : elt.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
class LineGap {
  constructor(from2, to, size2, displaySize) {
    this.from = from2;
    this.to = to;
    this.size = size2;
    this.displaySize = displaySize;
  }
  static same(a, b) {
    if (a.length != b.length)
      return false;
    for (let i2 = 0; i2 < a.length; i2++) {
      let gA = a[i2], gB = b[i2];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
}
class LineGapWidget extends WidgetType {
  constructor(size2, vertical) {
    super();
    this.size = size2;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ViewState {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = false;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    for (let i2 = 0; i2 < 2; i2++) {
      this.viewport = this.getViewport(0, null);
      if (!this.updateForViewport())
        break;
    }
    this.updateViewportLines();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i2 = 0; i2 <= 1; i2++) {
      let pos = i2 ? main.head : main.anchor;
      if (!viewports.some(({ from: from2, to }) => pos >= from2 && pos <= to)) {
        let { from: from2, to } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from2, to));
      }
    }
    this.viewports = viewports.sort((a, b) => a.from - b.from);
    return this.updateScaler();
  }
  updateScaler() {
    let scaler = this.scaler;
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    return scaler.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
      this.viewportLines.push(scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    clearHeightChangeFlag();
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight || heightChangeFlag)
      update.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = this.heightMap.height;
    }
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    update.flags |= this.updateForViewport();
    if (viewportChange || !update.changes.empty || update.flags & 2)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges();
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style2 = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style2.whiteSpace;
    this.defaultTextDirection = style2.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result2 = 0, bias = 0;
    if (domRect.width && domRect.height) {
      let { scaleX, scaleY } = getScale(dom, domRect);
      if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result2 |= 8;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style2.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style2.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result2 |= 8 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result2 |= 8;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget)
      return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result2 |= 8;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result2 |= 8;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      clearHeightChangeFlag();
      for (let vp of this.viewports) {
        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
      }
      if (heightChangeFlag)
        result2 |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange) {
      if (result2 & 2)
        result2 |= this.updateScaler();
      this.viewport = this.getViewport(bias, this.scrollTarget);
      result2 |= this.updateForViewport();
    }
    if (result2 & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result2 |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result2;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map2 = this.heightMap, oracle = this.heightOracle;
    let { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map2.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map2.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let { head } = scrollTarget.range;
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map2.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
          topPos = block.top;
        else
          topPos = block.bottom - viewHeight;
        viewport = new Viewport(map2.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map2.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from2 = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from2, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: from2, to }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from2, QueryType.ByPos, this.heightOracle, 0, 0);
    let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from2 == 0 || top2 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from2, to, line, structure) => {
      if (to - from2 < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from2 && pos < to) {
          addGap(from2, pos - 10, line, structure);
          addGap(pos + 10, to, line, structure);
          return;
        }
      }
      let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from2) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
          if (lineStart > from2)
            to = lineStart;
        }
        let size2 = this.gapSize(line, from2, to, structure);
        let displaySize = wrapping || size2 < 2e6 ? size2 : 2e6;
        gap = new LineGap(from2, to, size2, displaySize);
      }
      gaps.push(gap);
    };
    let checkLine = (line) => {
      if (line.length < doubleMargin || line.type != BlockType.Text)
        return;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin)
        return;
      let target2 = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target2 != null) {
          let targetFrac = findFraction(structure, target2);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let horizOffset = 0;
        if (totalWidth > 2e6)
          for (let old of current) {
            if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
              horizOffset = old.size - old.displaySize;
          }
        let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
        let left, right;
        if (target2 != null) {
          let targetFrac = findFraction(structure, target2);
          let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (pxLeft - marginWidth) / totalWidth;
          right = (pxRight + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from)
        addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to)
        addGap(viewTo, line.to, line, structure);
    };
    for (let line of this.viewportLines) {
      if (Array.isArray(line.type))
        line.type.forEach(checkLine);
      else
        checkLine(line);
    }
    return gaps;
  }
  gapSize(line, from2, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from2);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges() {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from2, to) {
        ranges.push({ from: from2, to });
      },
      point() {
      }
    }, 20);
    let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i2) => r.from != ranges[i2].from || r.to != ranges[i2].to);
    this.visibleRanges = ranges;
    return changed ? 4 : 0;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l) => l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block = this.lineBlockAtHeight(scrollTop + 8);
    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Viewport {
  constructor(from2, to) {
    this.from = from2;
    this.to = to;
  }
}
function lineStructure(from2, to, stateDeco) {
  let ranges = [], pos = from2, total = 0;
  RangeSet.spans(stateDeco, from2, to, {
    span() {
    },
    point(from3, to2) {
      if (from3 > pos) {
        ranges.push({ from: pos, to: from3 });
        total += from3 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i2 = 0; ; i2++) {
    let { from: from2, to } = ranges[i2], size2 = to - from2;
    if (dist2 <= size2)
      return from2 + dist2;
    dist2 -= size2;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from: from2, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from2;
      break;
    }
    counted += to - from2;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
const IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(other) {
    return other == this;
  }
};
class BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from: from2, to }) => {
      let top2 = heightMap.lineAt(from2, QueryType.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top2;
      return { from: from2, to, top: top2, bottom, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n) {
    for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
      let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
      if (!vp || n < vp.top)
        return domBase + (n - base2) * this.scale;
      if (n <= vp.bottom)
        return vp.domTop + (n - vp.top);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n) {
    for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
      let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
      if (!vp || n < vp.domTop)
        return base2 + (n - domBase) / this.scale;
      if (n <= vp.domBottom)
        return vp.top + (n - vp.domTop);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  eq(other) {
    if (!(other instanceof BigScaler))
      return false;
    return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i2) => vp.from == other.viewports[i2].from && vp.to == other.viewports[i2].to);
  }
}
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
}
const theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
const darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
const baseThemeID = /* @__PURE__ */ StyleModule.newName(), baseLightID = /* @__PURE__ */ StyleModule.newName(), baseDarkID = /* @__PURE__ */ StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m2) => {
        if (m2 == "&")
          return main;
        if (!scopes || !scopes[m2])
          throw new RangeError(`Unsupported selector: ${m2}`);
        return scopes[m2];
      }) : main + " " + sel;
    }
  });
}
const baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
const observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.editContext = null;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.printQuery = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m2) => m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (window.EditContext && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(browser.chrome && browser.chrome_version < 126)) {
      this.editContext = new EditContextManager(view);
      if (view.state.facet(editable))
        view.contentDOM.editContext = this.editContext.editContext;
    }
    if (useCharData)
      this.onCharData = (event2) => {
        this.queue.push({
          target: event2.target,
          type: "characterData",
          oldValue: event2.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (window.matchMedia)
      this.printQuery = window.matchMedia("print");
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a;
        if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75)
          this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, { threshold: [0, 1e-3] });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e) {
    if (this.intersecting)
      this.flush(false);
    if (this.editContext)
      this.view.requestMeasure(this.editContext.measureReq);
    this.onScrollChanged(e);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint(event2) {
    if ((event2.type == "change" || !event2.type) && !event2.matches)
      return;
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i2) => g != gaps[i2]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event2) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event2)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let selection = getSelection(view.root);
    if (!selection)
      return false;
    let range2 = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection) || selection;
    if (!range2 || this.selectionRange.eq(range2))
      return false;
    let local = hasSelection(this.dom, range2);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range2)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range2);
    if (local)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i2 = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i2 < this.scrollTargets.length && this.scrollTargets[i2] == dom)
          i2++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i2);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i2 < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i2);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active)
      return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key2, keyCode) {
    var _a;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key3 = this.delayedAndroidKey;
        if (key3) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key3.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key3.force)
            dispatchKey(this.dom, key3.key, key3.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key2 == "Enter")
      this.delayedAndroidKey = {
        key: key2,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords())
      this.queue.push(mut);
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length)
      this.queue = [];
    let from2 = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range2 = this.readMutation(record);
      if (!range2)
        continue;
      if (range2.typeOver)
        typeOver = true;
      if (from2 == -1) {
        ({ from: from2, to } = range2);
      } else {
        from2 = Math.min(range2.from, from2);
        to = Math.max(range2.to, to);
      }
    }
    return { from: from2, to, typeOver };
  }
  readChange() {
    let { from: from2, to, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from2 < 0 && !newSel)
      return null;
    if (from2 > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from2, to, typeOver);
    this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
    return change;
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange) {
      this.view.requestMeasure();
      return false;
    }
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes")
      cView.flags |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.addEventListener)
        this.printQuery.addEventListener("change", this.onPrint);
      else
        this.printQuery.addListener(this.onPrint);
    } else
      win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.removeEventListener)
        this.printQuery.removeEventListener("change", this.onPrint);
      else
        this.printQuery.removeListener(this.onPrint);
    } else
      win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(update) {
    if (this.editContext) {
      this.editContext.update(update);
      if (update.startState.facet(editable) != update.state.facet(editable))
        update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
    }
  }
  destroy() {
    var _a, _b, _c;
    this.stop();
    (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    if (this.editContext) {
      this.view.contentDOM.editContext = null;
      this.editContext.destroy();
    }
  }
}
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function buildSelectionRangeFromRange(view, range2) {
  let anchorNode = range2.startContainer, anchorOffset = range2.startOffset;
  let focusNode = range2.endContainer, focusOffset = range2.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariSelectionRangeHack(view, selection) {
  if (selection.getComposedRanges) {
    let range2 = selection.getComposedRanges(view.root)[0];
    if (range2)
      return buildSelectionRangeFromRange(view, range2);
  }
  let found2 = null;
  function read(event2) {
    event2.preventDefault();
    event2.stopImmediatePropagation();
    found2 = event2.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  return found2 ? buildSelectionRangeFromRange(view, found2) : null;
}
class EditContextManager {
  constructor(view) {
    this.from = 0;
    this.to = 0;
    this.pendingContextChange = null;
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = null;
    this.resetRange(view.state);
    let context = this.editContext = new window.EditContext({
      text: view.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(view.state.selection.main.head)
    });
    this.handlers.textupdate = (e) => {
      let { anchor } = view.state.selection.main;
      let from2 = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);
      if (view.inputState.composing >= 0 && !this.composing)
        this.composing = { contextBase: e.updateRangeStart, editorBase: from2, drifted: false };
      let change = { from: from2, to, insert: Text.of(e.text.split("\n")) };
      if (change.from == this.from && anchor < this.from)
        change.from = anchor;
      else if (change.to == this.to && anchor > this.to)
        change.to = anchor;
      if (change.from == change.to && !change.insert.length)
        return;
      this.pendingContextChange = change;
      if (!view.state.readOnly)
        applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd)));
      if (this.pendingContextChange) {
        this.revertPending(view.state);
        this.setSelection(view.state);
      }
    };
    this.handlers.characterboundsupdate = (e) => {
      let rects = [], prev = null;
      for (let i2 = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i2 < end; i2++) {
        let rect = view.coordsForChar(i2);
        prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
        rects.push(prev);
      }
      context.updateCharacterBounds(e.rangeStart, rects);
    };
    this.handlers.textformatupdate = (e) => {
      let deco = [];
      for (let format2 of e.getTextFormats()) {
        let lineStyle = format2.underlineStyle, thickness = format2.underlineThickness;
        if (lineStyle != "None" && thickness != "None") {
          let style2 = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
          deco.push(Decoration.mark({ attributes: { style: style2 } }).range(this.toEditorPos(format2.rangeStart), this.toEditorPos(format2.rangeEnd)));
        }
      }
      view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
    };
    this.handlers.compositionstart = () => {
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
        view.inputState.compositionFirstChange = true;
      }
    };
    this.handlers.compositionend = () => {
      view.inputState.composing = -1;
      view.inputState.compositionFirstChange = null;
      if (this.composing) {
        let { drifted } = this.composing;
        this.composing = null;
        if (drifted)
          this.reset(view.state);
      }
    };
    for (let event2 in this.handlers)
      context.addEventListener(event2, this.handlers[event2]);
    this.measureReq = { read: (view2) => {
      this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
      let sel = getSelection(view2.root);
      if (sel && sel.rangeCount)
        this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(update) {
    let off = 0, abort = false, pending = this.pendingContextChange;
    update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
      if (abort)
        return;
      let dLen = insert2.length - (toA - fromA);
      if (pending && toA >= pending.to) {
        if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
          pending = this.pendingContextChange = null;
          off += dLen;
          this.to += dLen;
          return;
        } else {
          pending = null;
          this.revertPending(update.state);
        }
      }
      fromA += off;
      toA += off;
      if (toA <= this.from) {
        this.from += dLen;
        this.to += dLen;
      } else if (fromA < this.to) {
        if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
          abort = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
        this.to += dLen;
      }
      off += dLen;
    });
    if (pending && !abort)
      this.revertPending(update.state);
    return !abort;
  }
  update(update) {
    let reverted = this.pendingContextChange;
    if (this.composing && (this.composing.drifted || update.transactions.some((tr) => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
      this.composing.drifted = true;
      this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
    } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
      this.pendingContextChange = null;
      this.reset(update.state);
    } else if (update.docChanged || update.selectionSet || reverted) {
      this.setSelection(update.state);
    }
    if (update.geometryChanged || update.docChanged || update.selectionSet)
      update.view.requestMeasure(this.measureReq);
  }
  resetRange(state) {
    let { head } = state.selection.main;
    this.from = Math.max(
      0,
      head - 1e4
      /* CxVp.Margin */
    );
    this.to = Math.min(
      state.doc.length,
      head + 1e4
      /* CxVp.Margin */
    );
  }
  reset(state) {
    this.resetRange(state);
    this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
    this.setSelection(state);
  }
  revertPending(state) {
    let pending = this.pendingContextChange;
    this.pendingContextChange = null;
    this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
  }
  setSelection(state) {
    let { main } = state.selection;
    let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
    let end = this.toContextPos(main.head);
    if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
      this.editContext.updateSelection(start, end);
  }
  rangeIsValid(state) {
    let { head } = state.selection.main;
    return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(contextPos) {
    let c = this.composing;
    return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
  }
  toContextPos(editorPos) {
    let c = this.composing;
    return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
  }
  destroy() {
    for (let event2 in this.handlers)
      this.editContext.removeEventListener(event2, this.handlers[event2]);
  }
}
class EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config2 = {}) {
    var _a;
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.className = "cm-announced";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    if (config2.parent)
      config2.parent.appendChild(this.dom);
    let { dispatch } = config2;
    this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config2.root || getRoot(config2.parent) || document;
    this.viewState = new ViewState(config2.state || EditorState.create(config2));
    if (config2.scrollTo && config2.scrollTo.is(scrollIntoView))
      this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin2 of this.plugins)
      plugin2.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if ((_a = document.fonts) === null || _a === void 0 ? void 0 : _a.ready)
      document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...input2) {
    let trs = input2.length == 1 && input2[0] instanceof Transaction ? input2 : input2.length == 1 && Array.isArray(input2[0]) ? input2[0] : [this.state.update(...input2)];
    this.dispatchTransactions(trs, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr) => tr.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus)
        focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr.changes);
        if (tr.scrollIntoView) {
          let { main } = tr.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e of tr.effects)
          if (e.is(scrollIntoView))
            scrollTarget = e.value.clip(this.state);
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (redrawn)
      this.docViewUpdate();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener)) {
        try {
          listener(update);
        } catch (e) {
          logException(this.state, e, "update listener");
        }
      }
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState)
          this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin2 of this.plugins)
        plugin2.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin2 of this.plugins)
        plugin2.update(this);
      this.docView.destroy();
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found2 = prevSpecs.indexOf(spec);
        if (found2 < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin2 = this.plugins[found2];
          plugin2.mustUpdate = update;
          newPlugins.push(plugin2);
        }
      }
      for (let plugin2 of this.plugins)
        if (plugin2.mustUpdate != update)
          plugin2.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i2 = 0; i2 < this.plugins.length; i2++)
      this.plugins[i2].update(this);
    if (prevSpecs != specs)
      this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let plugin2 of this.plugins) {
      let val = plugin2.value;
      if (val && val.docViewUpdate) {
        try {
          val.docViewUpdate(this);
        } catch (e) {
          logException(this.state, e, "doc view update listener");
        }
      }
    }
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
    let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
      scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i2 = 0; ; i2++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block.from;
            scrollAnchorHeight = block.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i2 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m2) => {
          try {
            return m2.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
          if (redrawn)
            this.docViewUpdate();
        }
        for (let i3 = 0; i3 < measuring.length; i3++)
          if (measured[i3] != BadMeasure) {
            try {
              let m2 = measuring[i3];
              if (m2.write)
                m2.write(measured[i3], this);
            } catch (e) {
              logException(this.state, e);
            }
          }
        if (redrawn)
          this.docView.updateSelection(true);
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrollAnchorHeight = -1;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff = newAnchorHeight - scrollAnchorHeight;
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1)
        return;
      if (request.key != null)
        for (let i2 = 0; i2 < this.measureRequests.length; i2++) {
          if (this.measureRequests[i2].key === request.key) {
            this.measureRequests[i2] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin2) {
    let known = this.pluginMap.get(plugin2);
    if (known === void 0 || known && known.spec != plugin2)
      this.pluginMap.set(plugin2, known = this.plugins.find((p) => p.spec == plugin2) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(line, end) {
    let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
    let span = order[end ? order.length - 1 : 0];
    return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node2, offset = 0) {
    return this.docView.posFromDOM(node2, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from), isolates;
    for (let entry of this.bidiCache) {
      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
        return entry.order;
    }
    if (!isolates)
      isolates = getIsolatedRanges(this, line);
    let order = computeOrder(line.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
    return order;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root2) {
    if (this._root != root2) {
      this._root = root2;
      this.observer.setWindow((root2.nodeType == 9 ? root2 : root2.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    if (this.root.activeElement == this.contentDOM)
      this.contentDOM.blur();
    for (let plugin2 of this.plugins)
      plugin2.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.docView.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop, scrollLeft } = this.scrollDOM;
    let ref2 = this.viewState.scrollAnchorAt(scrollTop);
    return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref2.from), "start", "start", ref2.top - scrollTop, scrollLeft, true));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(to) {
    if (to == null)
      this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
    else if (typeof to == "boolean")
      this.inputState.tabFocusMode = to ? 0 : -1;
    else if (this.inputState.tabFocusMode != 0)
      this.inputState.tabFocusMode = Date.now() + to;
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result2 = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark)
      result2.push(darkTheme.of(true));
    return result2;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a;
    let content = dom.querySelector(".cm-content");
    let cView = content && ContentView.get(content) || ContentView.get(dom);
    return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
  }
}
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.clipboardInputFilter = clipboardInputFilter;
EditorView.clipboardOutputFilter = clipboardOutputFilter;
EditorView.scrollHandler = scrollHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : "" });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = /* @__PURE__ */ StateEffect.define();
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
  constructor(from2, to, dir, isolates, fresh, order) {
    this.from = from2;
    this.to = to;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order;
  }
  static update(cache2, changes) {
    if (changes.empty && !cache2.some((c) => c.fresh))
      return cache2;
    let result2 = [], lastDir = cache2.length ? cache2[cache2.length - 1].dir : Direction.LTR;
    for (let i2 = Math.max(0, cache2.length - 10); i2 < cache2.length; i2++) {
      let entry = cache2[i2];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result2.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result2;
  }
}
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i2 = sources.length - 1; i2 >= 0; i2--) {
    let source = sources[i2], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
const CanHidePrimary = !browser.ios;
const themeSpec = {
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
if (CanHidePrimary)
  themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
class GutterMarker extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
function isHTML(mime) {
  return mime === "text/html";
}
function getHTMLHeadings(html2, force = true) {
  var _a;
  const container2 = document.createElement("div");
  container2.innerHTML = html2;
  const headings = new Array();
  const headers = container2.querySelectorAll("h1, h2, h3, h4, h5, h6");
  for (const h2 of headers) {
    const level = parseInt(h2.tagName[1], 10);
    headings.push({
      text: (_a = h2.textContent) !== null && _a !== void 0 ? _a : "",
      level,
      id: h2 === null || h2 === void 0 ? void 0 : h2.getAttribute("id"),
      skip: h2.classList.contains("jp-toc-ignore") || h2.classList.contains("tocSkip")
    });
  }
  return headings;
}
async function getHeadingId(markdownParser, raw, level, sanitizer) {
  try {
    const host = document.createElement("div");
    await renderMarkdown({
      markdownParser,
      host,
      source: raw,
      trusted: false,
      sanitizer: sanitizer !== null && sanitizer !== void 0 ? sanitizer : new Sanitizer(),
      shouldTypeset: false,
      resolver: null,
      linkHandler: null,
      latexTypesetter: null
    });
    const header = host.querySelector(`h${level}`);
    if (!header) {
      return null;
    }
    return header.id;
  } catch (reason) {
    console.error("Failed to parse a heading.", reason);
  }
  return null;
}
function getHeadings(text2) {
  const lines = text2.split("\n");
  const headings = new Array();
  let isCodeBlock;
  let openingFence = 0;
  let fenceType;
  let lineIdx = 0;
  if (lines[lineIdx] === "---") {
    for (let frontmatterEndLineIdx = lineIdx + 1; frontmatterEndLineIdx < lines.length; frontmatterEndLineIdx++) {
      if (lines[frontmatterEndLineIdx] === "---") {
        lineIdx = frontmatterEndLineIdx + 1;
        break;
      }
    }
  }
  for (; lineIdx < lines.length; lineIdx++) {
    const line = lines[lineIdx];
    if (line === "") {
      continue;
    }
    if (line.startsWith("```") || line.startsWith("~~~")) {
      const closingFence = extractLeadingFences(line);
      if (closingFence === 0)
        continue;
      if (openingFence === 0) {
        fenceType = line.charAt(0);
        isCodeBlock = !isCodeBlock;
        openingFence = closingFence;
        continue;
      } else if (fenceType === line.charAt(0) && closingFence >= openingFence) {
        isCodeBlock = !isCodeBlock;
        openingFence = 0;
        fenceType = "";
      }
    }
    if (isCodeBlock) {
      continue;
    }
    const heading = parseHeading(line, lines[lineIdx + 1]);
    if (heading) {
      headings.push({
        ...heading,
        line: lineIdx
      });
    }
  }
  return headings;
}
function extractLeadingFences(line) {
  let match;
  if (line.startsWith("`"))
    match = line.match(/^(`{3,})/);
  else
    match = line.match(/^(~{3,})/);
  return match ? match[0].length : 0;
}
const MARKDOWN_MIME_TYPE = [
  "text/x-ipythongfm",
  "text/x-markdown",
  "text/x-gfm",
  "text/markdown"
];
function isMarkdown(mime) {
  return MARKDOWN_MIME_TYPE.includes(mime);
}
function parseHeading(line, nextLine) {
  let match = line.match(/^([#]{1,6}) (.*)/);
  if (match) {
    return {
      text: cleanTitle(match[2]),
      level: match[1].length,
      raw: line,
      skip: skipHeading.test(match[0])
    };
  }
  if (nextLine) {
    match = nextLine.match(/^ {0,3}([=]{2,}|[-]{2,})\s*$/);
    if (match) {
      return {
        text: cleanTitle(line),
        level: match[1][0] === "=" ? 1 : 2,
        raw: [line, nextLine].join("\n"),
        skip: skipHeading.test(line)
      };
    }
  }
  match = line.match(/<h([1-6]).*>(.*)<\/h\1>/i);
  if (match) {
    return {
      text: match[2],
      level: parseInt(match[1], 10),
      skip: skipHeading.test(match[0]),
      raw: line
    };
  }
  return null;
}
function cleanTitle(heading) {
  return heading.replace(/\[(.+)\]\(.+\)/g, "$1");
}
const skipHeading = /<\w+\s(.*?\s)?class="(.*?\s)?(jp-toc-ignore|tocSkip)(\s.*?)?"(\s.*?)?>/;
const RESIZE_HANDLE_CLASS = "jp-CellResizeHandle";
const CELL_RESIZED_CLASS = "jp-mod-resizedCell";
class ResizeHandle extends Widget {
  constructor(targetNode) {
    super();
    this.targetNode = targetNode;
    this._isActive = false;
    this._isDragging = false;
    this.sizeChanged = new Signal(this);
    this.addClass(RESIZE_HANDLE_CLASS);
    this._resizer = new Throttler((event2) => this._resize(event2), 50);
  }
  /**
   * Dispose the resizer handle.
   */
  dispose() {
    this._resizer.dispose();
    super.dispose();
  }
  /**
   * Handle the DOM events for the widget.
   *
   * @param event - The DOM event sent to the widget.
   *
   */
  handleEvent(event2) {
    var _a, _b;
    switch (event2.type) {
      case "dblclick":
        (_a = this.targetNode.parentNode) === null || _a === void 0 ? void 0 : _a.childNodes.forEach((node2) => {
          node2.classList.remove(CELL_RESIZED_CLASS);
        });
        document.documentElement.style.setProperty("--jp-side-by-side-output-size", `1fr`);
        this._isActive = false;
        break;
      case "mousedown":
        this._isDragging = true;
        if (!this._isActive) {
          (_b = this.targetNode.parentNode) === null || _b === void 0 ? void 0 : _b.childNodes.forEach((node2) => {
            node2.classList.add(CELL_RESIZED_CLASS);
          });
          this._isActive = true;
        }
        window.addEventListener("mousemove", this);
        window.addEventListener("mouseup", this);
        break;
      case "mousemove": {
        if (this._isActive && this._isDragging) {
          void this._resizer.invoke(event2);
        }
        break;
      }
      case "mouseup":
        this._isDragging = false;
        window.removeEventListener("mousemove", this);
        window.removeEventListener("mouseup", this);
        break;
    }
  }
  /**
   * Handle `after-attach` messages.
   */
  onAfterAttach(msg) {
    this.node.addEventListener("dblclick", this);
    this.node.addEventListener("mousedown", this);
    super.onAfterAttach(msg);
  }
  /**
   * Handle `before-detach` messages.
   */
  onBeforeDetach(msg) {
    this.node.removeEventListener("dblclick", this);
    this.node.removeEventListener("mousedown", this);
    super.onBeforeDetach(msg);
  }
  _resize(event2) {
    const { width, x: x2 } = this.targetNode.getBoundingClientRect();
    const position = event2.clientX - x2;
    const ratio = width / position - 1;
    if (0 < ratio) {
      const normalized = Math.max(Math.min(Math.abs(ratio), 50), 0.05);
      document.documentElement.style.setProperty("--jp-side-by-side-output-size", `${normalized}fr`);
      this.sizeChanged.emit(normalized);
    }
  }
}
const CELL_CLASS = "jp-Cell";
const CELL_HEADER_CLASS = "jp-Cell-header";
const CELL_FOOTER_CLASS = "jp-Cell-footer";
const CELL_INPUT_WRAPPER_CLASS = "jp-Cell-inputWrapper";
const CELL_OUTPUT_WRAPPER_CLASS = "jp-Cell-outputWrapper";
const CELL_INPUT_AREA_CLASS = "jp-Cell-inputArea";
const CELL_OUTPUT_AREA_CLASS = "jp-Cell-outputArea";
const CELL_INPUT_COLLAPSER_CLASS = "jp-Cell-inputCollapser";
const CELL_OUTPUT_COLLAPSER_CLASS = "jp-Cell-outputCollapser";
const DIRTY_CLASS$2 = "jp-mod-dirty";
const CODE_CELL_CLASS = "jp-CodeCell";
const MARKDOWN_CELL_CLASS = "jp-MarkdownCell";
const MARKDOWN_OUTPUT_CLASS = "jp-MarkdownOutput";
const MARKDOWN_HEADING_COLLAPSED = "jp-MarkdownHeadingCollapsed";
const HEADING_COLLAPSER_CLASS$1 = "jp-collapseHeadingButton";
const SHOW_HIDDEN_CELLS_CLASS = "jp-showHiddenCellsButton";
const RAW_CELL_CLASS = "jp-RawCell";
const RENDERED_CLASS = "jp-mod-rendered";
const NO_OUTPUTS_CLASS = "jp-mod-noOutputs";
const DEFAULT_MARKDOWN_TEXT = "Type Markdown and LaTeX: $ ^2 $";
const RENDER_TIMEOUT = 1e3;
const CONTENTS_MIME_RICH = "application/x-jupyter-icontentsrich";
class Cell extends Widget {
  /**
   * Construct a new base cell widget.
   */
  constructor(options) {
    var _a, _b, _c, _d;
    super();
    this.prompt = "";
    this._displayChanged = new Signal(this);
    this._scrollRequested = new Signal(this);
    this._scrollHandlerExtension = EditorView.scrollHandler.of((view, range2, options2) => {
      const inWindowedContainer = this._inViewport !== null;
      const preventDefault = inWindowedContainer && !this._inViewport;
      this._scrollRequested.emit({
        defaultPrevented: preventDefault,
        scrollWithinCell: () => {
          view.dispatch({
            effects: EditorView.scrollIntoView(range2, options2)
          });
        }
      });
      return preventDefault;
    });
    this._editorConfig = {};
    this._editorExtensions = [];
    this._inputHidden = false;
    this._inViewportChanged = new Signal(this);
    this._readOnly = false;
    this._ready = new PromiseDelegate();
    this._resizeDebouncer = new Debouncer(() => {
      this._displayChanged.emit();
    }, 0);
    this._syncCollapse = false;
    this._syncEditable = false;
    this.addClass(CELL_CLASS);
    const model = this._model = options.model;
    this.contentFactory = options.contentFactory;
    this.layout = (_a = options.layout) !== null && _a !== void 0 ? _a : new PanelLayout();
    this.translator = (_b = options.translator) !== null && _b !== void 0 ? _b : nullTranslator;
    this._editorConfig = { searchWithCM: false, ...options.editorConfig };
    this._editorExtensions = (_c = options.editorExtensions) !== null && _c !== void 0 ? _c : [];
    this._editorExtensions.push(this._scrollHandlerExtension);
    this._placeholder = true;
    this._inViewport = null;
    this.placeholder = (_d = options.placeholder) !== null && _d !== void 0 ? _d : true;
    model.metadataChanged.connect(this.onMetadataChanged, this);
  }
  /**
   * Initialize view state from model.
   *
   * #### Notes
   * Should be called after construction. For convenience, returns this, so it
   * can be chained in the construction, like `new Foo().initializeState();`
   */
  initializeState() {
    this.loadCollapseState();
    this.loadEditableState();
    return this;
  }
  /**
   * Signal to indicate that widget has changed visibly (in size, in type, etc)
   */
  get displayChanged() {
    return this._displayChanged;
  }
  /**
   * Whether the cell is in viewport or not.
   *
   * #### Notes
   * This property is managed by the windowed container which holds the cell.
   * When a cell is not in a windowed container, it always returns `false`,
   * but this may change in the future major version.
   */
  get inViewport() {
    var _a;
    return (_a = this._inViewport) !== null && _a !== void 0 ? _a : false;
  }
  set inViewport(v) {
    if (this._inViewport !== v) {
      this._inViewport = v;
      this._inViewportChanged.emit(this._inViewport);
    }
  }
  /**
   * Will emit true just after the node is attached to the DOM
   * Will emit false just before the node is detached of the DOM
   */
  get inViewportChanged() {
    return this._inViewportChanged;
  }
  /**
   * Whether the cell is a placeholder not yet fully rendered or not.
   */
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(v) {
    if (this._placeholder !== v && v === false) {
      this.initializeDOM();
      this._placeholder = v;
      this._ready.resolve();
    }
  }
  /**
   * Get the prompt node used by the cell.
   */
  get promptNode() {
    if (this.placeholder) {
      return null;
    }
    if (!this._inputHidden) {
      return this._input.promptNode;
    } else {
      return this._inputPlaceholder.node.firstElementChild;
    }
  }
  /**
   * Get the CodeEditorWrapper used by the cell.
   */
  get editorWidget() {
    var _a, _b;
    return (_b = (_a = this._input) === null || _a === void 0 ? void 0 : _a.editorWidget) !== null && _b !== void 0 ? _b : null;
  }
  /**
   * Get the CodeEditor used by the cell.
   */
  get editor() {
    var _a, _b;
    return (_b = (_a = this._input) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;
  }
  /**
   * Editor configuration
   */
  get editorConfig() {
    return this._editorConfig;
  }
  /**
   * Cell headings
   */
  get headings() {
    return new Array();
  }
  /**
   * Get the model used by the cell.
   */
  get model() {
    return this._model;
  }
  /**
   * Get the input area for the cell.
   */
  get inputArea() {
    return this._input;
  }
  /**
   * The read only state of the cell.
   */
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(value) {
    if (value === this._readOnly) {
      return;
    }
    this._readOnly = value;
    if (this.syncEditable) {
      this.saveEditableState();
    }
    this.update();
  }
  /**
   * Whether the cell is a placeholder that defer rendering
   *
   * #### Notes
   * You can wait for the promise `Cell.ready` to wait for the
   * cell to be rendered.
   */
  isPlaceholder() {
    return this.placeholder;
  }
  /**
   * Save view editable state to model
   */
  saveEditableState() {
    const { sharedModel } = this.model;
    const current = sharedModel.getMetadata("editable");
    if (this.readOnly && current === false || !this.readOnly && current === void 0) {
      return;
    }
    if (this.readOnly) {
      sharedModel.setMetadata("editable", false);
    } else {
      sharedModel.deleteMetadata("editable");
    }
  }
  /**
   * Load view editable state from model.
   */
  loadEditableState() {
    this.readOnly = this.model.sharedModel.getMetadata("editable") === false;
  }
  /**
   * A promise that resolves when the widget renders for the first time.
   */
  get ready() {
    return this._ready.promise;
  }
  /**
   * Set the prompt for the widget.
   * @deprecated - set the `executionState` on the model instead.
   */
  setPrompt(value) {
    return this._setPrompt(value);
  }
  /**
   * Set the prompt for the widget.
   *
   * Note: this method is protected because it is needed in the CodeCell subclass,
   * but it cannot be defined there because input is private to Cell class.
   */
  _setPrompt(value) {
    var _a;
    this.prompt = value;
    (_a = this._input) === null || _a === void 0 ? void 0 : _a.setPrompt(value);
  }
  /**
   * The view state of input being hidden.
   */
  get inputHidden() {
    return this._inputHidden;
  }
  set inputHidden(value) {
    var _a;
    if (this._inputHidden === value) {
      return;
    }
    if (!this.placeholder) {
      const layout = this._inputWrapper.layout;
      if (value) {
        this._input.parent = null;
        if (this._inputPlaceholder) {
          this._inputPlaceholder.text = (_a = this.model.sharedModel.getSource().split("\n")) === null || _a === void 0 ? void 0 : _a[0];
        }
        layout.addWidget(this._inputPlaceholder);
      } else {
        this._inputPlaceholder.parent = null;
        layout.addWidget(this._input);
      }
    }
    this._inputHidden = value;
    if (this.syncCollapse) {
      this.saveCollapseState();
    }
    this.handleInputHidden(value);
  }
  /**
   * Save view collapse state to model
   */
  saveCollapseState() {
    const jupyter = { ...this.model.getMetadata("jupyter") };
    if (this.inputHidden && jupyter.source_hidden === true || !this.inputHidden && jupyter.source_hidden === void 0) {
      return;
    }
    if (this.inputHidden) {
      jupyter.source_hidden = true;
    } else {
      delete jupyter.source_hidden;
    }
    if (Object.keys(jupyter).length === 0) {
      this.model.deleteMetadata("jupyter");
    } else {
      this.model.setMetadata("jupyter", jupyter);
    }
  }
  /**
   * Revert view collapse state from model.
   */
  loadCollapseState() {
    var _a;
    const jupyter = (_a = this.model.getMetadata("jupyter")) !== null && _a !== void 0 ? _a : {};
    this.inputHidden = !!jupyter.source_hidden;
  }
  /**
   * Handle the input being hidden.
   *
   * #### Notes
   * This is called by the `inputHidden` setter so that subclasses
   * can perform actions upon the input being hidden without accessing
   * private state.
   */
  handleInputHidden(value) {
    return;
  }
  /**
   * Whether to sync the collapse state to the cell model.
   */
  get syncCollapse() {
    return this._syncCollapse;
  }
  set syncCollapse(value) {
    if (this._syncCollapse === value) {
      return;
    }
    this._syncCollapse = value;
    if (value) {
      this.loadCollapseState();
    }
  }
  /**
   * Whether to sync the editable state to the cell model.
   */
  get syncEditable() {
    return this._syncEditable;
  }
  set syncEditable(value) {
    if (this._syncEditable === value) {
      return;
    }
    this._syncEditable = value;
    if (value) {
      this.loadEditableState();
    }
  }
  /**
   * Clone the cell, using the same model.
   */
  clone() {
    const constructor = this.constructor;
    return new constructor({
      model: this.model,
      contentFactory: this.contentFactory,
      placeholder: false,
      translator: this.translator
    });
  }
  /**
   * Dispose of the resources held by the widget.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._resizeDebouncer.dispose();
    this._input = null;
    this._model = null;
    this._inputWrapper = null;
    this._inputPlaceholder = null;
    super.dispose();
  }
  /**
   * Update the editor configuration with the partial provided dictionary.
   *
   * @param v Partial editor configuration
   */
  updateEditorConfig(v) {
    this._editorConfig = { ...this._editorConfig, ...v };
    if (this.editor) {
      this.editor.setOptions(this._editorConfig);
    }
  }
  /**
   * Signal emitted when cell requests scrolling to its element.
   */
  get scrollRequested() {
    return this._scrollRequested;
  }
  /**
   * Create children widgets.
   */
  initializeDOM() {
    if (!this.placeholder) {
      return;
    }
    const contentFactory = this.contentFactory;
    const model = this._model;
    const header = contentFactory.createCellHeader();
    header.addClass(CELL_HEADER_CLASS);
    this.layout.addWidget(header);
    const inputWrapper = this._inputWrapper = new Panel();
    inputWrapper.addClass(CELL_INPUT_WRAPPER_CLASS);
    const inputCollapser = new InputCollapser();
    inputCollapser.addClass(CELL_INPUT_COLLAPSER_CLASS);
    const input2 = this._input = new InputArea({
      model,
      contentFactory,
      editorOptions: this.getEditorOptions()
    });
    input2.addClass(CELL_INPUT_AREA_CLASS);
    inputWrapper.addWidget(inputCollapser);
    inputWrapper.addWidget(input2);
    this.layout.addWidget(inputWrapper);
    this._inputPlaceholder = new InputPlaceholder({
      callback: () => {
        this.inputHidden = !this.inputHidden;
      },
      text: input2.model.sharedModel.getSource().split("\n")[0],
      translator: this.translator
    });
    input2.model.contentChanged.connect((sender, args) => {
      var _a;
      if (this._inputPlaceholder && this.inputHidden) {
        this._inputPlaceholder.text = (_a = sender.sharedModel.getSource().split("\n")) === null || _a === void 0 ? void 0 : _a[0];
      }
    });
    if (this.inputHidden) {
      input2.parent = null;
      inputWrapper.layout.addWidget(this._inputPlaceholder);
    }
    const footer = this.contentFactory.createCellFooter();
    footer.addClass(CELL_FOOTER_CLASS);
    this.layout.addWidget(footer);
  }
  /**
   * Get the editor options at initialization.
   *
   * @returns Editor options
   */
  getEditorOptions() {
    return { config: this.editorConfig, extensions: this._editorExtensions };
  }
  /**
   * Handle `before-attach` messages.
   */
  onBeforeAttach(msg) {
    if (this.placeholder) {
      this.placeholder = false;
    }
  }
  /**
   * Handle `after-attach` messages.
   */
  onAfterAttach(msg) {
    this.update();
  }
  /**
   * Handle `'activate-request'` messages.
   */
  onActivateRequest(msg) {
    var _a;
    (_a = this.editor) === null || _a === void 0 ? void 0 : _a.focus();
  }
  /**
   * Handle `resize` messages.
   */
  onResize(msg) {
    void this._resizeDebouncer.invoke();
  }
  /**
   * Handle `update-request` messages.
   */
  onUpdateRequest(msg) {
    var _a, _b;
    if (!this._model) {
      return;
    }
    if (((_a = this.editor) === null || _a === void 0 ? void 0 : _a.getOption("readOnly")) !== this._readOnly) {
      (_b = this.editor) === null || _b === void 0 ? void 0 : _b.setOption("readOnly", this._readOnly);
    }
  }
  onContentChanged() {
    var _a;
    if (this.inputHidden && this._inputPlaceholder) {
      this._inputPlaceholder.text = (_a = this.model.sharedModel.getSource().split("\n")) === null || _a === void 0 ? void 0 : _a[0];
    }
  }
  /**
   * Handle changes in the metadata.
   */
  onMetadataChanged(model, args) {
    switch (args.key) {
      case "jupyter":
        if (this.syncCollapse) {
          this.loadCollapseState();
        }
        break;
      case "editable":
        if (this.syncEditable) {
          this.loadEditableState();
        }
        break;
    }
  }
}
(function(Cell2) {
  (function(HeadingType) {
    HeadingType[HeadingType["HTML"] = 0] = "HTML";
    HeadingType[HeadingType["Markdown"] = 1] = "Markdown";
  })(Cell2.HeadingType || (Cell2.HeadingType = {}));
  class ContentFactory {
    /**
     * Create a content factory for a cell.
     */
    constructor(options) {
      this._editorFactory = options.editorFactory;
    }
    /**
     * The readonly editor factory that create code editors
     */
    get editorFactory() {
      return this._editorFactory;
    }
    /**
     * Create a new cell header for the parent widget.
     */
    createCellHeader() {
      return new CellHeader();
    }
    /**
     * Create a new cell footer for the parent widget.
     */
    createCellFooter() {
      return new CellFooter();
    }
    /**
     * Create an input prompt.
     */
    createInputPrompt() {
      return new InputPrompt();
    }
    /**
     * Create the output prompt for the widget.
     */
    createOutputPrompt() {
      return new OutputPrompt();
    }
    /**
     * Create an stdin widget.
     */
    createStdin(options) {
      return new Stdin(options);
    }
  }
  Cell2.ContentFactory = ContentFactory;
})(Cell || (Cell = {}));
class CodeCellLayout extends PanelLayout {
  /**
   * A message handler invoked on a `'before-attach'` message.
   *
   * #### Notes
   * The default implementation of this method forwards the message
   * to all widgets. It assumes all widget nodes are attached to the
   * parent widget node.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onBeforeAttach(msg) {
    let beforeOutputArea = true;
    const outputAreaWrapper = this.parent.node.firstElementChild;
    for (const widget of this) {
      if (outputAreaWrapper) {
        if (widget.node === outputAreaWrapper) {
          beforeOutputArea = false;
        } else {
          MessageLoop.sendMessage(widget, msg);
          if (beforeOutputArea) {
            this.parent.node.insertBefore(widget.node, outputAreaWrapper);
          } else {
            this.parent.node.appendChild(widget.node);
          }
          if (!this.parent.isHidden) {
            widget.setFlag(Widget.Flag.IsVisible);
          }
          MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
        }
      }
    }
  }
  /**
   * A message handler invoked on an `'after-detach'` message.
   *
   * #### Notes
   * The default implementation of this method forwards the message
   * to all widgets. It assumes all widget nodes are attached to the
   * parent widget node.
   *
   * This may be reimplemented by subclasses as needed.
   */
  onAfterDetach(msg) {
    for (const widget of this) {
      if (!widget.hasClass(CELL_OUTPUT_WRAPPER_CLASS) && widget.node.isConnected) {
        MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
        this.parent.node.removeChild(widget.node);
        MessageLoop.sendMessage(widget, msg);
      }
    }
  }
}
class CodeCell extends Cell {
  /**
   * Construct a code cell widget.
   */
  constructor(options) {
    var _a;
    super({ layout: new CodeCellLayout(), ...options, placeholder: true });
    this._detectCaretMovementInOuput = (e) => {
      const inWindowedContainer = this._inViewport !== null;
      const defaultPrevented = inWindowedContainer && !this._inViewport;
      const target2 = e.target;
      if (!target2 || !(target2 instanceof HTMLElement)) {
        return;
      }
      if (this._lastTarget) {
        this._lastTarget.removeEventListener("selectionchange", this._lastOnCaretMovedHandler);
        document.removeEventListener("selectionchange", this._lastOnCaretMovedHandler);
      }
      const onCaretMoved = () => {
        this._scrollRequested.emit({
          scrollWithinCell: ({ scroller }) => {
            ElementExt.scrollIntoViewIfNeeded(scroller, target2);
          },
          defaultPrevented
        });
      };
      this._lastTarget = target2;
      this._lastOnCaretMovedHandler = onCaretMoved;
      target2.addEventListener("selectionchange", onCaretMoved, { once: true });
      document.addEventListener("selectionchange", onCaretMoved, {
        once: true
      });
      setTimeout(() => {
        target2.removeEventListener("selectionchange", onCaretMoved);
        document.removeEventListener("selectionchange", onCaretMoved);
      }, 250);
    };
    this._headingsCache = null;
    this._outputHidden = false;
    this._outputWrapper = null;
    this._outputPlaceholder = null;
    this._syncScrolled = false;
    this._lastTarget = null;
    this._lastOutputHeight = "";
    this.addClass(CODE_CELL_CLASS);
    const trans = this.translator.load("jupyterlab");
    const rendermime = this._rendermime = options.rendermime;
    const contentFactory = this.contentFactory;
    const model = this.model;
    this.maxNumberOutputs = options.maxNumberOutputs;
    const ariaLabel = model.outputs.length === 0 ? trans.__("Code Cell Content") : trans.__("Code Cell Content with Output");
    this.node.setAttribute("aria-label", ariaLabel);
    const output = this._output = new OutputArea({
      model: this.model.outputs,
      rendermime,
      contentFactory,
      maxNumberOutputs: this.maxNumberOutputs,
      translator: this.translator,
      promptOverlay: true,
      inputHistoryScope: options.inputHistoryScope
    });
    output.node.addEventListener("keydown", this._detectCaretMovementInOuput);
    output.addClass(CELL_OUTPUT_AREA_CLASS);
    output.toggleScrolling.connect(() => {
      this.outputsScrolled = !this.outputsScrolled;
    });
    output.initialize.connect(() => {
      this.updatePromptOverlayIcon();
    });
    this.placeholder = (_a = options.placeholder) !== null && _a !== void 0 ? _a : true;
    model.outputs.changed.connect(this.onOutputChanged, this);
    model.outputs.stateChanged.connect(this.onOutputChanged, this);
    model.stateChanged.connect(this.onStateChanged, this);
  }
  /**
   * Create children widgets.
   */
  initializeDOM() {
    if (!this.placeholder) {
      return;
    }
    super.initializeDOM();
    this._updatePrompt();
    const outputWrapper = this._outputWrapper = new Panel();
    outputWrapper.addClass(CELL_OUTPUT_WRAPPER_CLASS);
    const outputCollapser = new OutputCollapser();
    outputCollapser.addClass(CELL_OUTPUT_COLLAPSER_CLASS);
    outputWrapper.addWidget(outputCollapser);
    if (this.model.outputs.length === 0) {
      this.addClass(NO_OUTPUTS_CLASS);
    }
    this._output.outputLengthChanged.connect(this._outputLengthHandler, this);
    outputWrapper.addWidget(this._output);
    const layout = this.layout;
    const resizeHandle = new ResizeHandle(this.node);
    resizeHandle.sizeChanged.connect(this._sizeChangedHandler, this);
    layout.insertWidget(layout.widgets.length - 1, resizeHandle);
    layout.insertWidget(layout.widgets.length - 1, outputWrapper);
    if (this.model.isDirty) {
      this.addClass(DIRTY_CLASS$2);
    }
    this._outputPlaceholder = new OutputPlaceholder({
      callback: () => {
        this.outputHidden = !this.outputHidden;
      },
      text: this.getOutputPlaceholderText(),
      translator: this.translator
    });
    const layoutWrapper = outputWrapper.layout;
    if (this.outputHidden) {
      layoutWrapper.removeWidget(this._output);
      layoutWrapper.addWidget(this._outputPlaceholder);
      if (this.inputHidden && !outputWrapper.isHidden) {
        this._outputWrapper.hide();
      }
    }
    const trans = this.translator.load("jupyterlab");
    const ariaLabel = this.model.outputs.length === 0 ? trans.__("Code Cell Content") : trans.__("Code Cell Content with Output");
    this.node.setAttribute("aria-label", ariaLabel);
  }
  getOutputPlaceholderText() {
    var _a;
    const firstOutput = this.model.outputs.get(0);
    const outputData = firstOutput === null || firstOutput === void 0 ? void 0 : firstOutput.data;
    if (!outputData) {
      return void 0;
    }
    const supportedOutputTypes = [
      "text/html",
      "image/svg+xml",
      "application/pdf",
      "text/markdown",
      "text/plain",
      "application/vnd.jupyter.stderr",
      "application/vnd.jupyter.stdout",
      "text"
    ];
    const preferredOutput = supportedOutputTypes.find((mt) => {
      const data = firstOutput.data[mt];
      return (Array.isArray(data) ? typeof data[0] : typeof data) === "string";
    });
    const dataToDisplay = firstOutput.data[preferredOutput !== null && preferredOutput !== void 0 ? preferredOutput : ""];
    if (dataToDisplay !== void 0) {
      return (_a = Array.isArray(dataToDisplay) ? dataToDisplay : dataToDisplay === null || dataToDisplay === void 0 ? void 0 : dataToDisplay.split("\n")) === null || _a === void 0 ? void 0 : _a.find((part) => part !== "");
    }
    return void 0;
  }
  /**
   * Initialize view state from model.
   *
   * #### Notes
   * Should be called after construction. For convenience, returns this, so it
   * can be chained in the construction, like `new Foo().initializeState();`
   */
  initializeState() {
    super.initializeState();
    this.loadScrolledState();
    this._updatePrompt();
    return this;
  }
  get headings() {
    if (!this._headingsCache) {
      const headings = [];
      const outputs = this.model.outputs;
      for (let j = 0; j < outputs.length; j++) {
        const m2 = outputs.get(j);
        let htmlType = null;
        let mdType = null;
        Object.keys(m2.data).forEach((t) => {
          if (!mdType && isMarkdown(t)) {
            mdType = t;
          } else if (!htmlType && isHTML(t)) {
            htmlType = t;
          }
        });
        if (htmlType) {
          headings.push(...getHTMLHeadings(this._rendermime.sanitizer.sanitize(m2.data[htmlType])).map((heading) => {
            return {
              ...heading,
              outputIndex: j,
              type: Cell.HeadingType.HTML
            };
          }));
        } else if (mdType) {
          headings.push(...getHeadings(m2.data[mdType]).map((heading) => {
            return {
              ...heading,
              outputIndex: j,
              type: Cell.HeadingType.Markdown
            };
          }));
        }
      }
      this._headingsCache = headings;
    }
    return [...this._headingsCache];
  }
  /**
   * Get the output area for the cell.
   */
  get outputArea() {
    return this._output;
  }
  /**
   * The view state of output being collapsed.
   */
  get outputHidden() {
    return this._outputHidden;
  }
  set outputHidden(value) {
    var _a;
    if (this._outputHidden === value) {
      return;
    }
    if (!this.placeholder) {
      const layout = this._outputWrapper.layout;
      if (value) {
        layout.removeWidget(this._output);
        layout.addWidget(this._outputPlaceholder);
        if (this.inputHidden && !this._outputWrapper.isHidden) {
          this._outputWrapper.hide();
        }
        if (this._outputPlaceholder) {
          this._outputPlaceholder.text = (_a = this.getOutputPlaceholderText()) !== null && _a !== void 0 ? _a : "";
        }
      } else {
        if (this._outputWrapper.isHidden) {
          this._outputWrapper.show();
        }
        layout.removeWidget(this._outputPlaceholder);
        layout.addWidget(this._output);
      }
    }
    this._outputHidden = value;
    if (this.syncCollapse) {
      this.saveCollapseState();
    }
  }
  /**
   * Save view collapse state to model
   */
  saveCollapseState() {
    this.model.sharedModel.transact(() => {
      super.saveCollapseState();
      const collapsed = this.model.getMetadata("collapsed");
      if (this.outputHidden && collapsed === true || !this.outputHidden && collapsed === void 0) {
        return;
      }
      if (this.outputHidden) {
        this.model.setMetadata("collapsed", true);
      } else {
        this.model.deleteMetadata("collapsed");
      }
    }, false, "silent-change");
  }
  /**
   * Revert view collapse state from model.
   *
   * We consider the `collapsed` metadata key as the source of truth for outputs
   * being hidden.
   */
  loadCollapseState() {
    super.loadCollapseState();
    this.outputHidden = !!this.model.getMetadata("collapsed");
  }
  /**
   * Whether the output is in a scrolled state?
   */
  get outputsScrolled() {
    return this._outputsScrolled;
  }
  set outputsScrolled(value) {
    this.toggleClass("jp-mod-outputsScrolled", value);
    this._outputsScrolled = value;
    if (this.syncScrolled) {
      this.saveScrolledState();
    }
    this.updatePromptOverlayIcon();
  }
  /**
   * Update the Prompt Overlay Icon
   */
  updatePromptOverlayIcon() {
    var _a;
    const overlay = DOMUtils.findElement(this.node, "jp-OutputArea-promptOverlay");
    if (!overlay) {
      return;
    }
    const ICON_HEIGHT = 16 + 4 + 4;
    if (overlay.clientHeight <= ICON_HEIGHT) {
      (_a = overlay.firstChild) === null || _a === void 0 ? void 0 : _a.remove();
      return;
    }
    let overlayTitle;
    if (this._outputsScrolled) {
      expandIcon.element({
        container: overlay
      });
      overlayTitle = "Expand Output";
    } else {
      collapseIcon.element({
        container: overlay
      });
      overlayTitle = "Collapse Output";
    }
    const trans = this.translator.load("jupyterlab");
    overlay.title = trans.__(overlayTitle);
  }
  /**
   * Save view collapse state to model
   */
  saveScrolledState() {
    const current = this.model.getMetadata("scrolled");
    if (this.outputsScrolled && current === true || !this.outputsScrolled && current === void 0) {
      return;
    }
    if (this.outputsScrolled) {
      this.model.setMetadata("scrolled", true);
    } else {
      this.outputArea.node.style.height = "";
      this.model.deleteMetadata("scrolled");
    }
  }
  /**
   * Revert view collapse state from model.
   */
  loadScrolledState() {
    if (this.model.getMetadata("scrolled") === "auto") {
      this.outputsScrolled = false;
    } else {
      this.outputsScrolled = !!this.model.getMetadata("scrolled");
    }
  }
  /**
   * Whether to sync the scrolled state to the cell model.
   */
  get syncScrolled() {
    return this._syncScrolled;
  }
  set syncScrolled(value) {
    if (this._syncScrolled === value) {
      return;
    }
    this._syncScrolled = value;
    if (value) {
      this.loadScrolledState();
    }
  }
  /**
   * Handle the input being hidden.
   *
   * #### Notes
   * This method is called by the case cell implementation and is
   * subclasses here so the code cell can watch to see when input
   * is hidden without accessing private state.
   */
  handleInputHidden(value) {
    if (this.placeholder) {
      return;
    }
    if (!value && this._outputWrapper.isHidden) {
      this._outputWrapper.show();
    } else if (value && !this._outputWrapper.isHidden && this._outputHidden) {
      this._outputWrapper.hide();
    }
  }
  /**
   * Clone the cell, using the same model.
   */
  clone() {
    const constructor = this.constructor;
    return new constructor({
      model: this.model,
      contentFactory: this.contentFactory,
      rendermime: this._rendermime,
      placeholder: false,
      translator: this.translator
    });
  }
  /**
   * Clone the OutputArea alone, returning a simplified output area, using the same model.
   */
  cloneOutputArea() {
    return new SimplifiedOutputArea({
      model: this.model.outputs,
      contentFactory: this.contentFactory,
      rendermime: this._rendermime
    });
  }
  /**
   * Dispose of the resources used by the widget.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._output.outputLengthChanged.disconnect(this._outputLengthHandler, this);
    this._output.node.removeEventListener("keydown", this._detectCaretMovementInOuput);
    this._rendermime = null;
    this._output = null;
    this._outputWrapper = null;
    this._outputPlaceholder = null;
    super.dispose();
  }
  /**
   * Handle changes in the model.
   */
  onStateChanged(model, args) {
    switch (args.name) {
      case "executionCount":
        this.model.executionState = "idle";
        this._updatePrompt();
        break;
      case "executionState":
        this._updatePrompt();
        break;
      case "isDirty":
        if (model.isDirty) {
          this.addClass(DIRTY_CLASS$2);
        } else {
          this.removeClass(DIRTY_CLASS$2);
        }
        break;
    }
  }
  /**
   * Callback on output changes
   */
  onOutputChanged() {
    var _a;
    this._headingsCache = null;
    if (this._outputPlaceholder && this.outputHidden) {
      this._outputPlaceholder.text = (_a = this.getOutputPlaceholderText()) !== null && _a !== void 0 ? _a : "";
    }
    this.updatePromptOverlayIcon();
    const height = this.outputArea.node.style.height;
    if (this.model.outputs.length === 0 && height !== "") {
      this._lastOutputHeight = height;
      this.outputArea.node.style.height = "";
    } else if (this.model.outputs.length > 0 && height === "") {
      this.outputArea.node.style.height = this._lastOutputHeight;
    }
  }
  /**
   * Handle changes in the metadata.
   */
  onMetadataChanged(model, args) {
    switch (args.key) {
      case "scrolled":
        if (this.syncScrolled) {
          this.loadScrolledState();
        }
        break;
      case "collapsed":
        if (this.syncCollapse) {
          this.loadCollapseState();
        }
        break;
    }
    super.onMetadataChanged(model, args);
  }
  _updatePrompt() {
    let prompt;
    if (this.model.executionState == "running") {
      prompt = "*";
    } else {
      prompt = `${this.model.executionCount || ""}`;
    }
    this._setPrompt(prompt);
  }
  /**
   * Handle changes in the number of outputs in the output area.
   */
  _outputLengthHandler(sender, args) {
    const force = args === 0 ? true : false;
    this.toggleClass(NO_OUTPUTS_CLASS, force);
    const trans = this.translator.load("jupyterlab");
    const ariaLabel = force ? trans.__("Code Cell Content") : trans.__("Code Cell Content with Output");
    this.node.setAttribute("aria-label", ariaLabel);
  }
  /**
   * Handle changes in input/output proportions in side-by-side mode.
   */
  _sizeChangedHandler(sender) {
    this._displayChanged.emit();
  }
}
(function(CodeCell2) {
  async function execute(cell, sessionContext, metadata) {
    var _a;
    const model = cell.model;
    const code2 = model.sharedModel.getSource();
    if (!code2.trim() || !((_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel)) {
      model.sharedModel.transact(() => {
        model.clearExecution();
      }, false, "silent-change");
      return;
    }
    const cellId = { cellId: model.sharedModel.getId() };
    metadata = {
      ...model.metadata,
      ...metadata,
      ...cellId
    };
    const { recordTiming } = metadata;
    model.sharedModel.transact(() => {
      model.clearExecution();
      cell.outputHidden = false;
    }, false, "silent-change");
    model.executionState = "running";
    model.trusted = true;
    let future2;
    try {
      const msgPromise = OutputArea.execute(code2, cell.outputArea, sessionContext, metadata);
      if (recordTiming) {
        const recordTimingHook = (msg2) => {
          let label;
          switch (msg2.header.msg_type) {
            case "status":
              label = `status.${msg2.content.execution_state}`;
              break;
            case "execute_input":
              label = "execute_input";
              break;
            default:
              return true;
          }
          const value = msg2.header.date || (/* @__PURE__ */ new Date()).toISOString();
          const timingInfo = Object.assign({}, model.getMetadata("execution"));
          timingInfo[`iopub.${label}`] = value;
          model.setMetadata("execution", timingInfo);
          return true;
        };
        cell.outputArea.future.registerMessageHook(recordTimingHook);
      } else {
        model.deleteMetadata("execution");
      }
      future2 = cell.outputArea.future;
      const msg = await msgPromise;
      model.executionCount = msg.content.execution_count;
      if (recordTiming) {
        const timingInfo = Object.assign({}, model.getMetadata("execution"));
        const started = msg.metadata.started;
        if (started) {
          timingInfo["shell.execute_reply.started"] = started;
        }
        const finished = msg.header.date;
        timingInfo["shell.execute_reply"] = finished || (/* @__PURE__ */ new Date()).toISOString();
        model.setMetadata("execution", timingInfo);
      }
      return msg;
    } catch (e) {
      if (future2 && !cell.isDisposed && cell.outputArea.future === future2) {
        cell.model.executionState = "idle";
        if (recordTiming && future2.isDisposed) {
          const timingInfo = Object.assign({}, model.getMetadata("execution"));
          timingInfo["execution_failed"] = (/* @__PURE__ */ new Date()).toISOString();
          model.setMetadata("execution", timingInfo);
        }
      }
      throw e;
    }
  }
  CodeCell2.execute = execute;
})(CodeCell || (CodeCell = {}));
class AttachmentsCell extends Cell {
  /**
   * Handle the DOM events for the widget.
   *
   * @param event - The DOM event sent to the widget.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the notebook panel's node. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "lm-dragover":
        this._evtDragOver(event2);
        break;
      case "lm-drop":
        this._evtDrop(event2);
        break;
    }
  }
  /**
   * Get the editor options at initialization.
   *
   * @returns Editor options
   */
  getEditorOptions() {
    var _a, _b;
    const base2 = (_a = super.getEditorOptions()) !== null && _a !== void 0 ? _a : {};
    base2.extensions = [
      ...(_b = base2.extensions) !== null && _b !== void 0 ? _b : [],
      EditorView.domEventHandlers({
        dragenter: (event2) => {
          event2.preventDefault();
        },
        dragover: (event2) => {
          event2.preventDefault();
        },
        drop: (event2) => {
          this._evtNativeDrop(event2);
        },
        paste: (event2) => {
          this._evtPaste(event2);
        }
      })
    ];
    return base2;
  }
  /**
   * Handle `after-attach` messages for the widget.
   */
  onAfterAttach(msg) {
    super.onAfterAttach(msg);
    const node2 = this.node;
    node2.addEventListener("lm-dragover", this);
    node2.addEventListener("lm-drop", this);
  }
  /**
   * A message handler invoked on a `'before-detach'`
   * message
   */
  onBeforeDetach(msg) {
    const node2 = this.node;
    node2.removeEventListener("lm-dragover", this);
    node2.removeEventListener("lm-drop", this);
    super.onBeforeDetach(msg);
  }
  _evtDragOver(event2) {
    const supportedMimeType = some$1(imageRendererFactory.mimeTypes, (mimeType) => {
      if (!event2.mimeData.hasData(CONTENTS_MIME_RICH)) {
        return false;
      }
      const data = event2.mimeData.getData(CONTENTS_MIME_RICH);
      return data.model.mimetype === mimeType;
    });
    if (!supportedMimeType) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    event2.dropAction = event2.proposedAction;
  }
  /**
   * Handle the `paste` event for the widget
   */
  _evtPaste(event2) {
    var _a;
    const isEditable = (_a = this.model.getMetadata("editable")) !== null && _a !== void 0 ? _a : true;
    if (event2.clipboardData && isEditable) {
      const items = event2.clipboardData.items;
      for (let i2 = 0; i2 < items.length; i2++) {
        if (items[i2].type === "text/plain") {
          if (i2 < items.length - 1 && items[i2 + 1].kind === "file") {
            continue;
          }
          items[i2].getAsString((text2) => {
            var _a2, _b;
            (_b = (_a2 = this.editor).replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a2, text2.replace(/\r\n/g, "\n").replace(/\r/g, "\n"));
          });
        }
        this._attachFiles(event2.clipboardData.items);
      }
    }
    event2.preventDefault();
  }
  /**
   * Handle the `drop` event for the widget
   */
  _evtNativeDrop(event2) {
    if (event2.dataTransfer) {
      this._attachFiles(event2.dataTransfer.items);
    }
    event2.preventDefault();
  }
  /**
   * Handle the `'lm-drop'` event for the widget.
   */
  _evtDrop(event2) {
    const supportedMimeTypes = event2.mimeData.types().filter((mimeType) => {
      if (mimeType === CONTENTS_MIME_RICH) {
        const data = event2.mimeData.getData(CONTENTS_MIME_RICH);
        return imageRendererFactory.mimeTypes.indexOf(data.model.mimetype) !== -1;
      }
      return imageRendererFactory.mimeTypes.indexOf(mimeType) !== -1;
    });
    if (supportedMimeTypes.length === 0) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    if (event2.proposedAction === "none") {
      event2.dropAction = "none";
      return;
    }
    event2.dropAction = "copy";
    for (const mimeType of supportedMimeTypes) {
      if (mimeType === CONTENTS_MIME_RICH) {
        const { model, withContent } = event2.mimeData.getData(CONTENTS_MIME_RICH);
        if (model.type === "file") {
          const URI = this._generateURI(model.name);
          this.updateCellSourceWithAttachment(model.name, URI);
          void withContent().then((fullModel) => {
            this.model.attachments.set(URI, {
              [fullModel.mimetype]: fullModel.content
            });
          });
        }
      } else {
        const URI = this._generateURI();
        this.model.attachments.set(URI, {
          [mimeType]: event2.mimeData.getData(mimeType)
        });
        this.updateCellSourceWithAttachment(URI, URI);
      }
    }
  }
  /**
   * Attaches all DataTransferItems (obtained from
   * clipboard or native drop events) to the cell
   */
  _attachFiles(items) {
    for (let i2 = 0; i2 < items.length; i2++) {
      const item = items[i2];
      if (item.kind === "file") {
        const blob = item.getAsFile();
        if (blob) {
          this._attachFile(blob);
        }
      }
    }
  }
  /**
   * Takes in a file object and adds it to
   * the cell attachments
   */
  _attachFile(blob) {
    const reader = new FileReader();
    reader.onload = (evt) => {
      const { href, protocol } = lib$9.URLExt.parse(reader.result);
      if (protocol !== "data:") {
        return;
      }
      const dataURIRegex = /([\w+\/\+]+)?(?:;(charset=[\w\d-]*|base64))?,(.*)/;
      const matches2 = dataURIRegex.exec(href);
      if (!matches2 || matches2.length !== 4) {
        return;
      }
      const mimeType = matches2[1];
      const encodedData = matches2[3];
      const bundle = { [mimeType]: encodedData };
      const URI = this._generateURI(blob.name);
      if (mimeType.startsWith("image/")) {
        this.model.attachments.set(URI, bundle);
        this.updateCellSourceWithAttachment(blob.name, URI);
      }
    };
    reader.onerror = (evt) => {
      console.error(`Failed to attach ${blob.name}` + evt);
    };
    reader.readAsDataURL(blob);
  }
  /**
   * Generates a unique URI for a file
   * while preserving the file extension.
   */
  _generateURI(name2 = "") {
    const lastIndex = name2.lastIndexOf(".");
    return lastIndex !== -1 ? UUID.uuid4().concat(name2.substring(lastIndex)) : UUID.uuid4();
  }
}
class MarkdownCell extends AttachmentsCell {
  /**
   * Construct a Markdown cell widget.
   */
  constructor(options) {
    var _a, _b, _c, _d;
    super({ ...options, placeholder: true });
    this._headingsCache = null;
    this._headingCollapsedChanged = new Signal(this);
    this._prevText = "";
    this._rendered = true;
    this._renderedChanged = new Signal(this);
    this._showEditorForReadOnlyMarkdown = true;
    this.addClass(MARKDOWN_CELL_CLASS);
    this.model.contentChanged.connect(this.onContentChanged, this);
    const trans = this.translator.load("jupyterlab");
    this.node.setAttribute("aria-label", trans.__("Markdown Cell Content"));
    this._rendermime = options.rendermime.clone({
      resolver: new AttachmentsResolver({
        parent: (_a = options.rendermime.resolver) !== null && _a !== void 0 ? _a : void 0,
        model: this.model.attachments
      })
    });
    this._renderer = this._rendermime.createRenderer("text/markdown");
    this._renderer.addClass(MARKDOWN_OUTPUT_CLASS);
    this._headingCollapsed = (_b = this.model.getMetadata(MARKDOWN_HEADING_COLLAPSED)) !== null && _b !== void 0 ? _b : false;
    this._showEditorForReadOnlyMarkdown = (_c = options.showEditorForReadOnlyMarkdown) !== null && _c !== void 0 ? _c : MarkdownCell.defaultShowEditorForReadOnlyMarkdown;
    this.placeholder = (_d = options.placeholder) !== null && _d !== void 0 ? _d : true;
    this._monitor = new lib$9.ActivityMonitor({
      signal: this.model.contentChanged,
      timeout: RENDER_TIMEOUT
    });
    this.ready.then(() => {
      if (this.isDisposed) {
        return;
      }
      this._monitor.activityStopped.connect(() => {
        if (this._rendered) {
          this.update();
        }
      }, this);
    }).catch((reason) => {
      console.error("Failed to be ready", reason);
    });
  }
  /**
   * Text that represents the highest heading (i.e. lowest level) if cell is a heading.
   * Returns empty string if not a heading.
   */
  get headingInfo() {
    const headings = this.headings;
    if (headings.length > 0) {
      const { text: text2, level } = headings.reduce((prev, curr) => prev.level <= curr.level ? prev : curr, headings[0]);
      return { text: text2, level };
    } else {
      return { text: "", level: -1 };
    }
  }
  get headings() {
    if (!this._headingsCache) {
      const headings = getHeadings(this.model.sharedModel.getSource());
      this._headingsCache = headings.map((h2) => {
        return { ...h2, type: Cell.HeadingType.Markdown };
      });
    }
    return [...this._headingsCache];
  }
  /**
   * Whether the heading is collapsed or not.
   */
  get headingCollapsed() {
    return this._headingCollapsed;
  }
  set headingCollapsed(value) {
    var _a;
    if (this._headingCollapsed !== value) {
      this._headingCollapsed = value;
      if (value) {
        this.model.setMetadata(MARKDOWN_HEADING_COLLAPSED, value);
      } else if (this.model.getMetadata(MARKDOWN_HEADING_COLLAPSED) !== "undefined") {
        this.model.deleteMetadata(MARKDOWN_HEADING_COLLAPSED);
      }
      const collapseButton = (_a = this.inputArea) === null || _a === void 0 ? void 0 : _a.promptNode.getElementsByClassName(HEADING_COLLAPSER_CLASS$1)[0];
      if (collapseButton) {
        if (value) {
          collapseButton.classList.add("jp-mod-collapsed");
        } else {
          collapseButton.classList.remove("jp-mod-collapsed");
        }
      }
      this.renderCollapseButtons(this._renderer);
      this._headingCollapsedChanged.emit(this._headingCollapsed);
    }
  }
  /**
   * Number of collapsed sub cells.
   */
  get numberChildNodes() {
    return this._numberChildNodes;
  }
  set numberChildNodes(value) {
    this._numberChildNodes = value;
    this.renderCollapseButtons(this._renderer);
  }
  /**
   * Signal emitted when the cell collapsed state changes.
   */
  get headingCollapsedChanged() {
    return this._headingCollapsedChanged;
  }
  /**
   * Whether the cell is rendered.
   */
  get rendered() {
    return this._rendered;
  }
  set rendered(value) {
    if (this.readOnly && this._showEditorForReadOnlyMarkdown === false) {
      value = true;
    }
    if (value === this._rendered) {
      return;
    }
    this._rendered = value;
    this._handleRendered().then(() => {
      this._displayChanged.emit();
      this._renderedChanged.emit(this._rendered);
    }).catch((reason) => {
      console.error("Failed to render", reason);
    });
  }
  /**
   * Signal emitted when the markdown cell rendered state changes
   */
  get renderedChanged() {
    return this._renderedChanged;
  }
  /*
   * Whether the Markdown editor is visible in read-only mode.
   */
  get showEditorForReadOnly() {
    return this._showEditorForReadOnlyMarkdown;
  }
  set showEditorForReadOnly(value) {
    this._showEditorForReadOnlyMarkdown = value;
    if (value === false) {
      this.rendered = true;
    }
  }
  /**
   * Renderer
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Dispose of the resources held by the widget.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._monitor.dispose();
    super.dispose();
  }
  /**
   * Create children widgets.
   */
  initializeDOM() {
    if (!this.placeholder) {
      return;
    }
    super.initializeDOM();
    this.renderCollapseButtons(this._renderer);
    this._handleRendered().catch((reason) => {
      console.error("Failed to render", reason);
    });
  }
  maybeCreateCollapseButton() {
    var _a;
    const { level } = this.headingInfo;
    if (level > 0 && ((_a = this.inputArea) === null || _a === void 0 ? void 0 : _a.promptNode.getElementsByClassName(HEADING_COLLAPSER_CLASS$1).length) == 0) {
      let collapseButton = this.inputArea.promptNode.appendChild(document.createElement("button"));
      collapseButton.className = `jp-Button ${HEADING_COLLAPSER_CLASS$1}`;
      collapseButton.setAttribute("data-heading-level", level.toString());
      if (this._headingCollapsed) {
        collapseButton.classList.add("jp-mod-collapsed");
      } else {
        collapseButton.classList.remove("jp-mod-collapsed");
      }
      collapseButton.onclick = (event2) => {
        this.headingCollapsed = !this.headingCollapsed;
      };
    }
  }
  /**
   * Create, update or remove the hidden cells button.
   * Note that the actual visibility is controlled in Static Notebook by toggling jp-mod-showHiddenCellsButton class.
   */
  maybeCreateOrUpdateExpandButton() {
    const showHiddenCellsButtonList = this.node.getElementsByClassName(SHOW_HIDDEN_CELLS_CLASS);
    let trans = this.translator.load("jupyterlab");
    let buttonText = trans._n("%1 cell hidden", "%1 cells hidden", this._numberChildNodes);
    let needToCreateButton = this.headingCollapsed && this._numberChildNodes > 0 && showHiddenCellsButtonList.length == 0;
    if (needToCreateButton) {
      const newShowHiddenCellsButton = document.createElement("button");
      newShowHiddenCellsButton.className = `jp-mod-minimal jp-Button ${SHOW_HIDDEN_CELLS_CLASS}`;
      addIcon.render(newShowHiddenCellsButton);
      const buttonTextElement = document.createElement("div");
      buttonTextElement.textContent = buttonText;
      newShowHiddenCellsButton.appendChild(buttonTextElement);
      newShowHiddenCellsButton.onclick = () => {
        this.headingCollapsed = false;
      };
      this.node.appendChild(newShowHiddenCellsButton);
    }
    let needToUpdateButtonText = this.headingCollapsed && this._numberChildNodes > 0 && showHiddenCellsButtonList.length == 1;
    if (needToUpdateButtonText) {
      showHiddenCellsButtonList[0].childNodes[1].textContent = buttonText;
    }
    let needToRemoveButton = !(this.headingCollapsed && this._numberChildNodes > 0);
    if (needToRemoveButton) {
      for (const button of showHiddenCellsButtonList) {
        this.node.removeChild(button);
      }
    }
  }
  /**
   * Callback on content changed
   */
  onContentChanged() {
    super.onContentChanged();
    this._headingsCache = null;
  }
  /**
   * Render the collapse button for heading cells,
   * and for collapsed heading cells render the "expand hidden cells"
   * button.
   */
  renderCollapseButtons(widget) {
    this.node.classList.toggle(MARKDOWN_HEADING_COLLAPSED, this._headingCollapsed);
    this.maybeCreateCollapseButton();
    this.maybeCreateOrUpdateExpandButton();
  }
  /**
   * Render an input instead of the text editor.
   */
  renderInput(widget) {
    this.addClass(RENDERED_CLASS);
    if (!this.placeholder && !this.isDisposed) {
      this.renderCollapseButtons(widget);
      this.inputArea.renderInput(widget);
    }
  }
  /**
   * Show the text editor instead of rendered input.
   */
  showEditor() {
    this.removeClass(RENDERED_CLASS);
    if (!this.placeholder && !this.isDisposed) {
      this.inputArea.showEditor();
      let numHashAtStart = (this.model.sharedModel.getSource().match(/^#+/g) || [""])[0].length;
      if (numHashAtStart > 0) {
        this.inputArea.editor.setCursorPosition({
          column: numHashAtStart + 1,
          line: 0
        }, { scroll: false });
      }
    }
  }
  /*
   * Handle `update-request` messages.
   */
  onUpdateRequest(msg) {
    this._handleRendered().catch((reason) => {
      console.error("Failed to render", reason);
    });
    super.onUpdateRequest(msg);
  }
  /**
   * Modify the cell source to include a reference to the attachment.
   */
  updateCellSourceWithAttachment(attachmentName, URI) {
    var _a, _b;
    const textToBeAppended = `![${attachmentName}](attachment:${URI !== null && URI !== void 0 ? URI : attachmentName})`;
    (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.replaceSelection) === null || _b === void 0 ? void 0 : _b.call(_a, textToBeAppended);
  }
  /**
   * Handle the rendered state.
   */
  async _handleRendered() {
    if (!this._rendered) {
      this.showEditor();
    } else {
      await this._updateRenderedInput();
      if (this._rendered) {
        this.renderInput(this._renderer);
      }
    }
  }
  /**
   * Update the rendered input.
   */
  _updateRenderedInput() {
    if (this.placeholder) {
      return Promise.resolve();
    }
    const model = this.model;
    const text2 = model && model.sharedModel.getSource() || DEFAULT_MARKDOWN_TEXT;
    if (text2 !== this._prevText) {
      const mimeModel = new MimeModel({ data: { "text/markdown": text2 } });
      this._prevText = text2;
      return this._renderer.renderModel(mimeModel);
    }
    return Promise.resolve();
  }
  /**
   * Clone the cell, using the same model.
   */
  clone() {
    const constructor = this.constructor;
    return new constructor({
      model: this.model,
      contentFactory: this.contentFactory,
      rendermime: this._rendermime,
      placeholder: false,
      translator: this.translator
    });
  }
}
(function(MarkdownCell2) {
  MarkdownCell2.defaultShowEditorForReadOnlyMarkdown = true;
})(MarkdownCell || (MarkdownCell = {}));
class RawCell extends Cell {
  /**
   * Construct a raw cell widget.
   */
  constructor(options) {
    super(options);
    this.addClass(RAW_CELL_CLASS);
    const trans = this.translator.load("jupyterlab");
    this.node.setAttribute("aria-label", trans.__("Raw Cell Content"));
  }
  /**
   * Clone the cell, using the same model.
   */
  clone() {
    const constructor = this.constructor;
    return new constructor({
      model: this.model,
      contentFactory: this.contentFactory,
      placeholder: false,
      translator: this.translator
    });
  }
}
async function runCell({ cell, notebook, notebookConfig, onCellExecuted, onCellExecutionScheduled, sessionContext, sessionDialogs, translator }) {
  var _a;
  translator = translator !== null && translator !== void 0 ? translator : nullTranslator;
  const trans = translator.load("jupyterlab");
  switch (cell.model.type) {
    case "markdown":
      cell.rendered = true;
      cell.inputHidden = false;
      onCellExecuted({ cell, success: true });
      break;
    case "code":
      if (sessionContext) {
        if (sessionContext.isTerminating) {
          await showDialog({
            title: trans.__("Kernel Terminating"),
            body: trans.__("The kernel for %1 appears to be terminating. You can not run any cell for now.", (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),
            buttons: [Dialog.okButton()]
          });
          break;
        }
        if (sessionContext.pendingInput) {
          await showDialog({
            title: trans.__("Cell not executed due to pending input"),
            body: trans.__("The cell has not been executed to avoid kernel deadlock as there is another pending input! Type your input in the input box, press Enter and try again."),
            buttons: [Dialog.okButton()]
          });
          return false;
        }
        if (sessionContext.hasNoKernel) {
          const shouldSelect = await sessionContext.startKernel();
          if (shouldSelect && sessionDialogs) {
            await sessionDialogs.selectKernel(sessionContext);
          }
        }
        if (sessionContext.hasNoKernel) {
          cell.model.sharedModel.transact(() => {
            cell.model.clearExecution();
          });
          return true;
        }
        const deletedCells = notebook.deletedCells;
        onCellExecutionScheduled({ cell });
        let ran = false;
        try {
          const reply = await CodeCell.execute(cell, sessionContext, {
            deletedCells,
            recordTiming: notebookConfig.recordTiming
          });
          deletedCells.splice(0, deletedCells.length);
          ran = (() => {
            if (cell.isDisposed) {
              return false;
            }
            if (!reply) {
              return true;
            }
            if (reply.content.status === "ok") {
              const content = reply.content;
              if (content.payload && content.payload.length) {
                handlePayload(content, notebook, cell);
              }
              return true;
            } else {
              throw new KernelError(reply.content);
            }
          })();
        } catch (reason) {
          if (cell.isDisposed || reason.message.startsWith("Canceled")) {
            ran = false;
          } else {
            onCellExecuted({
              cell,
              success: false,
              error: reason
            });
            throw reason;
          }
        }
        if (ran) {
          onCellExecuted({ cell, success: true });
        }
        return ran;
      }
      cell.model.sharedModel.transact(() => {
        cell.model.clearExecution();
      }, false);
      break;
  }
  return Promise.resolve(true);
}
function handlePayload(content, notebook, cell) {
  var _a;
  const setNextInput = (_a = content.payload) === null || _a === void 0 ? void 0 : _a.filter((i2) => {
    return i2.source === "set_next_input";
  })[0];
  if (!setNextInput) {
    return;
  }
  const text2 = setNextInput.text;
  const replace2 = setNextInput.replace;
  if (replace2) {
    cell.model.sharedModel.setSource(text2);
    return;
  }
  const notebookModel = notebook.sharedModel;
  const cells = notebook.cells;
  const index = findIndex(cells, (model) => model === cell.model);
  if (index === -1) {
    notebookModel.insertCell(notebookModel.cells.length, {
      cell_type: "code",
      source: text2,
      metadata: {
        trusted: false
      }
    });
  } else {
    notebookModel.insertCell(index + 1, {
      cell_type: "code",
      source: text2,
      metadata: {
        trusted: false
      }
    });
  }
}
const JUPYTER_CELL_MIME$1 = "application/vnd.jupyter.cells";
class KernelError extends Error {
  /**
   * Construct the kernel error.
   */
  constructor(content) {
    const errorContent = content;
    const errorName = errorContent.ename;
    const errorValue = errorContent.evalue;
    super(`KernelReplyNotOK: ${errorName} ${errorValue}`);
    this.errorName = errorName;
    this.errorValue = errorValue;
    this.traceback = errorContent.traceback;
    Object.setPrototypeOf(this, KernelError.prototype);
  }
}
class NotebookActions {
  /**
   * A signal that emits whenever a cell completes execution.
   */
  static get executed() {
    return Private$2.executed;
  }
  /**
   * A signal that emits whenever a cell execution is scheduled.
   */
  static get executionScheduled() {
    return Private$2.executionScheduled;
  }
  /**
   * A signal that emits when one notebook's cells are all executed.
   */
  static get selectionExecuted() {
    return Private$2.selectionExecuted;
  }
  /**
   * A signal that emits when a cell's output is cleared.
   */
  static get outputCleared() {
    return Private$2.outputCleared;
  }
  /**
   * A private constructor for the `NotebookActions` class.
   *
   * #### Notes
   * This class can never be instantiated. Its static member `executed` will be
   * merged with the `NotebookActions` namespace. The reason it exists as a
   * standalone class is because at run time, the `Private.executed` variable
   * does not yet exist, so it needs to be referenced via a getter.
   */
  constructor() {
  }
}
(function(NotebookActions2) {
  function splitCell(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.mode = "edit";
    notebook.deselectAll();
    const nbModel = notebook.model;
    const index = notebook.activeCellIndex;
    const child = notebook.widgets[index];
    const editor = child.editor;
    if (!editor) {
      return;
    }
    const selections = editor.getSelections();
    const orig = child.model.sharedModel.getSource();
    const offsets = [0];
    let start = -1;
    let end = -1;
    for (let i2 = 0; i2 < selections.length; i2++) {
      start = editor.getOffsetAt(selections[i2].start);
      end = editor.getOffsetAt(selections[i2].end);
      if (start < end) {
        offsets.push(start);
        offsets.push(end);
      } else if (end < start) {
        offsets.push(end);
        offsets.push(start);
      } else {
        offsets.push(start);
      }
    }
    offsets.push(orig.length);
    const cellCountAfterSplit = offsets.length - 1;
    const clones = offsets.slice(0, -1).map((offset, offsetIdx) => {
      const { cell_type, metadata, outputs } = child.model.sharedModel.toJSON();
      return {
        cell_type,
        metadata,
        source: orig.slice(offset, offsets[offsetIdx + 1]).replace(/^\n+/, "").replace(/\n+$/, ""),
        outputs: offsetIdx === cellCountAfterSplit - 1 && cell_type === "code" ? outputs : void 0
      };
    });
    nbModel.sharedModel.transact(() => {
      nbModel.sharedModel.deleteCell(index);
      nbModel.sharedModel.insertCells(index, clones);
    });
    const activeCellDelta = start !== end ? 2 : 1;
    notebook.activeCellIndex = index + clones.length - activeCellDelta;
    notebook.scrollToItem(notebook.activeCellIndex).then(() => {
      var _a;
      (_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.editor.focus();
    }).catch((reason) => {
    });
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.splitCell = splitCell;
  function mergeCells(notebook, mergeAbove = false) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    const toMerge = [];
    const toDelete = [];
    const model = notebook.model;
    const cells = model.cells;
    const primary = notebook.activeCell;
    const active = notebook.activeCellIndex;
    const attachments = {};
    notebook.widgets.forEach((child, index) => {
      if (notebook.isSelectedOrActive(child)) {
        toMerge.push(child.model.sharedModel.getSource());
        if (index !== active) {
          toDelete.push(index);
        }
        const model2 = child.model;
        if (isRawCellModel(model2) || isMarkdownCellModel(model2)) {
          for (const key2 of model2.attachments.keys) {
            attachments[key2] = model2.attachments.get(key2).toJSON();
          }
        }
      }
    });
    if (toMerge.length === 1) {
      if (mergeAbove === true) {
        if (active === 0) {
          return;
        }
        const cellModel = cells.get(active - 1);
        toMerge.unshift(cellModel.sharedModel.getSource());
        toDelete.push(active - 1);
      } else if (mergeAbove === false) {
        if (active === cells.length - 1) {
          return;
        }
        const cellModel = cells.get(active + 1);
        toMerge.push(cellModel.sharedModel.getSource());
        toDelete.push(active + 1);
      }
    }
    notebook.deselectAll();
    const primaryModel = primary.model.sharedModel;
    const { cell_type, metadata } = primaryModel.toJSON();
    if (primaryModel.cell_type === "code") {
      metadata.trusted = true;
    }
    const newModel = {
      cell_type,
      metadata,
      source: toMerge.join("\n\n"),
      attachments: primaryModel.cell_type === "markdown" || primaryModel.cell_type === "raw" ? attachments : void 0
    };
    model.sharedModel.transact(() => {
      model.sharedModel.deleteCell(active);
      model.sharedModel.insertCell(active, newModel);
      toDelete.sort((a, b) => b - a).forEach((index) => {
        model.sharedModel.deleteCell(index);
      });
    });
    if (primary instanceof MarkdownCell) {
      notebook.activeCell.rendered = false;
    }
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.mergeCells = mergeCells;
  function deleteCells(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    Private$2.deleteCells(notebook);
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.deleteCells = deleteCells;
  function insertAbove(notebook) {
    if (!notebook.model) {
      return;
    }
    const state = Private$2.getState(notebook);
    const model = notebook.model;
    const newIndex = notebook.activeCell ? notebook.activeCellIndex : 0;
    model.sharedModel.insertCell(newIndex, {
      cell_type: notebook.notebookConfig.defaultCell,
      metadata: notebook.notebookConfig.defaultCell === "code" ? {
        // This is an empty cell created by user, thus is trusted
        trusted: true
      } : {}
    });
    notebook.activeCellIndex = newIndex;
    notebook.deselectAll();
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.insertAbove = insertAbove;
  function insertBelow(notebook) {
    if (!notebook.model) {
      return;
    }
    const state = Private$2.getState(notebook);
    const model = notebook.model;
    const newIndex = notebook.activeCell ? notebook.activeCellIndex + 1 : 0;
    model.sharedModel.insertCell(newIndex, {
      cell_type: notebook.notebookConfig.defaultCell,
      metadata: notebook.notebookConfig.defaultCell === "code" ? {
        // This is an empty cell created by user, thus is trusted
        trusted: true
      } : {}
    });
    notebook.activeCellIndex = newIndex;
    notebook.deselectAll();
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.insertBelow = insertBelow;
  function move(notebook, shift2) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    const firstIndex = notebook.widgets.findIndex((w) => notebook.isSelectedOrActive(w));
    let lastIndex = notebook.widgets.slice(firstIndex + 1).findIndex((w) => !notebook.isSelectedOrActive(w));
    if (lastIndex >= 0) {
      lastIndex += firstIndex + 1;
    } else {
      lastIndex = notebook.model.cells.length;
    }
    if (shift2 > 0) {
      notebook.moveCell(firstIndex, lastIndex, lastIndex - firstIndex);
    } else {
      notebook.moveCell(firstIndex, firstIndex + shift2, lastIndex - firstIndex);
    }
    void Private$2.handleState(notebook, state, true);
  }
  function moveDown(notebook) {
    move(notebook, 1);
  }
  NotebookActions2.moveDown = moveDown;
  function moveUp(notebook) {
    move(notebook, -1);
  }
  NotebookActions2.moveUp = moveUp;
  function changeCellType(notebook, value, translator) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    Private$2.changeCellType(notebook, value, translator);
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.changeCellType = changeCellType;
  function run(notebook, sessionContext, sessionDialogs, translator) {
    if (!notebook.model || !notebook.activeCell) {
      return Promise.resolve(false);
    }
    const state = Private$2.getState(notebook);
    const promise = Private$2.runSelected(notebook, sessionContext, sessionDialogs, translator);
    void Private$2.handleRunState(notebook, state);
    return promise;
  }
  NotebookActions2.run = run;
  function runCells(notebook, cells, sessionContext, sessionDialogs, translator) {
    if (!notebook.model) {
      return Promise.resolve(false);
    }
    const state = Private$2.getState(notebook);
    const promise = Private$2.runCells(notebook, cells, sessionContext, sessionDialogs, translator);
    void Private$2.handleRunState(notebook, state);
    return promise;
  }
  NotebookActions2.runCells = runCells;
  async function runAndAdvance(notebook, sessionContext, sessionDialogs, translator) {
    var _a;
    if (!notebook.model || !notebook.activeCell) {
      return Promise.resolve(false);
    }
    const state = Private$2.getState(notebook);
    const promise = Private$2.runSelected(notebook, sessionContext, sessionDialogs, translator);
    const model = notebook.model;
    if (notebook.activeCellIndex === notebook.widgets.length - 1) {
      model.sharedModel.insertCell(notebook.widgets.length, {
        cell_type: notebook.notebookConfig.defaultCell,
        metadata: notebook.notebookConfig.defaultCell === "code" ? {
          // This is an empty cell created by user, thus is trusted
          trusted: true
        } : {}
      });
      notebook.activeCellIndex++;
      if (((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.inViewport) === false) {
        await lib$9.signalToPromise(notebook.activeCell.inViewportChanged, 200).catch(() => {
        });
      }
      notebook.mode = "edit";
    } else {
      notebook.activeCellIndex++;
    }
    void Private$2.handleRunState(notebook, state, "center");
    return promise;
  }
  NotebookActions2.runAndAdvance = runAndAdvance;
  async function runAndInsert(notebook, sessionContext, sessionDialogs, translator) {
    var _a;
    if (!notebook.model || !notebook.activeCell) {
      return Promise.resolve(false);
    }
    const state = Private$2.getState(notebook);
    const promise = Private$2.runSelected(notebook, sessionContext, sessionDialogs, translator);
    const model = notebook.model;
    model.sharedModel.insertCell(notebook.activeCellIndex + 1, {
      cell_type: notebook.notebookConfig.defaultCell,
      metadata: notebook.notebookConfig.defaultCell === "code" ? {
        // This is an empty cell created by user, thus is trusted
        trusted: true
      } : {}
    });
    notebook.activeCellIndex++;
    if (((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.inViewport) === false) {
      await lib$9.signalToPromise(notebook.activeCell.inViewportChanged, 200).catch(() => {
      });
    }
    notebook.mode = "edit";
    void Private$2.handleRunState(notebook, state, "center");
    return promise;
  }
  NotebookActions2.runAndInsert = runAndInsert;
  function runAll(notebook, sessionContext, sessionDialogs, translator) {
    if (!notebook.model || !notebook.activeCell) {
      return Promise.resolve(false);
    }
    const state = Private$2.getState(notebook);
    const lastIndex = notebook.widgets.length;
    const promise = Private$2.runCells(notebook, notebook.widgets, sessionContext, sessionDialogs, translator);
    notebook.activeCellIndex = lastIndex;
    notebook.deselectAll();
    void Private$2.handleRunState(notebook, state);
    return promise;
  }
  NotebookActions2.runAll = runAll;
  function renderAllMarkdown(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return Promise.resolve(false);
    }
    const previousIndex = notebook.activeCellIndex;
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((child, index) => {
      if (child.model.type === "markdown") {
        notebook.select(child);
        notebook.activeCellIndex = index;
      }
    });
    if (notebook.activeCell.model.type !== "markdown") {
      return Promise.resolve(true);
    }
    const promise = Private$2.runSelected(notebook);
    notebook.activeCellIndex = previousIndex;
    void Private$2.handleRunState(notebook, state);
    return promise;
  }
  NotebookActions2.renderAllMarkdown = renderAllMarkdown;
  function runAllAbove(notebook, sessionContext, sessionDialogs, translator) {
    const { activeCell, activeCellIndex, model } = notebook;
    if (!model || !activeCell || activeCellIndex < 1) {
      return Promise.resolve(false);
    }
    const state = Private$2.getState(notebook);
    const promise = Private$2.runCells(notebook, notebook.widgets.slice(0, notebook.activeCellIndex), sessionContext, sessionDialogs, translator);
    notebook.deselectAll();
    void Private$2.handleRunState(notebook, state);
    return promise;
  }
  NotebookActions2.runAllAbove = runAllAbove;
  function runAllBelow(notebook, sessionContext, sessionDialogs, translator) {
    if (!notebook.model || !notebook.activeCell) {
      return Promise.resolve(false);
    }
    const state = Private$2.getState(notebook);
    const lastIndex = notebook.widgets.length;
    const promise = Private$2.runCells(notebook, notebook.widgets.slice(notebook.activeCellIndex), sessionContext, sessionDialogs, translator);
    notebook.activeCellIndex = lastIndex;
    notebook.deselectAll();
    void Private$2.handleRunState(notebook, state);
    return promise;
  }
  NotebookActions2.runAllBelow = runAllBelow;
  function replaceSelection(notebook, text2) {
    var _a, _b, _c;
    if (!notebook.model || !((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.editor)) {
      return;
    }
    (_c = (_b = notebook.activeCell.editor).replaceSelection) === null || _c === void 0 ? void 0 : _c.call(_b, text2);
  }
  NotebookActions2.replaceSelection = replaceSelection;
  function selectAbove(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const footer = notebook.layout.footer;
    if (footer && document.activeElement === footer.node) {
      footer.node.blur();
      notebook.mode = "command";
      return;
    }
    if (notebook.activeCellIndex === 0) {
      return;
    }
    let possibleNextCellIndex = notebook.activeCellIndex - 1;
    while (possibleNextCellIndex >= 0) {
      const possibleNextCell = notebook.widgets[possibleNextCellIndex];
      if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {
        break;
      }
      possibleNextCellIndex -= 1;
    }
    const state = Private$2.getState(notebook);
    notebook.activeCellIndex = possibleNextCellIndex;
    notebook.deselectAll();
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.selectAbove = selectAbove;
  function selectBelow(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    let maxCellIndex = notebook.widgets.length - 1;
    while (notebook.widgets[maxCellIndex].isHidden || notebook.widgets[maxCellIndex].inputHidden) {
      maxCellIndex -= 1;
    }
    if (notebook.activeCellIndex === maxCellIndex) {
      const footer = notebook.layout.footer;
      footer === null || footer === void 0 ? void 0 : footer.node.focus();
      return;
    }
    let possibleNextCellIndex = notebook.activeCellIndex + 1;
    while (possibleNextCellIndex < maxCellIndex) {
      let possibleNextCell = notebook.widgets[possibleNextCellIndex];
      if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {
        break;
      }
      possibleNextCellIndex += 1;
    }
    const state = Private$2.getState(notebook);
    notebook.activeCellIndex = possibleNextCellIndex;
    notebook.deselectAll();
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.selectBelow = selectBelow;
  async function insertSameLevelHeadingAbove(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    let headingLevel = Private$2.Headings.determineHeadingLevel(notebook.activeCell, notebook);
    if (headingLevel == -1) {
      await Private$2.Headings.insertHeadingAboveCellIndex(0, 1, notebook);
    } else {
      await Private$2.Headings.insertHeadingAboveCellIndex(notebook.activeCellIndex, headingLevel, notebook);
    }
  }
  NotebookActions2.insertSameLevelHeadingAbove = insertSameLevelHeadingAbove;
  async function insertSameLevelHeadingBelow(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    let headingLevel = Private$2.Headings.determineHeadingLevel(notebook.activeCell, notebook);
    headingLevel = headingLevel > -1 ? headingLevel : 1;
    let cellIdxOfHeadingBelow = Private$2.Headings.findLowerEqualLevelHeadingBelow(notebook.activeCell, notebook, true);
    await Private$2.Headings.insertHeadingAboveCellIndex(cellIdxOfHeadingBelow == -1 ? notebook.model.cells.length : cellIdxOfHeadingBelow, headingLevel, notebook);
  }
  NotebookActions2.insertSameLevelHeadingBelow = insertSameLevelHeadingBelow;
  function selectHeadingAboveOrCollapseHeading(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    let hInfoActiveCell = getHeadingInfo(notebook.activeCell);
    if (hInfoActiveCell.isHeading && !hInfoActiveCell.collapsed) {
      setHeadingCollapse(notebook.activeCell, true, notebook);
    } else {
      let targetHeadingCellIdx = Private$2.Headings.findLowerEqualLevelParentHeadingAbove(notebook.activeCell, notebook, true);
      if (targetHeadingCellIdx > -1) {
        notebook.activeCellIndex = targetHeadingCellIdx;
      }
    }
    notebook.deselectAll();
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.selectHeadingAboveOrCollapseHeading = selectHeadingAboveOrCollapseHeading;
  function selectHeadingBelowOrExpandHeading(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    let hInfo = getHeadingInfo(notebook.activeCell);
    if (hInfo.isHeading && hInfo.collapsed) {
      setHeadingCollapse(notebook.activeCell, false, notebook);
    } else {
      let targetHeadingCellIdx = Private$2.Headings.findHeadingBelow(
        notebook.activeCell,
        notebook,
        true
        // return index of heading cell
      );
      if (targetHeadingCellIdx > -1) {
        notebook.activeCellIndex = targetHeadingCellIdx;
      }
    }
    notebook.deselectAll();
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.selectHeadingBelowOrExpandHeading = selectHeadingBelowOrExpandHeading;
  function extendSelectionAbove(notebook, toTop = false) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    if (notebook.activeCellIndex === 0) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.mode = "command";
    if (toTop) {
      notebook.extendContiguousSelectionTo(0);
    } else {
      notebook.extendContiguousSelectionTo(notebook.activeCellIndex - 1);
    }
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.extendSelectionAbove = extendSelectionAbove;
  function extendSelectionBelow(notebook, toBottom = false) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    if (notebook.activeCellIndex === notebook.widgets.length - 1) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.mode = "command";
    if (toBottom) {
      notebook.extendContiguousSelectionTo(notebook.widgets.length - 1);
    } else {
      notebook.extendContiguousSelectionTo(notebook.activeCellIndex + 1);
    }
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.extendSelectionBelow = extendSelectionBelow;
  function selectAll(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    notebook.widgets.forEach((child) => {
      notebook.select(child);
    });
  }
  NotebookActions2.selectAll = selectAll;
  function deselectAll(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    notebook.deselectAll();
  }
  NotebookActions2.deselectAll = deselectAll;
  function copy2(notebook) {
    Private$2.copyOrCut(notebook, false);
  }
  NotebookActions2.copy = copy2;
  function cut(notebook) {
    Private$2.copyOrCut(notebook, true);
  }
  NotebookActions2.cut = cut;
  function paste(notebook, mode = "below") {
    const clipboard = Clipboard.getInstance();
    if (!clipboard.hasData(JUPYTER_CELL_MIME$1)) {
      return;
    }
    const values = clipboard.getData(JUPYTER_CELL_MIME$1);
    addCells(notebook, mode, values, true);
    void focusActiveCell(notebook);
  }
  NotebookActions2.paste = paste;
  function duplicate(notebook, mode = "below") {
    const values = Private$2.selectedCells(notebook);
    if (!values || values.length === 0) {
      return;
    }
    addCells(notebook, mode, values, false);
  }
  NotebookActions2.duplicate = duplicate;
  function addCells(notebook, mode = "below", values, cellsFromClipboard = false) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    const model = notebook.model;
    notebook.mode = "command";
    let index = 0;
    const prevActiveCellIndex = notebook.activeCellIndex;
    model.sharedModel.transact(() => {
      switch (mode) {
        case "below":
          index = notebook.activeCellIndex + 1;
          break;
        case "belowSelected":
          notebook.widgets.forEach((child, childIndex) => {
            if (notebook.isSelectedOrActive(child)) {
              index = childIndex + 1;
            }
          });
          break;
        case "above":
          index = notebook.activeCellIndex;
          break;
        case "replace": {
          const toDelete = [];
          notebook.widgets.forEach((child, index2) => {
            const deletable = child.model.sharedModel.getMetadata("deletable") !== false;
            if (notebook.isSelectedOrActive(child) && deletable) {
              toDelete.push(index2);
            }
          });
          if (toDelete.length > 0) {
            toDelete.reverse().forEach((i2) => {
              model.sharedModel.deleteCell(i2);
            });
          }
          index = toDelete[0];
          break;
        }
      }
      model.sharedModel.insertCells(index, values.map((cell) => {
        cell.id = cell.cell_type === "code" && notebook.lastClipboardInteraction === "cut" && typeof cell.id === "string" ? cell.id : void 0;
        return cell;
      }));
    });
    notebook.activeCellIndex = prevActiveCellIndex + values.length;
    notebook.deselectAll();
    if (cellsFromClipboard) {
      notebook.lastClipboardInteraction = "paste";
    }
    void Private$2.handleState(notebook, state, true);
  }
  function undo(notebook) {
    if (!notebook.model) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.mode = "command";
    notebook.model.sharedModel.undo();
    notebook.deselectAll();
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.undo = undo;
  function redo(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.mode = "command";
    notebook.model.sharedModel.redo();
    notebook.deselectAll();
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.redo = redo;
  function toggleAllLineNumbers(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    const config2 = notebook.editorConfig;
    const lineNumbers = !(config2.code.lineNumbers && config2.markdown.lineNumbers && config2.raw.lineNumbers);
    const newConfig = {
      code: { ...config2.code, lineNumbers },
      markdown: { ...config2.markdown, lineNumbers },
      raw: { ...config2.raw, lineNumbers }
    };
    notebook.editorConfig = newConfig;
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.toggleAllLineNumbers = toggleAllLineNumbers;
  function clearOutputs(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    let index = -1;
    for (const cell of notebook.model.cells) {
      const child = notebook.widgets[++index];
      if (notebook.isSelectedOrActive(child) && cell.type === "code") {
        cell.sharedModel.transact(() => {
          cell.clearExecution();
          child.outputHidden = false;
        }, false);
        Private$2.outputCleared.emit({ notebook, cell: child });
      }
    }
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.clearOutputs = clearOutputs;
  function clearAllOutputs(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    let index = -1;
    for (const cell of notebook.model.cells) {
      const child = notebook.widgets[++index];
      if (cell.type === "code") {
        cell.sharedModel.transact(() => {
          cell.clearExecution();
          child.outputHidden = false;
        }, false);
        Private$2.outputCleared.emit({ notebook, cell: child });
      }
    }
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.clearAllOutputs = clearAllOutputs;
  function hideCode(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((cell) => {
      if (notebook.isSelectedOrActive(cell) && cell.model.type === "code") {
        cell.inputHidden = true;
      }
    });
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.hideCode = hideCode;
  function showCode(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((cell) => {
      if (notebook.isSelectedOrActive(cell) && cell.model.type === "code") {
        cell.inputHidden = false;
      }
    });
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.showCode = showCode;
  function hideAllCode(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((cell) => {
      if (cell.model.type === "code") {
        cell.inputHidden = true;
      }
    });
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.hideAllCode = hideAllCode;
  function showAllCode(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((cell) => {
      if (cell.model.type === "code") {
        cell.inputHidden = false;
      }
    });
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.showAllCode = showAllCode;
  function hideOutput(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((cell) => {
      if (notebook.isSelectedOrActive(cell) && cell.model.type === "code") {
        cell.outputHidden = true;
      }
    });
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.hideOutput = hideOutput;
  function showOutput(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((cell) => {
      if (notebook.isSelectedOrActive(cell) && cell.model.type === "code") {
        cell.outputHidden = false;
      }
    });
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.showOutput = showOutput;
  function toggleOutput(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    for (const cell of notebook.widgets) {
      if (notebook.isSelectedOrActive(cell) && cell.model.type === "code") {
        if (cell.outputHidden === false) {
          return hideOutput(notebook);
        }
      }
    }
    return showOutput(notebook);
  }
  NotebookActions2.toggleOutput = toggleOutput;
  function hideAllOutputs(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((cell) => {
      if (cell.model.type === "code") {
        cell.outputHidden = true;
      }
    });
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.hideAllOutputs = hideAllOutputs;
  function renderSideBySide(notebook) {
    notebook.renderingLayout = "side-by-side";
  }
  NotebookActions2.renderSideBySide = renderSideBySide;
  function renderDefault(notebook) {
    notebook.renderingLayout = "default";
  }
  NotebookActions2.renderDefault = renderDefault;
  function showAllOutputs(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((cell) => {
      if (cell.model.type === "code") {
        cell.outputHidden = false;
      }
    });
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.showAllOutputs = showAllOutputs;
  function enableOutputScrolling(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((cell) => {
      if (notebook.isSelectedOrActive(cell) && cell.model.type === "code") {
        cell.outputsScrolled = true;
      }
    });
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.enableOutputScrolling = enableOutputScrolling;
  function disableOutputScrolling(notebook) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    notebook.widgets.forEach((cell) => {
      if (notebook.isSelectedOrActive(cell) && cell.model.type === "code") {
        cell.outputsScrolled = false;
      }
    });
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.disableOutputScrolling = disableOutputScrolling;
  function selectLastRunCell(notebook) {
    let latestTime = null;
    let latestCellIdx = null;
    notebook.widgets.forEach((cell, cellIndx) => {
      if (cell.model.type === "code") {
        const execution = cell.model.getMetadata("execution");
        if (execution && JSONExt.isObject(execution) && execution["iopub.status.busy"] !== void 0) {
          const timestamp = execution["iopub.status.busy"].toString();
          if (timestamp) {
            const startTime = new Date(timestamp);
            if (!latestTime || startTime >= latestTime) {
              latestTime = startTime;
              latestCellIdx = cellIndx;
            }
          }
        }
      }
    });
    if (latestCellIdx !== null) {
      notebook.activeCellIndex = latestCellIdx;
    }
  }
  NotebookActions2.selectLastRunCell = selectLastRunCell;
  function setMarkdownHeader(notebook, level, translator) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = Private$2.getState(notebook);
    const cells = notebook.model.cells;
    level = Math.min(Math.max(level, 1), 6);
    notebook.widgets.forEach((child, index) => {
      if (notebook.isSelectedOrActive(child)) {
        Private$2.setMarkdownHeader(cells.get(index), level);
      }
    });
    Private$2.changeCellType(notebook, "markdown", translator);
    void Private$2.handleState(notebook, state);
  }
  NotebookActions2.setMarkdownHeader = setMarkdownHeader;
  function collapseAllHeadings(notebook) {
    const state = Private$2.getState(notebook);
    for (const cell of notebook.widgets) {
      if (NotebookActions2.getHeadingInfo(cell).isHeading) {
        NotebookActions2.setHeadingCollapse(cell, true, notebook);
        NotebookActions2.setCellCollapse(cell, true);
      }
    }
    notebook.activeCellIndex = 0;
    void Private$2.handleState(notebook, state, true);
  }
  NotebookActions2.collapseAllHeadings = collapseAllHeadings;
  function expandAllHeadings(notebook) {
    for (const cell of notebook.widgets) {
      if (NotebookActions2.getHeadingInfo(cell).isHeading) {
        NotebookActions2.setHeadingCollapse(cell, false, notebook);
        NotebookActions2.setCellCollapse(cell, false);
      }
    }
  }
  NotebookActions2.expandAllHeadings = expandAllHeadings;
  function findNearestParentHeader(cell, notebook) {
    const index = findIndex(notebook.widgets, (possibleCell, index2) => {
      return cell.model.id === possibleCell.model.id;
    });
    if (index === -1) {
      return;
    }
    if (index >= notebook.widgets.length) {
      return;
    }
    let childHeaderInfo = getHeadingInfo(notebook.widgets[index]);
    for (let cellN = index - 1; cellN >= 0; cellN--) {
      if (cellN < notebook.widgets.length) {
        let hInfo = getHeadingInfo(notebook.widgets[cellN]);
        if (hInfo.isHeading && hInfo.headingLevel < childHeaderInfo.headingLevel) {
          return notebook.widgets[cellN];
        }
      }
    }
    return;
  }
  function expandParent(cell, notebook) {
    let nearestParentCell = findNearestParentHeader(cell, notebook);
    if (!nearestParentCell) {
      return;
    }
    if (!getHeadingInfo(nearestParentCell).collapsed && !nearestParentCell.isHidden) {
      return;
    }
    if (nearestParentCell.isHidden) {
      expandParent(nearestParentCell, notebook);
    }
    if (getHeadingInfo(nearestParentCell).collapsed) {
      setHeadingCollapse(nearestParentCell, false, notebook);
    }
  }
  NotebookActions2.expandParent = expandParent;
  function findNextParentHeading(cell, notebook) {
    let index = findIndex(notebook.widgets, (possibleCell, index2) => {
      return cell.model.id === possibleCell.model.id;
    });
    if (index === -1) {
      return -1;
    }
    let childHeaderInfo = getHeadingInfo(cell);
    for (index = index + 1; index < notebook.widgets.length; index++) {
      let hInfo = getHeadingInfo(notebook.widgets[index]);
      if (hInfo.isHeading && hInfo.headingLevel <= childHeaderInfo.headingLevel) {
        return index;
      }
    }
    return notebook.widgets.length;
  }
  NotebookActions2.findNextParentHeading = findNextParentHeading;
  function setHeadingCollapse(cell, collapsing, notebook) {
    const which = findIndex(notebook.widgets, (possibleCell, index) => {
      return cell.model.id === possibleCell.model.id;
    });
    if (which === -1) {
      return -1;
    }
    if (!notebook.widgets.length) {
      return which + 1;
    }
    let selectedHeadingInfo = NotebookActions2.getHeadingInfo(cell);
    if (cell.isHidden || !(cell instanceof MarkdownCell) || !selectedHeadingInfo.isHeading) {
      return which + 1;
    }
    let localCollapsed = false;
    let localCollapsedLevel = 0;
    let cellNum;
    for (cellNum = which + 1; cellNum < notebook.widgets.length; cellNum++) {
      let subCell = notebook.widgets[cellNum];
      let subCellHeadingInfo = NotebookActions2.getHeadingInfo(subCell);
      if (subCellHeadingInfo.isHeading && subCellHeadingInfo.headingLevel <= selectedHeadingInfo.headingLevel) {
        cellNum -= 1;
        break;
      }
      if (localCollapsed && subCellHeadingInfo.isHeading && subCellHeadingInfo.headingLevel <= localCollapsedLevel) {
        localCollapsed = false;
      }
      if (collapsing || localCollapsed) {
        subCell.setHidden(true);
        continue;
      }
      if (subCellHeadingInfo.collapsed && subCellHeadingInfo.isHeading) {
        localCollapsed = true;
        localCollapsedLevel = subCellHeadingInfo.headingLevel;
      }
      subCell.setHidden(false);
    }
    if (cellNum === notebook.widgets.length) {
      cell.numberChildNodes = cellNum - which - 1;
    } else {
      cell.numberChildNodes = cellNum - which;
    }
    NotebookActions2.setCellCollapse(cell, collapsing);
    return cellNum + 1;
  }
  NotebookActions2.setHeadingCollapse = setHeadingCollapse;
  function toggleCurrentHeadingCollapse(notebook) {
    if (!notebook.activeCell || notebook.activeCellIndex === void 0) {
      return;
    }
    let headingInfo = NotebookActions2.getHeadingInfo(notebook.activeCell);
    if (headingInfo.isHeading) {
      NotebookActions2.setHeadingCollapse(notebook.activeCell, !headingInfo.collapsed, notebook);
    }
    notebook.scrollToItem(notebook.activeCellIndex).catch((reason) => {
    });
  }
  NotebookActions2.toggleCurrentHeadingCollapse = toggleCurrentHeadingCollapse;
  function setCellCollapse(cell, collapsing) {
    if (cell instanceof MarkdownCell) {
      cell.headingCollapsed = collapsing;
    } else {
      cell.setHidden(collapsing);
    }
  }
  NotebookActions2.setCellCollapse = setCellCollapse;
  function getHeadingInfo(cell) {
    if (!(cell instanceof MarkdownCell)) {
      return { isHeading: false, headingLevel: 7 };
    }
    let level = cell.headingInfo.level;
    let collapsed = cell.headingCollapsed;
    return { isHeading: level > 0, headingLevel: level, collapsed };
  }
  NotebookActions2.getHeadingInfo = getHeadingInfo;
  function trust(notebook, translator) {
    translator = translator || nullTranslator;
    const trans = translator.load("jupyterlab");
    if (!notebook.model) {
      return Promise.resolve();
    }
    const trusted = every$1(notebook.model.cells, (cell) => cell.trusted);
    const trustMessage = reactExports.createElement(
      "p",
      null,
      trans.__("A trusted Jupyter notebook may execute hidden malicious code when you open it."),
      reactExports.createElement("br", null),
      trans.__('Selecting "Trust" will re-render this notebook in a trusted state.'),
      reactExports.createElement("br", null),
      trans.__("For more information, see"),
      " ",
      reactExports.createElement("a", { href: "https://jupyter-server.readthedocs.io/en/stable/operators/security.html", target: "_blank", rel: "noopener noreferrer" }, trans.__("the Jupyter security documentation")),
      "."
    );
    if (trusted) {
      return showDialog({
        body: trans.__("Notebook is already trusted"),
        buttons: [Dialog.okButton()]
      }).then(() => void 0);
    }
    return showDialog({
      body: trustMessage,
      title: trans.__("Trust this notebook?"),
      buttons: [
        Dialog.cancelButton(),
        Dialog.warnButton({
          label: trans.__("Trust"),
          ariaLabel: trans.__("Confirm Trusting this notebook")
        })
      ]
      // FIXME?
    }).then((result2) => {
      if (result2.button.accept) {
        if (notebook.model) {
          for (const cell of notebook.model.cells) {
            cell.trusted = true;
          }
        }
      }
    });
  }
  NotebookActions2.trust = trust;
  async function focusActiveCell(notebook, options = { waitUntilReady: true, preventScroll: false }) {
    const { activeCell } = notebook;
    const { waitUntilReady, preventScroll } = options;
    if (!activeCell) {
      return;
    }
    if (waitUntilReady) {
      await activeCell.ready;
    }
    if (notebook.isDisposed || activeCell.isDisposed) {
      return;
    }
    activeCell.node.focus({
      preventScroll
    });
  }
  NotebookActions2.focusActiveCell = focusActiveCell;
  async function accessPreviousHistory(notebook) {
    if (!notebook.notebookConfig.accessKernelHistory) {
      return;
    }
    const activeCell = notebook.activeCell;
    if (activeCell) {
      if (notebook.kernelHistory) {
        const previousHistory = await notebook.kernelHistory.back(activeCell);
        notebook.kernelHistory.updateEditor(activeCell, previousHistory);
      }
    }
  }
  NotebookActions2.accessPreviousHistory = accessPreviousHistory;
  async function accessNextHistory(notebook) {
    if (!notebook.notebookConfig.accessKernelHistory) {
      return;
    }
    const activeCell = notebook.activeCell;
    if (activeCell) {
      if (notebook.kernelHistory) {
        const nextHistory = await notebook.kernelHistory.forward(activeCell);
        notebook.kernelHistory.updateEditor(activeCell, nextHistory);
      }
    }
  }
  NotebookActions2.accessNextHistory = accessNextHistory;
})(NotebookActions || (NotebookActions = {}));
var Private$2;
(function(Private2) {
  Private2.executed = new Signal({});
  Private2.executionScheduled = new Signal({});
  Private2.selectionExecuted = new Signal({});
  Private2.outputCleared = new Signal({});
  function getState2(notebook) {
    var _a, _b;
    return {
      wasFocused: notebook.node.contains(document.activeElement),
      activeCellId: (_b = (_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.model.id) !== null && _b !== void 0 ? _b : null
    };
  }
  Private2.getState = getState2;
  async function handleState(notebook, state, scrollIfNeeded = false) {
    const { activeCell, activeCellIndex } = notebook;
    if (scrollIfNeeded && activeCell) {
      await notebook.scrollToItem(activeCellIndex, "auto", 0).catch((reason) => {
      });
    }
    if (state.wasFocused || notebook.mode === "edit") {
      notebook.activate();
    }
  }
  Private2.handleState = handleState;
  async function handleRunState(notebook, state, alignPreference) {
    const { activeCell, activeCellIndex } = notebook;
    if (activeCell) {
      await notebook.scrollToItem(activeCellIndex, "smart", 0, alignPreference).catch((reason) => {
      });
    }
    if (state.wasFocused || notebook.mode === "edit") {
      notebook.activate();
    }
  }
  Private2.handleRunState = handleRunState;
  function runCells(notebook, cells, sessionContext, sessionDialogs, translator) {
    const lastCell = cells[-1];
    notebook.mode = "command";
    let initializingDialogShown = false;
    return Promise.all(cells.map((cell) => {
      if (cell.model.type === "code" && notebook.notebookConfig.enableKernelInitNotification && sessionContext && sessionContext.kernelDisplayStatus === "initializing" && !initializingDialogShown) {
        initializingDialogShown = true;
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        Notification.emit(trans.__(`Kernel '${sessionContext.kernelDisplayName}' for '${sessionContext.path}' is still initializing. You can run code cells when the kernel has initialized.`), "warning", {
          autoClose: false
        });
        return Promise.resolve(false);
      }
      if (cell.model.type === "code" && notebook.notebookConfig.enableKernelInitNotification && initializingDialogShown) {
        return Promise.resolve(false);
      }
      return runCell$1(notebook, cell, sessionContext, sessionDialogs, translator);
    })).then((results) => {
      if (notebook.isDisposed) {
        return false;
      }
      Private2.selectionExecuted.emit({
        notebook,
        lastCell
      });
      notebook.update();
      return results.every((result2) => result2);
    }).catch((reason) => {
      if (reason.message.startsWith("KernelReplyNotOK")) {
        cells.map((cell) => {
          if (cell.model.type === "code" && cell.model.executionCount == null) {
            cell.model.executionState = "idle";
          }
        });
      } else {
        throw reason;
      }
      Private2.selectionExecuted.emit({
        notebook,
        lastCell
      });
      notebook.update();
      return false;
    });
  }
  Private2.runCells = runCells;
  function runSelected(notebook, sessionContext, sessionDialogs, translator) {
    notebook.mode = "command";
    let lastIndex = notebook.activeCellIndex;
    const selected = notebook.widgets.filter((child, index) => {
      const active = notebook.isSelectedOrActive(child);
      if (active) {
        lastIndex = index;
      }
      return active;
    });
    notebook.activeCellIndex = lastIndex;
    notebook.deselectAll();
    return runCells(notebook, selected, sessionContext, sessionDialogs, translator);
  }
  Private2.runSelected = runSelected;
  async function runCell$1(notebook, cell, sessionContext, sessionDialogs, translator) {
    if (!Private2.executor) {
      console.warn("Requesting cell execution without any cell executor defined. Falling back to default execution.");
    }
    const options = {
      cell,
      notebook: notebook.model,
      notebookConfig: notebook.notebookConfig,
      onCellExecuted: (args) => {
        Private2.executed.emit({ notebook, ...args });
      },
      onCellExecutionScheduled: (args) => {
        Private2.executionScheduled.emit({ notebook, ...args });
      },
      sessionContext,
      sessionDialogs,
      translator
    };
    return Private2.executor ? Private2.executor.runCell(options) : runCell(options);
  }
  function selectedCells(notebook) {
    return notebook.widgets.filter((cell) => notebook.isSelectedOrActive(cell)).map((cell) => cell.model.toJSON()).map((cellJSON) => {
      if (cellJSON.metadata.deletable !== void 0) {
        delete cellJSON.metadata.deletable;
      }
      return cellJSON;
    });
  }
  Private2.selectedCells = selectedCells;
  function copyOrCut(notebook, cut) {
    if (!notebook.model || !notebook.activeCell) {
      return;
    }
    const state = getState2(notebook);
    const clipboard = Clipboard.getInstance();
    notebook.mode = "command";
    clipboard.clear();
    const data = Private2.selectedCells(notebook);
    clipboard.setData(JUPYTER_CELL_MIME$1, data);
    if (cut) {
      deleteCells(notebook);
    } else {
      notebook.deselectAll();
    }
    if (cut) {
      notebook.lastClipboardInteraction = "cut";
    } else {
      notebook.lastClipboardInteraction = "copy";
    }
    void handleState(notebook, state);
  }
  Private2.copyOrCut = copyOrCut;
  function changeCellType(notebook, value, translator) {
    const notebookSharedModel = notebook.model.sharedModel;
    notebook.widgets.forEach((child, index) => {
      if (!notebook.isSelectedOrActive(child)) {
        return;
      }
      if (child.model.type === "code" && child.outputArea.pendingInput) {
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        void showDialog({
          title: trans.__("Cell type not changed due to pending input"),
          body: trans.__("The cell type has not been changed to avoid kernel deadlock as this cell has pending input! Submit your pending input and try again."),
          buttons: [Dialog.okButton()]
        });
        return;
      }
      if (child.model.getMetadata("editable") == false) {
        translator = translator || nullTranslator;
        const trans = translator.load("jupyterlab");
        void showDialog({
          title: trans.__("Cell is read-only"),
          body: trans.__("The cell is read-only, its type cannot be changed!"),
          buttons: [Dialog.okButton()]
        });
        return;
      }
      if (child.model.type !== value) {
        const raw = child.model.toJSON();
        notebookSharedModel.transact(() => {
          notebookSharedModel.deleteCell(index);
          if (value === "code") {
            raw.metadata.trusted = true;
          } else {
            raw.metadata.trusted = void 0;
          }
          const newCell = notebookSharedModel.insertCell(index, {
            cell_type: value,
            source: raw.source,
            metadata: raw.metadata
          });
          if (raw.attachments && ["markdown", "raw"].includes(value)) {
            newCell.attachments = raw.attachments;
          }
        });
      }
      if (value === "markdown") {
        child = notebook.widgets[index];
        child.rendered = false;
      }
    });
    notebook.deselectAll();
  }
  Private2.changeCellType = changeCellType;
  function deleteCells(notebook) {
    const model = notebook.model;
    const sharedModel = model.sharedModel;
    const toDelete = [];
    notebook.mode = "command";
    notebook.widgets.forEach((child, index) => {
      var _a;
      const deletable = child.model.getMetadata("deletable") !== false;
      if (notebook.isSelectedOrActive(child) && deletable) {
        toDelete.push(index);
        (_a = notebook.model) === null || _a === void 0 ? void 0 : _a.deletedCells.push(child.model.id);
      }
    });
    if (toDelete.length > 0) {
      sharedModel.transact(() => {
        toDelete.reverse().forEach((index) => {
          sharedModel.deleteCell(index);
        });
        if (sharedModel.cells.length == toDelete.length) {
          sharedModel.insertCell(0, {
            cell_type: notebook.notebookConfig.defaultCell,
            metadata: notebook.notebookConfig.defaultCell === "code" ? {
              // This is an empty cell created in empty notebook, thus is trusted
              trusted: true
            } : {}
          });
        }
      });
      notebook.activeCellIndex = toDelete[0] - toDelete.length + 1;
    }
    notebook.deselectAll();
  }
  Private2.deleteCells = deleteCells;
  function setMarkdownHeader(cell, level) {
    let source = cell.sharedModel.getSource();
    const regex = /^(#+\s*)|^(\s*)/;
    const newHeader = Array(level + 1).join("#") + " ";
    const matches2 = regex.exec(source);
    if (matches2) {
      source = source.slice(matches2[0].length);
    }
    cell.sharedModel.setSource(newHeader + source);
  }
  Private2.setMarkdownHeader = setMarkdownHeader;
  (function(Headings) {
    function findParentHeading(childCell, notebook, includeChildCell = false, returnIndex = false) {
      let cellIdx = notebook.widgets.indexOf(childCell) - (includeChildCell ? 1 : 0);
      while (cellIdx >= 0) {
        let headingInfo = NotebookActions.getHeadingInfo(notebook.widgets[cellIdx]);
        if (headingInfo.isHeading) {
          return returnIndex ? cellIdx : notebook.widgets[cellIdx];
        }
        cellIdx--;
      }
      return returnIndex ? -1 : null;
    }
    Headings.findParentHeading = findParentHeading;
    function findLowerEqualLevelParentHeadingAbove(baseCell, notebook, returnIndex = false) {
      let baseHeadingLevel = Private2.Headings.determineHeadingLevel(baseCell, notebook);
      if (baseHeadingLevel == -1) {
        baseHeadingLevel = 1;
      }
      let cellIdx = notebook.widgets.indexOf(baseCell) - 1;
      while (cellIdx >= 0) {
        let cell = notebook.widgets[cellIdx];
        let headingInfo = NotebookActions.getHeadingInfo(cell);
        if (headingInfo.isHeading && headingInfo.headingLevel <= baseHeadingLevel) {
          return returnIndex ? cellIdx : cell;
        }
        cellIdx--;
      }
      return returnIndex ? -1 : null;
    }
    Headings.findLowerEqualLevelParentHeadingAbove = findLowerEqualLevelParentHeadingAbove;
    function findLowerEqualLevelHeadingBelow(baseCell, notebook, returnIndex = false) {
      let baseHeadingLevel = Private2.Headings.determineHeadingLevel(baseCell, notebook);
      if (baseHeadingLevel == -1) {
        baseHeadingLevel = 1;
      }
      let cellIdx = notebook.widgets.indexOf(baseCell) + 1;
      while (cellIdx < notebook.widgets.length) {
        let cell = notebook.widgets[cellIdx];
        let headingInfo = NotebookActions.getHeadingInfo(cell);
        if (headingInfo.isHeading && headingInfo.headingLevel <= baseHeadingLevel) {
          return returnIndex ? cellIdx : cell;
        }
        cellIdx++;
      }
      return returnIndex ? -1 : null;
    }
    Headings.findLowerEqualLevelHeadingBelow = findLowerEqualLevelHeadingBelow;
    function findHeadingBelow(baseCell, notebook, returnIndex = false) {
      let cellIdx = notebook.widgets.indexOf(baseCell) + 1;
      while (cellIdx < notebook.widgets.length) {
        let cell = notebook.widgets[cellIdx];
        let headingInfo = NotebookActions.getHeadingInfo(cell);
        if (headingInfo.isHeading) {
          return returnIndex ? cellIdx : cell;
        }
        cellIdx++;
      }
      return returnIndex ? -1 : null;
    }
    Headings.findHeadingBelow = findHeadingBelow;
    function determineHeadingLevel(baseCell, notebook) {
      let headingInfoBaseCell = NotebookActions.getHeadingInfo(baseCell);
      if (headingInfoBaseCell.isHeading) {
        return headingInfoBaseCell.headingLevel;
      } else {
        let parentHeading = findParentHeading(baseCell, notebook, true);
        if (parentHeading == null) {
          return -1;
        }
        return NotebookActions.getHeadingInfo(parentHeading).headingLevel;
      }
    }
    Headings.determineHeadingLevel = determineHeadingLevel;
    async function insertHeadingAboveCellIndex(cellIndex, headingLevel, notebook) {
      var _a;
      headingLevel = Math.min(Math.max(headingLevel, 1), 6);
      const state = Private2.getState(notebook);
      const model = notebook.model;
      const sharedModel = model.sharedModel;
      sharedModel.insertCell(cellIndex, {
        cell_type: "markdown",
        source: "#".repeat(headingLevel) + " "
      });
      notebook.activeCellIndex = cellIndex;
      if (((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.inViewport) === false) {
        await lib$9.signalToPromise(notebook.activeCell.inViewportChanged, 200).catch(() => {
        });
      }
      notebook.deselectAll();
      void Private2.handleState(notebook, state, true);
      notebook.mode = "edit";
      notebook.widgets[cellIndex].setHidden(false);
    }
    Headings.insertHeadingAboveCellIndex = insertHeadingAboveCellIndex;
  })(Private2.Headings || (Private2.Headings = {}));
})(Private$2 || (Private$2 = {}));
class CellList {
  /**
   * Construct the cell list.
   */
  constructor(model) {
    this.model = model;
    this._cellMap = /* @__PURE__ */ new WeakMap();
    this._changed = new Signal(this);
    this._isDisposed = false;
    this._insertCells(0, this.model.cells);
    this.model.changed.connect(this._onSharedModelChanged, this);
  }
  /**
   * A signal emitted when the cell list has changed.
   */
  get changed() {
    return this._changed;
  }
  /**
   * Test whether the cell list has been disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Get the length of the cell list.
   *
   * @returns The number of cells in the cell list.
   */
  get length() {
    return this.model.cells.length;
  }
  /**
   * Create an iterator over the cells in the cell list.
   *
   * @returns A new iterator starting at the front of the cell list.
   */
  *[Symbol.iterator]() {
    for (const cell of this.model.cells) {
      yield this._cellMap.get(cell);
    }
  }
  /**
   * Dispose of the resources held by the cell list.
   */
  dispose() {
    var _a;
    if (this._isDisposed) {
      return;
    }
    this._isDisposed = true;
    for (const cell of this.model.cells) {
      (_a = this._cellMap.get(cell)) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    Signal.clearData(this);
  }
  /**
   * Get the cell at the specified index.
   *
   * @param index - The positive integer index of interest.
   *
   * @returns The cell at the specified index.
   */
  get(index) {
    return this._cellMap.get(this.model.cells[index]);
  }
  _insertCells(index, cells) {
    cells.forEach((sharedModel) => {
      let cellModel;
      switch (sharedModel.cell_type) {
        case "code": {
          cellModel = new CodeCellModel({
            sharedModel
          });
          break;
        }
        case "markdown": {
          cellModel = new MarkdownCellModel({
            sharedModel
          });
          break;
        }
        default: {
          cellModel = new RawCellModel({
            sharedModel
          });
        }
      }
      this._cellMap.set(sharedModel, cellModel);
      sharedModel.disposed.connect(() => {
        cellModel.dispose();
        this._cellMap.delete(sharedModel);
      });
    });
    return this.length;
  }
  _onSharedModelChanged(self2, change) {
    var _a;
    let currpos = 0;
    const events = new Array();
    (_a = change.cellsChange) === null || _a === void 0 ? void 0 : _a.forEach((delta) => {
      if (delta.insert != null) {
        this._insertCells(currpos, delta.insert);
        events.push({
          type: "add",
          newIndex: currpos,
          newValues: delta.insert.map((c) => this._cellMap.get(c)),
          oldIndex: -2,
          oldValues: []
        });
        currpos += delta.insert.length;
      } else if (delta.delete != null) {
        events.push({
          type: "remove",
          newIndex: -1,
          newValues: [],
          oldIndex: currpos,
          // Cells have been disposed, so we don't know which one are gone.
          oldValues: new Array(delta.delete).fill(void 0)
        });
      } else if (delta.retain != null) {
        currpos += delta.retain;
      }
    });
    events.forEach((msg) => this._changed.emit(msg));
  }
}
class NotebookModel {
  /**
   * Construct a new notebook model.
   */
  constructor(options = {}) {
    var _a, _b;
    this.standaloneModel = false;
    this._dirty = false;
    this._readOnly = false;
    this._contentChanged = new Signal(this);
    this._stateChanged = new Signal(this);
    this._isDisposed = false;
    this._metadataChanged = new Signal(this);
    this.standaloneModel = typeof options.sharedModel === "undefined";
    if (options.sharedModel) {
      this.sharedModel = options.sharedModel;
    } else {
      this.sharedModel = YNotebook.create({
        disableDocumentWideUndoRedo: (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : true,
        data: {
          nbformat: MAJOR_VERSION,
          nbformat_minor: MINOR_VERSION,
          metadata: {
            kernelspec: { name: "", display_name: "" },
            language_info: { name: (_b = options.languagePreference) !== null && _b !== void 0 ? _b : "" }
          }
        }
      });
    }
    this._cells = new CellList(this.sharedModel);
    this._trans = (options.translator || nullTranslator).load("jupyterlab");
    this._deletedCells = [];
    this._collaborationEnabled = !!(options === null || options === void 0 ? void 0 : options.collaborationEnabled);
    this._cells.changed.connect(this._onCellsChanged, this);
    this.sharedModel.changed.connect(this._onStateChanged, this);
    this.sharedModel.metadataChanged.connect(this._onMetadataChanged, this);
  }
  /**
   * A signal emitted when the document content changes.
   */
  get contentChanged() {
    return this._contentChanged;
  }
  /**
   * Signal emitted when notebook metadata changes.
   */
  get metadataChanged() {
    return this._metadataChanged;
  }
  /**
   * A signal emitted when the document state changes.
   */
  get stateChanged() {
    return this._stateChanged;
  }
  /**
   * Get the observable list of notebook cells.
   */
  get cells() {
    return this._cells;
  }
  /**
   * The dirty state of the document.
   */
  get dirty() {
    return this._dirty;
  }
  set dirty(newValue) {
    const oldValue = this._dirty;
    if (newValue === oldValue) {
      return;
    }
    this._dirty = newValue;
    this.triggerStateChange({
      name: "dirty",
      oldValue,
      newValue
    });
  }
  /**
   * The read only state of the document.
   */
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(newValue) {
    if (newValue === this._readOnly) {
      return;
    }
    const oldValue = this._readOnly;
    this._readOnly = newValue;
    this.triggerStateChange({ name: "readOnly", oldValue, newValue });
  }
  /**
   * The metadata associated with the notebook.
   *
   * ### Notes
   * This is a copy of the metadata. Changing a part of it
   * won't affect the model.
   * As this returns a copy of all metadata, it is advised to
   * use `getMetadata` to speed up the process of getting a single key.
   */
  get metadata() {
    return this.sharedModel.metadata;
  }
  /**
   * The major version number of the nbformat.
   */
  get nbformat() {
    return this.sharedModel.nbformat;
  }
  /**
   * The minor version number of the nbformat.
   */
  get nbformatMinor() {
    return this.sharedModel.nbformat_minor;
  }
  /**
   * The default kernel name of the document.
   */
  get defaultKernelName() {
    var _a;
    const spec = this.getMetadata("kernelspec");
    return (_a = spec === null || spec === void 0 ? void 0 : spec.name) !== null && _a !== void 0 ? _a : "";
  }
  /**
   * A list of deleted cells for the notebook..
   */
  get deletedCells() {
    return this._deletedCells;
  }
  /**
   * The default kernel language of the document.
   */
  get defaultKernelLanguage() {
    var _a;
    const info = this.getMetadata("language_info");
    return (_a = info === null || info === void 0 ? void 0 : info.name) !== null && _a !== void 0 ? _a : "";
  }
  /**
   * Whether the model is collaborative or not.
   */
  get collaborative() {
    return this._collaborationEnabled;
  }
  /**
   * Dispose of the resources held by the model.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._isDisposed = true;
    const cells = this.cells;
    this._cells = null;
    cells.dispose();
    if (this.standaloneModel) {
      this.sharedModel.dispose();
    }
    Signal.clearData(this);
  }
  /**
   * Delete a metadata
   *
   * @param key Metadata key
   */
  deleteMetadata(key2) {
    return this.sharedModel.deleteMetadata(key2);
  }
  /**
   * Get a metadata
   *
   * ### Notes
   * This returns a copy of the key value.
   *
   * @param key Metadata key
   */
  getMetadata(key2) {
    return this.sharedModel.getMetadata(key2);
  }
  /**
   * Set a metadata
   *
   * @param key Metadata key
   * @param value Metadata value
   */
  setMetadata(key2, value) {
    if (typeof value === "undefined") {
      this.sharedModel.deleteMetadata(key2);
    } else {
      this.sharedModel.setMetadata(key2, value);
    }
  }
  /**
   * Serialize the model to a string.
   */
  toString() {
    return JSON.stringify(this.toJSON());
  }
  /**
   * Deserialize the model from a string.
   *
   * #### Notes
   * Should emit a [contentChanged] signal.
   */
  fromString(value) {
    this.fromJSON(JSON.parse(value));
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    this._ensureMetadata();
    return this.sharedModel.toJSON();
  }
  /**
   * Deserialize the model from JSON.
   *
   * #### Notes
   * Should emit a [contentChanged] signal.
   */
  fromJSON(value) {
    var _a, _b;
    const copy2 = JSONExt.deepCopy(value);
    const origNbformat = value.metadata.orig_nbformat;
    copy2.nbformat = Math.max(value.nbformat, MAJOR_VERSION);
    if (copy2.nbformat !== value.nbformat || copy2.nbformat_minor < MINOR_VERSION) {
      copy2.nbformat_minor = MINOR_VERSION;
    }
    if (origNbformat !== void 0 && copy2.nbformat !== origNbformat) {
      const newer = copy2.nbformat > origNbformat;
      let msg;
      if (newer) {
        msg = this._trans.__(`This notebook has been converted from an older notebook format (v%1)
to the current notebook format (v%2).
The next time you save this notebook, the current notebook format (v%2) will be used.
'Older versions of Jupyter may not be able to read the new format.' To preserve the original format version,
close the notebook without saving it.`, origNbformat, copy2.nbformat);
      } else {
        msg = this._trans.__(`This notebook has been converted from an newer notebook format (v%1)
to the current notebook format (v%2).
The next time you save this notebook, the current notebook format (v%2) will be used.
Some features of the original notebook may not be available.' To preserve the original format version,
close the notebook without saving it.`, origNbformat, copy2.nbformat);
      }
      void showDialog({
        title: this._trans.__("Notebook converted"),
        body: msg,
        buttons: [Dialog.okButton({ label: this._trans.__("Ok") })]
      });
    }
    if (((_b = (_a = copy2.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0) {
      copy2["cells"] = [
        { cell_type: "code", source: "", metadata: { trusted: true } }
      ];
    }
    this.sharedModel.fromJSON(copy2);
    this._ensureMetadata();
    this.dirty = true;
  }
  /**
   * Handle a change in the cells list.
   */
  _onCellsChanged(list2, change) {
    switch (change.type) {
      case "add":
        change.newValues.forEach((cell) => {
          cell.contentChanged.connect(this.triggerContentChange, this);
        });
        break;
      case "remove":
        break;
      case "set":
        change.newValues.forEach((cell) => {
          cell.contentChanged.connect(this.triggerContentChange, this);
        });
        break;
    }
    this.triggerContentChange();
  }
  _onMetadataChanged(sender, changes) {
    this._metadataChanged.emit(changes);
    this.triggerContentChange();
  }
  _onStateChanged(sender, changes) {
    if (changes.stateChange) {
      changes.stateChange.forEach((value) => {
        if (value.name === "dirty") {
          this.dirty = value.newValue;
        } else if (value.oldValue !== value.newValue) {
          this.triggerStateChange({
            newValue: void 0,
            oldValue: void 0,
            ...value
          });
        }
      });
    }
  }
  /**
   * Make sure we have the required metadata fields.
   */
  _ensureMetadata(languageName = "") {
    if (!this.getMetadata("language_info")) {
      this.sharedModel.setMetadata("language_info", { name: languageName });
    }
    if (!this.getMetadata("kernelspec")) {
      this.sharedModel.setMetadata("kernelspec", {
        name: "",
        display_name: ""
      });
    }
  }
  /**
   * Trigger a state change signal.
   */
  triggerStateChange(args) {
    this._stateChanged.emit(args);
  }
  /**
   * Trigger a content changed signal.
   */
  triggerContentChange() {
    this._contentChanged.emit(void 0);
    this.dirty = true;
  }
  /**
   * Whether the model is disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
}
class Context {
  /**
   * Construct a new document context.
   */
  constructor(options) {
    var _a, _b;
    this._isReady = false;
    this._isDisposed = false;
    this._isPopulated = false;
    this._path = "";
    this._lineEnding = null;
    this._contentsModel = null;
    this._populatedPromise = new PromiseDelegate();
    this._pathChanged = new Signal(this);
    this._fileChanged = new Signal(this);
    this._saveState = new Signal(this);
    this._disposed = new Signal(this);
    this._lastModifiedCheckMargin = 500;
    this._conflictModalIsOpen = false;
    const manager2 = this._manager = options.manager;
    this.translator = options.translator || nullTranslator;
    this._trans = this.translator.load("jupyterlab");
    this._factory = options.factory;
    this._dialogs = (_a = options.sessionDialogs) !== null && _a !== void 0 ? _a : new SessionContextDialogs({ translator: options.translator });
    this._opener = options.opener || Private$1.noOp;
    this._path = this._manager.contents.normalize(options.path);
    this._lastModifiedCheckMargin = options.lastModifiedCheckMargin || 500;
    const localPath = this._manager.contents.localPath(this._path);
    const lang = this._factory.preferredLanguage(lib$9.PathExt.basename(localPath));
    const sharedFactory = this._manager.contents.getSharedModelFactory(this._path);
    const sharedModel = sharedFactory === null || sharedFactory === void 0 ? void 0 : sharedFactory.createNew({
      path: localPath,
      format: this._factory.fileFormat,
      contentType: this._factory.contentType,
      collaborative: this._factory.collaborative
    });
    this._model = this._factory.createNew({
      languagePreference: lang,
      sharedModel,
      collaborationEnabled: (_b = sharedFactory === null || sharedFactory === void 0 ? void 0 : sharedFactory.collaborative) !== null && _b !== void 0 ? _b : false
    });
    this._readyPromise = manager2.ready.then(() => {
      return this._populatedPromise.promise;
    });
    const ext = lib$9.PathExt.extname(this._path);
    this.sessionContext = new SessionContext({
      kernelManager: manager2.kernels,
      sessionManager: manager2.sessions,
      specsManager: manager2.kernelspecs,
      path: localPath,
      type: ext === ".ipynb" ? "notebook" : "file",
      name: lib$9.PathExt.basename(localPath),
      kernelPreference: options.kernelPreference || { shouldStart: false },
      setBusy: options.setBusy
    });
    this.sessionContext.propertyChanged.connect(this._onSessionChanged, this);
    manager2.contents.fileChanged.connect(this._onFileChanged, this);
    this.urlResolver = new RenderMimeRegistry.UrlResolver({
      path: this._path,
      contents: manager2.contents
    });
  }
  /**
   * A signal emitted when the path changes.
   */
  get pathChanged() {
    return this._pathChanged;
  }
  /**
   * A signal emitted when the model is saved or reverted.
   */
  get fileChanged() {
    return this._fileChanged;
  }
  /**
   * A signal emitted on the start and end of a saving operation.
   */
  get saveState() {
    return this._saveState;
  }
  /**
   * A signal emitted when the context is disposed.
   */
  get disposed() {
    return this._disposed;
  }
  /**
   * Configurable margin used to detect document modification conflicts, in milliseconds
   */
  get lastModifiedCheckMargin() {
    return this._lastModifiedCheckMargin;
  }
  set lastModifiedCheckMargin(value) {
    this._lastModifiedCheckMargin = value;
  }
  /**
   * Get the model associated with the document.
   */
  get model() {
    return this._model;
  }
  /**
   * The current path associated with the document.
   */
  get path() {
    return this._path;
  }
  /**
   * The current local path associated with the document.
   * If the document is in the default notebook file browser,
   * this is the same as the path.
   */
  get localPath() {
    return this._manager.contents.localPath(this._path);
  }
  /**
   * The document metadata, stored as a services contents model.
   *
   * #### Notes
   * The contents model will be `null` until the context is populated.
   * It will not have a `content` field.
   */
  get contentsModel() {
    return this._contentsModel ? { ...this._contentsModel } : null;
  }
  /**
   * Get the model factory name.
   *
   * #### Notes
   * This is not part of the `IContext` API.
   */
  get factoryName() {
    return this.isDisposed ? "" : this._factory.name;
  }
  /**
   * Test whether the context is disposed.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of the resources held by the context.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._isDisposed = true;
    this.sessionContext.dispose();
    this._model.dispose();
    this._model.sharedModel.dispose();
    this._disposed.emit(void 0);
    Signal.clearData(this);
  }
  /**
   * Whether the context is ready.
   */
  get isReady() {
    return this._isReady;
  }
  /**
   * A promise that is fulfilled when the context is ready.
   */
  get ready() {
    return this._readyPromise;
  }
  /**
   * Whether the document can be saved via the Contents API.
   */
  get canSave() {
    var _a;
    return !!(((_a = this._contentsModel) === null || _a === void 0 ? void 0 : _a.writable) && !this._model.collaborative);
  }
  /**
   * Initialize the context.
   *
   * @param isNew - Whether it is a new file.
   *
   * @returns a promise that resolves upon initialization.
   */
  async initialize(isNew) {
    if (isNew) {
      await this._save();
    } else {
      await this._revert();
    }
    this.model.sharedModel.clearUndoHistory();
  }
  /**
   * Rename the document.
   *
   * @param newName - the new name for the document.
   */
  rename(newName) {
    return this.ready.then(() => {
      return this._manager.ready.then(() => {
        return this._rename(newName);
      });
    });
  }
  /**
   * Save the document contents to disk.
   */
  async save() {
    await this.ready;
    await this._save();
  }
  /**
   * Save the document to a different path chosen by the user.
   *
   * It will be rejected if the user abort providing a new path.
   */
  async saveAs() {
    await this.ready;
    const localPath = this._manager.contents.localPath(this.path);
    const newLocalPath = await Private$1.getSavePath(localPath);
    if (this.isDisposed || !newLocalPath) {
      return;
    }
    const drive = this._manager.contents.driveName(this.path);
    const newPath = drive == "" ? newLocalPath : `${drive}:${newLocalPath}`;
    if (newPath === this._path) {
      return this.save();
    }
    try {
      await this._manager.ready;
      await this._manager.contents.get(newPath);
      await this._maybeOverWrite(newPath);
    } catch (err) {
      if (!err.response || err.response.status !== 404) {
        throw err;
      }
      await this._finishSaveAs(newPath);
    }
  }
  /**
   * Download a file.
   *
   * @returns A promise which resolves when the file has begun
   *   downloading.
   */
  async download() {
    const url2 = await this._manager.contents.getDownloadUrl(this._path);
    const element = document.createElement("a");
    element.href = url2;
    element.download = "";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
    return void 0;
  }
  /**
   * Revert the document contents to disk contents.
   */
  async revert() {
    await this.ready;
    await this._revert();
  }
  /**
   * Create a checkpoint for the file.
   */
  createCheckpoint() {
    const contents2 = this._manager.contents;
    return this._manager.ready.then(() => {
      return contents2.createCheckpoint(this._path);
    });
  }
  /**
   * Delete a checkpoint for the file.
   */
  deleteCheckpoint(checkpointId) {
    const contents2 = this._manager.contents;
    return this._manager.ready.then(() => {
      return contents2.deleteCheckpoint(this._path, checkpointId);
    });
  }
  /**
   * Restore the file to a known checkpoint state.
   */
  restoreCheckpoint(checkpointId) {
    const contents2 = this._manager.contents;
    const path2 = this._path;
    return this._manager.ready.then(() => {
      if (checkpointId) {
        return contents2.restoreCheckpoint(path2, checkpointId);
      }
      return this.listCheckpoints().then((checkpoints) => {
        if (this.isDisposed || !checkpoints.length) {
          return;
        }
        checkpointId = checkpoints[checkpoints.length - 1].id;
        return contents2.restoreCheckpoint(path2, checkpointId);
      });
    });
  }
  /**
   * List available checkpoints for a file.
   */
  listCheckpoints() {
    const contents2 = this._manager.contents;
    return this._manager.ready.then(() => {
      return contents2.listCheckpoints(this._path);
    });
  }
  /**
   * Add a sibling widget to the document manager.
   *
   * @param widget - The widget to add to the document manager.
   *
   * @param options - The desired options for adding the sibling.
   *
   * @returns A disposable used to remove the sibling if desired.
   *
   * #### Notes
   * It is assumed that the widget has the same model and context
   * as the original widget.
   */
  addSibling(widget, options = {}) {
    const opener = this._opener;
    if (opener) {
      opener(widget, options);
    }
    return new DisposableDelegate(() => {
      widget.close();
    });
  }
  /**
   * Handle a change on the contents manager.
   */
  _onFileChanged(sender, change) {
    var _a;
    if (change.type === "save" && this._model.collaborative) {
      this._updateContentsModel({
        ...this._contentsModel,
        ...change.newValue
      });
      return;
    }
    if (change.type !== "rename") {
      return;
    }
    let oldPath = change.oldValue && change.oldValue.path;
    let newPath = change.newValue && change.newValue.path;
    if (newPath && this._path.indexOf(oldPath || "") === 0) {
      let changeModel = change.newValue;
      if (oldPath !== this._path) {
        newPath = this._path.replace(new RegExp(`^${oldPath}/`), `${newPath}/`);
        oldPath = this._path;
        changeModel = {
          last_modified: (_a = change.newValue) === null || _a === void 0 ? void 0 : _a.created,
          path: newPath
        };
      }
      this._updateContentsModel({
        ...this._contentsModel,
        ...changeModel
      });
      this._updatePath(newPath);
    }
  }
  /**
   * Handle a change to a session property.
   */
  _onSessionChanged(sender, type) {
    if (type !== "path") {
      return;
    }
    const driveName = this._manager.contents.driveName(this.path);
    let newPath = this.sessionContext.session.path;
    if (driveName) {
      newPath = `${driveName}:${newPath}`;
    }
    this._updatePath(newPath);
  }
  /**
   * Update our contents model, without the content.
   */
  _updateContentsModel(model) {
    var _a, _b, _c, _d;
    const writable = model.writable && !this._model.collaborative;
    const newModel = {
      path: model.path,
      name: model.name,
      type: model.type,
      writable,
      created: model.created,
      last_modified: model.last_modified,
      mimetype: model.mimetype,
      format: model.format,
      hash: model.hash,
      hash_algorithm: model.hash_algorithm
    };
    const mod = (_b = (_a = this._contentsModel) === null || _a === void 0 ? void 0 : _a.last_modified) !== null && _b !== void 0 ? _b : null;
    const hash = (_d = (_c = this._contentsModel) === null || _c === void 0 ? void 0 : _c.hash) !== null && _d !== void 0 ? _d : null;
    this._contentsModel = newModel;
    if (
      // If neither modification date nor hash available, assume the file has changed
      !mod && !hash || // Compare last_modified if no hash
      !hash && newModel.last_modified !== mod || // Compare hash if available
      hash && newModel.hash !== hash
    ) {
      this._fileChanged.emit(newModel);
    }
  }
  _updatePath(newPath) {
    var _a, _b, _c, _d;
    if (this._path === newPath) {
      return;
    }
    this._path = newPath;
    const localPath = this._manager.contents.localPath(newPath);
    const name2 = lib$9.PathExt.basename(localPath);
    if (((_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path) !== localPath) {
      void ((_b = this.sessionContext.session) === null || _b === void 0 ? void 0 : _b.setPath(localPath));
    }
    if (((_c = this.sessionContext.session) === null || _c === void 0 ? void 0 : _c.name) !== name2) {
      void ((_d = this.sessionContext.session) === null || _d === void 0 ? void 0 : _d.setName(name2));
    }
    if (this.urlResolver.path !== newPath) {
      this.urlResolver.path = newPath;
    }
    if (this._contentsModel && (this._contentsModel.path !== newPath || this._contentsModel.name !== name2)) {
      const contentsModel = {
        ...this._contentsModel,
        name: name2,
        path: newPath
      };
      this._updateContentsModel(contentsModel);
    }
    this._pathChanged.emit(newPath);
  }
  /**
   * Handle an initial population.
   */
  async _populate() {
    this._isPopulated = true;
    this._isReady = true;
    this._populatedPromise.resolve(void 0);
    await this._maybeCheckpoint(false);
    if (this.isDisposed) {
      return;
    }
    const name2 = this._model.defaultKernelName || this.sessionContext.kernelPreference.name;
    this.sessionContext.kernelPreference = {
      ...this.sessionContext.kernelPreference,
      name: name2,
      language: this._model.defaultKernelLanguage
    };
    void this.sessionContext.initialize().then((shouldSelect) => {
      if (shouldSelect) {
        void this._dialogs.selectKernel(this.sessionContext);
      }
    });
  }
  /**
   * Rename the document.
   *
   * @param newName - the new name for the document.
   */
  async _rename(newName) {
    const splitPath = this.localPath.split("/");
    splitPath[splitPath.length - 1] = newName;
    let newPath = lib$9.PathExt.join(...splitPath);
    const driveName = this._manager.contents.driveName(this.path);
    if (driveName) {
      newPath = `${driveName}:${newPath}`;
    }
    await this._manager.contents.rename(this.path, newPath);
  }
  /**
   * Save the document contents to disk.
   */
  async _save() {
    this._saveState.emit("started");
    const options = this._createSaveOptions();
    try {
      await this._manager.ready;
      const value = await this._maybeSave(options);
      if (this.isDisposed) {
        return;
      }
      this._model.dirty = false;
      this._updateContentsModel(value);
      if (!this._isPopulated) {
        await this._populate();
      }
      this._saveState.emit("completed");
    } catch (err) {
      const { name: name2 } = err;
      if (name2 === "ModalCancelError" || name2 === "ModalDuplicateError") {
        throw err;
      }
      const localPath = this._manager.contents.localPath(this._path);
      const file = lib$9.PathExt.basename(localPath);
      void this._handleError(err, this._trans.__("File Save Error for %1", file));
      this._saveState.emit("failed");
      throw err;
    }
  }
  /**
   * Revert the document contents to disk contents.
   *
   * @param initializeModel - call the model's initialization function after
   * deserializing the content.
   */
  _revert(initializeModel = false) {
    const opts = {
      type: this._factory.contentType,
      content: this._factory.fileFormat !== null,
      hash: this._factory.fileFormat !== null,
      ...this._factory.fileFormat !== null ? { format: this._factory.fileFormat } : {}
    };
    const path2 = this._path;
    const model = this._model;
    return this._manager.ready.then(() => {
      return this._manager.contents.get(path2, opts);
    }).then((contents2) => {
      if (this.isDisposed) {
        return;
      }
      if (contents2.content) {
        if (contents2.format === "json") {
          model.fromJSON(contents2.content);
        } else {
          let content = contents2.content;
          if (content.indexOf("\r\n") !== -1) {
            this._lineEnding = "\r\n";
            content = content.replace(/\r\n/g, "\n");
          } else if (content.indexOf("\r") !== -1) {
            this._lineEnding = "\r";
            content = content.replace(/\r/g, "\n");
          } else {
            this._lineEnding = null;
          }
          model.fromString(content);
        }
      }
      this._updateContentsModel(contents2);
      model.dirty = false;
      if (!this._isPopulated) {
        return this._populate();
      }
    }).catch(async (err) => {
      const localPath = this._manager.contents.localPath(this._path);
      const name2 = lib$9.PathExt.basename(localPath);
      void this._handleError(err, this._trans.__("File Load Error for %1", name2));
      throw err;
    });
  }
  /**
   * Save a file, dealing with conflicts.
   */
  _maybeSave(options) {
    const path2 = this._path;
    const promise = this._manager.contents.get(path2, {
      content: false,
      hash: true
    });
    return promise.then((model) => {
      var _a, _b, _c, _d;
      if (this.isDisposed) {
        return Promise.reject(new Error("Disposed"));
      }
      const hashAvailable = ((_a = this.contentsModel) === null || _a === void 0 ? void 0 : _a.hash) !== void 0 && ((_b = this.contentsModel) === null || _b === void 0 ? void 0 : _b.hash) !== null && model.hash !== void 0 && model.hash !== null;
      const hClient = (_c = this.contentsModel) === null || _c === void 0 ? void 0 : _c.hash;
      const hDisk = model.hash;
      if (hashAvailable && hClient !== hDisk) {
        console.warn(`Different hash found for ${this.path}`);
        return this._raiseConflict(model, options);
      }
      const lastModifiedCheckMargin = this._lastModifiedCheckMargin;
      const modified = (_d = this.contentsModel) === null || _d === void 0 ? void 0 : _d.last_modified;
      const tClient = modified ? new Date(modified) : /* @__PURE__ */ new Date();
      const tDisk = new Date(model.last_modified);
      if (!hashAvailable && modified && tDisk.getTime() - tClient.getTime() > lastModifiedCheckMargin) {
        console.warn(`Last saving performed ${tClient} while the current file seems to have been saved ${tDisk}`);
        return this._raiseConflict(model, options);
      }
      return this._manager.contents.save(path2, options).then(async (contentsModel) => {
        const model2 = await this._manager.contents.get(path2, {
          content: false,
          hash: true
        });
        return {
          ...contentsModel,
          hash: model2.hash,
          hash_algorithm: model2.hash_algorithm
        };
      });
    }, (err) => {
      if (err.response && err.response.status === 404) {
        return this._manager.contents.save(path2, options).then(async (contentsModel) => {
          const model = await this._manager.contents.get(path2, {
            content: false,
            hash: true
          });
          return {
            ...contentsModel,
            hash: model.hash,
            hash_algorithm: model.hash_algorithm
          };
        });
      }
      throw err;
    });
  }
  /**
   * Handle a save/load error with a dialog.
   */
  async _handleError(err, title) {
    await showErrorMessage(title, err);
    return;
  }
  /**
   * Add a checkpoint the file is writable.
   */
  _maybeCheckpoint(force) {
    let promise = Promise.resolve(void 0);
    if (!this.canSave) {
      return promise;
    }
    if (force) {
      promise = this.createCheckpoint().then(
        /* no-op */
      );
    } else {
      promise = this.listCheckpoints().then((checkpoints) => {
        if (!this.isDisposed && !checkpoints.length && this.canSave) {
          return this.createCheckpoint().then(
            /* no-op */
          );
        }
      });
    }
    return promise.catch((err) => {
      if (!err.response || err.response.status !== 403) {
        throw err;
      }
    });
  }
  /**
   * Handle a time conflict.
   */
  _raiseConflict(model, options) {
    if (this._conflictModalIsOpen) {
      const error = new Error("Modal is already displayed");
      error.name = "ModalDuplicateError";
      return Promise.reject(error);
    }
    const body = this._trans.__(`"%1" has changed on disk since the last time it was opened or saved.
Do you want to overwrite the file on disk with the version open here,
or load the version on disk (revert)?`, this.path);
    const revertBtn = Dialog.okButton({
      label: this._trans.__("Revert"),
      actions: ["revert"]
    });
    const overwriteBtn = Dialog.warnButton({
      label: this._trans.__("Overwrite"),
      actions: ["overwrite"]
    });
    this._conflictModalIsOpen = true;
    return showDialog({
      title: this._trans.__("File Changed"),
      body,
      buttons: [Dialog.cancelButton(), revertBtn, overwriteBtn]
    }).then((result2) => {
      this._conflictModalIsOpen = false;
      if (this.isDisposed) {
        return Promise.reject(new Error("Disposed"));
      }
      if (result2.button.actions.includes("overwrite")) {
        return this._manager.contents.save(this._path, options);
      }
      if (result2.button.actions.includes("revert")) {
        return this.revert().then(() => {
          return model;
        });
      }
      const error = new Error("Cancel");
      error.name = "ModalCancelError";
      return Promise.reject(error);
    });
  }
  /**
   * Handle a time conflict.
   */
  _maybeOverWrite(path2) {
    const body = this._trans.__('"%1" already exists. Do you want to replace it?', path2);
    const overwriteBtn = Dialog.warnButton({
      label: this._trans.__("Overwrite"),
      accept: true
    });
    return showDialog({
      title: this._trans.__("File Overwrite?"),
      body,
      buttons: [Dialog.cancelButton(), overwriteBtn]
    }).then((result2) => {
      if (this.isDisposed) {
        return Promise.reject(new Error("Disposed"));
      }
      if (result2.button.accept) {
        return this._manager.contents.delete(path2).then(() => {
          return this._finishSaveAs(path2);
        });
      }
    });
  }
  /**
   * Finish a saveAs operation given a new path.
   */
  async _finishSaveAs(newPath) {
    this._saveState.emit("started");
    try {
      await this._manager.ready;
      const options = this._createSaveOptions();
      await this._manager.contents.save(newPath, options);
      await this._maybeCheckpoint(true);
      this._saveState.emit("completed");
    } catch (err) {
      if (err.message === "Cancel" || err.message === "Modal is already displayed") {
        throw err;
      }
      const localPath = this._manager.contents.localPath(this._path);
      const name2 = lib$9.PathExt.basename(localPath);
      void this._handleError(err, this._trans.__("File Save Error for %1", name2));
      this._saveState.emit("failed");
      return;
    }
  }
  _createSaveOptions() {
    let content = null;
    if (this._factory.fileFormat === "json") {
      content = this._model.toJSON();
    } else {
      content = this._model.toString();
      if (this._lineEnding) {
        content = content.replace(/\n/g, this._lineEnding);
      }
    }
    return {
      type: this._factory.contentType,
      format: this._factory.fileFormat,
      content
    };
  }
}
var Private$1;
(function(Private2) {
  function getSavePath(path2, translator) {
    translator = translator || nullTranslator;
    const trans = translator.load("jupyterlab");
    const saveBtn = Dialog.okButton({ label: trans.__("Save"), accept: true });
    return showDialog({
      title: trans.__("Save File As"),
      body: new SaveWidget(path2),
      buttons: [Dialog.cancelButton(), saveBtn]
    }).then((result2) => {
      var _a;
      if (result2.button.accept) {
        return (_a = result2.value) !== null && _a !== void 0 ? _a : void 0;
      }
      return;
    });
  }
  Private2.getSavePath = getSavePath;
  function noOp() {
  }
  Private2.noOp = noOp;
  class SaveWidget extends Widget {
    /**
     * Construct a new save widget.
     */
    constructor(path2) {
      super({ node: createSaveNode(path2) });
    }
    /**
     * Get the value for the widget.
     */
    getValue() {
      return this.node.value;
    }
  }
  function createSaveNode(path2) {
    const input2 = document.createElement("input");
    input2.value = path2;
    return input2;
  }
})(Private$1 || (Private$1 = {}));
function createReadonlyLabel(panel, translator) {
  var _a;
  let trans = nullTranslator.load("jupyterlab");
  return ReactWidget.create(reactExports.createElement(
    "div",
    null,
    reactExports.createElement("span", { className: "jp-ToolbarLabelComponent", title: trans.__(`Document is read-only. "Save" is disabled; use "Save as" instead`) }, trans.__(`%1 is read-only`, (_a = panel.context.contentsModel) === null || _a === void 0 ? void 0 : _a.type))
  ));
}
class DocumentModel extends CodeEditor.Model {
  /**
   * Construct a new document model.
   */
  constructor(options = {}) {
    var _a;
    super({ sharedModel: options.sharedModel });
    this._defaultLang = "";
    this._dirty = false;
    this._readOnly = false;
    this._contentChanged = new Signal(this);
    this._stateChanged = new Signal(this);
    this._defaultLang = (_a = options.languagePreference) !== null && _a !== void 0 ? _a : "";
    this._collaborationEnabled = !!options.collaborationEnabled;
    this.sharedModel.changed.connect(this._onStateChanged, this);
  }
  /**
   * A signal emitted when the document content changes.
   */
  get contentChanged() {
    return this._contentChanged;
  }
  /**
   * A signal emitted when the document state changes.
   */
  get stateChanged() {
    return this._stateChanged;
  }
  /**
   * The dirty state of the document.
   */
  get dirty() {
    return this._dirty;
  }
  set dirty(newValue) {
    const oldValue = this._dirty;
    if (newValue === oldValue) {
      return;
    }
    this._dirty = newValue;
    this.triggerStateChange({
      name: "dirty",
      oldValue,
      newValue
    });
  }
  /**
   * The read only state of the document.
   */
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(newValue) {
    if (newValue === this._readOnly) {
      return;
    }
    const oldValue = this._readOnly;
    this._readOnly = newValue;
    this.triggerStateChange({ name: "readOnly", oldValue, newValue });
  }
  /**
   * The default kernel name of the document.
   *
   * #### Notes
   * This is a read-only property.
   */
  get defaultKernelName() {
    return "";
  }
  /**
   * The default kernel language of the document.
   *
   * #### Notes
   * This is a read-only property.
   */
  get defaultKernelLanguage() {
    return this._defaultLang;
  }
  /**
   * Whether the model is collaborative or not.
   */
  get collaborative() {
    return this._collaborationEnabled;
  }
  /**
   * Serialize the model to a string.
   */
  toString() {
    return this.sharedModel.getSource();
  }
  /**
   * Deserialize the model from a string.
   *
   * #### Notes
   * Should emit a [contentChanged] signal.
   */
  fromString(value) {
    this.sharedModel.setSource(value);
  }
  /**
   * Serialize the model to JSON.
   */
  toJSON() {
    return JSON.parse(this.sharedModel.getSource() || "null");
  }
  /**
   * Deserialize the model from JSON.
   *
   * #### Notes
   * Should emit a [contentChanged] signal.
   */
  fromJSON(value) {
    this.fromString(JSON.stringify(value));
  }
  /**
   * Initialize the model with its current state.
   */
  initialize() {
    return;
  }
  /**
   * Trigger a state change signal.
   */
  triggerStateChange(args) {
    this._stateChanged.emit(args);
  }
  /**
   * Trigger a content changed signal.
   */
  triggerContentChange() {
    this._contentChanged.emit(void 0);
    this.dirty = true;
  }
  _onStateChanged(sender, changes) {
    if (changes.sourceChange) {
      this.triggerContentChange();
    }
    if (changes.stateChange) {
      changes.stateChange.forEach((value) => {
        if (value.name === "dirty") {
          this.dirty = value.newValue;
        } else if (value.oldValue !== value.newValue) {
          this.triggerStateChange({
            newValue: void 0,
            oldValue: void 0,
            ...value
          });
        }
      });
    }
  }
}
const DIRTY_CLASS$1 = "jp-mod-dirty";
class DocumentWidget extends MainAreaWidget {
  constructor(options) {
    var _a;
    options.reveal = Promise.all([options.reveal, options.context.ready]);
    super(options);
    this._trans = ((_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator).load("jupyterlab");
    this.context = options.context;
    this.context.pathChanged.connect(this._onPathChanged, this);
    this._onPathChanged(this.context, this.context.path);
    this.context.model.stateChanged.connect(this._onModelStateChanged, this);
    void this.context.ready.then(() => {
      this._handleDirtyState();
    });
    this.title.changed.connect(this._onTitleChanged, this);
  }
  /**
   * Set URI fragment identifier.
   */
  setFragment(fragment) {
  }
  /**
   * Handle a title change.
   */
  async _onTitleChanged(_sender) {
    const validNameExp = /[\/\\:]/;
    const name2 = this.title.label;
    const filename = this.context.localPath.split("/").pop() || this.context.localPath;
    if (name2 === filename) {
      return;
    }
    if (name2.length > 0 && !validNameExp.test(name2)) {
      const oldPath = this.context.path;
      await this.context.rename(name2);
      if (this.context.path !== oldPath) {
        return;
      }
    }
    this.title.label = filename;
  }
  /**
   * Handle a path change.
   */
  _onPathChanged(sender, path2) {
    this.title.label = lib$9.PathExt.basename(sender.localPath);
    this.isUntitled = false;
  }
  /**
   * Handle a change to the context model state.
   */
  _onModelStateChanged(sender, args) {
    var _a;
    if (args.name === "dirty") {
      this._handleDirtyState();
    }
    if (!this.context.model.dirty) {
      if (!this.context.model.collaborative) {
        if (!((_a = this.context.contentsModel) === null || _a === void 0 ? void 0 : _a.writable)) {
          const readOnlyIndicator = createReadonlyLabel(this);
          let roi = this.toolbar.insertBefore("kernelName", "read-only-indicator", readOnlyIndicator);
          if (!roi) {
            this.toolbar.addItem("read-only-indicator", readOnlyIndicator);
          }
        }
      }
    }
  }
  /**
   * Handle the dirty state of the context model.
   */
  _handleDirtyState() {
    if (this.context.model.dirty && !this.title.className.includes(DIRTY_CLASS$1)) {
      this.title.className += ` ${DIRTY_CLASS$1}`;
    } else {
      this.title.className = this.title.className.replace(DIRTY_CLASS$1, "");
    }
  }
}
const DROP_TARGET_CLASS = "jp-mod-dropTarget";
const DROP_SOURCE_CLASS = "jp-mod-dropSource";
class NotebookViewModel extends WindowedListModel {
  /**
   * Construct a notebook windowed list model.
   */
  constructor(cells, options) {
    super(options);
    this.cells = cells;
    this.estimateWidgetSize = (index) => {
      const model = this.cells[index].model;
      const height = this.cellsEstimatedHeight.get(model.id);
      if (typeof height === "number") {
        return height;
      }
      const nLines = model.sharedModel.getSource().split("\n").length;
      let outputsLines = 0;
      if (model instanceof CodeCellModel) {
        for (let outputIdx = 0; outputIdx < model.outputs.length; outputIdx++) {
          const output = model.outputs.get(outputIdx);
          const data = output.data["text/plain"];
          if (typeof data === "string") {
            outputsLines += data.split("\n").length;
          } else if (Array.isArray(data)) {
            outputsLines += data.join("").split("\n").length;
          }
        }
      }
      return NotebookViewModel.DEFAULT_EDITOR_LINE_HEIGHT * (nLines + outputsLines) + NotebookViewModel.DEFAULT_CELL_MARGIN;
    };
    this.widgetRenderer = (index) => {
      return this.cells[index];
    };
    this.scrollDownThreshold = NotebookViewModel.DEFAULT_CELL_MARGIN / 2 + NotebookViewModel.DEFAULT_EDITOR_LINE_HEIGHT;
    this.scrollUpThreshold = NotebookViewModel.DEFAULT_CELL_MARGIN / 2;
    this.cellsEstimatedHeight = /* @__PURE__ */ new Map();
    this._emitEstimatedHeightChanged = new Debouncer(() => {
      this._stateChanged.emit({
        name: "estimatedWidgetSize",
        newValue: null,
        oldValue: null
      });
    });
    this._estimatedWidgetSize = NotebookViewModel.DEFAULT_CELL_SIZE;
  }
  /**
   * Set an estimated height for a cell
   *
   * @param cellId Cell ID
   * @param size Cell height
   */
  setEstimatedWidgetSize(cellId, size2) {
    if (size2 === null) {
      if (this.cellsEstimatedHeight.has(cellId)) {
        this.cellsEstimatedHeight.delete(cellId);
      }
    } else {
      this.cellsEstimatedHeight.set(cellId, size2);
      this._emitEstimatedHeightChanged.invoke().catch((error) => {
        console.error("Fail to trigger an update following a estimated height update.", error);
      });
    }
  }
}
NotebookViewModel.DEFAULT_CELL_SIZE = 39;
NotebookViewModel.DEFAULT_EDITOR_LINE_HEIGHT = 17;
NotebookViewModel.DEFAULT_CELL_MARGIN = 22;
class NotebookWindowedLayout extends WindowedLayout {
  constructor() {
    super(...arguments);
    this._header = null;
    this._footer = null;
    this._willBeRemoved = null;
    this._topHiddenCodeCells = -1;
  }
  /**
   * Notebook's header
   */
  get header() {
    return this._header;
  }
  set header(header) {
    var _a;
    if (this._header && this._header.isAttached) {
      Widget.detach(this._header);
    }
    this._header = header;
    if (this._header && ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isAttached)) {
      Widget.attach(this._header, this.parent.node);
    }
  }
  /**
   * Notebook widget's footer
   */
  get footer() {
    return this._footer;
  }
  set footer(footer) {
    var _a;
    if (this._footer && this._footer.isAttached) {
      Widget.detach(this._footer);
    }
    this._footer = footer;
    if (this._footer && ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isAttached)) {
      Widget.attach(this._footer, this.parent.outerNode);
    }
  }
  /**
   * Notebook's active cell
   */
  get activeCell() {
    return this._activeCell;
  }
  set activeCell(widget) {
    this._activeCell = widget;
  }
  /**
   * Dispose the layout
   * */
  dispose() {
    var _a, _b;
    if (this.isDisposed) {
      return;
    }
    (_a = this._header) === null || _a === void 0 ? void 0 : _a.dispose();
    (_b = this._footer) === null || _b === void 0 ? void 0 : _b.dispose();
    super.dispose();
  }
  /**
   * * A message handler invoked on a `'child-removed'` message.
   * *
   * @param widget - The widget to remove from the layout.
   *
   * #### Notes
   * A widget is automatically removed from the layout when its `parent`
   * is set to `null`. This method should only be invoked directly when
   * removing a widget from a layout which has yet to be installed on a
   * parent widget.
   *
   * This method does *not* modify the widget's `parent`.
   */
  removeWidget(widget) {
    const index = this.widgets.indexOf(widget);
    if (index >= 0) {
      this.removeWidgetAt(index);
    } else if (widget === this._willBeRemoved && this.parent) {
      this.detachWidget(index, widget);
    }
  }
  /**
   * Attach a widget to the parent's DOM node.
   *
   * @param index - The current index of the widget in the layout.
   *
   * @param widget - The widget to attach to the parent.
   *
   * #### Notes
   * This method is called automatically by the panel layout at the
   * appropriate time. It should not be called directly by user code.
   *
   * The default implementation adds the widgets's node to the parent's
   * node at the proper location, and sends the appropriate attach
   * messages to the widget if the parent is attached to the DOM.
   *
   * Subclasses may reimplement this method to control how the widget's
   * node is added to the parent's node.
   */
  attachWidget(index, widget) {
    const wasPlaceholder = widget.isPlaceholder();
    const isSoftHidden = this._isSoftHidden(widget);
    if (this.parent.isAttached && !isSoftHidden) {
      MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);
    }
    if (isSoftHidden) {
      this._toggleSoftVisibility(widget, true);
    }
    if (!wasPlaceholder && widget instanceof CodeCell && widget.node.parentElement) {
      widget.node.style.display = "";
      this._topHiddenCodeCells = -1;
    } else if (!isSoftHidden) {
      const siblingIndex = this._findNearestChildBinarySearch(this.parent.viewportNode.childElementCount - 1, 0, parseInt(widget.dataset.windowedListIndex, 10) + 1);
      let ref2 = this.parent.viewportNode.children[siblingIndex];
      this.parent.viewportNode.insertBefore(widget.node, ref2);
      if (this.parent.isAttached) {
        MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);
      }
    }
    widget.inViewport = true;
  }
  /**
   * Detach a widget from the parent's DOM node.
   *
   * @param index - The previous index of the widget in the layout.
   *
   * @param widget - The widget to detach from the parent.
   *
   * #### Notes
   * This method is called automatically by the panel layout at the
   * appropriate time. It should not be called directly by user code.
   *
   * The default implementation removes the widget's node from the
   * parent's node, and sends the appropriate detach messages to the
   * widget if the parent is attached to the DOM.
   *
   * Subclasses may reimplement this method to control how the widget's
   * node is removed from the parent's node.
   */
  detachWidget(index, widget) {
    widget.inViewport = false;
    if (widget === this.activeCell && widget !== this._willBeRemoved) {
      this._toggleSoftVisibility(widget, false);
      return;
    }
    if (
      // We detach the code cell currently dragged otherwise it won't be attached at the correct position
      widget instanceof CodeCell && !widget.node.classList.contains(DROP_SOURCE_CLASS) && widget !== this._willBeRemoved
    ) {
      widget.node.style.display = "none";
      this._topHiddenCodeCells = -1;
    } else {
      if (this.parent.isAttached) {
        MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);
      }
      this.parent.viewportNode.removeChild(widget.node);
      widget.node.classList.remove(DROP_TARGET_CLASS);
    }
    if (this.parent.isAttached) {
      MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);
    }
  }
  /**
   * Move a widget in the parent's DOM node.
   *
   * @param fromIndex - The previous index of the widget in the layout.
   *
   * @param toIndex - The current index of the widget in the layout.
   *
   * @param widget - The widget to move in the parent.
   *
   * #### Notes
   * This method is called automatically by the panel layout at the
   * appropriate time. It should not be called directly by user code.
   *
   * The default implementation moves the widget's node to the proper
   * location in the parent's node and sends the appropriate attach and
   * detach messages to the widget if the parent is attached to the DOM.
   *
   * Subclasses may reimplement this method to control how the widget's
   * node is moved in the parent's node.
   */
  moveWidget(fromIndex, toIndex, widget) {
    if (this._topHiddenCodeCells < 0) {
      this._topHiddenCodeCells = 0;
      for (let idx = 0; idx < this.parent.viewportNode.children.length; idx++) {
        const n = this.parent.viewportNode.children[idx];
        if (n.style.display == "none") {
          this._topHiddenCodeCells++;
        } else {
          break;
        }
      }
    }
    const ref2 = this.parent.viewportNode.children[toIndex + this._topHiddenCodeCells];
    if (fromIndex < toIndex) {
      ref2.insertAdjacentElement("afterend", widget.node);
    } else {
      ref2.insertAdjacentElement("beforebegin", widget.node);
    }
  }
  onAfterAttach(msg) {
    super.onAfterAttach(msg);
    if (this._header && !this._header.isAttached) {
      Widget.attach(this._header, this.parent.node, this.parent.node.firstElementChild);
    }
    if (this._footer && !this._footer.isAttached) {
      Widget.attach(this._footer, this.parent.outerNode);
    }
  }
  onBeforeDetach(msg) {
    var _a, _b;
    if ((_a = this._header) === null || _a === void 0 ? void 0 : _a.isAttached) {
      Widget.detach(this._header);
    }
    if ((_b = this._footer) === null || _b === void 0 ? void 0 : _b.isAttached) {
      Widget.detach(this._footer);
    }
    super.onBeforeDetach(msg);
  }
  /**
   * A message handler invoked on a `'child-removed'` message.
   *
   * @param msg Message
   */
  onChildRemoved(msg) {
    this._willBeRemoved = msg.child;
    super.onChildRemoved(msg);
    this._willBeRemoved = null;
  }
  /**
   * Toggle "soft" visibility of the widget.
   *
   * #### Notes
   * To ensure that user events reach the CodeMirror editor, this method
   * does not toggle `display` nor `visibility` which have side effects,
   * but instead hides it in the compositor and ensures that the bounding
   * box is has an area equal to zero.
   * To ensure we do not trigger style recalculation, we set the styles
   * directly on the node instead of using a class.
   */
  _toggleSoftVisibility(widget, show) {
    if (show) {
      widget.node.style.opacity = "";
      widget.node.style.height = "";
      widget.node.style.padding = "";
    } else {
      widget.node.style.opacity = "0";
      widget.node.style.height = "0";
      widget.node.style.padding = "0";
    }
  }
  _isSoftHidden(widget) {
    return widget.node.style.opacity === "0";
  }
  _findNearestChildBinarySearch(high, low, index) {
    while (low <= high) {
      const middle = low + Math.floor((high - low) / 2);
      const currentIndex = parseInt(this.parent.viewportNode.children[middle].dataset.windowedListIndex, 10);
      if (currentIndex === index) {
        return middle;
      } else if (currentIndex < index) {
        low = middle + 1;
      } else if (currentIndex > index) {
        high = middle - 1;
      }
    }
    if (low > 0) {
      return low;
    } else {
      return 0;
    }
  }
}
const NOTEBOOK_FOOTER_CLASS = "jp-Notebook-footer";
class NotebookFooter extends Widget {
  /**
   * Construct a footer widget.
   */
  constructor(notebook) {
    super({ node: document.createElement("button") });
    this.notebook = notebook;
    const trans = notebook.translator.load("jupyterlab");
    this.addClass(NOTEBOOK_FOOTER_CLASS);
    this.node.setAttribute("tabindex", "-1");
    this.node.innerText = trans.__("Click to add a cell.");
  }
  /**
   * Handle incoming events.
   */
  handleEvent(event2) {
    switch (event2.type) {
      case "click":
        this.onClick();
        break;
      case "keydown":
        if (event2.key === "ArrowUp") {
          this.onArrowUp();
          break;
        }
    }
  }
  /**
   * On single click (mouse event), insert a cell below (at the end of the notebook as default behavior).
   */
  onClick() {
    if (this.notebook.widgets.length > 0) {
      this.notebook.activeCellIndex = this.notebook.widgets.length - 1;
    }
    NotebookActions.insertBelow(this.notebook);
    void NotebookActions.focusActiveCell(this.notebook);
  }
  /**
   * On arrow up key pressed (keydown keyboard event).
   * @deprecated To be removed in v5, this is a no-op
   */
  onArrowUp() {
  }
  /*
   * Handle `after-detach` messages for the widget.
   */
  onAfterAttach(msg) {
    super.onAfterAttach(msg);
    this.node.addEventListener("click", this);
    this.node.addEventListener("keydown", this);
  }
  /**
   * Handle `before-detach` messages for the widget.
   */
  onBeforeDetach(msg) {
    this.node.removeEventListener("click", this);
    this.node.removeEventListener("keydown", this);
    super.onBeforeDetach(msg);
  }
}
const KERNEL_USER = "jpKernelUser";
const CODE_RUNNER = "jpCodeRunner";
const UNDOER = "jpUndoer";
const NB_CLASS = "jp-Notebook";
const NB_CELL_CLASS = "jp-Notebook-cell";
const EDIT_CLASS = "jp-mod-editMode";
const COMMAND_CLASS = "jp-mod-commandMode";
const ACTIVE_CLASS = "jp-mod-active";
const SELECTED_CLASS = "jp-mod-selected";
const DIRTY_CLASS = "jp-mod-dirty";
const OTHER_SELECTED_CLASS = "jp-mod-multiSelected";
const UNCONFINED_CLASS = "jp-mod-unconfined";
const READ_WRITE_CLASS = "jp-mod-readWrite";
const DRAG_IMAGE_CLASS = "jp-dragImage";
const SINGLE_DRAG_IMAGE_CLASS = "jp-dragImage-singlePrompt";
const CELL_DRAG_CONTENT_CLASS = "jp-dragImage-content";
const CELL_DRAG_PROMPT_CLASS = "jp-dragImage-prompt";
const CELL_DRAG_MULTIPLE_BACK = "jp-dragImage-multipleBack";
const JUPYTER_CELL_MIME = "application/vnd.jupyter.cells";
const DRAG_THRESHOLD = 5;
const MAXIMUM_TIME_REMAINING = 50;
const HEADING_COLLAPSER_CLASS = "jp-collapseHeadingButton";
const HEADING_COLLAPSER_VISBILITY_CONTROL_CLASS = "jp-mod-showHiddenCellsButton";
const SIDE_BY_SIDE_CLASS = "jp-mod-sideBySide";
if (window.requestIdleCallback === void 0) {
  window.requestIdleCallback = function(handler) {
    let startTime = Date.now();
    return setTimeout(function() {
      handler({
        didTimeout: false,
        timeRemaining: function() {
          return Math.max(0, 50 - (Date.now() - startTime));
        }
      });
    }, 1);
  };
  window.cancelIdleCallback = function(id) {
    clearTimeout(id);
  };
}
class StaticNotebook extends WindowedList {
  /**
   * Construct a notebook widget.
   */
  constructor(options) {
    var _a, _b, _c, _d, _e, _f;
    const cells = new Array();
    const windowingActive = ((_b = (_a = options.notebookConfig) === null || _a === void 0 ? void 0 : _a.windowingMode) !== null && _b !== void 0 ? _b : StaticNotebook.defaultNotebookConfig.windowingMode) === "full";
    super({
      model: new NotebookViewModel(cells, {
        overscanCount: (_d = (_c = options.notebookConfig) === null || _c === void 0 ? void 0 : _c.overscanCount) !== null && _d !== void 0 ? _d : StaticNotebook.defaultNotebookConfig.overscanCount,
        windowingActive
      }),
      layout: new NotebookWindowedLayout(),
      renderer: (_e = options.renderer) !== null && _e !== void 0 ? _e : WindowedList.defaultRenderer,
      scrollbar: false
    });
    this._cellCollapsed = new Signal(this);
    this._cellInViewportChanged = new Signal(this);
    this._renderingLayoutChanged = new Signal(this);
    this.addClass(NB_CLASS);
    this.cellsArray = cells;
    this._idleCallBack = null;
    this._editorConfig = StaticNotebook.defaultEditorConfig;
    this._notebookConfig = StaticNotebook.defaultNotebookConfig;
    this._mimetype = IEditorMimeTypeService.defaultMimeType;
    this._notebookModel = null;
    this._modelChanged = new Signal(this);
    this._modelContentChanged = new Signal(this);
    this.node.dataset[KERNEL_USER] = "true";
    this.node.dataset[UNDOER] = "true";
    this.node.dataset[CODE_RUNNER] = "true";
    this.rendermime = options.rendermime;
    this.translator = options.translator || nullTranslator;
    this.contentFactory = options.contentFactory;
    this.editorConfig = options.editorConfig || StaticNotebook.defaultEditorConfig;
    this.notebookConfig = options.notebookConfig || StaticNotebook.defaultNotebookConfig;
    this._updateNotebookConfig();
    this._mimetypeService = options.mimeTypeService;
    this.renderingLayout = (_f = options.notebookConfig) === null || _f === void 0 ? void 0 : _f.renderingLayout;
    this.kernelHistory = options.kernelHistory;
  }
  get cellCollapsed() {
    return this._cellCollapsed;
  }
  get cellInViewportChanged() {
    return this._cellInViewportChanged;
  }
  /**
   * A signal emitted when the model of the notebook changes.
   */
  get modelChanged() {
    return this._modelChanged;
  }
  /**
   * A signal emitted when the model content changes.
   *
   * #### Notes
   * This is a convenience signal that follows the current model.
   */
  get modelContentChanged() {
    return this._modelContentChanged;
  }
  /**
   * A signal emitted when the rendering layout of the notebook changes.
   */
  get renderingLayoutChanged() {
    return this._renderingLayoutChanged;
  }
  /**
   * The model for the widget.
   */
  get model() {
    return this._notebookModel;
  }
  set model(newValue) {
    var _a;
    newValue = newValue || null;
    if (this._notebookModel === newValue) {
      return;
    }
    const oldValue = this._notebookModel;
    this._notebookModel = newValue;
    this._onModelChanged(oldValue, newValue);
    this.onModelChanged(oldValue, newValue);
    this._modelChanged.emit(void 0);
    this.viewModel.itemsList = (_a = newValue === null || newValue === void 0 ? void 0 : newValue.cells) !== null && _a !== void 0 ? _a : null;
  }
  /**
   * Get the mimetype for code cells.
   */
  get codeMimetype() {
    return this._mimetype;
  }
  /**
   * A read-only sequence of the widgets in the notebook.
   */
  get widgets() {
    return this.cellsArray;
  }
  /**
   * A configuration object for cell editor settings.
   */
  get editorConfig() {
    return this._editorConfig;
  }
  set editorConfig(value) {
    this._editorConfig = value;
    this._updateEditorConfig();
  }
  /**
   * A configuration object for notebook settings.
   */
  get notebookConfig() {
    return this._notebookConfig;
  }
  set notebookConfig(value) {
    this._notebookConfig = value;
    this._updateNotebookConfig();
  }
  get renderingLayout() {
    return this._renderingLayout;
  }
  set renderingLayout(value) {
    var _a;
    this._renderingLayout = value;
    if (this._renderingLayout === "side-by-side") {
      this.node.classList.add(SIDE_BY_SIDE_CLASS);
    } else {
      this.node.classList.remove(SIDE_BY_SIDE_CLASS);
    }
    this._renderingLayoutChanged.emit((_a = this._renderingLayout) !== null && _a !== void 0 ? _a : "default");
  }
  /**
   * Dispose of the resources held by the widget.
   */
  dispose() {
    var _a;
    if (this.isDisposed) {
      return;
    }
    this._notebookModel = null;
    (_a = this.layout.header) === null || _a === void 0 ? void 0 : _a.dispose();
    super.dispose();
  }
  /**
   * Move cells preserving widget view state.
   *
   * #### Notes
   * This is required because at the model level a move is a deletion
   * followed by an insertion. Hence the view state is not preserved.
   *
   * @param from The index of the cell to move
   * @param to The new index of the cell
   * @param n Number of cells to move
   */
  moveCell(from2, to, n = 1) {
    if (!this.model) {
      return;
    }
    const boundedTo = Math.min(this.model.cells.length - 1, Math.max(0, to));
    if (boundedTo === from2) {
      return;
    }
    const viewModel = new Array(n);
    let dirtyState = new Array(n);
    for (let i2 = 0; i2 < n; i2++) {
      viewModel[i2] = {};
      const oldCell = this.widgets[from2 + i2];
      if (oldCell.model.type === "markdown") {
        for (const k of ["rendered", "headingCollapsed"]) {
          viewModel[i2][k] = oldCell[k];
        }
      } else if (oldCell.model.type === "code") {
        const oldCodeCell = oldCell.model;
        dirtyState[i2] = oldCodeCell.isDirty;
      }
    }
    this.model.sharedModel.moveCells(from2, boundedTo, n);
    for (let i2 = 0; i2 < n; i2++) {
      const newCell = this.widgets[to + i2];
      const view = viewModel[i2];
      for (const state in view) {
        newCell[state] = view[state];
      }
      if (from2 > to) {
        if (this.widgets[to + i2].model.type === "code") {
          this.widgets[to + i2].model.isDirty = dirtyState[i2];
        }
      } else {
        if (this.widgets[to + i2 - n + 1].model.type === "code") {
          this.widgets[to + i2 - n + 1].model.isDirty = dirtyState[i2];
        }
      }
    }
  }
  /**
   * Force rendering the cell outputs of a given cell if it is still a placeholder.
   *
   * #### Notes
   * The goal of this method is to allow search on cell outputs (that is based
   * on DOM tree introspection).
   *
   * @param index The cell index
   */
  renderCellOutputs(index) {
    const cell = this.viewModel.widgetRenderer(index);
    if (cell instanceof CodeCell && cell.isPlaceholder()) {
      cell.dataset.windowedListIndex = `${index}`;
      this.layout.insertWidget(index, cell);
      if (this.notebookConfig.windowingMode === "full") {
        requestAnimationFrame(() => {
          this.layout.removeWidget(cell);
        });
      }
    }
  }
  /**
   * Adds a message to the notebook as a header.
   */
  addHeader() {
    const trans = this.translator.load("jupyterlab");
    const info = new Widget();
    info.node.textContent = trans.__("The notebook is empty. Click the + button on the toolbar to add a new cell.");
    this.layout.header = info;
  }
  /**
   * Removes the header.
   */
  removeHeader() {
    var _a;
    (_a = this.layout.header) === null || _a === void 0 ? void 0 : _a.dispose();
    this.layout.header = null;
  }
  /**
   * Handle a new model.
   *
   * #### Notes
   * This method is called after the model change has been handled
   * internally and before the `modelChanged` signal is emitted.
   * The default implementation is a no-op.
   */
  onModelChanged(oldValue, newValue) {
  }
  /**
   * Handle changes to the notebook model content.
   *
   * #### Notes
   * The default implementation emits the `modelContentChanged` signal.
   */
  onModelContentChanged(model, args) {
    this._modelContentChanged.emit(void 0);
  }
  /**
   * Handle changes to the notebook model metadata.
   *
   * #### Notes
   * The default implementation updates the mimetypes of the code cells
   * when the `language_info` metadata changes.
   */
  onMetadataChanged(sender, args) {
    switch (args.key) {
      case "language_info":
        this._updateMimetype();
        break;
    }
  }
  /**
   * Handle a cell being inserted.
   *
   * The default implementation is a no-op
   */
  onCellInserted(index, cell) {
  }
  /**
   * Handle a cell being removed.
   *
   * The default implementation is a no-op
   */
  onCellRemoved(index, cell) {
  }
  /**
   * A message handler invoked on an `'update-request'` message.
   *
   * #### Notes
   * The default implementation of this handler is a no-op.
   */
  onUpdateRequest(msg) {
    if (this.notebookConfig.windowingMode === "defer") {
      void this._runOnIdleTime();
    } else {
      super.onUpdateRequest(msg);
    }
  }
  /**
   * Handle a new model on the widget.
   */
  _onModelChanged(oldValue, newValue) {
    var _a;
    if (oldValue) {
      oldValue.contentChanged.disconnect(this.onModelContentChanged, this);
      oldValue.metadataChanged.disconnect(this.onMetadataChanged, this);
      oldValue.cells.changed.disconnect(this._onCellsChanged, this);
      while (this.cellsArray.length) {
        this._removeCell(0);
      }
    }
    if (!newValue) {
      this._mimetype = IEditorMimeTypeService.defaultMimeType;
      return;
    }
    this._updateMimetype();
    const cells = newValue.cells;
    const collab = (_a = newValue.collaborative) !== null && _a !== void 0 ? _a : false;
    if (!collab && !cells.length) {
      newValue.sharedModel.insertCell(0, {
        cell_type: this.notebookConfig.defaultCell,
        metadata: this.notebookConfig.defaultCell === "code" ? {
          // This is an empty cell created in empty notebook, thus is trusted
          trusted: true
        } : {}
      });
    }
    let index = -1;
    for (const cell of cells) {
      this._insertCell(++index, cell);
    }
    newValue.cells.changed.connect(this._onCellsChanged, this);
    newValue.metadataChanged.connect(this.onMetadataChanged, this);
    newValue.contentChanged.connect(this.onModelContentChanged, this);
  }
  /**
   * Handle a change cells event.
   */
  _onCellsChanged(sender, args) {
    this.removeHeader();
    switch (args.type) {
      case "add": {
        let index = 0;
        index = args.newIndex;
        for (const value of args.newValues) {
          this._insertCell(index++, value);
        }
        this._updateDataWindowedListIndex(args.newIndex, this.model.cells.length, args.newValues.length);
        break;
      }
      case "remove":
        for (let length2 = args.oldValues.length; length2 > 0; length2--) {
          this._removeCell(args.oldIndex);
        }
        this._updateDataWindowedListIndex(args.oldIndex, this.model.cells.length + args.oldValues.length, -1 * args.oldValues.length);
        if (!sender.length) {
          const model = this.model;
          requestAnimationFrame(() => {
            if (model && !model.isDisposed && !model.sharedModel.cells.length) {
              model.sharedModel.insertCell(0, {
                cell_type: this.notebookConfig.defaultCell,
                metadata: this.notebookConfig.defaultCell === "code" ? {
                  // This is an empty cell created in empty notebook, thus is trusted
                  trusted: true
                } : {}
              });
            }
          });
        }
        break;
      default:
        return;
    }
    if (!this.model.sharedModel.cells.length) {
      this.addHeader();
    }
    this.update();
  }
  /**
   * Create a cell widget and insert into the notebook.
   */
  _insertCell(index, cell) {
    let widget;
    switch (cell.type) {
      case "code":
        widget = this._createCodeCell(cell);
        widget.model.mimeType = this._mimetype;
        break;
      case "markdown":
        widget = this._createMarkdownCell(cell);
        if (cell.sharedModel.getSource() === "") {
          widget.rendered = false;
        }
        break;
      default:
        widget = this._createRawCell(cell);
    }
    widget.inViewportChanged.connect(this._onCellInViewportChanged, this);
    widget.addClass(NB_CELL_CLASS);
    ArrayExt.insert(this.cellsArray, index, widget);
    this.onCellInserted(index, widget);
    this._scheduleCellRenderOnIdle();
  }
  /**
   * Create a code cell widget from a code cell model.
   */
  _createCodeCell(model) {
    const rendermime = this.rendermime;
    const contentFactory = this.contentFactory;
    const editorConfig = this.editorConfig.code;
    const options = {
      contentFactory,
      editorConfig,
      inputHistoryScope: this.notebookConfig.inputHistoryScope,
      maxNumberOutputs: this.notebookConfig.maxNumberOutputs,
      model,
      placeholder: this._notebookConfig.windowingMode !== "none",
      rendermime,
      translator: this.translator
    };
    const cell = this.contentFactory.createCodeCell(options);
    cell.syncCollapse = true;
    cell.syncEditable = true;
    cell.syncScrolled = true;
    cell.outputArea.inputRequested.connect((_, stdin) => {
      this._onInputRequested(cell).catch((reason) => {
        console.error("Failed to scroll to cell requesting input.", reason);
      });
      stdin.disposed.connect(() => {
        cell.node.focus();
      });
    });
    return cell;
  }
  /**
   * Create a markdown cell widget from a markdown cell model.
   */
  _createMarkdownCell(model) {
    const rendermime = this.rendermime;
    const contentFactory = this.contentFactory;
    const editorConfig = this.editorConfig.markdown;
    const options = {
      contentFactory,
      editorConfig,
      model,
      placeholder: this._notebookConfig.windowingMode !== "none",
      rendermime,
      showEditorForReadOnlyMarkdown: this._notebookConfig.showEditorForReadOnlyMarkdown
    };
    const cell = this.contentFactory.createMarkdownCell(options);
    cell.syncCollapse = true;
    cell.syncEditable = true;
    cell.headingCollapsedChanged.connect(this._onCellCollapsed, this);
    return cell;
  }
  /**
   * Create a raw cell widget from a raw cell model.
   */
  _createRawCell(model) {
    const contentFactory = this.contentFactory;
    const editorConfig = this.editorConfig.raw;
    const options = {
      editorConfig,
      model,
      contentFactory,
      placeholder: this._notebookConfig.windowingMode !== "none"
    };
    const cell = this.contentFactory.createRawCell(options);
    cell.syncCollapse = true;
    cell.syncEditable = true;
    return cell;
  }
  /**
   * Remove a cell widget.
   */
  _removeCell(index) {
    const widget = this.cellsArray[index];
    widget.parent = null;
    ArrayExt.removeAt(this.cellsArray, index);
    this.onCellRemoved(index, widget);
    widget.dispose();
  }
  /**
   * Update the mimetype of the notebook.
   */
  _updateMimetype() {
    var _a;
    const info = (_a = this._notebookModel) === null || _a === void 0 ? void 0 : _a.getMetadata("language_info");
    if (!info) {
      return;
    }
    this._mimetype = this._mimetypeService.getMimeTypeByLanguage(info);
    for (const widget of this.widgets) {
      if (widget.model.type === "code") {
        widget.model.mimeType = this._mimetype;
      }
    }
  }
  /**
   * Callback when a cell collapsed status changes.
   *
   * @param cell Cell changed
   * @param collapsed New collapsed status
   */
  _onCellCollapsed(cell, collapsed) {
    NotebookActions.setHeadingCollapse(cell, collapsed, this);
    this._cellCollapsed.emit(cell);
  }
  /**
   * Callback when a cell viewport status changes.
   *
   * @param cell Cell changed
   */
  _onCellInViewportChanged(cell) {
    this._cellInViewportChanged.emit(cell);
  }
  /**
   * Ensure to load in the DOM a cell requesting an user input
   *
   * @param cell Cell requesting an input
   */
  async _onInputRequested(cell) {
    if (!cell.inViewport) {
      const cellIndex = this.widgets.findIndex((c) => c === cell);
      if (cellIndex >= 0) {
        await this.scrollToItem(cellIndex);
        const inputEl = cell.node.querySelector(".jp-Stdin");
        if (inputEl) {
          ElementExt.scrollIntoViewIfNeeded(this.node, inputEl);
          inputEl.focus();
        }
      }
    }
  }
  _scheduleCellRenderOnIdle() {
    if (this.notebookConfig.windowingMode !== "none" && !this.isDisposed) {
      if (!this._idleCallBack) {
        this._idleCallBack = requestIdleCallback((deadline) => {
          this._idleCallBack = null;
          void this._runOnIdleTime(deadline.didTimeout ? MAXIMUM_TIME_REMAINING : deadline.timeRemaining());
        }, {
          timeout: 3e3
        });
      }
    }
  }
  _updateDataWindowedListIndex(start, end, delta) {
    for (let cellIdx = 0; cellIdx < this.viewportNode.childElementCount; cellIdx++) {
      const cell = this.viewportNode.children[cellIdx];
      const globalIndex = parseInt(cell.dataset.windowedListIndex, 10);
      if (globalIndex >= start && globalIndex < end) {
        cell.dataset.windowedListIndex = `${globalIndex + delta}`;
      }
    }
  }
  /**
   * Update editor settings for notebook cells.
   */
  _updateEditorConfig() {
    for (let i2 = 0; i2 < this.widgets.length; i2++) {
      const cell = this.widgets[i2];
      let config2 = {};
      switch (cell.model.type) {
        case "code":
          config2 = this._editorConfig.code;
          break;
        case "markdown":
          config2 = this._editorConfig.markdown;
          break;
        default:
          config2 = this._editorConfig.raw;
          break;
      }
      cell.updateEditorConfig({ ...config2 });
    }
  }
  async _runOnIdleTime(remainingTime = MAXIMUM_TIME_REMAINING) {
    const startTime = Date.now();
    let cellIdx = 0;
    while (Date.now() - startTime < remainingTime && cellIdx < this.cellsArray.length) {
      const cell = this.cellsArray[cellIdx];
      if (cell.isPlaceholder()) {
        if (["defer", "full"].includes(this.notebookConfig.windowingMode)) {
          await this._updateForDeferMode(cell, cellIdx);
          if (this.notebookConfig.windowingMode === "full") {
            requestAnimationFrame(() => {
              this.viewModel.setEstimatedWidgetSize(cell.model.id, cell.node.getBoundingClientRect().height);
              this.layout.removeWidget(cell);
            });
          }
        }
      }
      cellIdx++;
    }
    if (cellIdx < this.cellsArray.length) {
      if (this.notebookConfig.windowingMode === "defer" && this.viewportNode.clientHeight < this.node.clientHeight) {
        await this._runOnIdleTime();
      } else {
        this._scheduleCellRenderOnIdle();
      }
    } else {
      if (this._idleCallBack) {
        window.cancelIdleCallback(this._idleCallBack);
        this._idleCallBack = null;
      }
    }
  }
  async _updateForDeferMode(cell, cellIdx) {
    cell.dataset.windowedListIndex = `${cellIdx}`;
    this.layout.insertWidget(cellIdx, cell);
    await cell.ready;
  }
  /**
   * Apply updated notebook settings.
   */
  _updateNotebookConfig() {
    this.toggleClass("jp-mod-scrollPastEnd", this._notebookConfig.scrollPastEnd);
    this.toggleClass(HEADING_COLLAPSER_VISBILITY_CONTROL_CLASS, this._notebookConfig.showHiddenCellsButton);
    const showEditorForReadOnlyMarkdown = this._notebookConfig.showEditorForReadOnlyMarkdown;
    if (showEditorForReadOnlyMarkdown !== void 0) {
      for (const cell of this.cellsArray) {
        if (cell.model.type === "markdown") {
          cell.showEditorForReadOnly = showEditorForReadOnlyMarkdown;
        }
      }
    }
    this.viewModel.windowingActive = this._notebookConfig.windowingMode === "full";
  }
}
(function(StaticNotebook2) {
  StaticNotebook2.defaultEditorConfig = {
    code: {
      lineNumbers: false,
      lineWrap: false,
      matchBrackets: true,
      tabFocusable: false
    },
    markdown: {
      lineNumbers: false,
      lineWrap: true,
      matchBrackets: false,
      tabFocusable: false
    },
    raw: {
      lineNumbers: false,
      lineWrap: true,
      matchBrackets: false,
      tabFocusable: false
    }
  };
  StaticNotebook2.defaultNotebookConfig = {
    enableKernelInitNotification: false,
    showHiddenCellsButton: true,
    scrollPastEnd: true,
    defaultCell: "code",
    recordTiming: false,
    inputHistoryScope: "global",
    maxNumberOutputs: 50,
    showEditorForReadOnlyMarkdown: true,
    disableDocumentWideUndoRedo: true,
    renderingLayout: "default",
    sideBySideLeftMarginOverride: "10px",
    sideBySideRightMarginOverride: "10px",
    sideBySideOutputRatio: 1,
    overscanCount: 1,
    windowingMode: "full",
    accessKernelHistory: false
  };
  class ContentFactory extends Cell.ContentFactory {
    /**
     * Create a new code cell widget.
     *
     * #### Notes
     * If no cell content factory is passed in with the options, the one on the
     * notebook content factory is used.
     */
    createCodeCell(options) {
      return new CodeCell(options).initializeState();
    }
    /**
     * Create a new markdown cell widget.
     *
     * #### Notes
     * If no cell content factory is passed in with the options, the one on the
     * notebook content factory is used.
     */
    createMarkdownCell(options) {
      return new MarkdownCell(options).initializeState();
    }
    /**
     * Create a new raw cell widget.
     *
     * #### Notes
     * If no cell content factory is passed in with the options, the one on the
     * notebook content factory is used.
     */
    createRawCell(options) {
      return new RawCell(options).initializeState();
    }
  }
  StaticNotebook2.ContentFactory = ContentFactory;
})(StaticNotebook || (StaticNotebook = {}));
class ScrollbarItem {
  /**
   * Construct a scrollbar item.
   */
  constructor(options) {
    this.render = (props) => {
      if (!this._element) {
        this._element = this._createElement();
        this._notebook.activeCellChanged.connect(this._updateActive);
        this._notebook.selectionChanged.connect(this._updateSelection);
        if (this._model.type === "code") {
          const model = this._model;
          model.outputs.changed.connect(this._updatePrompt);
          model.stateChanged.connect(this._updateState);
        }
      }
      if (this._model.type != this._element.dataset.type) {
        this._element.dataset.type = this._model.type;
      }
      const source = this._model.sharedModel.source;
      const trimmedSource = source.length > 1e4 ? source.substring(0, 1e4) : source;
      if (trimmedSource !== this._source.textContent) {
        this._source.textContent = trimmedSource;
      }
      this._updateActive();
      this._updateSelection();
      this._updatePrompt();
      this._updateDirty();
      return this._element;
    };
    this.dispose = () => {
      this._isDisposed = true;
      this._notebook.activeCellChanged.disconnect(this._updateActive);
      this._notebook.selectionChanged.disconnect(this._updateSelection);
      if (this._model.type === "code") {
        const model = this._model;
        if (model.outputs) {
          model.outputs.changed.disconnect(this._updatePrompt);
          model.stateChanged.disconnect(this._updateState);
        }
      }
    };
    this._updateState = (_, change) => {
      switch (change.name) {
        case "executionCount":
        case "executionState":
          this._updatePrompt();
          break;
        case "isDirty": {
          this._updateDirty();
          break;
        }
      }
    };
    this._updatePrompt = () => {
      if (this._model.type !== "code") {
        return;
      }
      const model = this._model;
      let hasError = false;
      for (let i2 = 0; i2 < model.outputs.length; i2++) {
        const output = model.outputs.get(i2);
        if (output.type === "error") {
          hasError = true;
          break;
        }
      }
      let content;
      let state = "";
      if (hasError) {
        content = "[!]";
        state = "error";
      } else if (model.executionState == "running") {
        content = "[*]";
      } else if (model.executionCount) {
        content = `[${model.executionCount}]`;
      } else {
        content = "[ ]";
      }
      if (this._executionIndicator.textContent !== content) {
        this._executionIndicator.textContent = content;
      }
      if (this._element.dataset.output !== state) {
        this._element.dataset.output = state;
      }
    };
    this._updateActive = () => {
      var _a;
      if (!this._element) {
        this._element = this._createElement();
      }
      const li = this._element;
      const wasActive = li.classList.contains(ACTIVE_CLASS);
      if (((_a = this._notebook.activeCell) === null || _a === void 0 ? void 0 : _a.model) === this._model) {
        if (!wasActive) {
          li.classList.add(ACTIVE_CLASS);
        }
      } else if (wasActive) {
        li.classList.remove(ACTIVE_CLASS);
        li.classList.remove(SELECTED_CLASS);
      }
    };
    this._updateSelection = () => {
      if (!this._element) {
        this._element = this._createElement();
      }
      const li = this._element;
      const wasSelected = li.classList.contains(SELECTED_CLASS);
      if (this._notebook.selectedCells.some((cell) => this._model === cell.model)) {
        if (!wasSelected) {
          li.classList.add(SELECTED_CLASS);
        }
      } else if (wasSelected) {
        li.classList.remove(SELECTED_CLASS);
      }
    };
    this._isDisposed = false;
    this._element = null;
    this._model = options.model;
    this._notebook = options.notebook;
  }
  /**
   * Unique item key used for caching.
   */
  get key() {
    return this._model.id;
  }
  /**
   * Test whether the item has been disposed.
   */
  get isDisposed() {
    if (!this._isDisposed && this._model.isDisposed) {
      this.dispose();
    }
    return this._isDisposed;
  }
  _updateDirty() {
    if (this._model.type !== "code" || !this._element) {
      return;
    }
    const model = this._model;
    const wasDirty = this._element.classList.contains(DIRTY_CLASS);
    if (wasDirty !== model.isDirty) {
      if (model.isDirty) {
        this._element.classList.add(DIRTY_CLASS);
      } else {
        this._element.classList.remove(DIRTY_CLASS);
      }
    }
  }
  _createElement() {
    const li = document.createElement("li");
    const executionIndicator = this._executionIndicator = document.createElement("div");
    executionIndicator.className = "jp-scrollbarItem-executionIndicator";
    const source = this._source = document.createElement("div");
    source.className = "jp-scrollbarItem-source";
    li.append(executionIndicator);
    li.append(source);
    return li;
  }
}
class Notebook extends StaticNotebook {
  /**
   * Construct a notebook widget.
   */
  constructor(options) {
    super({
      renderer: {
        createOuter() {
          return document.createElement("div");
        },
        createViewport() {
          const el = document.createElement("div");
          el.setAttribute("role", "feed");
          el.setAttribute("aria-label", "Cells");
          return el;
        },
        createScrollbar() {
          return document.createElement("ol");
        },
        createScrollbarViewportIndicator() {
          return document.createElement("div");
        },
        createScrollbarItem(notebook, _index, model) {
          return new ScrollbarItem({
            notebook,
            model
          });
        }
      },
      ...options
    });
    this._activeCellIndex = -1;
    this._activeCell = null;
    this._mode = "command";
    this._drag = null;
    this._dragData = null;
    this._selectData = null;
    this._mouseMode = null;
    this._activeCellChanged = new Signal(this);
    this._stateChanged = new Signal(this);
    this._selectionChanged = new Signal(this);
    this._checkCacheOnNextResize = false;
    this._lastClipboardInteraction = null;
    this._selectedCells = [];
    this.outerNode.setAttribute("data-lm-dragscroll", "true");
    this.activeCellChanged.connect(this._updateSelectedCells, this);
    this.jumped.connect((_, index) => this.activeCellIndex = index);
    this.selectionChanged.connect(this._updateSelectedCells, this);
    this.addFooter();
  }
  /**
   * List of selected and active cells
   */
  get selectedCells() {
    return this._selectedCells;
  }
  /**
   * Adds a footer to the notebook.
   */
  addFooter() {
    const info = new NotebookFooter(this);
    this.layout.footer = info;
  }
  /**
   * Handle a change cells event.
   */
  _onCellsChanged(sender, args) {
    var _a, _b;
    const activeCellId = (_a = this.activeCell) === null || _a === void 0 ? void 0 : _a.model.id;
    super._onCellsChanged(sender, args);
    if (activeCellId) {
      const newActiveCellIndex = (_b = this.model) === null || _b === void 0 ? void 0 : _b.sharedModel.cells.findIndex((cell) => cell.getId() === activeCellId);
      if (newActiveCellIndex != null) {
        this.activeCellIndex = newActiveCellIndex;
      }
    }
  }
  /**
   * A signal emitted when the active cell changes.
   *
   * #### Notes
   * This can be due to the active index changing or the
   * cell at the active index changing.
   */
  get activeCellChanged() {
    return this._activeCellChanged;
  }
  /**
   * A signal emitted when the state of the notebook changes.
   */
  get stateChanged() {
    return this._stateChanged;
  }
  /**
   * A signal emitted when the selection state of the notebook changes.
   */
  get selectionChanged() {
    return this._selectionChanged;
  }
  /**
   * The interactivity mode of the notebook.
   */
  get mode() {
    return this._mode;
  }
  set mode(newValue) {
    this.setMode(newValue);
  }
  /**
   * Set the notebook mode.
   *
   * @param newValue Notebook mode
   * @param options Control mode side-effect
   * @param options.focus Whether to ensure focus (default) or not when setting the mode.
   */
  setMode(newValue, options = {}) {
    var _a;
    const setFocus = (_a = options.focus) !== null && _a !== void 0 ? _a : true;
    const activeCell = this.activeCell;
    if (!activeCell) {
      newValue = "command";
    }
    if (newValue === this._mode) {
      if (setFocus) {
        this._ensureFocus();
      }
      return;
    }
    this.update();
    const oldValue = this._mode;
    this._mode = newValue;
    if (newValue === "edit") {
      for (const widget of this.widgets) {
        this.deselect(widget);
      }
      if (activeCell instanceof MarkdownCell) {
        activeCell.rendered = false;
      }
      activeCell.inputHidden = false;
    } else {
      if (setFocus) {
        void NotebookActions.focusActiveCell(this, {
          // Do not await the active cell because that creates a bug. If the user
          // is editing a code cell and presses Accel Shift C to open the command
          // palette, then the command palette opens before
          // activeCell.node.focus() is called, which closes the command palette.
          // To the end user, it looks as if all the keyboard shortcut did was
          // move focus from the cell editor to the cell as a whole.
          waitUntilReady: false,
          preventScroll: true
        });
      }
    }
    this._stateChanged.emit({ name: "mode", oldValue, newValue });
    if (setFocus) {
      this._ensureFocus();
    }
  }
  /**
   * The active cell index of the notebook.
   *
   * #### Notes
   * The index will be clamped to the bounds of the notebook cells.
   */
  get activeCellIndex() {
    if (!this.model) {
      return -1;
    }
    return this.widgets.length ? this._activeCellIndex : -1;
  }
  set activeCellIndex(newValue) {
    var _a;
    const oldValue = this._activeCellIndex;
    if (!this.model || !this.widgets.length) {
      newValue = -1;
    } else {
      newValue = Math.max(newValue, 0);
      newValue = Math.min(newValue, this.widgets.length - 1);
    }
    this._activeCellIndex = newValue;
    const cell = (_a = this.widgets[newValue]) !== null && _a !== void 0 ? _a : null;
    this.layout.activeCell = cell;
    const cellChanged = cell !== this._activeCell;
    if (cellChanged) {
      this.update();
      this._activeCell = cell;
    }
    if (cellChanged || newValue != oldValue) {
      this._activeCellChanged.emit(cell);
    }
    if (this.mode === "edit" && cell instanceof MarkdownCell) {
      cell.rendered = false;
    }
    this._ensureFocus();
    if (newValue === oldValue) {
      return;
    }
    this._trimSelections();
    this._stateChanged.emit({ name: "activeCellIndex", oldValue, newValue });
  }
  /**
   * Get the active cell widget.
   *
   * #### Notes
   * This is a cell or `null` if there is no active cell.
   */
  get activeCell() {
    return this._activeCell;
  }
  get lastClipboardInteraction() {
    return this._lastClipboardInteraction;
  }
  set lastClipboardInteraction(newValue) {
    this._lastClipboardInteraction = newValue;
  }
  /**
   * Dispose of the resources held by the widget.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this._activeCell = null;
    super.dispose();
  }
  /**
   * Move cells preserving widget view state.
   *
   * #### Notes
   * This is required because at the model level a move is a deletion
   * followed by an insertion. Hence the view state is not preserved.
   *
   * @param from The index of the cell to move
   * @param to The new index of the cell
   * @param n Number of cells to move
   */
  moveCell(from2, to, n = 1) {
    const newActiveCellIndex = from2 <= this.activeCellIndex && this.activeCellIndex < from2 + n ? this.activeCellIndex + to - from2 - (from2 > to ? 0 : n - 1) : -1;
    const isSelected = this.widgets.slice(from2, from2 + n).map((w) => this.isSelected(w));
    super.moveCell(from2, to, n);
    if (newActiveCellIndex >= 0) {
      this.activeCellIndex = newActiveCellIndex;
    }
    if (from2 > to) {
      isSelected.forEach((selected, idx) => {
        if (selected) {
          this.select(this.widgets[to + idx]);
        }
      });
    } else {
      isSelected.forEach((selected, idx) => {
        if (selected) {
          this.select(this.widgets[to - n + 1 + idx]);
        }
      });
    }
  }
  /**
   * Select a cell widget.
   *
   * #### Notes
   * It is a no-op if the value does not change.
   * It will emit the `selectionChanged` signal.
   */
  select(widget) {
    if (Private.selectedProperty.get(widget)) {
      return;
    }
    Private.selectedProperty.set(widget, true);
    this._selectionChanged.emit(void 0);
    this.update();
  }
  /**
   * Deselect a cell widget.
   *
   * #### Notes
   * It is a no-op if the value does not change.
   * It will emit the `selectionChanged` signal.
   */
  deselect(widget) {
    if (!Private.selectedProperty.get(widget)) {
      return;
    }
    Private.selectedProperty.set(widget, false);
    this._selectionChanged.emit(void 0);
    this.update();
  }
  /**
   * Whether a cell is selected.
   */
  isSelected(widget) {
    return Private.selectedProperty.get(widget);
  }
  /**
   * Whether a cell is selected or is the active cell.
   */
  isSelectedOrActive(widget) {
    if (widget === this._activeCell) {
      return true;
    }
    return Private.selectedProperty.get(widget);
  }
  /**
   * Deselect all of the cells.
   */
  deselectAll() {
    let changed = false;
    for (const widget of this.widgets) {
      if (Private.selectedProperty.get(widget)) {
        changed = true;
      }
      Private.selectedProperty.set(widget, false);
    }
    if (changed) {
      this._selectionChanged.emit(void 0);
    }
    this.activeCellIndex = this.activeCellIndex;
    this.update();
  }
  /**
   * Move the head of an existing contiguous selection to extend the selection.
   *
   * @param index - The new head of the existing selection.
   *
   * #### Notes
   * If there is no existing selection, the active cell is considered an
   * existing one-cell selection.
   *
   * If the new selection is a single cell, that cell becomes the active cell
   * and all cells are deselected.
   *
   * There is no change if there are no cells (i.e., activeCellIndex is -1).
   */
  extendContiguousSelectionTo(index) {
    let { head, anchor } = this.getContiguousSelection();
    let i2;
    if (anchor === null || head === null) {
      if (index === this.activeCellIndex) {
        return;
      }
      head = this.activeCellIndex;
      anchor = this.activeCellIndex;
    }
    this.activeCellIndex = index;
    index = this.activeCellIndex;
    if (index === anchor) {
      this.deselectAll();
      return;
    }
    let selectionChanged = false;
    if (head < index) {
      if (head < anchor) {
        Private.selectedProperty.set(this.widgets[head], false);
        selectionChanged = true;
      }
      for (i2 = head + 1; i2 < index; i2++) {
        if (i2 !== anchor) {
          Private.selectedProperty.set(this.widgets[i2], !Private.selectedProperty.get(this.widgets[i2]));
          selectionChanged = true;
        }
      }
    } else if (index < head) {
      if (anchor < head) {
        Private.selectedProperty.set(this.widgets[head], false);
        selectionChanged = true;
      }
      for (i2 = index + 1; i2 < head; i2++) {
        if (i2 !== anchor) {
          Private.selectedProperty.set(this.widgets[i2], !Private.selectedProperty.get(this.widgets[i2]));
          selectionChanged = true;
        }
      }
    }
    if (!Private.selectedProperty.get(this.widgets[anchor])) {
      selectionChanged = true;
    }
    Private.selectedProperty.set(this.widgets[anchor], true);
    if (!Private.selectedProperty.get(this.widgets[index])) {
      selectionChanged = true;
    }
    Private.selectedProperty.set(this.widgets[index], true);
    if (selectionChanged) {
      this._selectionChanged.emit(void 0);
    }
  }
  /**
   * Get the head and anchor of a contiguous cell selection.
   *
   * The head of a contiguous selection is always the active cell.
   *
   * If there are no cells selected, `{head: null, anchor: null}` is returned.
   *
   * Throws an error if the currently selected cells do not form a contiguous
   * selection.
   */
  getContiguousSelection() {
    const cells = this.widgets;
    const first = ArrayExt.findFirstIndex(cells, (c) => this.isSelected(c));
    if (first === -1) {
      return { head: null, anchor: null };
    }
    const last2 = ArrayExt.findLastIndex(cells, (c) => this.isSelected(c), -1, first);
    for (let i2 = first; i2 <= last2; i2++) {
      if (!this.isSelected(cells[i2])) {
        throw new Error("Selection not contiguous");
      }
    }
    const activeIndex = this.activeCellIndex;
    if (first !== activeIndex && last2 !== activeIndex) {
      throw new Error("Active cell not at endpoint of selection");
    }
    if (first === activeIndex) {
      return { head: first, anchor: last2 };
    } else {
      return { head: last2, anchor: first };
    }
  }
  /**
   * Scroll so that the given cell is in view. Selects and activates cell.
   *
   * @param cell - A cell in the notebook widget.
   * @param align - Type of alignment.
   *
   */
  async scrollToCell(cell, align = "auto") {
    try {
      await this.scrollToItem(this.widgets.findIndex((c) => c === cell), align);
    } catch (r) {
    }
    this.deselectAll();
    this.select(cell);
    cell.activate();
  }
  _parseFragment(fragment) {
    const cleanedFragment = fragment.slice(1);
    if (!cleanedFragment) {
      return;
    }
    const parts = cleanedFragment.split("=");
    if (parts.length === 1) {
      return {
        kind: "heading",
        value: cleanedFragment
      };
    }
    return {
      kind: parts[0],
      value: parts.slice(1).join("=")
    };
  }
  /**
   * Set URI fragment identifier.
   */
  async setFragment(fragment) {
    const parsedFragment = this._parseFragment(fragment);
    if (!parsedFragment) {
      return;
    }
    let result2;
    switch (parsedFragment.kind) {
      case "heading":
        result2 = await this._findHeading(parsedFragment.value);
        break;
      case "cell-id":
        result2 = this._findCellById(parsedFragment.value);
        break;
      default:
        console.warn(`Unknown target type for URI fragment ${fragment}, interpreting as a heading`);
        result2 = await this._findHeading(parsedFragment.kind + "=" + parsedFragment.value);
        break;
    }
    if (result2 == null) {
      return;
    }
    let { cell, element } = result2;
    if (!cell.inViewport) {
      await this.scrollToCell(cell, "center");
    }
    if (element == null) {
      element = cell.node;
    }
    const widgetBox = this.node.getBoundingClientRect();
    const elementBox = element.getBoundingClientRect();
    if (elementBox.top > widgetBox.bottom || elementBox.bottom < widgetBox.top) {
      element.scrollIntoView({ block: "center" });
    }
  }
  /**
   * Handle the DOM events for the widget.
   *
   * @param event - The DOM event sent to the widget.
   *
   * #### Notes
   * This method implements the DOM `EventListener` interface and is
   * called in response to events on the notebook panel's node. It should
   * not be called directly by user code.
   */
  handleEvent(event2) {
    if (!this.model) {
      return;
    }
    switch (event2.type) {
      case "contextmenu":
        if (event2.eventPhase === Event.CAPTURING_PHASE) {
          this._evtContextMenuCapture(event2);
        }
        break;
      case "mousedown":
        if (event2.eventPhase === Event.CAPTURING_PHASE) {
          this._evtMouseDownCapture(event2);
        } else {
          if (!event2.defaultPrevented) {
            this._evtMouseDown(event2);
          }
        }
        break;
      case "mouseup":
        if (event2.currentTarget === document) {
          this._evtDocumentMouseup(event2);
        }
        break;
      case "mousemove":
        if (event2.currentTarget === document) {
          this._evtDocumentMousemove(event2);
        }
        break;
      case "keydown":
        this._ensureFocus(true);
        break;
      case "dblclick":
        this._evtDblClick(event2);
        break;
      case "focusin":
        this._evtFocusIn(event2);
        break;
      case "focusout":
        this._evtFocusOut(event2);
        break;
      case "lm-dragenter":
        this._evtDragEnter(event2);
        break;
      case "lm-dragleave":
        this._evtDragLeave(event2);
        break;
      case "lm-dragover":
        this._evtDragOver(event2);
        break;
      case "lm-drop":
        this._evtDrop(event2);
        break;
      default:
        super.handleEvent(event2);
        break;
    }
  }
  /**
   * Handle `after-attach` messages for the widget.
   */
  onAfterAttach(msg) {
    super.onAfterAttach(msg);
    const node2 = this.node;
    node2.addEventListener("contextmenu", this, true);
    node2.addEventListener("mousedown", this, true);
    node2.addEventListener("mousedown", this);
    node2.addEventListener("keydown", this);
    node2.addEventListener("dblclick", this);
    node2.addEventListener("focusin", this);
    node2.addEventListener("focusout", this);
    node2.addEventListener("lm-dragenter", this, true);
    node2.addEventListener("lm-dragleave", this, true);
    node2.addEventListener("lm-dragover", this, true);
    node2.addEventListener("lm-drop", this, true);
  }
  /**
   * Handle `before-detach` messages for the widget.
   */
  onBeforeDetach(msg) {
    const node2 = this.node;
    node2.removeEventListener("contextmenu", this, true);
    node2.removeEventListener("mousedown", this, true);
    node2.removeEventListener("mousedown", this);
    node2.removeEventListener("keydown", this);
    node2.removeEventListener("dblclick", this);
    node2.removeEventListener("focusin", this);
    node2.removeEventListener("focusout", this);
    node2.removeEventListener("lm-dragenter", this, true);
    node2.removeEventListener("lm-dragleave", this, true);
    node2.removeEventListener("lm-dragover", this, true);
    node2.removeEventListener("lm-drop", this, true);
    document.removeEventListener("mousemove", this, true);
    document.removeEventListener("mouseup", this, true);
    super.onBeforeAttach(msg);
  }
  /**
   * A message handler invoked on an `'after-show'` message.
   */
  onAfterShow(msg) {
    super.onAfterShow(msg);
    this._checkCacheOnNextResize = true;
  }
  /**
   * A message handler invoked on a `'resize'` message.
   */
  onResize(msg) {
    var _a;
    if (!this._checkCacheOnNextResize) {
      return super.onResize(msg);
    }
    super.onResize(msg);
    this._checkCacheOnNextResize = false;
    const cache2 = this._cellLayoutStateCache;
    const width = parseInt(this.node.style.width, 10);
    if (cache2) {
      if (width === cache2.width) {
        return;
      }
    }
    this._cellLayoutStateCache = { width };
    for (const w of this.widgets) {
      if (w instanceof Cell && w.inViewport) {
        (_a = w.editorWidget) === null || _a === void 0 ? void 0 : _a.update();
      }
    }
  }
  /**
   * A message handler invoked on an `'before-hide'` message.
   */
  onBeforeHide(msg) {
    super.onBeforeHide(msg);
    const width = parseInt(this.node.style.width, 10);
    this._cellLayoutStateCache = { width };
  }
  /**
   * Handle `'activate-request'` messages.
   */
  onActivateRequest(msg) {
    super.onActivateRequest(msg);
    this._ensureFocus(true);
  }
  /**
   * Handle `update-request` messages sent to the widget.
   */
  onUpdateRequest(msg) {
    super.onUpdateRequest(msg);
    const activeCell = this.activeCell;
    if (this.mode === "edit") {
      this.addClass(EDIT_CLASS);
      this.removeClass(COMMAND_CLASS);
    } else {
      this.addClass(COMMAND_CLASS);
      this.removeClass(EDIT_CLASS);
    }
    let count = 0;
    for (const widget of this.widgets) {
      widget.node.tabIndex = -1;
      widget.removeClass(ACTIVE_CLASS);
      widget.removeClass(OTHER_SELECTED_CLASS);
      if (this.isSelectedOrActive(widget)) {
        widget.addClass(SELECTED_CLASS);
        count++;
      } else {
        widget.removeClass(SELECTED_CLASS);
      }
    }
    if (activeCell) {
      activeCell.addClass(ACTIVE_CLASS);
      activeCell.addClass(SELECTED_CLASS);
      activeCell.node.tabIndex = 0;
      if (count > 1) {
        activeCell.addClass(OTHER_SELECTED_CLASS);
      }
    }
  }
  /**
   * Handle a cell being inserted.
   */
  onCellInserted(index, cell) {
    void cell.ready.then(() => {
      if (!cell.isDisposed) {
        cell.editor.edgeRequested.connect(this._onEdgeRequest, this);
      }
    });
    cell.scrollRequested.connect((_emitter, scrollRequest) => {
      if (cell !== this.activeCell) {
        return;
      }
      if (!scrollRequest.defaultPrevented) {
        return;
      }
      const scroller = this.outerNode;
      if (cell.inViewport) {
        return scrollRequest.scrollWithinCell({ scroller });
      }
      this.scrollToItem(this.activeCellIndex).then(() => {
        void cell.ready.then(() => {
          scrollRequest.scrollWithinCell({ scroller });
        });
      }).catch((reason) => {
      });
    });
    this.activeCellIndex = index <= this.activeCellIndex ? this.activeCellIndex + 1 : this.activeCellIndex;
  }
  /**
   * Handle a cell being removed.
   */
  onCellRemoved(index, cell) {
    this.activeCellIndex = index <= this.activeCellIndex ? this.activeCellIndex - 1 : this.activeCellIndex;
    if (this.isSelected(cell)) {
      this._selectionChanged.emit(void 0);
    }
  }
  /**
   * Handle a new model.
   */
  onModelChanged(oldValue, newValue) {
    super.onModelChanged(oldValue, newValue);
    this.activeCellIndex = 0;
  }
  /**
   * Handle edge request signals from cells.
   */
  _onEdgeRequest(editor, location2) {
    const prev = this.activeCellIndex;
    if (location2 === "top") {
      this.activeCellIndex--;
      if (this.activeCellIndex < prev) {
        const editor2 = this.activeCell.editor;
        if (editor2) {
          const lastLine = editor2.lineCount - 1;
          editor2.setCursorPosition({ line: lastLine, column: 0 });
        }
      }
    } else if (location2 === "bottom") {
      this.activeCellIndex++;
      if (this.activeCellIndex > prev) {
        const editor2 = this.activeCell.editor;
        if (editor2) {
          editor2.setCursorPosition({ line: 0, column: 0 });
        }
      }
    }
    this.mode = "edit";
  }
  /**
   * Ensure that the notebook has proper focus.
   */
  _ensureFocus(force = false) {
    var _a, _b;
    const footer = this.layout.footer;
    if (footer && document.activeElement === footer.node) {
      return;
    }
    const activeCell = this.activeCell;
    if (this.mode === "edit" && activeCell) {
      if (((_a = activeCell.editor) === null || _a === void 0 ? void 0 : _a.hasFocus()) !== true) {
        if (activeCell.inViewport) {
          (_b = activeCell.editor) === null || _b === void 0 ? void 0 : _b.focus();
        } else {
          this.scrollToItem(this.activeCellIndex).then(() => {
            void activeCell.ready.then(() => {
              var _a2;
              (_a2 = activeCell.editor) === null || _a2 === void 0 ? void 0 : _a2.focus();
            });
          }).catch((reason) => {
          });
        }
      }
    }
    if (force && activeCell && !activeCell.node.contains(document.activeElement)) {
      void NotebookActions.focusActiveCell(this, {
        preventScroll: true
      });
    }
  }
  /**
   * Find the cell index containing the target html element.
   *
   * #### Notes
   * Returns -1 if the cell is not found.
   */
  _findCell(node2) {
    let n = node2;
    while (n && n !== this.node) {
      if (n.classList.contains(NB_CELL_CLASS)) {
        const i2 = ArrayExt.findFirstIndex(this.widgets, (widget) => widget.node === n);
        if (i2 !== -1) {
          return i2;
        }
        break;
      }
      n = n.parentElement;
    }
    return -1;
  }
  /**
   * Find the target of html mouse event and cell index containing this target.
   *
   * #### Notes
   * Returned index is -1 if the cell is not found.
   */
  _findEventTargetAndCell(event2) {
    let target2 = event2.target;
    let index = this._findCell(target2);
    if (index === -1) {
      target2 = document.elementFromPoint(event2.clientX, event2.clientY);
      index = this._findCell(target2);
    }
    return [target2, index];
  }
  /**
   * Find heading with given ID in any of the cells.
   */
  async _findHeading(queryId) {
    for (let cellIdx = 0; cellIdx < this.widgets.length; cellIdx++) {
      const cell = this.widgets[cellIdx];
      if (cell.model.type === "raw" || cell.model.type === "markdown" && !cell.rendered) {
        continue;
      }
      for (const heading of cell.headings) {
        let id = "";
        switch (heading.type) {
          case Cell.HeadingType.HTML:
            id = heading.id;
            break;
          case Cell.HeadingType.Markdown:
            {
              const mdHeading = heading;
              id = await getHeadingId(this.rendermime.markdownParser, mdHeading.raw, mdHeading.level, this.rendermime.sanitizer);
            }
            break;
        }
        if (id === queryId) {
          const element = this.node.querySelector(`h${heading.level}[id="${CSS.escape(id)}"]`);
          return {
            cell,
            element
          };
        }
      }
    }
    return null;
  }
  /**
   * Find cell by its unique ID.
   */
  _findCellById(queryId) {
    for (let cellIdx = 0; cellIdx < this.widgets.length; cellIdx++) {
      const cell = this.widgets[cellIdx];
      if (cell.model.id === queryId) {
        return {
          cell
        };
      }
    }
    return null;
  }
  /**
   * Handle `contextmenu` event.
   */
  _evtContextMenuCapture(event2) {
    var _a;
    if (event2.shiftKey) {
      return;
    }
    const [target2, index] = this._findEventTargetAndCell(event2);
    const widget = this.widgets[index];
    if (widget && ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(target2))) {
      event2.preventDefault();
    }
  }
  /**
   * Handle `mousedown` event in the capture phase for the widget.
   */
  _evtMouseDownCapture(event2) {
    var _a;
    const { button, shiftKey } = event2;
    const [target2, index] = this._findEventTargetAndCell(event2);
    const widget = this.widgets[index];
    if (button === 2 && !shiftKey && widget && ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(target2))) {
      this.mode = "command";
      event2.preventDefault();
    }
  }
  /**
   * Handle `mousedown` events for the widget.
   */
  _evtMouseDown(event2) {
    var _a, _b, _c;
    const { button, shiftKey } = event2;
    if (!(button === 0 || button === 2)) {
      return;
    }
    if (shiftKey && button === 2) {
      return;
    }
    const [target2, index] = this._findEventTargetAndCell(event2);
    const widget = this.widgets[index];
    let targetArea;
    if (widget) {
      if ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(target2)) {
        targetArea = "input";
      } else if ((_b = widget.promptNode) === null || _b === void 0 ? void 0 : _b.contains(target2)) {
        targetArea = "prompt";
      } else {
        targetArea = "cell";
      }
    } else {
      targetArea = "notebook";
    }
    if (targetArea !== "input") {
      this.mode = "command";
    }
    if (targetArea === "notebook") {
      this.deselectAll();
    } else if (targetArea === "prompt" || targetArea === "cell") {
      const hasSelection2 = ((_c = window.getSelection()) !== null && _c !== void 0 ? _c : "").toString() !== "";
      if (button === 0 && shiftKey && !hasSelection2 && !["INPUT", "OPTION"].includes(target2.tagName)) {
        event2.preventDefault();
        try {
          this.extendContiguousSelectionTo(index);
        } catch (e) {
          console.error(e);
          this.deselectAll();
          return;
        }
        this._mouseMode = "select";
        this._selectData = {
          startedOnActiveCell: index == this.activeCellIndex,
          startingCellIndex: this.activeCellIndex
        };
        document.addEventListener("mouseup", this, true);
        document.addEventListener("mousemove", this, true);
      } else if (button === 0 && !shiftKey) {
        if (targetArea === "prompt") {
          this._dragData = {
            pressX: event2.clientX,
            pressY: event2.clientY,
            index
          };
          this._mouseMode = "couldDrag";
          document.addEventListener("mouseup", this, true);
          document.addEventListener("mousemove", this, true);
          event2.preventDefault();
        }
        if (!this.isSelectedOrActive(widget)) {
          this.deselectAll();
          this.activeCellIndex = index;
        }
      } else if (button === 2) {
        if (!this.isSelectedOrActive(widget)) {
          this.deselectAll();
          this.activeCellIndex = index;
        }
        event2.preventDefault();
      }
    } else if (targetArea === "input") {
      if (button === 2 && !this.isSelectedOrActive(widget)) {
        this.deselectAll();
        this.activeCellIndex = index;
      }
    }
    this._ensureFocus(true);
  }
  /**
   * Handle the `'mouseup'` event on the document.
   */
  _evtDocumentMouseup(event2) {
    const [, index] = this._findEventTargetAndCell(event2);
    let shouldPreventDefault = true;
    if (this._mouseMode === "select" && this._selectData) {
      const { startedOnActiveCell, startingCellIndex } = this._selectData;
      if (startedOnActiveCell && index === startingCellIndex) {
        shouldPreventDefault = false;
      }
      this._selectData = null;
    }
    if (shouldPreventDefault) {
      event2.preventDefault();
      event2.stopPropagation();
    }
    document.removeEventListener("mousemove", this, true);
    document.removeEventListener("mouseup", this, true);
    if (this._mouseMode === "couldDrag") {
      this.deselectAll();
      this.activeCellIndex = index;
      if (!this.activeCell.node.contains(document.activeElement)) {
        void NotebookActions.focusActiveCell(this);
      }
    }
    this._mouseMode = null;
  }
  /**
   * Handle the `'mousemove'` event for the widget.
   */
  _evtDocumentMousemove(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    switch (this._mouseMode) {
      case "select": {
        const target2 = event2.target;
        const index = this._findCell(target2);
        if (index !== -1) {
          this.extendContiguousSelectionTo(index);
        }
        break;
      }
      case "couldDrag": {
        const data = this._dragData;
        const dx = Math.abs(event2.clientX - data.pressX);
        const dy = Math.abs(event2.clientY - data.pressY);
        if (dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD) {
          this._mouseMode = null;
          this._startDrag(data.index, event2.clientX, event2.clientY);
        }
        break;
      }
    }
  }
  /**
   * Handle the `'lm-dragenter'` event for the widget.
   */
  _evtDragEnter(event2) {
    if (!event2.mimeData.hasData(JUPYTER_CELL_MIME)) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    const target2 = event2.target;
    const index = this._findCell(target2);
    if (index === -1) {
      return;
    }
    const widget = this.cellsArray[index];
    widget.node.classList.add(DROP_TARGET_CLASS);
  }
  /**
   * Handle the `'lm-dragleave'` event for the widget.
   */
  _evtDragLeave(event2) {
    if (!event2.mimeData.hasData(JUPYTER_CELL_MIME)) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    const elements2 = this.node.getElementsByClassName(DROP_TARGET_CLASS);
    if (elements2.length) {
      elements2[0].classList.remove(DROP_TARGET_CLASS);
    }
  }
  /**
   * Handle the `'lm-dragover'` event for the widget.
   */
  _evtDragOver(event2) {
    if (!event2.mimeData.hasData(JUPYTER_CELL_MIME)) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    event2.dropAction = event2.proposedAction;
    const elements2 = this.node.getElementsByClassName(DROP_TARGET_CLASS);
    if (elements2.length) {
      elements2[0].classList.remove(DROP_TARGET_CLASS);
    }
    const target2 = event2.target;
    const index = this._findCell(target2);
    if (index === -1) {
      return;
    }
    const widget = this.cellsArray[index];
    widget.node.classList.add(DROP_TARGET_CLASS);
  }
  /**
   * Handle the `'lm-drop'` event for the widget.
   */
  _evtDrop(event2) {
    if (!event2.mimeData.hasData(JUPYTER_CELL_MIME)) {
      return;
    }
    event2.preventDefault();
    event2.stopPropagation();
    if (event2.proposedAction === "none") {
      event2.dropAction = "none";
      return;
    }
    let target2 = event2.target;
    while (target2 && target2.parentElement) {
      if (target2.classList.contains(DROP_TARGET_CLASS)) {
        target2.classList.remove(DROP_TARGET_CLASS);
        break;
      }
      target2 = target2.parentElement;
    }
    const model = this.model;
    const source = event2.source;
    if (source === this) {
      event2.dropAction = "move";
      const toMove = event2.mimeData.getData("internal:cells");
      const cell = toMove[toMove.length - 1];
      if (cell instanceof MarkdownCell && cell.headingCollapsed) {
        const nextParent = NotebookActions.findNextParentHeading(cell, source);
        if (nextParent > 0) {
          const index = findIndex(source.widgets, (possibleCell) => {
            return cell.model.id === possibleCell.model.id;
          });
          toMove.push(...source.widgets.slice(index + 1, nextParent));
        }
      }
      let fromIndex = ArrayExt.firstIndexOf(this.widgets, toMove[0]);
      let toIndex = this._findCell(target2);
      if (toIndex !== -1 && toIndex > fromIndex) {
        toIndex -= 1;
      } else if (toIndex === -1) {
        toIndex = this.widgets.length - 1;
      }
      if (toIndex >= fromIndex && toIndex < fromIndex + toMove.length) {
        return;
      }
      this.moveCell(fromIndex, toIndex, toMove.length);
    } else {
      event2.dropAction = "copy";
      let index = this._findCell(target2);
      if (index === -1) {
        index = this.widgets.length;
      }
      const start = index;
      const values = event2.mimeData.getData(JUPYTER_CELL_MIME);
      model.sharedModel.insertCells(index, values);
      this.deselectAll();
      this.activeCellIndex = start;
      this.extendContiguousSelectionTo(index - 1);
    }
    void NotebookActions.focusActiveCell(this);
  }
  /**
   * Start a drag event.
   */
  _startDrag(index, clientX, clientY) {
    var _a;
    const cells = this.model.cells;
    const selected = [];
    const toMove = [];
    let i2 = -1;
    for (const widget of this.widgets) {
      const cell = cells.get(++i2);
      if (this.isSelectedOrActive(widget)) {
        widget.addClass(DROP_SOURCE_CLASS);
        selected.push(cell.toJSON());
        toMove.push(widget);
      }
    }
    const activeCell = this.activeCell;
    let dragImage = null;
    let countString;
    if ((activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.type) === "code") {
      const executionCount = activeCell.model.executionCount;
      countString = " ";
      if (executionCount) {
        countString = executionCount.toString();
      }
    } else {
      countString = "";
    }
    dragImage = Private.createDragImage(selected.length, countString, (_a = activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.sharedModel.getSource().split("\n")[0].slice(0, 26)) !== null && _a !== void 0 ? _a : "");
    this._drag = new Drag({
      mimeData: new MimeData(),
      dragImage,
      supportedActions: "copy-move",
      proposedAction: "copy",
      source: this
    });
    this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);
    this._drag.mimeData.setData("internal:cells", toMove);
    const textContent2 = toMove.map((cell) => cell.model.sharedModel.getSource()).join("\n");
    this._drag.mimeData.setData("text/plain", textContent2);
    document.removeEventListener("mousemove", this, true);
    document.removeEventListener("mouseup", this, true);
    this._mouseMode = null;
    void this._drag.start(clientX, clientY).then((action) => {
      if (this.isDisposed) {
        return;
      }
      this._drag = null;
      for (const widget of toMove) {
        widget.removeClass(DROP_SOURCE_CLASS);
      }
    });
  }
  /**
   * Update the notebook node with class indicating read-write state.
   */
  _updateReadWrite() {
    const inReadWrite = DOMUtils.hasActiveEditableElement(this.node);
    this.node.classList.toggle(READ_WRITE_CLASS, inReadWrite);
  }
  /**
   * Handle `focus` events for the widget.
   */
  _evtFocusIn(event2) {
    var _a, _b;
    this._updateReadWrite();
    const target2 = event2.target;
    const index = this._findCell(target2);
    if (index !== -1) {
      const widget = this.widgets[index];
      if (widget.editorWidget && !widget.editorWidget.node.contains(target2)) {
        this.setMode("command", { focus: false });
      }
      this.activeCellIndex = index;
      const node2 = (_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node;
      if (node2 === null || node2 === void 0 ? void 0 : node2.contains(target2)) {
        this.setMode("edit", { focus: false });
      }
    } else {
      this.setMode("command", { focus: false });
      event2.preventDefault();
      const source = event2.relatedTarget;
      if (this._activeCell && !this._activeCell.node.contains(source)) {
        this._activeCell.ready.then(() => {
          var _a2;
          (_a2 = this._activeCell) === null || _a2 === void 0 ? void 0 : _a2.node.focus({
            preventScroll: true
          });
        }).catch(() => {
          var _a2;
          (_a2 = this.layout.footer) === null || _a2 === void 0 ? void 0 : _a2.node.focus({
            preventScroll: true
          });
        });
      } else {
        (_b = this.layout.footer) === null || _b === void 0 ? void 0 : _b.node.focus({
          preventScroll: true
        });
      }
    }
  }
  /**
   * Handle `focusout` events for the notebook.
   */
  _evtFocusOut(event2) {
    var _a;
    this._updateReadWrite();
    const relatedTarget = event2.relatedTarget;
    if (!relatedTarget) {
      return;
    }
    const index = this._findCell(relatedTarget);
    if (index !== -1) {
      const widget = this.widgets[index];
      if ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(relatedTarget)) {
        return;
      }
    }
    if (this.mode !== "command") {
      this.setMode("command", { focus: false });
    }
  }
  /**
   * Handle `dblclick` events for the widget.
   */
  _evtDblClick(event2) {
    const model = this.model;
    if (!model) {
      return;
    }
    this.deselectAll();
    const [target2, index] = this._findEventTargetAndCell(event2);
    if (event2.target.classList.contains(HEADING_COLLAPSER_CLASS)) {
      return;
    }
    if (index === -1) {
      return;
    }
    this.activeCellIndex = index;
    if (model.cells.get(index).type === "markdown") {
      const widget = this.widgets[index];
      widget.rendered = false;
    } else if (target2.localName === "img") {
      target2.classList.toggle(UNCONFINED_CLASS);
    }
  }
  /**
   * Remove selections from inactive cells to avoid
   * spurious cursors.
   */
  _trimSelections() {
    for (let i2 = 0; i2 < this.widgets.length; i2++) {
      if (i2 !== this._activeCellIndex) {
        const cell = this.widgets[i2];
        if (!cell.model.isDisposed && cell.editor) {
          cell.model.selections.delete(cell.editor.uuid);
        }
      }
    }
  }
  _updateSelectedCells() {
    this._selectedCells = this.widgets.filter((cell) => this.isSelectedOrActive(cell));
    if (this.kernelHistory) {
      this.kernelHistory.reset();
    }
  }
}
(function(Notebook2) {
  class ContentFactory extends StaticNotebook.ContentFactory {
  }
  Notebook2.ContentFactory = ContentFactory;
})(Notebook || (Notebook = {}));
var Private;
(function(Private2) {
  Private2.selectedProperty = new AttachedProperty({
    name: "selected",
    create: () => false
  });
  class NotebookPanelLayout extends PanelLayout {
    /**
     * A message handler invoked on an `'update-request'` message.
     *
     * #### Notes
     * This is a reimplementation of the base class method,
     * and is a no-op.
     */
    onUpdateRequest(msg) {
    }
  }
  Private2.NotebookPanelLayout = NotebookPanelLayout;
  function createDragImage(count, promptNumber, cellContent) {
    if (count > 1) {
      if (promptNumber !== "") {
        return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, "[" + promptNumber + "]:"), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, "")));
      } else {
        return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, "")));
      }
    } else {
      if (promptNumber !== "") {
        return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, "[" + promptNumber + "]:"), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));
      } else {
        return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));
      }
    }
  }
  Private2.createDragImage = createDragImage;
})(Private || (Private = {}));
const NOTEBOOK_PANEL_CLASS = "jp-NotebookPanel";
const NOTEBOOK_PANEL_TOOLBAR_CLASS = "jp-NotebookPanel-toolbar";
const NOTEBOOK_PANEL_NOTEBOOK_CLASS = "jp-NotebookPanel-notebook";
class NotebookPanel extends DocumentWidget {
  /**
   * Construct a new notebook panel.
   */
  constructor(options) {
    super(options);
    this._autorestarting = false;
    this.addClass(NOTEBOOK_PANEL_CLASS);
    this.toolbar.addClass(NOTEBOOK_PANEL_TOOLBAR_CLASS);
    this.content.addClass(NOTEBOOK_PANEL_NOTEBOOK_CLASS);
    this.content.model = this.context.model;
    this.context.sessionContext.kernelChanged.connect(this._onKernelChanged, this);
    this.context.sessionContext.statusChanged.connect(this._onSessionStatusChanged, this);
    this.context.saveState.connect(this._onSave, this);
    void this.revealed.then(() => {
      if (this.isDisposed) {
        return;
      }
      if (this.content.widgets.length === 1) {
        const cellModel = this.content.widgets[0].model;
        if (cellModel.type === "code" && cellModel.sharedModel.getSource() === "") {
          this.content.mode = "edit";
        }
      }
    });
  }
  /**
   * Handle a change to the document registry save state.
   *
   * @param sender The document registry context
   * @param state The document registry save state
   */
  _onSave(sender, state) {
    if (state === "started" && this.model) {
      for (const cell of this.model.cells) {
        if (isMarkdownCellModel(cell)) {
          for (const key2 of cell.attachments.keys) {
            if (!cell.sharedModel.getSource().includes(key2)) {
              cell.attachments.remove(key2);
            }
          }
        }
      }
    }
  }
  /**
   * The session context used by the panel.
   */
  get sessionContext() {
    return this.context.sessionContext;
  }
  /**
   * The model for the widget.
   */
  get model() {
    return this.content.model;
  }
  /**
   * Update the options for the current notebook panel.
   *
   * @param config new options to set
   */
  setConfig(config2) {
    this.content.editorConfig = config2.editorConfig;
    this.content.notebookConfig = config2.notebookConfig;
    const kernelPreference = this.context.sessionContext.kernelPreference;
    this.context.sessionContext.kernelPreference = {
      ...kernelPreference,
      shutdownOnDispose: config2.kernelShutdown,
      autoStartDefault: config2.autoStartDefault
    };
  }
  /**
   * Set URI fragment identifier.
   */
  setFragment(fragment) {
    void this.context.ready.then(() => {
      void this.content.setFragment(fragment);
    });
  }
  /**
   * Dispose of the resources used by the widget.
   */
  dispose() {
    this.content.dispose();
    super.dispose();
  }
  /**
   * Prints the notebook by converting to HTML with nbconvert.
   */
  [Printing.symbol]() {
    return async () => {
      if (this.context.model.dirty && !this.context.model.readOnly) {
        await this.context.save();
      }
      await Printing.printURL(lib$9.PageConfig.getNBConvertURL({
        format: "html",
        download: false,
        path: this.context.path
      }));
    };
  }
  /**
   * A message handler invoked on a 'before-hide' message.
   */
  onBeforeHide(msg) {
    super.onBeforeHide(msg);
    this.content.isParentHidden = true;
  }
  /**
   * A message handler invoked on a 'before-show' message.
   */
  onBeforeShow(msg) {
    this.content.isParentHidden = false;
    super.onBeforeShow(msg);
  }
  /**
   * Handle a change in the kernel by updating the document metadata.
   */
  _onKernelChanged(sender, args) {
    if (!this.model || !args.newValue) {
      return;
    }
    const { newValue } = args;
    void newValue.info.then((info) => {
      var _a;
      if (this.model && ((_a = this.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === newValue) {
        this._updateLanguage(info.language_info);
      }
    });
    void this._updateSpec(newValue);
  }
  _onSessionStatusChanged(sender, status) {
    var _a;
    if (status === "autorestarting" && !this._autorestarting) {
      void showDialog({
        title: this._trans.__("Kernel Restarting"),
        body: this._trans.__("The kernel for %1 appears to have died. It will restart automatically.", (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),
        buttons: [Dialog.okButton({ label: this._trans.__("Ok") })]
      });
      this._autorestarting = true;
    } else if (status === "restarting") ;
    else {
      this._autorestarting = false;
    }
  }
  /**
   * Update the kernel language.
   */
  _updateLanguage(language) {
    this.model.setMetadata("language_info", language);
  }
  /**
   * Update the kernel spec.
   */
  async _updateSpec(kernel2) {
    const spec = await kernel2.spec;
    if (this.isDisposed) {
      return;
    }
    this.model.setMetadata("kernelspec", {
      name: kernel2.name,
      display_name: spec === null || spec === void 0 ? void 0 : spec.display_name,
      language: spec === null || spec === void 0 ? void 0 : spec.language
    });
  }
}
(function(NotebookPanel2) {
  class ContentFactory extends Notebook.ContentFactory {
    /**
     * Create a new content area for the panel.
     */
    createNotebook(options) {
      return new Notebook(options);
    }
  }
  NotebookPanel2.ContentFactory = ContentFactory;
  NotebookPanel2.IContentFactory = new Token("@jupyterlab/notebook:IContentFactory", `A factory object that creates new notebooks.
    Use this if you want to create and host notebooks in your own UI elements.`);
})(NotebookPanel || (NotebookPanel = {}));
export {
  Context as C,
  NotebookModel as N,
  Notebook as a,
  NotebookPanel as b
};
